<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>부피입자(Volume-Particle, VP) 이론 백서 — 백서 (Draft v0.1.2 (Korean edition; synced to SEO\_v11\_SOCN750))</title>
  <meta name="description" content="부피입자(Volume-Particle, VP) 이론 백서: LOCK $\rightarrow$ 유도 $\rightarrow$ Gate 프레임 및 재현 규격 (HTML 버전). DOI: 10.5281/zenodo.17932567."/>
  <link rel="canonical" href="https://jamming-physics.org/ko/whitepaper.html"/>
  <link rel="alternate" hreflang="ko" href="https://jamming-physics.org/ko/whitepaper.html"/>
  <link rel="alternate" hreflang="en" href="https://jamming-physics.org/en/whitepaper.html"/>
  <link rel="alternate" hreflang="x-default" href="https://jamming-physics.org/"/>
  <meta property="og:type" content="website"/>
  <meta property="og:title" content="부피입자(Volume-Particle, VP) 이론 백서 — 백서 (Draft v0.1.2 (Korean edition; synced to SEO\_v11\_SOCN750))"/>
  <meta property="og:description" content="부피입자(Volume-Particle, VP) 이론 백서: LOCK $\rightarrow$ 유도 $\rightarrow$ Gate 프레임 및 재현 규격 (HTML 버전). DOI: 10.5281/zenodo.17932567."/>
  <meta property="og:url" content="https://jamming-physics.org/ko/whitepaper.html"/>
  <meta property="og:image" content="/assets/og.png"/>
  <meta name="twitter:card" content="summary_large_image"/>
  <link rel="stylesheet" href="/assets/style.css"/>
  <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "ScholarlyArticle",
  "inLanguage": "ko",
  "name": "부피입자(Volume-Particle, VP) 이론 백서 — Draft v0.1.2 (Korean edition; synced to SEO\\_v11\\_SOCN750)",
  "headline": "부피입자(Volume-Particle, VP) 이론 백서",
  "author": [
    {
      "@type": "Person",
      "name": "Young jae Lee",
      "identifier": "https://orcid.org/0009-0002-7535-8245"
    }
  ],
  "datePublished": "2025-12-15",
  "identifier": "https://doi.org/10.5281/zenodo.17932567",
  "url": "https://jamming-physics.org/ko/whitepaper.html",
  "license": "https://creativecommons.org/licenses/by/4.0/",
  "publisher": {
    "@type": "Organization",
    "name": "Zenodo"
  },
  "sameAs": [
    "https://doi.org/10.5281/zenodo.17932567"
  ]
}
</script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <meta name="citation_title" content="부피입자(Volume-Particle, VP) 이론 백서"/>
  <meta name="citation_author" content="Young jae Lee"/>
  <meta name="citation_publication_date" content="2025/12/15"/>
  <meta name="citation_doi" content="10.5281/zenodo.17932567"/>
  <meta name="citation_pdf_url" content="https://doi.org/10.5281/zenodo.17932567"/>
</head>
<body>
<a class="skip-link" href="#main">본문으로 바로가기</a>
<nav class="navbar">
  <a href="https://jamming-physics.org/ko/" class="nav-logo">JAMMING PHYSICS</a>
  <div class="nav-right">
    <button class="toc-toggle" id="tocToggle" aria-controls="sidebar" aria-expanded="false">TOC</button>
    <div class="lang-switch" aria-label="Language switch">
      <a href="https://jamming-physics.org/en/whitepaper.html">English</a>
    </div>
  </div>
</nav>
<div class="page">
  <aside class="sidebar" id="sidebar" aria-label="Table of contents">
    <h2>목차</h2>
    <nav id="TOC" role="doc-toc">
<ul>
<li><a href="#w.-백서-요약executive-summary"><span class="toc-section-number">1</span> W. 백서 요약(Executive Summary)</a>
<ul>
<li><a href="#w.1-한-페이지-요약무엇을-잠그고-무엇을-내며-어떻게-판정하는가"><span class="toc-section-number">1.1</span> W.1 한 페이지 요약(무엇을 잠그고, 무엇을 내며, 어떻게 판정하는가)</a></li>
<li><a href="#w.2-입력lock-vs-산출derived-회계표요약"><span class="toc-section-number">1.2</span> W.2 입력(LOCK) vs 산출(derived) 회계표(요약)</a></li>
<li><a href="#w.3-gate판정과-재현artifact-요약"><span class="toc-section-number">1.3</span> W.3 Gate(판정)과 재현(artifact) 요약</a></li>
<li><a href="#w.4-알려진-제약열린-항목백서-관점의-명시"><span class="toc-section-number">1.4</span> W.4 알려진 제약/열린 항목(백서 관점의 명시)</a></li>
</ul></li>
<li><a href="#프롤로그문서-사용법"><span class="toc-section-number">2</span> 0. 프롤로그(문서 사용법)</a>
<ul>
<li><a href="#장의-목적">장의 목적</a></li>
<li><a href="#산출물">산출물</a></li>
<li><a href="#문서-순회-루트의-정의">문서 순회 루트의 정의</a></li>
<li><a href="#lock-rightarrow-유도-rightarrow-gate-흐름-선언"><span class="toc-section-number">2.1</span> 0.4 LOCK <span class="math inline">\(\rightarrow\)</span> 유도 <span class="math inline">\(\rightarrow\)</span> Gate 흐름 선언</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#이-문서가-주장하는-것주장하지-않는-것claim-level"><span class="toc-section-number">2.2</span> 0.1 이 문서가 주장하는 것/주장하지 않는 것(Claim Level)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-1">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#독자-가이드-필수-루트-vs-선택-루트"><span class="toc-section-number">2.3</span> 0.2 독자 가이드: 필수 루트 vs 선택 루트</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-2">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#입력lockrightarrow유도rightarrow검증gate-흐름도-파일레지스트리-개요"><span class="toc-section-number">2.4</span> 0.3 “입력(LOCK)<span class="math inline">\(\rightarrow\)</span>유도<span class="math inline">\(\rightarrow\)</span>검증(Gate)” 흐름도 + 파일/레지스트리 개요</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-3">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#거버넌스-no-tuning-lock-gate"><span class="toc-section-number">3</span> 1. 거버넌스: No-Tuning / LOCK / Gate</a>
<ul>
<li><a href="#전역-최상위-규칙의-선언">전역 최상위 규칙의 선언</a></li>
<li><a href="#no-tuning의-선언사후조정-금지">No-Tuning의 선언(사후조정 금지)</a></li>
<li><a href="#lock의-선언정준-고정과-단일-출처">LOCK의 선언(정준 고정과 단일 출처)</a></li>
<li><a href="#gate의-선언결론-자격-판정"><span class="toc-section-number">3.1</span> 1.4 Gate의 선언(결론 자격 판정)</a></li>
<li><a href="#세-규칙의-결합-구조전역-우선순위"><span class="toc-section-number">3.2</span> 1.5 세 규칙의 결합 구조(전역 우선순위)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-4">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#no-tuning-규칙과-금지행위"><span class="toc-section-number">3.3</span> 1.1 No-Tuning 규칙과 금지행위</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-5">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#lock-3종과-ssot"><span class="toc-section-number">3.4</span> 1.2 LOCK 3종과 SSOT</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-6">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#gate-pass.rules"><span class="toc-section-number">3.5</span> 1.3 Gate &amp; PASS.rules</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-7">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#표기용어스케일-계층"><span class="toc-section-number">4</span> 2. 표기·용어·스케일 계층</a>
<ul>
<li><a href="#목적과-최상위-원칙">목적과 최상위 원칙</a></li>
<li><a href="#기호단위스케일-레지스트리의-우선순위충돌-해소-순서">기호·단위·스케일 레지스트리의 우선순위(충돌 해소 순서)</a></li>
<li><a href="#레지스트리의-단일-출처ssot와-분리-보관">레지스트리의 단일 출처(SSOT)와 분리 보관</a></li>
<li><a href="#기호-레지스트리의-표준-필드의미의-봉인">기호 레지스트리의 표준 필드(의미의 봉인)</a></li>
<li><a href="#단위-레지스트리의-표준-필드차원의-봉인"><span class="toc-section-number">4.1</span> 2.5 단위 레지스트리의 표준 필드(차원의 봉인)</a></li>
<li><a href="#스케일-레지스트리의-표준-필드정준실현의-분리"><span class="toc-section-number">4.2</span> 2.6 스케일 레지스트리의 표준 필드(정준/실현의 분리)</a></li>
<li><a href="#충돌의-판정과-버전업-절차해석-금지"><span class="toc-section-number">4.3</span> 2.7 충돌의 판정과 버전업 절차(해석 금지)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-8">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#기호단위객체-표준"><span class="toc-section-number">4.4</span> 2.1 기호·단위·객체 표준</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-9">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#canon-입력정준"><span class="toc-section-number">4.5</span> 2.2 CANON 입력(정준)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-10">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#realization-입력"><span class="toc-section-number">4.6</span> 2.3 REALIZATION 입력</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-11">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#지름반지름셀-기하-혼동-방지"><span class="toc-section-number">4.7</span> 2.4 지름/반지름/셀 기하 혼동 방지</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-12">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#공리와-프리미티브부피입자격자양자셀"><span class="toc-section-number">5</span> 3. 공리와 프리미티브(부피입자/격자/양자셀)</a>
<ul>
<li><a href="#장의-선언-프리미티브에서-시작하는-단일-골격">장의 선언: 프리미티브에서 시작하는 단일 골격</a></li>
<li><a href="#vp-공리-세트최소-공리의-고정">VP 공리 세트(최소 공리의 고정)</a></li>
<li><a href="#기판stone-레짐과-vp-공리의-관계">기판(Stone) 레짐과 VP 공리의 관계</a></li>
<li><a href="#셀cell-정의-집계좌표계로서의-1차-객체">셀(Cell) 정의: 집계/좌표계로서의 1차 객체</a></li>
<li><a href="#vp-공리와-셀-정의의-결합-무엇이-먼저이고-무엇이-파생인가"><span class="toc-section-number">5.1</span> 3.5 VP 공리와 셀 정의의 결합: 무엇이 먼저이고 무엇이 파생인가</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-13">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#vp-공리최소-가정"><span class="toc-section-number">5.2</span> 3.1 VP 공리(최소 가정)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-14">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#재밍-격자와-point-j"><span class="toc-section-number">5.3</span> 3.2 재밍 격자와 Point-J</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-15">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#양자셀anchor-cell-정의"><span class="toc-section-number">5.4</span> 3.3 양자셀(Anchor Cell) 정의</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-16">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#ell_mathrmrot-처리참고값"><span class="toc-section-number">5.5</span> 3.4 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 처리(참고값)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-17">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#의미층-사상11과-닫힘closure-시스템"><span class="toc-section-number">6</span> 4. 의미층 사상(1:1)과 닫힘(Closure) 시스템</a>
<ul>
<li><a href="#장의-선언-의미층semantic-layers과-닫힘closure의-역할">장의 선언: 의미층(semantic layers)과 닫힘(closure)의 역할</a></li>
<li><a href="#의미층-사상11의-전역-원칙">의미층 사상(1:1)의 전역 원칙</a></li>
<li><a href="#의미층의-표준-4층-구조">의미층의 표준 4층 구조</a></li>
<li><a href="#사상semantic-mapping의-표준-템플릿"><span class="toc-section-number">6.1</span> 4.4 1:1 사상(semantic mapping)의 표준 템플릿</a></li>
<li><a href="#닫힘closure의-정의"><span class="toc-section-number">6.2</span> 4.5 닫힘(Closure)의 정의</a></li>
<li><a href="#닫힘-dag의존성-그래프의-전역-원칙"><span class="toc-section-number">6.3</span> 4.6 닫힘 DAG(의존성 그래프)의 전역 원칙</a></li>
<li><a href="#실패모드failure-modes의-표준-분류"><span class="toc-section-number">6.4</span> 4.7 실패모드(Failure Modes)의 표준 분류</a></li>
<li><a href="#검증이-필수인-이유닫힘사상의-결론-자격-조건"><span class="toc-section-number">6.5</span> 4.8 검증이 필수인 이유(닫힘/사상의 결론 자격 조건)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-18">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#의미층-사상-pressurefluxdeficitcharge"><span class="toc-section-number">6.6</span> 4.1 의미층 사상: pressure/flux/deficit/charge</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-19">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#closure-타입스택dag-규칙"><span class="toc-section-number">6.7</span> 4.2 Closure 타입·스택·DAG 규칙</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-20">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#레짐맵적용-범위"><span class="toc-section-number">6.8</span> 4.3 레짐맵(적용 범위)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-21">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#기하학-정류-상수유일-출처"><span class="toc-section-number">7</span> 5. 기하학 정류 상수(유일 출처)</a>
<ul>
<li><a href="#목적과-범위">목적과 범위</a></li>
<li><a href="#정류-상수의-정의예약-기호">정류 상수의 정의(예약 기호)</a></li>
<li><a href="#유일-출처ssot-규칙">유일 출처(SSOT) 규칙</a></li>
<li><a href="#재사용-규칙참조-방식과-결론-문장-형식"><span class="toc-section-number">7.1</span> 5.4 재사용 규칙(참조 방식과 결론 문장 형식)</a></li>
<li><a href="#위반-유형과-즉시-무효-규칙"><span class="toc-section-number">7.2</span> 5.5 위반 유형과 즉시 무효 규칙</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-22">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#alpha2pi-유도"><span class="toc-section-number">7.3</span> 5.1 <span class="math inline">\(\alpha=2/\pi\)</span> 유도</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-23">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#delta1pi2-유도-보편성-공리"><span class="toc-section-number">7.4</span> 5.2 <span class="math inline">\(\delta=1/\pi^{2}\)</span> 유도 + 보편성 공리</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-24">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#delta가-들어가는-자리"><span class="toc-section-number">7.5</span> 5.3 <span class="math inline">\(\delta\)</span>가 들어가는 자리</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-25">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#연속체-코어-모델-r_p-유도"><span class="toc-section-number">8</span> 6. 연속체 코어 모델: <span class="math inline">\(R_p\)</span> 유도</a>
<ul>
<li><a href="#목적산출물의-고정">목적(산출물의 고정)</a></li>
<li><a href="#입력lock과-레짐적용-범위">입력(LOCK)과 레짐(적용 범위)</a></li>
<li><a href="#연속체-코어-모델의-내부-정의기하-구조의-연속-근사">연속체 코어 모델의 내부 정의(기하-구조의 연속 근사)</a></li>
<li><a href="#안정-조건의-내부-정의두-스케일-법칙의-교차로서의-선택-반경">안정 조건의 내부 정의(두 스케일 법칙의 교차로서의 선택 반경)</a></li>
<li><a href="#본-장-결론의-형식외부-정당화-금지의-구현"><span class="toc-section-number">8.1</span> 6.5 본 장 결론의 형식(외부 정당화 금지의 구현)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-26">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#l_q와-lambda_c-연결l_qlambda_c"><span class="toc-section-number">8.2</span> 6.1 <span class="math inline">\(L_q\)</span>와 <span class="math inline">\(\lambda_C\)</span> 연결(<span class="math inline">\(L_q=\lambda_C\)</span>)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-27">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#r4-vs-1r5-균형-rightarrow-r_pl_q2pi"><span class="toc-section-number">8.3</span> 6.2 <span class="math inline">\(1/R^{4}\)</span> vs <span class="math inline">\(1/R^{5}\)</span> 균형 <span class="math inline">\(\rightarrow R_p/L_q=2/\pi\)</span></a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-28">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#r_p-수치-대입-불변량-정리"><span class="toc-section-number">8.4</span> 6.3 <span class="math inline">\(R_p\)</span> 수치 대입 + 불변량 정리</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-29">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#연속체rightarrow이산827-안정-조건"><span class="toc-section-number">8.5</span> 6.4 연속체<span class="math inline">\(\rightarrow\)</span>이산(82+7) 안정 조건</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-30">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#섹터-정수화120와-빌드-타임"><span class="toc-section-number">9</span> 7. 3-섹터 정수화(120)와 빌드 타임</a>
<ul>
<li><a href="#섹터의-위상학적-필연성">3-섹터의 위상학적 필연성</a></li>
<li><a href="#장의-목적과-산출물">장의 목적과 산출물</a></li>
<li><a href="#섹터120-축의-정의">3-섹터(120) 축의 정의</a></li>
<li><a href="#정수화-규칙-연속-기여-rightarrow-k_1k_2k_3">정수화 규칙: 연속 기여 <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\((k_1,k_2,k_3)\)</span></a></li>
<li><a href="#잔차불상쇄-벡터와-전하전자-라벨의-연결">잔차(불상쇄) 벡터와 전하/전자 라벨의 연결</a></li>
<li><a href="#빌드-타임build-time의-정의"><span class="toc-section-number">9.1</span> 7.5 빌드 타임(Build Time)의 정의</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-31">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#최소분산-정수화n3mr-89-82"><span class="toc-section-number">9.2</span> 7.1 최소분산 정수화(<span class="math inline">\(N=3m+r\)</span>): 89, 82</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-32">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#빌드시간-t_pt_n-정의"><span class="toc-section-number">9.3</span> 7.2 빌드시간 <span class="math inline">\(T_p,T_n\)</span> 정의</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-33">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#phi-chi-정의관측분석-넘김-기준"><span class="toc-section-number">9.4</span> 7.3 <span class="math inline">\(\Phi\)</span>, <span class="math inline">\(\chi\)</span> 정의(관측·분석 넘김 기준)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-34">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#섹터부호pmrightarrow전자반전자-라벨"><span class="toc-section-number">9.5</span> 7.4 섹터/부호(<span class="math inline">\(\pm\)</span>)<span class="math inline">\(\rightarrow\)</span>전자·반전자 라벨</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-35">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#이산-양성자-구조827"><span class="toc-section-number">10</span> 8. 이산 양성자 구조(82+7)</a>
<ul>
<li><a href="#장의-목적정의의-고정과-산출물">장의 목적(정의의 고정과 산출물)</a></li>
<li><a href="#좌표-체계의-선언좌표단위기준점-잠금">좌표 체계의 선언(좌표/단위/기준점 잠금)</a></li>
<li><a href="#그래프접촉인접성의-선언노드간선가중치-잠금">그래프(접촉/인접성)의 선언(노드/간선/가중치 잠금)</a></li>
<li><a href="#검증-프레임구조-불변량-gate-스택의-선언">검증 프레임(구조 불변량 + Gate 스택)의 선언</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-36">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#코어-좌표계층d2-접촉-그래프"><span class="toc-section-number">10.1</span> 8.1 82-코어 좌표/계층(d2) + 접촉 그래프</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-37">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#셸-기본-구조"><span class="toc-section-number">10.2</span> 8.2 7-셸 기본 구조</a></li>
<li><a href="#셸-카운트7의-기하학적-최소성-잔여-일치">셸 카운트(7)의 기하학적 최소성 + 잔여 일치</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-38">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#상쇄1-생존-검증-프레임"><span class="toc-section-number">10.3</span> 8.3 “6 상쇄+1 생존” 검증 프레임</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-39">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#전자-생성-메커니즘-전하-레이블-정의"><span class="toc-section-number">10.4</span> 8.4 전자 생성 메커니즘 + 전하 레이블 정의</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-40">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#사건quantum-정의와-정준-사건율"><span class="toc-section-number">11</span> 9. 사건(Quantum) 정의와 정준 사건율</a>
<ul>
<li><a href="#장의-목적운영-정의의-고정">장의 목적(운영 정의의 고정)</a></li>
<li><a href="#상위-전제레짐잠금기호-규약">상위 전제(레짐/잠금/기호 규약)</a></li>
<li><a href="#운영-정의의-지위정의로서의-고정">운영 정의의 지위(정의로서의 고정)</a></li>
<li><a href="#사건상태소멸의-연결-골격">사건/상태/소멸의 연결 골격</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-41">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#양자사건상태소멸-운영정의"><span class="toc-section-number">11.1</span> 9.1 양자/사건/상태/소멸 운영정의</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-42">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#정준-사건율-법칙-nu_mathrmcanscdotdelta"><span class="toc-section-number">11.2</span> 9.2 정준 사건율 법칙 <span class="math inline">\(\nu_{\mathrm{can}}=s\cdot\delta\)</span></a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-43">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#전자-정준-nu_emathrmcan1-r_e"><span class="toc-section-number">11.3</span> 9.3 전자 정준: <span class="math inline">\(\nu_{e,\mathrm{can}}=1\)</span>, <span class="math inline">\(r_e\)</span></a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-44">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#양성자-정준-nu_pmathrmcan-수치-유도292.339978ldots"><span class="toc-section-number">11.4</span> 9.4 양성자 정준: <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span> 수치 유도(<span class="math inline">\(292.339978\ldots\)</span>)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-45">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#광속-구현clock-free-c과-격자-전파"><span class="toc-section-number">12</span> 10. 광속 구현(Clock-free <span class="math inline">\(c\)</span>)과 격자 전파</a>
<ul>
<li><a href="#장의-목적연결-선언">장의 목적(연결 선언)</a></li>
<li><a href="#전역-골격-스위치-rightarrow-퍼콜레이션-rightarrow-증폭-a-rightarrow-수치-패키지">전역 골격: 스위치 <span class="math inline">\(\rightarrow\)</span> 퍼콜레이션 <span class="math inline">\(\rightarrow\)</span> 증폭 <span class="math inline">\(A\)</span> <span class="math inline">\(\rightarrow\)</span> 수치 패키지</a></li>
<li><a href="#c-스위치의-선언전파-가능불가능"><span class="math inline">\(c\)</span> 스위치의 선언(전파 가능/불가능)</a></li>
<li><a href="#퍼콜레이션임계목-연결의-선언">퍼콜레이션(임계목) 연결의 선언</a></li>
<li><a href="#증폭-계수-a의-선언정의-자리"><span class="toc-section-number">12.1</span> 10.5 증폭 계수 <span class="math inline">\(A\)</span>의 선언(정의 자리)</a></li>
<li><a href="#clock-free-c-구현의-선언내부-전파-지표-rightarrow-실현"><span class="toc-section-number">12.2</span> 10.6 Clock-free <span class="math inline">\(c\)</span> 구현의 선언(내부 전파 지표 <span class="math inline">\(\rightarrow\)</span> 실현)</a></li>
<li><a href="#수치-패키지재현와-gate-스택의-선언"><span class="toc-section-number">12.3</span> 10.7 수치 패키지(재현)와 Gate 스택의 선언</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-46">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#c의-운영-정의b_mathrmeffrho_mathrmeff-스위치"><span class="toc-section-number">12.4</span> 10.1 <span class="math inline">\(c\)</span>의 운영 정의(<span class="math inline">\(B_{\mathrm{eff}}/\rho_{\mathrm{eff}}\)</span>) + 스위치</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-47">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#delta_mathrmeff퍼콜레이션-닫힘"><span class="toc-section-number">12.5</span> 10.2 <span class="math inline">\(\delta_{\mathrm{eff}}\)</span>·퍼콜레이션 닫힘</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-48">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#soc-퍼콜레이션과-증폭-a"><span class="toc-section-number">12.6</span> 10.3 SOC 퍼콜레이션과 증폭 <span class="math inline">\(A\)</span></a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-49">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#수치실험-패키지2d목3d재밍soc핀닝"><span class="toc-section-number">12.7</span> 10.4 수치실험 패키지(2D목/3D재밍/SOC핀닝)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-50">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#격자-마찰과-적색편이전파-중-에너지-소산"><span class="toc-section-number">12.8</span> 10.8 격자 마찰과 적색편이(전파 중 에너지 소산)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-51">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#단위-실현realization-adelta-tmathrmrcross"><span class="toc-section-number">13</span> 11. 단위 실현(Realization): <span class="math inline">\(a,\Delta t,\mathrm{RCROSS}\)</span></a>
<ul>
<li><a href="#목적단위-실현의-산출물">목적(단위 실현의 산출물)</a></li>
<li><a href="#option-b-선언실현-철학">Option-B 선언(실현 철학)</a></li>
<li><a href="#운영-닻anchors의-선언입력의-지위">운영 닻(Anchors)의 선언(입력의 지위)</a></li>
<li><a href="#교차검증-체계rcross의-선언">교차검증 체계(RCROSS)의 선언</a></li>
<li><a href="#adelta-t의-잠금과-연결-선언"><span class="math inline">\(a,\Delta t\)</span>의 잠금과 연결 선언</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-52">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#option-b-철학-c_mathrmref는-운영-닻"><span class="toc-section-number">13.1</span> 11.1 Option-B 철학: <span class="math inline">\(c_{\mathrm{ref}}\)</span>는 운영 닻</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-53">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#alambda_mathrmrefn-유도rightarrow-avpm"><span class="toc-section-number">13.2</span> 11.2 <span class="math inline">\(a=\lambda_{\mathrm{ref}}/N\)</span> 유도<span class="math inline">\(\rightarrow \aVPm\)</span></a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-54">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#delta-tacdot-ac_mathrmref-유도rightarrow-1.86times-10-21mathrms"><span class="toc-section-number">13.3</span> 11.3 <span class="math inline">\(\Delta t=(A\cdot a)/c_{\mathrm{ref}}\)</span> 유도<span class="math inline">\(\rightarrow 1.86\times 10^{-21}\,\mathrm{s}\)</span></a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-55">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#mathrmrcross633532-3-tier-gate"><span class="toc-section-number">13.4</span> 11.4 <span class="math inline">\(\mathrm{RCROSS}(633/532)\)</span>: 3-Tier Gate</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-56">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#통합부록-mms-operational-anchor-형식"><span class="toc-section-number">13.5</span> 11.5 (통합부록) MMS Operational Anchor 형식</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-57">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#전자-1초-크로스체크"><span class="toc-section-number">14</span> 12. 전자 1초 크로스체크</a>
<ul>
<li><a href="#목적시간-정합의-핵심-선언">목적(시간 정합의 핵심 선언)</a></li>
<li><a href="#입력lock과-연결-위치">입력(LOCK)과 연결 위치</a></li>
<li><a href="#전자-1초의-지위운영-시간-구간">“전자 1초”의 지위(운영 시간 구간)</a></li>
<li><a href="#크로스체크의-핵심-시간-사건-구조의-동시-정합"><span class="toc-section-number">14.1</span> 12.4 크로스체크의 핵심: 시간-사건-구조의 동시 정합</a></li>
<li><a href="#gate-선언최종-통과-조건의-자리"><span class="toc-section-number">14.2</span> 12.5 Gate 선언(최종 통과 조건의 자리)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-58">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#셀vp-부피-모델-phi_mathrmjam"><span class="toc-section-number">14.3</span> 12.1 셀/VP 부피 모델 + <span class="math inline">\(\phi_{\mathrm{jam}}\)</span></a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-59">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#전자-1초-재구성식"><span class="toc-section-number">14.4</span> 12.2 “전자 1초” 재구성식</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-60">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#phi_mathrmjam-측정lock오차예산반증-트리거"><span class="toc-section-number">14.5</span> 12.3 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span> 측정·LOCK·오차예산·반증 트리거</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-61">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#질량-u_mathrmlatrightarrow-m_hm_pm_e"><span class="toc-section-number">15</span> 13. 질량: <span class="math inline">\(U_{\mathrm{lat}}\rightarrow m_H/m_p/m_e\)</span></a>
<ul>
<li><a href="#목적본론-승격-선언">목적(본론 승격 선언)</a></li>
<li><a href="#산출물정의유도검증-항목">산출물(정의/유도/검증 항목)</a></li>
<li><a href="#입력lock과-금지-규칙외부-정당화-금지">입력(LOCK)과 금지 규칙(외부 정당화 금지)</a></li>
<li><a href="#누락-보강의-본문-승격-범위선언">누락 보강의 본문 승격 범위(선언)</a></li>
<li><a href="#gate-구조본-장-결론-자격-조건">Gate 구조(본 장 결론 자격 조건)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-62">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#u_mathrmlathca1958.7mathrmgev-정의단일-출처"><span class="toc-section-number">15.1</span> 13.1 <span class="math inline">\(U_{\mathrm{lat}}=hc/a=1958.7\,\mathrm{GeV}\)</span> 정의(단일 출처)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-63">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#질량저항sigma_mathrmeff-공리정의"><span class="toc-section-number">15.2</span> 13.2 질량=저항(<span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>) 공리/정의</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-64">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#pi-계수-유도rightarrow-m_hu_mathrmlat5pi"><span class="toc-section-number">15.3</span> 13.3 <span class="math inline">\(5\pi\)</span> 계수 유도<span class="math inline">\(\rightarrow m_H=U_{\mathrm{lat}}/(5\pi)\)</span></a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-65">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#양성자-질량-적분s_p-유도"><span class="toc-section-number">15.4</span> 13.4 양성자 질량 적분(<span class="math inline">\(S_p\)</span>) 유도</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-66">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#전자-질량-적분s-유도-m_pm_e2picdot-nu_p"><span class="toc-section-number">15.5</span> 13.5 전자 질량 적분(<span class="math inline">\(S\)</span>) 유도 + <span class="math inline">\(m_p/m_e=2\pi\cdot \nu_{p}\)</span></a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-67">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#질량-대통일-요약-정리"><span class="toc-section-number">15.6</span> 13.6 질량 대통일 요약 정리</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-68">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#교차검증비율-불변량-오차-보고"><span class="toc-section-number">15.7</span> 13.7 교차검증(비율 불변량) + 오차 보고</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-69">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#힘-격자-장력-rightarrow-coulomb-절대-크기뉴턴-유도누락-보강"><span class="toc-section-number">16</span> 14. 힘: 격자 장력 <span class="math inline">\(\rightarrow\)</span> Coulomb 절대 크기(뉴턴) 유도(누락 보강)</a>
<ul>
<li><a href="#f_mathrmlath-c_mathrmrefa2와-기하-감쇄dilution-체계-정의"><span class="toc-section-number">16.1</span> 14.1 <span class="math inline">\(F_{\mathrm{lat}}=h c_{\mathrm{ref}}/a^{2}\)</span>와 “기하 감쇄(dilution)” 체계 정의</a></li>
<li><a href="#coulomb-힘-절대값-유도-및-표준-물리와의-수치-비교부록-r-통합"><span class="toc-section-number">16.2</span> 14.2 Coulomb 힘 절대값 유도 및 표준 물리와의 수치 비교(부록 R 통합)</a></li>
<li><a href="#r2-법칙의-기하학적-의미-전하의-운영-정의정준관측-분리"><span class="toc-section-number">16.3</span> 14.3 <span class="math inline">\(1/R^{2}\)</span> 법칙의 기하학적 의미 + “전하”의 운영 정의(정준/관측 분리)</a></li>
<li><a href="#casimir-압력-경계-스크리닝에-의한-1d4-힘검증-모듈"><span class="toc-section-number">16.4</span> 14.4 Casimir 압력: 경계 스크리닝에 의한 <span class="math inline">\(1/d^{4}\)</span> 힘(검증 모듈)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-70">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#sec:S14_05_alpha_em"><span class="toc-section-number">16.5</span> 14.5 미세구조상수 <span class="math inline">\(\alpha_{em}\)</span>의 기하학적 유도(정의<span class="math inline">\(\rightarrow\)</span>검산)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-71">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#양자역학-매핑빠진-부분-보강-표준-qm-요소를-대응표로-고정"><span class="toc-section-number">17</span> 15. 양자역학 매핑(빠진 부분 보강: 표준 QM 요소를 ‘대응표’로 고정)</a>
<ul>
<li><a href="#격자-분산평면파-해-leftrightarrow-파동함수상태공간-대응"><span class="toc-section-number">17.1</span> 15.1 격자 분산/평면파 해 <span class="math inline">\(\leftrightarrow\)</span> 파동함수(상태공간) 대응</a></li>
<li><a href="#born-규칙측정붕괴를-사건-빈도게이트로-재기술관측-프로토콜과-연결"><span class="toc-section-number">17.2</span> 15.2 Born 규칙·측정·붕괴를 사건 빈도/게이트로 재기술(관측 프로토콜과 연결)</a></li>
<li><a href="#연산자교환관계불확정성-스핀통계3-섹터-연결-정리가설검증항목-분리"><span class="toc-section-number">17.3</span> 15.3 연산자·교환관계·불확정성, 스핀/통계(3-섹터) 연결: “정리/가설/검증항목” 분리</a></li>
<li><a href="#표준모형-경계-공유관측-숫자-vs-비사용게이지-동역학와-유효-범위-선언"><span class="toc-section-number">17.4</span> 15.4 표준모형 경계: 공유(관측 숫자) vs 비사용(게이지 동역학)와 유효 범위 선언</a></li>
<li><a href="#sec:S15_05_blackbody"><span class="toc-section-number">17.5</span> 15.5 흑체 복사(플랑크 법칙)의 구조적 유도: 강성 껍질 필터링</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-72">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
</ul></li>
<li><a href="#검증재현성배포doi"><span class="toc-section-number">18</span> 16. 검증·재현성·배포(DOI)</a>
<ul>
<li><a href="#프로토콜-레지스트리사전등록반증-트리거fail도-공개-규칙"><span class="toc-section-number">18.1</span> 16.1 프로토콜 레지스트리/사전등록/반증 트리거(FAIL도 공개) 규칙</a></li>
<li><a href="#로그스키마manifest체크섬registry_snapshot-규격ssot"><span class="toc-section-number">18.2</span> 16.2 로그·스키마·manifest·체크섬·registry_snapshot 규격(SSOT)</a></li>
<li><a href="#참조-구현reference-implementation-실행-레시피-산출물-체크리스트-릴리즈-규정"><span class="toc-section-number">18.3</span> 16.3 참조 구현(Reference Implementation) 실행 레시피, 산출물 체크리스트, 릴리즈 규정</a></li>
<li><a href="#sec:S16_04_constant_closure_map"><span class="toc-section-number">18.4</span> 16.4 물리상수 완결 지도: GEOM/ANCHOR/CALIB의 분리</a></li>
<li><a href="#sec:S16_05_doi_guard"><span class="toc-section-number">18.5</span> 16.5 DOI 완결성 유지 규칙: “누락 0”의 자동 감사</a></li>
</ul></li>
<li><a href="#확장-파트선택-읽기"><span class="toc-section-number">19</span> 17. 확장 파트(선택 읽기)</a>
<ul>
<li><a href="#회전이방성-확장ell_mathrmrot-적용-포함과-실험-모듈-구조"><span class="toc-section-number">19.1</span> 17.1 회전/이방성 확장(<span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 적용 포함)과 실험 모듈 구조</a></li>
<li><a href="#제트특이점천체우주론-레짐-확장레짐맵에-편입"><span class="toc-section-number">19.2</span> 17.2 제트/특이점/천체·우주론 레짐 확장(레짐맵에 편입)</a></li>
<li><a href="#이-절의-lockgate-연결없으면-없음-73">이 절의 LOCK/Gate 연결(없으면 없음)</a></li>
<li><a href="#한계오픈문제vnext-로드맵새-lock-도입-조건수정-규칙-포함"><span class="toc-section-number">19.3</span> 17.3 한계·오픈문제·vNext 로드맵(새 LOCK 도입 조건/수정 규칙 포함)</a></li>
</ul></li>
<li><a href="#화학물질공학-확장선택-읽기"><span class="toc-section-number">20</span> 18. 화학/물질공학 확장(선택 읽기)</a>
<ul>
<li><a href="#범위-추가-기호-잠김-입력lock과-gate-스택요약"><span class="toc-section-number">20.1</span> 18.0 범위, 추가 기호, 잠김 입력(LOCK)과 Gate 스택(요약)</a></li>
<li><a href="#화학-반응의-물리적-재정의-확률에서-기하학으로"><span class="toc-section-number">20.2</span> 18.1 화학 반응의 물리적 재정의: 확률에서 기하학으로</a></li>
<li><a href="#표면-전하-밀도와-동적-진폭r_mathrmeff"><span class="toc-section-number">20.3</span> 18.2 표면 전하 밀도와 동적 진폭(<span class="math inline">\(r_{\mathrm{eff}}\)</span>)</a></li>
<li><a href="#결합-파괴의-절대-법칙-격자-대각선sqrt2"><span class="toc-section-number">20.4</span> 18.3 결합 파괴의 절대 법칙: 격자 대각선(<span class="math inline">\(\sqrt{2}\)</span>)</a></li>
<li><a href="#분자-구조와-결합각의-결정"><span class="toc-section-number">20.5</span> 18.4 분자 구조와 결합각의 결정</a></li>
<li><a href="#촉매와-분리-공학-압축과-이완"><span class="toc-section-number">20.6</span> 18.5 촉매와 분리 공학: 압축과 이완</a></li>
<li><a href="#주요-난제-해결-사례-검증"><span class="toc-section-number">20.7</span> 18.6 주요 난제 해결 사례 검증</a></li>
<li><a href="#결론-물질-과학의-새로운-지평"><span class="toc-section-number">20.8</span> 18.7 결론: 물질 과학의 새로운 지평</a></li>
<li><a href="#상전이와-열역학-진폭의-임계-온도"><span class="toc-section-number">20.9</span> 18.8 상전이와 열역학: 진폭의 임계 온도</a></li>
</ul></li>
<li><a href="#부록-a.-수학-보조정리증명-스케치">부록 A. 수학 보조정리/증명 스케치</a>
<ul>
<li><a href="#a.0-표기와-기본-약속공통">A.0 표기와 기본 약속(공통)</a></li>
<li><a href="#a.1-코시슈바르츠-부등식">A.1 코시–슈바르츠 부등식</a></li>
<li><a href="#a.2-삼각부등식">A.2 삼각부등식</a></li>
<li><a href="#a.3-몫공간-차원-정리전역-기준-자유도-제거">A.3 몫공간 차원 정리(전역 기준 자유도 제거)</a></li>
<li><a href="#a.4-이산-푸리에-변환과-파르세발-정리유한-격자">A.4 이산 푸리에 변환과 파르세발 정리(유한 격자)</a></li>
<li><a href="#a.5-교환자-기반-불확정성-부등식순수-대수">A.5 교환자 기반 불확정성 부등식(순수 대수)</a></li>
<li><a href="#a.6-민감도오차-전파-상한">A.6 민감도(오차 전파) 상한</a></li>
<li><a href="#a.7-유효숫자-반올림-연산자보고-규약">A.7 유효숫자 반올림 연산자(보고 규약)</a></li>
</ul></li>
<li><a href="#부록-b.-수치-프로토콜-상세게이트-시드-샘플링">부록 B. 수치 프로토콜 상세(게이트, 시드, 샘플링)</a>
<ul>
<li><a href="#b.0-실행-단위와-기록-단위정의">B.0 실행 단위와 기록 단위(정의)</a></li>
<li><a href="#b.1-시드-규약결정론">B.1 시드 규약(결정론)</a></li>
<li><a href="#b.2-샘플링-규약창시드반복">B.2 샘플링 규약(창/시드/반복)</a></li>
<li><a href="#b.3-수치-연산-규약오차안정성">B.3 수치 연산 규약(오차/안정성)</a></li>
<li><a href="#b.4-gate-평가-규약순서기록봉인">B.4 Gate 평가 규약(순서/기록/봉인)</a></li>
<li><a href="#b.5-fail-트리거반증-트리거-기록-형식">B.5 FAIL 트리거(반증 트리거 기록 형식)</a></li>
</ul></li>
<li><a href="#부록-c.-아카이브-스키마-파일-트리">부록 C. 아카이브 스키마 &amp; 파일 트리</a>
<ul>
<li><a href="#c.0-디렉터리-트리불변-규약">C.0 디렉터리 트리(불변 규약)</a></li>
<li><a href="#c.1-registry_snapshot-스키마ssot-봉인">C.1 registry_snapshot 스키마(SSOT 봉인)</a></li>
<li><a href="#c.2-canon_lock-스키마정준-입력">C.2 canon_lock 스키마(정준 입력)</a></li>
<li><a href="#c.3-realization_lock-스키마단위-실현">C.3 realization_lock 스키마(단위 실현)</a></li>
<li><a href="#c.4-analysis_lock-스키마선택레짐정의-고정">C.4 analysis_lock 스키마(선택/레짐/정의 고정)</a></li>
<li><a href="#c.5-gate_lock-스키마문턱판정-규칙">C.5 gate_lock 스키마(문턱/판정 규칙)</a></li>
<li><a href="#c.6-protocol_lock-스키마단위-변환보고-규약">C.6 protocol_lock 스키마(단위 변환/보고 규약)</a></li>
<li><a href="#c.7-run-manifest-스키마입력산출물-봉인">C.7 run manifest 스키마(입력/산출물 봉인)</a></li>
</ul></li>
<li><a href="#부록-d.-용어집색인">부록 D. 용어집/색인</a>
<ul>
<li><a href="#d.0-용어정의-고정">D.0 용어(정의 고정)</a></li>
<li><a href="#d.1-기호-색인최소">D.1 기호 색인(최소)</a></li>
</ul></li>
<li><a href="#부록-epmr.-핵심-유도-원문-결정론-검증-스크립트">부록 E/P/M/R. 핵심 유도 원문 + 결정론 검증 스크립트</a>
<ul>
<li><a href="#부록-e.-전자-질량의-기하학적-기원과-직접-측정">부록 E. 전자 질량의 기하학적 기원과 직접 측정</a></li>
<li><a href="#부록-p.-양성자-질량의-격자-기원과-적분법">부록 P. 양성자 질량의 격자 기원과 적분법</a></li>
<li><a href="#부록-m.-질량-대통일-격자-에너지의-기하학적-분화">부록 M. 질량 대통일: 격자 에너지의 기하학적 분화</a></li>
<li><a href="#부록-r.-격자-장력-이론-전자기력의-절대-크기-유도">부록 R. 격자 장력 이론: 전자기력의 절대 크기 유도</a></li>
</ul></li>
<li><a href="#부록-f.-사건율의-이산-분해-가설-정수부활성-사이트와-잔차진동">부록 F. 사건율의 이산 분해 가설: 정수부(활성 사이트)와 잔차(진동)</a>
<ul>
<li><a href="#f.0-목적과-범위비-lock">F.0 목적과 범위(비-LOCK)</a></li>
<li><a href="#f.1-정의-정수-활성도와-잔차">F.1 정의: 정수 활성도와 잔차</a></li>
<li><a href="#f.2-후보-이산-매핑-82times-4---9times-4-292">F.2 후보 이산 매핑: <span class="math inline">\(82\times 4 - 9\times 4 = 292\)</span></a></li>
<li><a href="#f.3-향후-gate-설계선언">F.3 향후 Gate 설계(선언)</a></li>
<li><a href="#f.4-결정론-계산-스니펫검증용">F.4 결정론 계산 스니펫(검증용)</a></li>
</ul></li>
<li><a href="#부록-g.-중력의-기하학적-유도-격자-강성-한계와-포화-이론">부록 G. 중력의 기하학적 유도: 격자 강성 한계와 포화 이론</a>
<ul>
<li><a href="#g.-1-적용-레짐게이트-강성-레짐에서만의-유도">G.-1 적용 레짐(게이트): 강성 레짐에서만의 유도</a></li>
<li><a href="#g.0-핵심-명제-9.8은-공간격자의-항복-강도이다">G.0 핵심 명제: 9.8은 ‘공간(격자)의 항복 강도’이다</a></li>
<li><a href="#g.1-방어-논리-중력은-단일-성분이-아니라-2-채널로-관측된다">G.1 방어 논리: 중력은 단일 성분이 아니라 <span class="math inline">\(\;2\)</span>-채널로 관측된다</a></li>
<li><a href="#g.2-기하학-파트-결손-곡률요구량-잠재가속도의-항등식">G.2 기하학 파트: 결손-곡률요구량-잠재가속도의 항등식</a></li>
<li><a href="#g.3-포화항복-파트-격자-복원압의-구성방정식constitutive-law">G.3 포화(항복) 파트: 격자 복원압의 구성방정식(constitutive law)</a></li>
<li><a href="#g.4-반례목성태양중성자별-등-처리">G.4 반례(목성/태양/중성자별 등) 처리</a></li>
<li><a href="#g.5-최종-정리요약-방정식">G.5 최종 정리(요약 방정식)</a></li>
<li><a href="#g.6-결정론-검증-스크립트재현-가능-출력">G.6 결정론 검증 스크립트(재현 가능 출력)</a></li>
</ul></li>
<li><a href="#app:geom_rigidity_v2_1"><span class="toc-section-number">21</span> Appendix H: Theory of Geometric Rigidity (v2.1)</a>
<ul>
<li><a href="#h.1-geometric-gap-and-barrier"><span class="toc-section-number">21.1</span> H.1 Geometric gap and barrier</a></li>
<li><a href="#h.2-statistical-stability-and-the-rigidity-form"><span class="toc-section-number">21.2</span> H.2 Statistical stability and the rigidity form</a></li>
<li><a href="#h.3-diagnostic-inversion-effective-coordination-from-modulus-ratios"><span class="toc-section-number">21.3</span> H.3 Diagnostic inversion: effective coordination from modulus ratios</a></li>
<li><a href="#h.4-doi-reproducibility-artifacts-lock"><span class="toc-section-number">21.4</span> H.4 DOI reproducibility artifacts (LOCK)</a></li>
</ul></li>
<li><a href="#app:doi_cite_registry"><span class="toc-section-number">22</span> Appendix I: DOI-anchored Citation Registry (No Missing DOI)</a></li>
<li><a href="#app:black_copper_ess"><span class="toc-section-number">23</span> Appendix J: 블랙-코팅 구리 ESS — 임피던스 변환 집열, 과립(Granular) 격자 저장, 그리고 Black-Copper 트랜스덕션 (공학 부록; NON-LOCK)</a>
<ul>
<li><a href="#j.0-범위와-상태-non-lock"><span class="toc-section-number">23.1</span> J.0 범위와 상태 (NON-LOCK)</a></li>
<li><a href="#j.1-격자-및-인터페이스의-공학적-정의"><span class="toc-section-number">23.2</span> J.1 격자 및 인터페이스의 공학적 정의</a></li>
<li><a href="#j.2-임피던스-미스매치와-진폭-변환-에너지-이득-없음"><span class="toc-section-number">23.3</span> J.2 임피던스 미스매치와 진폭 변환 (에너지 이득 없음)</a></li>
<li><a href="#j.3-기하-모닝글로리morning-glory-트럼펫을-임피던스-변환기로-사용"><span class="toc-section-number">23.4</span> J.3 기하: “모닝글로리(morning-glory)” 트럼펫을 임피던스 변환기로 사용</a></li>
<li><a href="#j.4-과립-격자-저장모래-배터리-용량"><span class="toc-section-number">23.5</span> J.4 과립 격자 저장(모래 배터리) 용량</a></li>
<li><a href="#j.5-공동-내부의-black-copper-스프링이중-용도-히터-트랜스듀서"><span class="toc-section-number">23.6</span> J.5 공동 내부의 Black-Copper 스프링(이중 용도: 히터 + 트랜스듀서)</a></li>
<li><a href="#j.6-본-부록을-위한-lock-rightarrow-gate-체크리스트-권장"><span class="toc-section-number">23.7</span> J.6 본 부록을 위한 “LOCK <span class="math inline">\(\rightarrow\)</span> Gate” 체크리스트 (권장)</a></li>
</ul></li>
<li><a href="#app:acoustic_validation"><span class="toc-section-number">24</span> Appendix K: 고전 기체 음향학을 통한 방법론 검증 (평균자유행로 재구성)</a>
<ul>
<li><a href="#k.0-범위와-의도-캘리브레이션-모듈-non-lock"><span class="toc-section-number">24.1</span> K.0 범위와 의도 (캘리브레이션 모듈; NON-LOCK)</a></li>
<li><a href="#k.1-공기-음향이-적절한-캘리브레이션-표적인-이유"><span class="toc-section-number">24.2</span> K.1 공기 음향이 적절한 캘리브레이션 표적인 이유</a></li>
<li><a href="#k.2-거시-자료로부터-lambda_mathrmmfp-재구성-예제-1건"><span class="toc-section-number">24.3</span> K.2 거시 자료로부터 <span class="math inline">\(\lambda_{\mathrm{mfp}}\)</span> 재구성 (예제 1건)</a></li>
<li><a href="#k.3-레짐-gate-연속체-음향-vs.-이산-충돌-스케일"><span class="toc-section-number">24.4</span> K.3 레짐 Gate: 연속체 음향 vs. 이산 충돌 스케일</a></li>
<li><a href="#k.4-동형isomorphic-비교표-음향-vs.-vp-격자-재구성"><span class="toc-section-number">24.5</span> K.4 동형(isomorphic) 비교표 (음향 vs. VP 격자 재구성)</a></li>
<li><a href="#k.5-주장-레벨과-한계"><span class="toc-section-number">24.6</span> K.5 주장 레벨과 한계</a></li>
</ul></li>
<li><a href="#app:state_dictionary_431"><span class="toc-section-number">25</span> Appendix L: 재밍 레짐 통합을 위한 4-3-1 상태 사전 (해석 모듈; NON-LOCK)</a>
<ul>
<li><a href="#l.0-범위-이-부록이-하는-것하지-않는-것"><span class="toc-section-number">25.1</span> L.0 범위 (이 부록이 하는 것/하지 않는 것)</a></li>
<li><a href="#l.1-4-3-1-사전-연결성connectivity을-레짐-라벨로"><span class="toc-section-number">25.2</span> L.1 4-3-1 사전 (연결성(connectivity)을 레짐 라벨로)</a></li>
<li><a href="#l.2-에너지를-언재밍-비용으로-보기-최소-계단staircase-모형"><span class="toc-section-number">25.3</span> L.2 에너지를 “언재밍 비용”으로 보기 (최소 계단(staircase) 모형)</a></li>
<li><a href="#l.3-state-2가-금지되는-이유-기하학적-폐곡면-실패"><span class="toc-section-number">25.4</span> L.3 “State 2”가 금지되는 이유 (기하학적 폐곡면 실패)</a></li>
<li><a href="#l.4-유동성-phi와의-관계-실패율-관점"><span class="toc-section-number">25.5</span> L.4 유동성 <span class="math inline">\(\phi\)</span>와의 관계 (실패율 관점)</a></li>
<li><a href="#l.5-빛은-기체-유사를-모순-없이-말하기-매질-vs-여기"><span class="toc-section-number">25.6</span> L.5 “빛은 기체-유사”를 모순 없이 말하기 (매질 vs 여기)</a></li>
<li><a href="#l.6-음향-캘리브레이션-모듈과의-연결"><span class="toc-section-number">25.7</span> L.6 음향 캘리브레이션 모듈과의 연결</a></li>
<li><a href="#l.7-에너지-부피-교환-우주-대사를-gate-정의-가설로"><span class="toc-section-number">25.8</span> L.7 에너지-부피 교환 (우주 “대사”를 Gate 정의 가설로)</a></li>
</ul></li>
</ul>
</nav>
  </aside>
  <main class="content" id="main">
    <header id="title-block-header">
<h1 class="title">부피입자(VP) 이론 백서 v0.1.2</h1>
<p class="author">Young jae Lee<br/>
Independent researcher, Daegu, Korea<br/>
<a href="https://orcid.org/0009-0002-7535-8245">ORCID: 0009-0002-7535-8245</a><br/>
<code>rego093@naver.com</code></p>
<p class="date">Draft v0.1.2 (Korean edition; synced to SEO_v11_SOCN750) (2025-12-15)</p>
<div class="abstract">
<div class="abstract-title">Abstract</div>
<p>본 문서는 “부피입자(Volume-Particle, VP)” 기반 이론의 핵심 골격을 <em>백서(white paper)</em> 형식으로 요약하고, 동일 파일 안에 전체 규격(LOCK 스키마, 유도 사슬, Gate 판정, 교차검증, 재현 패키지)을 포함한다.
문서가 채택하는 운영 원칙은 <strong>LOCK <span class="math inline">\(\rightarrow\)</span> 유도(derived) <span class="math inline">\(\rightarrow\)</span> Gate</strong> 단방향 흐름이다: (i) 입력값과 의미를 LOCK으로 고정(사후 보정 금지), (ii) LOCK에서 허용된 변환 규칙만으로 파생량을 유도, (iii) Gate의 PASS/FAIL/INCONCLUSIVE 판정으로 결과의 자격을 제한한다.
본 버전은 정준 길이 앵커 <span class="math inline">\(D_{\mathrm{anch}}\)</span>, 양성자 반경 <span class="math inline">\(r_p\)</span>, 회전 구동 길이 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>, 단위 실현 스케일 <span class="math inline">\(a,\Delta t\)</span>, 정류 상수 <span class="math inline">\(\alpha,\delta\)</span> 등을 LOCK 입력으로 취급하고, 사건율/길이-시간-질량/힘 스케일에 대한 유도식을 제시한다. 재현성은 <code>manifest+checksums+registry_snapshot</code> 및 실행 로그 봉인을 통해 규정한다.
<strong>DOI:</strong> <a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a> (text+code+data bundle).</p>
</div>
</header>
    <div class="center">
<p><strong>Affiliation:</strong> Independent researcher, Daegu, Korea
<strong>ORCID:</strong> <a href="https://orcid.org/0009-0002-7535-8245">0009-0002-7535-8245</a>
<strong>Email:</strong> <code>rego093@naver.com</code><br/>
<strong>DOI:</strong> <a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a><br/>
<strong>Conflict of interest:</strong> No conflict of interest
<strong>Funding:</strong> No funding</p>
</div>
<h1 data-number="1" id="w.-백서-요약executive-summary"><span class="header-section-number">1</span> W. 백서 요약(Executive Summary)</h1>
<h2 data-number="1.1" id="w.1-한-페이지-요약무엇을-잠그고-무엇을-내며-어떻게-판정하는가"><span class="header-section-number">1.1</span> W.1 한 페이지 요약(무엇을 잠그고, 무엇을 내며, 어떻게 판정하는가)</h2>
<ul>
<li><p><strong>핵심 아이디어</strong>: 공간의 기본 단위로 VP를 두고(무한강성/충만/재밍 레짐), 모든 결론을 “잠김 입력(LOCK)”에서만 출발시켜 유도한 뒤, Gate로 판정한다.</p></li>
<li><p><strong>문서의 역할</strong>: <em>(a) 무엇이 입력으로 잠기는지</em>, <em>(b) 무엇이 유도 산출물인지</em>, <em>(c) 어떤 조건에서 결과를 근거로 사용할 수 있는지(PASS)</em>를 기계 판독 가능하도록 고정한다.</p></li>
<li><p><strong>읽는 경로</strong>: 루트 A(정의<span class="math inline">\(\rightarrow\)</span>유도<span class="math inline">\(\rightarrow\)</span>검증), 루트 B(단위실현<span class="math inline">\(\rightarrow\)</span>교차검증<span class="math inline">\(\rightarrow\)</span>재현), 루트 C(수치<span class="math inline">\(\rightarrow\)</span>근거 역추적)를 제공한다(0장).</p></li>
</ul>
<h2 data-number="1.2" id="w.2-입력lock-vs-산출derived-회계표요약"><span class="header-section-number">1.2</span> W.2 입력(LOCK) vs 산출(derived) 회계표(요약)</h2>
<div class="center">
<table style="width:94%;">
<colgroup>
<col style="width: 47%"/>
<col style="width: 47%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>LOCK 입력(잠김; 변경은 버전업)</strong></th>
<th style="text-align: left;"><strong>파생 산출(유도; Gate로 자격화)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">정준 길이 앵커 <span class="math inline">\(D_{\mathrm{anch}}\)</span> (canon_lock)</td>
<td style="text-align: left;">전자 반경 <span class="math inline">\(r_e=(D_{\mathrm{anch}}/2)\delta\)</span> (예: 9.3, 13.5)</td>
</tr>
<tr class="even">
<td style="text-align: left;">양성자 반경 <span class="math inline">\(r_p\)</span> (canon_lock)</td>
<td style="text-align: left;"><span class="math inline">\(\lambda_C\)</span> 등의 연결 규약 및 길이비 불변량(예: 6.3, 13장)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">단위 실현 길이 <span class="math inline">\(a\)</span> (VP 지름; realization_lock)</td>
<td style="text-align: left;">격자 단위 에너지 <span class="math inline">\(U_{\mathrm{lat}}:=h\,c_{\mathrm{ref}}/a\)</span> (13.1)</td>
</tr>
<tr class="even">
<td style="text-align: left;">단위 실현 시간 <span class="math inline">\(\Delta t\)</span> (realization_lock)</td>
<td style="text-align: left;">사건 집계/시간 창의 교차정합(<code>RCROSS</code>, 11–12장)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">정류 상수 <span class="math inline">\(\alpha=2/\pi\)</span>, <span class="math inline">\(\delta=1/\pi^2\)</span> (보편 레짐)</td>
<td style="text-align: left;">질량 스케일 <span class="math inline">\(m(\mathcal{O})=U_{\mathrm{lat}}/S(\mathcal{O})\)</span> 계열(13장)</td>
</tr>
<tr class="even">
<td style="text-align: left;">회전 구동 길이 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> (protocol/realization 계열)</td>
<td style="text-align: left;">이방성/SOC/제트(선택 루트; 17장)</td>
</tr>
</tbody>
</table>
</div>
<h2 data-number="1.3" id="w.3-gate판정과-재현artifact-요약"><span class="header-section-number">1.3</span> W.3 Gate(판정)과 재현(artifact) 요약</h2>
<ul>
<li><p><strong>Gate 출력</strong>: PASS/FAIL/INCONCLUSIVE만 허용. FAIL 또는 INCONCLUSIVE인 결과는 이후 절에서 근거로 사용 금지(0장).</p></li>
<li><p><strong>필수 Gate 예시</strong>: G-SYM(기호/단위), G-LOCK(잠금 무결성), G-REG(레짐), G-RECT(정류), G-RCROSS(교차정합), G-REP(재현)(0.2).</p></li>
<li><p><strong>재현 패키지</strong>: <code>manifest</code>, <code>checksums</code>, <code>registry_snapshot</code>, 실행 로그 및 산출물 경로를 단일 스냅샷으로 봉인하는 규격을 제공한다(16장).</p></li>
</ul>
<h3 data-number="1.3.1" id="w.3.0-주장-범위와-엄격성-레벨claim-tiers"><span class="header-section-number">1.3.1</span> W.3.0 주장 범위와 엄격성 레벨(Claim Tiers)</h3>
<p>본 문서는 “엄격함”을 <em>문장 강도</em>가 아니라 <em>주장 범위와 검증 의무</em>로 정의한다.
즉, 더 강한 결론을 말할수록 더 많은 Gate 스택을 통과해야 하며, Gate 보고서가 없으면 결론은 자동으로 <code>UNLOGGED</code>/<code>INCONCLUSIVE</code>로 남는다.</p>
<ul>
<li><p><strong>Level-C0 (내부 정합/재현):</strong> LOCK<span class="math inline">\(\rightarrow\)</span>유도<span class="math inline">\(\rightarrow\)</span>Gate 프레임이 자기모순 없이 닫히고, <code>manifest+checksums+registry_snapshot</code>으로 재현성이 봉인된 수준.</p></li>
<li><p><strong>Level-C1 (이상 한계식/스케일링 재현):</strong> Casimir 이상식 등 표준식과 동형인 한계식을 재현하고, 스케일링(<span class="math inline">\(1/d^4\)</span> 등)과 단위/차원을 엄격히 고정한 수준. <em>해석</em>은 분리된다.</p></li>
<li><p><strong>Level-C2 (실험 정량 비교):</strong> 특정 실험 셋업(형상/물성/보정/거리 레짐)을 LOCK하고, 동일 조건에서 잔차 기준 Gate를 통과하는 수준.</p></li>
<li><p><strong>Level-C3 (강한 우주론 결론):</strong> 시간 신장/표면밝기/블러링/에너지 종착 등 필수 Gate 스택을 통과하여, “팽창 대체” 또는 “암흑에너지 불필요” 같은 결론을 산출할 자격이 있는 수준.</p></li>
</ul>
<h4 data-number="1.3.1.1" id="본-버전의-기본-스코프"><span class="header-section-number">1.3.1.1</span> 본 버전의 기본 스코프</h4>
<p>본 PDF(Draft v0.1.2 (Korean edition; synced to SEO_v11_SOCN750))는 기본적으로 Level-C0–C1 범위에서 <strong>규약과 유도식</strong>을 제시한다.
Level-C2 이상(정량 실험 일치, 우주론 대체)을 결론으로 사용하려면, 해당 Gate 보고서가 번들에 첨부되어 <code>PASS</code>가 확인되어야 한다.
그렇지 않으면 관련 문장은 <strong>가설/분기 예시</strong>로만 취급된다.</p>
<h3 data-number="1.3.2" id="w.3.1-gate-상태-요약표핵심-산출물-draft-v0.1.2-korean-edition-synced-to-seo_v11_socn750-기준"><span class="header-section-number">1.3.2</span> W.3.1 Gate 상태 요약표(핵심 산출물; Draft v0.1.2 (Korean edition; synced to SEO_v11_SOCN750) 기준)</h3>
<p>아래 표는 본 문서 본문에서 이미 등장하는 <strong>핵심 산출물</strong>을 대상으로, (i) 어떤 LOCK 입력을 사용했는지, (ii) 어떤 Gate 스택이 <code>PASS</code>해야 결론 자격을 갖는지, (iii) 그 <strong>판정 로그(증거)</strong>가 번들 내 어디에 있어야 하는지를 <em>첫 장에서 바로 찾을 수 있게</em> 한 페이지로 압축한 것이다.</p>
<p><strong>상태 표기 규약(요약)</strong>:
<code>PASS</code>/<code>FAIL</code>/<code>INCONCLUSIVE</code>는 <code>bundle_root/gate/reports/</code>의 보고서가 있을 때만 확정된다. 본 PDF만 단독 배포되어 Gate 보고서가 첨부되지 않은 경우 상태는 <code>UNLOGGED</code>(=증거 파일 미첨부)로 표기한다.</p>
<div class="center">
<table style="width:95%;">
<colgroup>
<col style="width: 18%"/>
<col style="width: 23%"/>
<col style="width: 19%"/>
<col style="width: 10%"/>
<col style="width: 25%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>산출물(요약)</strong></th>
<th style="text-align: left;"><strong>사용 LOCK(요약)</strong></th>
<th style="text-align: left;"><strong>필수 Gate(요약)</strong></th>
<th style="text-align: left;"><strong>상태</strong></th>
<th style="text-align: left;"><strong>증거 경로(표준)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(a\)</span> (VP 지름; SI 실현)</td>
<td style="text-align: left;"><code>realization_lock</code>: <span class="math inline">\(\lambda_{\mathrm{ref}}\)</span>, <span class="math inline">\(a\)</span>; <code>analysis_lock</code>: <span class="math inline">\(N\)</span></td>
<td style="text-align: left;">G-SYM, G-LOCK, G-REG, G-NT, (G-RCROSS), (G-NUM)</td>
<td style="text-align: left;">UNLOGGED</td>
<td style="text-align: left;"><code>gate/reports/gate_report_a.json</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>snapshot/manifest.(json|yaml)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\Delta t\)</span> (시간 틱; 실현)</td>
<td style="text-align: left;"><code>realization_lock</code>: <span class="math inline">\(a\)</span>, <span class="math inline">\(c_{\mathrm{ref}}\)</span>; <code>analysis_lock</code>: <span class="math inline">\(A\)</span></td>
<td style="text-align: left;">G-SYM, G-LOCK, G-REG, G-NT, (G-RCROSS), (G-NUM)</td>
<td style="text-align: left;">UNLOGGED</td>
<td style="text-align: left;"><code>gate/reports/gate_report_dt.json</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>gate/logs/*dt*.(log|csv)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(U_{\mathrm{lat}}:=h\,c_{\mathrm{ref}}/a\)</span> (격자 단위 에너지)</td>
<td style="text-align: left;"><code>canon_lock</code>: <span class="math inline">\(h\)</span>; <code>realization_lock</code>: <span class="math inline">\(c_{\mathrm{ref}},a\)</span></td>
<td style="text-align: left;">G-SYM, G-LOCK, G-REG, G-NT, (G-NUM)</td>
<td style="text-align: left;">UNLOGGED</td>
<td style="text-align: left;"><code>gate/reports/gate_report_Ulat.json</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>derived/claims.(tex|json)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(r_e=(D_{\mathrm{anch}}/2)\,\delta\)</span> (전자 반경)</td>
<td style="text-align: left;"><code>canon_lock</code>: <span class="math inline">\(D_{\mathrm{anch}}\)</span>; <code>analysis_lock</code>: <span class="math inline">\(\delta\)</span></td>
<td style="text-align: left;">G-SYM, G-LOCK, G-REG, G-NT, (G-RECT), (G-NUM)</td>
<td style="text-align: left;">UNLOGGED</td>
<td style="text-align: left;"><code>gate/reports/gate_report_re.json</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>derived/claims.(tex|json)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(m_e\)</span> (전자 질량; <span class="math inline">\(m_e=U_{\mathrm{lat}}/S\)</span>)</td>
<td style="text-align: left;"><code>realization_lock</code>: <span class="math inline">\(U_{\mathrm{lat}}\)</span>; <code>analysis_lock</code>: <span class="math inline">\(S\)</span>; <code>canon_lock</code>: <span class="math inline">\(r_e\)</span></td>
<td style="text-align: left;">G-SYM, G-LOCK, G-REG, G-NT, (G-RECT), (G-NUM)</td>
<td style="text-align: left;">UNLOGGED</td>
<td style="text-align: left;"><code>gate/reports/gate_report_me.json</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>derived/tables/*mass*.csv</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(m_p\)</span> (양성자 질량)</td>
<td style="text-align: left;"><code>canon_lock</code>: <span class="math inline">\(r_p\)</span>; <code>realization_lock</code>: <span class="math inline">\(U_{\mathrm{lat}}\)</span>; <code>analysis_lock</code>: <span class="math inline">\(S_p\)</span> 또는 사건율 대응</td>
<td style="text-align: left;">G-SYM, G-LOCK, G-REG, G-NT, (G-NUM)</td>
<td style="text-align: left;">UNLOGGED</td>
<td style="text-align: left;"><code>gate/reports/gate_report_mp.json</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>derived/claims.(tex|json)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(m_H\)</span> (힉스 질량; 예: <span class="math inline">\(U_{\mathrm{lat}}/(5\pi)\)</span>)</td>
<td style="text-align: left;"><code>realization_lock</code>: <span class="math inline">\(U_{\mathrm{lat}}\)</span>; <code>analysis_lock</code>: 계수(예: <span class="math inline">\(5\pi\)</span>)</td>
<td style="text-align: left;">G-SYM, G-LOCK, G-REG, G-NT, (G-NUM)</td>
<td style="text-align: left;">UNLOGGED</td>
<td style="text-align: left;"><code>gate/reports/gate_report_mH.json</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>derived/claims.(tex|json)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(m_p/m_e\)</span> (질량비; 교차정합 대상)</td>
<td style="text-align: left;"><code>analysis_lock</code>: <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span> 등; <code>derived</code>: <span class="math inline">\(m_p,m_e\)</span></td>
<td style="text-align: left;">G-SYM, G-LOCK, G-REG, G-NT, (G-RCROSS), (G-NUM)</td>
<td style="text-align: left;">UNLOGGED</td>
<td style="text-align: left;"><code>gate/reports/gate_report_mp_me.json</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>gate/reports/gate_report_RCROSS.json</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>manifest+checksums+registry_snapshot</code> (릴리즈 무결성)</td>
<td style="text-align: left;"><code>protocol_lock</code> &amp; <code>snapshot/*</code> (봉인 규격)</td>
<td style="text-align: left;">G-SYM, G-LOCK, G-NT, (G-REP)</td>
<td style="text-align: left;">UNLOGGED</td>
<td style="text-align: left;"><code>snapshot/manifest.(json|yaml|csv)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>snapshot/checksums.(txt|json)</code></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</div>
<h2 data-number="1.4" id="w.4-알려진-제약열린-항목백서-관점의-명시"><span class="header-section-number">1.4</span> W.4 알려진 제약/열린 항목(백서 관점의 명시)</h2>
<ul>
<li><p><strong>보고 규약(대응 규약)과 유도의 구분</strong>: 일부 절에서는 “표준형”을 보고 규약(대응 규약)으로 <code>analysis_lock</code>에 잠그는 선택을 포함한다. 이는 <em>유도 결과와 동일시되면 안 되며</em>, 동일 버전 내부 일관성은 Gate로 판정되어야 한다(예: 13.5의 질량비 표준형 고정).</p></li>
<li><p><strong>버전 규율</strong>: 결과를 보고 정의/문턱/의미(지름-반지름)를 바꾸는 행위는 금지이며, 필요 시 LOCK 버전업으로만 처리한다(0장, 1장).</p></li>
</ul>
<h1 data-number="2" id="프롤로그문서-사용법"><span class="header-section-number">2</span> 0. 프롤로그(문서 사용법)</h1>
<h2 class="unnumbered" id="장의-목적">장의 목적</h2>
<p>본 장은 이론서 전체의 작성 규약을 <em>선언</em>한다. 선언의 대상은 (i) 장의 목적, (ii) 장과 문서가 산출해야 하는 결과물, (iii) 문서 내부에 고정되는 순회 루트의 정의, (iv) 모든 명제가 따라야 하는 <strong>LOCK <span class="math inline">\(\rightarrow\)</span> 유도 <span class="math inline">\(\rightarrow\)</span> Gate</strong>의 단방향 흐름이다.
본 이론서의 서술은 하나의 사상(부피입자, 무한강성, 충만, 재밍, 임계목, 사건율, 단위실현, 교차검증)을 단일 골격으로 묶는다. 이 골격은 문서 전 구간에서 동일한 형식을 유지하며, 동일한 항목을 다른 절에서 다시 정의하거나 같은 유도를 반복하여 근거를 증식시키지 않는다.
본 장은 규칙의 반복 설명을 수행하지 않는다. 본 장에서 선언된 항목은 이후 절에서 <em>참조</em>될 뿐, 동일 내용이 서술형으로 재전개되지 않는다.</p>
<h2 class="unnumbered" id="산출물">산출물</h2>
<p>본 이론서의 산출물은 다음의 네 묶음으로 고정한다.</p>
<ol>
<li><p><strong>정준(LOCK) 묶음</strong>: 공리, 정의, 기호/단위 규약, 운영 닻(단위 실현의 기준점), 사전 등록된 문턱값과 판정 규칙, 그리고 이들 사이의 의존성(순서) 구조.</p></li>
<li><p><strong>유도(derived) 묶음</strong>: LOCK에서 시작하여 허용된 변환만으로 도달한 명제, 정리, 수치 결과, 스케일 관계, 비율 불변량, 그리고 각 결과가 어떤 LOCK 항목에 의존하는지의 추적표.</p></li>
<li><p><strong>검증(Gate) 묶음</strong>: 유도 결과를 평가하기 위한 판정 조건의 집합(PASS/FAIL/INCONCLUSIVE), 교차검증 채널, 민감도/로버스트성 점검 항목, 실패 모드 정의, 그리고 판정 로그.</p></li>
<li><p><strong>재현(artifact) 묶음</strong>: 코드, 입력 파일, 환경 정보, 시드, 로그, 데이터, 산출물(그림/표/수치 요약), 해시/체크섬, 매니페스트, 릴리즈 태그 및 변경 기록.</p></li>
</ol>
<p>각 산출물은 문서 내부에서 상호 참조되며, 어느 한 산출물만으로 결론을 자격화하지 않는다. 수치 결과는 반드시 <strong>LOCK 근거</strong>와 <strong>Gate 판정</strong>을 함께 가진다.</p>
<h2 class="unnumbered" id="문서-순회-루트의-정의">문서 순회 루트의 정의</h2>
<p>본 이론서는 동일한 본문을 서로 다른 목적에 맞게 재배열한 <strong>순회 루트</strong>를 내부 정의로 제공한다. 루트는 “누가 무엇을 읽어야 한다”는 권고가 아니라, 문서 내부 의존성 그래프를 따라 가능한 경로를 <em>형식</em>으로 구분한 것이다.</p>
<ul>
<li><p><strong>루트 A(정의<span class="math inline">\(\rightarrow\)</span>유도<span class="math inline">\(\rightarrow\)</span>검증)</strong>: 공리/정의/기호 규약을 고정한 뒤, 핵심 수치와 스케일 관계를 유도하고, 각 결과에 대응하는 Gate로 판정을 부여하는 경로.</p></li>
<li><p><strong>루트 B(단위실현<span class="math inline">\(\rightarrow\)</span>교차검증<span class="math inline">\(\rightarrow\)</span>재현)</strong>: 운영 닻과 단위 실현 절차를 먼저 고정하고, 교차채널(RCROSS 등)을 통해 자가정합성을 판정한 뒤, 재현 패키지의 로그와 매니페스트로 결론을 봉인하는 경로.</p></li>
<li><p><strong>루트 C(수치결과<span class="math inline">\(\rightarrow\)</span>근거 역추적)</strong>: 특정 수치(길이/시간/질량/힘 등) 또는 특정 불변량을 시작점으로 삼아, 해당 결과의 유도 사슬을 거슬러 올라가 LOCK 항목과 Gate 판정까지 역추적하여 의존성의 비순환성과 잠금 상태를 확인하는 경로.</p></li>
</ul>
<p>세 루트는 동일한 본문을 공유하며, 서로 다른 루트가 서로 다른 가정을 추가하지 않는다. 루트의 차이는 순서와 강조점에 한정된다.</p>
<h2 data-number="2.1" id="lock-rightarrow-유도-rightarrow-gate-흐름-선언"><span class="header-section-number">2.1</span> 0.4 LOCK <span class="math inline">\(\rightarrow\)</span> 유도 <span class="math inline">\(\rightarrow\)</span> Gate 흐름 선언</h2>
<p>본 이론서의 모든 결론은 <strong>LOCK <span class="math inline">\(\rightarrow\)</span> 유도 <span class="math inline">\(\rightarrow\)</span> Gate</strong>의 단방향 흐름에서만 생성된다. 각 단계는 다음의 역할로 고정한다.</p>
<h4 data-number="2.1.0.1" id="lock"><span class="header-section-number">2.1.0.1</span> (1) LOCK</h4>
<p>LOCK은 문서 전체에서 <em>한 번 고정되면</em> 이후에 수정되거나 보정되지 않는 항목의 집합이다. LOCK은 공리/정의/규약/운영 닻/문턱값/판정 규칙을 포함하며, LOCK 항목 간의 의존성 순서가 함께 기록된다. LOCK의 변경은 “수정”이 아니라 “새 버전”으로만 존재하며, 기존 결론은 기존 LOCK 버전에 귀속된다.</p>
<h4 data-number="2.1.0.2" id="유도"><span class="header-section-number">2.1.0.2</span> (2) 유도</h4>
<p>유도는 LOCK 항목만을 출발점으로 하여, 허용된 변환 규칙과 명시된 닫힘(closure)을 적용해 예측 가능한 형태를 산출하는 과정이다. 유도는 (i) 수치 값, (ii) 스케일 관계, (iii) 비율 불변량, (iv) 검증 가능한 판정식 중 하나 이상의 형태로 종료된다. 유도 과정에서 정의의 교체, 단위의 재해석, 기준점의 이동은 허용되지 않으며, 필요한 경우 해당 변경은 LOCK 버전업으로만 처리된다.</p>
<h4 data-number="2.1.0.3" id="gate"><span class="header-section-number">2.1.0.3</span> (3) Gate</h4>
<p>Gate는 유도 결과의 자격을 부여하는 판정 장치이다. Gate는 사전 등록된 문턱값, 교차검증 채널, 민감도 점검, 실패 모드 조건을 포함한다. Gate의 출력은 PASS/FAIL/INCONCLUSIVE로 제한되며, INCONCLUSIVE는 결론의 유예를 의미한다. Gate 판정이 FAIL 또는 INCONCLUSIVE인 결과는 이후 절에서 근거로 사용되지 않으며, 사용을 위해서는 LOCK 변경 또는 추가 Gate의 사전 등록이 요구된다.</p>
<h4 data-number="2.1.0.4" id="결론-문장-형식"><span class="header-section-number">2.1.0.4</span> (4) 결론 문장 형식</h4>
<p>본 이론서에서 수치 또는 법칙을 진술하는 모든 문장은 다음 세 요소를 함께 가진다: (i) 근거가 되는 LOCK 항목의 식별자, (ii) 유도 사슬의 요약 식별자, (iii) 통과한 Gate(또는 판정 상태)의 식별자. 이 세 요소가 없는 진술은 결론이 아니라 미분류 문장으로 취급되어, 후속 절의 근거로 승격되지 않는다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 산출물 4묶음(정준/유도/검증/재현) 정의.</p></li>
<li><p>LOCK: 문서 순회 루트 A/B/C의 내부 정의.</p></li>
<li><p>LOCK: 결론 문장 형식(LOCK 식별자, 유도 식별자, Gate 식별자 동반) 고정.</p></li>
<li><p>Gate: 판정 출력의 형식(PASS/FAIL/INCONCLUSIVE) 고정.</p></li>
<li><p>Gate: FAIL 또는 INCONCLUSIVE 결과의 근거 사용 금지 규정 고정.</p></li>
</ul>
<h2 data-number="2.2" id="이-문서가-주장하는-것주장하지-않는-것claim-level"><span class="header-section-number">2.2</span> 0.1 이 문서가 주장하는 것/주장하지 않는 것(Claim Level)</h2>
<h3 data-number="2.2.1" id="주장-레벨claim-level의-정의"><span class="header-section-number">2.2.1</span> 0.1.1 주장 레벨(Claim Level)의 정의</h3>
<p>본 문서에서 “주장”은 하나의 문장 또는 하나의 수식 블록이 <strong>어떤 자격</strong>으로 서술되는지를 의미한다. 자격은 다음 셋으로 고정한다.</p>
<ol>
<li><p><strong>[F] 사실(Fact)</strong>: 정의(Definition), 공리(Axiom), 기호/단위 규약, LOCK으로 고정된 입력값, 그리고 Gate를 통과하여 재현된 결과를 포함한다. [F]는 문서 내부에서 “기준”으로만 사용되며, [F]를 만들기 위해 [H]를 소급하여 끌어올리는 행위는 허용되지 않는다.</p></li>
<li><p><strong>[H] 가설(Hypothesis)</strong>: 닫힘(closure), 이상화, 근사, 모델 선택, 계산 절차의 선택을 포함한다. [H]는 반드시 (i) 가정 목록, (ii) 산출되는 예측(관측 가능한 형태), (iii) 적용 범위(레짐 조건)를 함께 포함한다. 이 세 요소가 없는 [H]는 주장으로 인정되지 않는다.</p></li>
<li><p><strong>[V] 검증(Verification)</strong>: [H]의 예측을 어떤 절차로 시험했는지에 대한 기록이다. [V]는 (i) 방법, (ii) 결과(수치/그림/표), (iii) 재현 정보(입력/시드/환경/오차), (iv) 판정(PASS/FAIL/INCONCLUSIVE)을 반드시 포함한다. [V]가 없는 [H]는 결론 근거로 승격되지 않는다.</p></li>
</ol>
<p>위 셋은 “문장 자격”의 분류이며, 내용의 크고 작음과 무관하게 동일하게 적용된다. 하나의 절에서 [F]/[H]/[V]가 섞일 수 있으나, 섞임은 “구분”으로만 허용되며 “혼합”(정의의 재해석, 기준의 이동, 사후 보정)은 금지된다.</p>
<h3 data-number="2.2.2" id="이-문서가-주장하는-것주장-목록"><span class="header-section-number">2.2.2</span> 0.1.2 이 문서가 주장하는 것(주장 목록)</h3>
<p>본 문서가 책임지는 주장은 다음과 같이 고정한다. 각 항목은 본문에서 [F]/[H]/[V]로 분해되어 제시되며, 분해 없이 결론만 제시하지 않는다.</p>
<h4 data-number="2.2.2.1" id="c1-공간의-기본-구성과-강성-공리"><span class="header-section-number">2.2.2.1</span> (C1) 공간의 기본 구성과 강성 공리</h4>
<p>공간의 기본 단위는 부피입자(VP)이며, VP는 내부적으로 더 압축되지 않는 “돌(Stone)”의 성질을 가진다. 이 성질은 무한강성(압축 불가)으로 선언되며, 이 공리는 이후 모든 강성/전파/임계 논리의 출발점으로 사용된다.</p>
<h4 data-number="2.2.2.2" id="c2-충만full-packing과-재밍-레짐의-존재"><span class="header-section-number">2.2.2.2</span> (C2) 충만(Full Packing)과 재밍 레짐의 존재</h4>
<p>VP는 공간을 충만하게 채우는 격자/패킹 구조를 형성하며, 그 구조는 재밍(강성 네트워크가 도메인을 가로지르는 상태)과 비재밍(강성 스패닝이 성립하지 않는 상태)으로 구분된다. “전파 가능/불가능”의 경계는 재밍 레짐의 판정으로 정의되며, 이 판정은 Gate로 구현된다.</p>
<h4 data-number="2.2.2.3" id="c3-정류geometric-rectification-상수의-고정"><span class="header-section-number">2.2.2.3</span> (C3) 정류(Geometric Rectification) 상수의 고정</h4>
<p>본 문서는 특정 기하 평균/투영 규약에서 정류 상수들이 결정된다고 주장한다. 이때 핵심 정류 상수는 <span class="math inline">\(\alpha=2/\pi\)</span> 및 <span class="math inline">\(\delta=1/\pi^2\)</span>이며, 이 상수들은 단일 위치에서 유도되어 LOCK으로 고정되고, 이후 절에서는 재유도 없이 참조만 수행한다. 정류 상수는 사건율, 속도 스케일, 길이-시간-질량의 연쇄 유도에서 동일한 형태로 반복 출현한다.</p>
<h4 data-number="2.2.2.4" id="c4-정준-길이-스케일앵커의-존재와-파생-기하의-결정론"><span class="header-section-number">2.2.2.4</span> (C4) 정준 길이 스케일(앵커)의 존재와 파생 기하의 결정론</h4>
<p>본 문서는 “앵커 길이” <span class="math inline">\(D_{\mathrm{anch}}\)</span>를 정준(CANON) LOCK 입력으로 둔다. 앵커가 고정되면 <span class="math inline">\(r_0=D_{\mathrm{anch}}/2\)</span> 등 파생 기하 값이 결정론적으로 산출된다고 주장한다. 또한 “양성자 반경” <span class="math inline">\(r_p=\rproton\)</span>는 별도의 CANON LOCK 입력으로 취급되며, 앵커와 결합하여 사건율 및 질량 유도의 핵심 분기점으로 사용된다.</p>
<h4 data-number="2.2.2.5" id="c5-회전-구동-길이-스케일의-별도-잠금"><span class="header-section-number">2.2.2.5</span> (C5) 회전 구동 길이 스케일의 별도 잠금</h4>
<p>본 문서는 회전-구동 재밍 실험에서 길이 단위의 구동량 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 정의하고, 그 수치를 LOCK 항목으로 기록한다고 주장한다. <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 “정의로 잠김”을 요구하며, 결과를 보고 값을 바꾸는 행위는 튜닝으로 판정되어 금지된다. <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 이방성, 스핀 지표, 임계목 분포의 변화에 대한 표준 실험 입력으로 사용된다.</p>
<h4 data-number="2.2.2.6" id="c6-사건quantum-event의-운영-정의와-정준-사건율"><span class="header-section-number">2.2.2.6</span> (C6) 사건(Quantum Event)의 운영 정의와 정준 사건율</h4>
<p>본 문서는 “사건”을 관측/로그 가능한 형태로 운영 정의하고, 사건율을 정류 상수와 결합된 정준 규칙으로 기술한다고 주장한다. 전자 및 양성자에 대해 정준 사건율이 별도의 정의-유도 사슬로 제시되며, 이 사슬은 (i) LOCK 입력, (ii) 유도 규칙, (iii) Gate 판정의 결합으로만 결론 자격을 획득한다.</p>
<h4 data-number="2.2.2.7" id="c7-단위-실현realization로부터-vp-길이-a와-시간-틱-delta-t의-고정"><span class="header-section-number">2.2.2.7</span> (C7) 단위 실현(Realization)로부터 VP 길이 <span class="math inline">\(a\)</span>와 시간 틱 <span class="math inline">\(\Delta t\)</span>의 고정</h4>
<p>본 문서는 무차원(시뮬레이션) 세계에서 정의된 길이/시간을 SI 단위로 실현하는 절차를 가진다고 주장한다. 이 절차의 산출물은
<span class="math display">\[a = \aVP,
\qquad
\Delta t = 1.86\times 10^{-21}\ \mathrm{s}\]</span>
이며, 두 값은 REALIZATION LOCK에 기록된다. 또한 <span class="math inline">\(a\)</span>와 <span class="math inline">\(\Delta t\)</span>는 “지름/반지름 의미” 및 “셀 기하(예: cube)”가 함께 잠기지 않으면 교차검증이 즉시 붕괴한다는 조건을 포함한다.</p>
<h4 data-number="2.2.2.8" id="c8-격자-단위-에너지-u_mathrmlat의-정의와-질량-스케일-유도"><span class="header-section-number">2.2.2.8</span> (C8) 격자 단위 에너지 <span class="math inline">\(U_{\mathrm{lat}}\)</span>의 정의와 질량 스케일 유도</h4>
<p>본 문서는 <span class="math inline">\(a\)</span>가 고정된 이후, 격자 한 칸(길이 <span class="math inline">\(a\)</span>)이 직접 드러나는 단위 에너지 <span class="math inline">\(U_{\mathrm{lat}}\)</span>를 정의하고, 이를 기반으로 질량 스케일을 유도한다고 주장한다. 이때 질량은 “기하적 저항(유효 단면/유효 길이 적분)”의 형태로 기술되며, 양성자 질량 <span class="math inline">\(m_p\)</span>와 전자 질량 <span class="math inline">\(m_e\)</span>가 각각
<span class="math display">\[m_p \approx 0.938\ \mathrm{GeV},
\qquad
m_e \approx 0.511\ \mathrm{MeV}\]</span>
로 산출된다는 수치 결과를 포함한다. 위 수치 결과는 본문에서 반드시 LOCK 항목과 유도 사슬, 그리고 Gate 판정을 함께 갖는다.</p>
<h4 data-number="2.2.2.9" id="c9-전하-상호작용-힘-스케일의-내부-유도절대값와-판정"><span class="header-section-number">2.2.2.9</span> (C9) 전하 상호작용 힘 스케일의 내부 유도(절대값)와 판정</h4>
<p>본 문서는 “전하 상호작용 힘”의 절대 스케일을 격자 단위(길이, 시간, 에너지)와 기하 감쇄 규약으로부터 내부 유도할 수 있다고 주장한다. 외부 수치와의 일치는 정당화가 아니라 Gate 판정 항목으로만 취급되며, 판정 실패 시 결론 자격이 부여되지 않는다.</p>
<h4 data-number="2.2.2.10" id="c10-확장이방성-soc-제트튜브-처리량-상한의-조건부-주장"><span class="header-section-number">2.2.2.10</span> (C10) 확장(이방성, SOC, 제트/튜브, 처리량 상한)의 조건부 주장</h4>
<p>본 문서는 이방성(회전 구동), 임계목 네트워크, SOC 증폭, 스트림튜브/제트(제트류) 형태, 처리량 기반 상한과 같은 확장을 포함한다. 이때 “제트”는 유체역학 용어의 차용이 아니라, <strong>사건 플럭스가 백본/임계목 네트워크에서 특정 방향으로 집중되는 패턴</strong>을 의미한다(17.2). 대기/해양 제트류 또는 천체 제트는 <em>대응 가능한 실체 예시</em>로만 언급되며, 외부 이론/수치/방정식을 근거로 사용하지 않는다. 단, 이들은 모두 적용 레짐과 닫힘(closure)이 함께 제시되는 조건부 주장([H])이며, 각 확장은 지정된 Gate를 통과한 범위에서만 결론 자격을 획득한다.</p>
<h3 data-number="2.2.3" id="이-문서가-주장하지-않는-것비주장-목록"><span class="header-section-number">2.2.3</span> 0.1.3 이 문서가 주장하지 않는 것(비주장 목록)</h3>
<p>본 문서가 <strong>직접</strong> 책임지지 않는 비주장은 다음과 같이 고정한다.</p>
<ol>
<li><p><strong>검증 불가능한 선언</strong>: 관측/로그/재현 절차로 판정할 수 없는 궁극적 실재 선언, 가치 판단, 형이상학적 결론을 [F]로 서술하지 않는다.</p></li>
<li><p><strong>외부 체계의 전면 재구성</strong>: 외부 이론 체계를 처음부터 끝까지 다시 증명하거나, 그 체계를 본 문서의 결론 근거로 끌어와 정당화하지 않는다. 외부 텍스트는 “대응표/비사용 범위 선언”의 대상일 때만 제한적으로 언급된다.</p></li>
<li><p><strong>전 레짐 보편화</strong>: 특정 초기조건/경계조건/차원/프로토콜/시드에 의존하는 결과를 보편 법칙으로 서술하지 않는다.</p></li>
<li><p><strong>사후 보정의 정당화</strong>: 결과를 보고 정의, 기준, 잠금값, 의미(지름/반지름), 판정 문턱을 바꾸는 행위를 정당화하지 않는다. 변경이 필요하면 LOCK 버전업으로만 존재한다.</p></li>
<li><p><strong>일치 <span class="math inline">\(\Rightarrow\)</span> 진리의 도약</strong>: 외부 수치와의 일치를 이유로 공리/정의의 “참”을 선언하지 않는다. 일치는 오직 Gate의 PASS 조건 또는 오차예산의 보고로만 기록된다.</p></li>
</ol>
<h3 data-number="2.2.4" id="적용-범위와-비적용-범위레짐-선언"><span class="header-section-number">2.2.4</span> 0.1.4 적용 범위와 비적용 범위(레짐 선언)</h3>
<p>본 문서의 적용 범위는 “정의된 레짐”의 집합으로 기술한다. 레짐은 다음 요소들의 조합으로 지정되며, 각 PART는 자신의 레짐을 첫 페이지에 명시한다.</p>
<ol>
<li><p><strong>차원</strong>: 계산/시뮬레이션/그래프 정의가 수행되는 공간 차원(2D/3D 등)과, 그 차원이 결론에 미치는 영향의 분리.</p></li>
<li><p><strong>경계조건</strong>: 닫힌계/열린계, 구동/비구동, 고정/자유 경계 등 경계 선택이 어떤 항목을 보존 또는 비보존으로 만드는지의 선언.</p></li>
<li><p><strong>초기조건</strong>: 재밍 근방/재밍 위/재밍 아래, 결함 분포, 점유율, 스핀 분포 등 초기 설정의 선언과 로그 고정.</p></li>
<li><p><strong>스케일 범위</strong>: 장파장/단파장, 준정적/동적, 선형/비선형 등 적용 가능한 스케일 창의 선언.</p></li>
<li><p><strong>프로토콜</strong>: 회전 구동(예: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 입력), 퍼콜레이션 정의(임계목 규약), 샘플링/평균 방식 등 절차 선택의 선언.</p></li>
</ol>
<p>비적용 범위는 “레짐 요소가 정의되지 않았거나, 정의되었으나 Gate에서 FAIL 또는 INCONCLUSIVE로 판정된 경우”로 고정한다. 또한 지름/반지름 의미가 잠기지 않아 동일한 수치가 서로 다른 기하로 해석될 수 있는 경우는 자동으로 비적용(결론 자격 없음)으로 분류한다.</p>
<h3 data-number="2.2.5" id="금지되는-해석-문장-예시짧게"><span class="header-section-number">2.2.5</span> 0.1.5 금지되는 해석 문장 예시(짧게)</h3>
<p>다음 유형의 문장은 결론 자격을 갖지 못하며, [H]로도 허용되지 않는다(원인: 비검증, 과잉 일반화, 사후 정당화, 레짐 미선언).</p>
<ol>
<li><p>“이 수치가 맞으므로 공리 전체가 참이다.”</p></li>
<li><p>“한 번의 설정에서 얻은 결과이므로 모든 조건에서 성립한다.”</p></li>
<li><p>“정의(지름/반지름)를 바꿔도 결론은 같을 것이다.”</p></li>
<li><p>“Gate에서 FAIL이 나왔지만 해석으로는 옳다.”</p></li>
<li><p>“검증 없이도 직관적으로 반드시 성립한다.”</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-1">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 주장 레벨([F]/[H]/[V])과 각 레벨의 필수 구성요소(가정/예측/레짐, 방법/재현/판정) 정의.</p></li>
<li><p>LOCK: 주장 목록(C1–C10) 및 비주장 목록의 범주 고정(문서가 직접 책임지는 영역/직접 책임지지 않는 영역).</p></li>
<li><p>LOCK: 적용 범위(레짐 요소 5종)와 비적용 판정 조건(레짐 미정의 또는 Gate FAIL/INCONCLUSIVE) 고정.</p></li>
<li><p>Gate: 판정 출력(PASS/FAIL/INCONCLUSIVE)만으로 결론 자격 부여, FAIL/INCONCLUSIVE 결과의 근거 사용 금지.</p></li>
<li><p>Gate: 외부 수치와의 일치는 정당화가 아니라 오직 판정/오차예산 보고 항목으로만 기록.</p></li>
</ul>
<h2 data-number="2.3" id="독자-가이드-필수-루트-vs-선택-루트"><span class="header-section-number">2.3</span> 0.2 독자 가이드: 필수 루트 vs 선택 루트</h2>
<h3 data-number="2.3.1" id="루트의-정의"><span class="header-section-number">2.3.1</span> 0.2.1 루트의 정의</h3>
<p>루트는 문서 내부 의존성(LOCK 항목 <span class="math inline">\(\rightarrow\)</span> 유도 사슬 <span class="math inline">\(\rightarrow\)</span> Gate 판정)의 방향을 보존하는 <em>순서 규약</em>이다. 루트는 두 종류로 고정한다.</p>
<ul>
<li><p><strong>필수 루트(핵심 유도)</strong>: 본문 전체에서 반복 사용되는 정준 정의/기하/사건/단위실현/질량·힘 산출의 최소 사슬로 구성된다. 필수 루트의 모든 산출물은 이후 어떤 확장 절에서도 수정되지 않으며, 확장 절은 필수 루트의 산출물에 <em>부가</em>되는 형태로만 존재한다.</p></li>
<li><p><strong>선택 루트(확장)</strong>: 이방성(회전 구동), SOC 증폭, 스트림튜브/제트, 처리량 상한, 스케일업(거시 적용) 등 추가 레짐과 추가 닫힘(closure)을 포함한다. 선택 루트의 결과는 필수 루트의 결론 자격을 강화하거나 약화시키지 않으며, 선택 루트 고유의 Gate를 통과한 범위에서만 독립 결론으로 존재한다.</p></li>
</ul>
<h3 data-number="2.3.2" id="필수-루트핵심-유도-구성"><span class="header-section-number">2.3.2</span> 0.2.2 필수 루트(핵심 유도) 구성</h3>
<p>필수 루트는 다음의 단계 묶음으로 구성된다. 각 단계는 “LOCK 고정 <span class="math inline">\(\rightarrow\)</span> 유도 <span class="math inline">\(\rightarrow\)</span> Gate 판정”의 내부 완료를 요구한다.</p>
<ol>
<li><p><strong>정준 규약 단계</strong>: 기호/단위/지름-반지름 의미, 정준 입력(앵커 길이, 기준 반경 등), 정의 충돌 금지 규약을 LOCK으로 고정한다.</p></li>
<li><p><strong>공리 단계</strong>: 무한강성(Stone)과 충만(Full Packing), 재밍 레짐의 존재를 LOCK으로 고정한다.</p></li>
<li><p><strong>정류 상수 단계</strong>: 기하 정류 상수(예: <span class="math inline">\(\alpha=2/\pi\)</span>, <span class="math inline">\(\delta=1/\pi^2\)</span>)의 유도 위치를 단일화하여 LOCK으로 고정한다.</p></li>
<li><p><strong>코어 기하 단계</strong>: 정준 길이와 정준 반경을 결합하여 코어 기하(반경비, 면적비, 불변 비율)를 유도하고 Gate로 판정한다.</p></li>
<li><p><strong>이산 구조 단계</strong>: 코어/셸 구조(예: 코어 정수 구조, 셸 상쇄 구조)를 정의하고, 구조적 필수 불변량(합, 대칭, 상쇄 규약)을 Gate로 판정한다.</p></li>
<li><p><strong>사건 단계</strong>: 사건(quantum event)의 운영 정의, 사건율의 정준 유도, 전자/양성자의 정준 사건율을 유도하고 Gate로 판정한다.</p></li>
<li><p><strong>단위실현 단계</strong>: 길이 스케일 <span class="math inline">\(a\)</span>와 시간 틱 <span class="math inline">\(\Delta t\)</span>의 실현(운영 닻)과 교차정합을 수행하고 Gate로 판정한다.</p></li>
<li><p><strong>질량·힘 단계</strong>: 단위 에너지 및 기하 저항(유효 단면/유효 길이 적분) 규약으로부터 질량(전자/양성자/추가 질량 스케일)과 힘 스케일을 산출하고 Gate로 판정한다.</p></li>
</ol>
<h3 data-number="2.3.3" id="필수-루트가-통과해야-할-gate-종류선언"><span class="header-section-number">2.3.3</span> 0.2.3 필수 루트가 통과해야 할 Gate 종류(선언)</h3>
<p>필수 루트는 다음 Gate 종류의 <em>PASS</em>를 결론 자격 조건으로 갖는다. Gate의 문턱값/판정식/로그 형식은 각 해당 절에서 LOCK으로 고정된다.</p>
<ol>
<li><p><strong>G-SYM(기호/단위 일관성 Gate)</strong>: 기호의 의미(지름/반지름 포함), 단위 차원, 정의 충돌의 부재를 판정한다.</p></li>
<li><p><strong>G-LOCK(잠금 무결성 Gate)</strong>: 참조되는 LOCK 항목이 동일 버전으로 고정되어 있으며 사후 변경이 없음을 판정한다.</p></li>
<li><p><strong>G-REG(레짐 적합성 Gate)</strong>: 재밍/비재밍, 선형/비선형, 장파장/단파장, 경계조건/초기조건의 유효 범위를 판정한다.</p></li>
<li><p><strong>G-RECT(정류 상수 Gate)</strong>: 정류 상수의 정의 위치 단일화 및 내부 일관성을 판정한다(재유도/재정의의 금지 포함).</p></li>
<li><p><strong>G-STR(구조 불변량 Gate)</strong>: 이산 구조의 필수 불변량(합/대칭/상쇄 규약)의 보존을 판정한다.</p></li>
<li><p><strong>G-RCROSS(교차정합 Gate)</strong>: 단위실현에서 두 개 이상의 독립 채널(예: 서로 다른 기준선/기준 입력)의 상호 일관성을 판정한다.</p></li>
<li><p><strong>G-REP(재현 Gate)</strong>: 코드/입력/환경/시드/로그/산출물이 동일 규약으로 재현됨을 판정한다.</p></li>
</ol>
<h3 data-number="2.3.4" id="선택-루트확장-구성"><span class="header-section-number">2.3.4</span> 0.2.4 선택 루트(확장) 구성</h3>
<p>선택 루트는 필수 루트 산출물 위에 다음의 확장 묶음을 추가한다. 각 확장 묶음은 자체 LOCK과 자체 Gate를 가진다.</p>
<ol>
<li><p><strong>이방성 확장</strong>: 회전 구동 입력(예: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>)을 LOCK으로 고정하고, 방향 분포/패브릭/임계목의 방향 의존성을 유도한다.</p></li>
<li><p><strong>SOC 증폭 확장</strong>: 사건 클러스터(눈사태) 정의와 증폭 계수 정의를 LOCK으로 고정하고, 분포/스케일 불변성/핀닝 조건을 유도한다.</p></li>
<li><p><strong>스트림튜브/제트 확장</strong>: 임계목 네트워크에서 유량 집중 경로의 안정성, 대체경로, 병목 연쇄의 지표를 유도한다.</p></li>
<li><p><strong>처리량 상한 확장</strong>: 단위 셀의 처리량(throughput) 기반 상한 규약을 LOCK으로 고정하고, 상한의 스케일링을 유도한다.</p></li>
<li><p><strong>스케일업(거시 적용) 확장</strong>: <span class="math inline">\(\mu\)</span>–<span class="math inline">\(m\)</span>–<span class="math inline">\(M\)</span> 스케일 변환 규약과 적용 레짐을 LOCK으로 고정하고, 거시 프록시를 유도한다.</p></li>
</ol>
<h3 data-number="2.3.5" id="선택-루트가-통과해야-할-gate-종류선언"><span class="header-section-number">2.3.5</span> 0.2.5 선택 루트가 통과해야 할 Gate 종류(선언)</h3>
<p>선택 루트는 <strong>필수 루트 Gate 전부</strong>의 PASS를 <em>전제</em>로 하며, 추가로 다음 Gate 종류의 PASS를 요구한다.</p>
<ol>
<li><p><strong>G-ANISO(이방성 Gate)</strong>: 회전 구동 입력의 잠금, 방향 분포의 통계적 안정성, 방향별 결과의 재현성을 판정한다.</p></li>
<li><p><strong>G-SOC(SOC Gate)</strong>: 이벤트 정의의 고정, 스케일 구간의 존재, 분포 진단의 로버스트성을 판정한다.</p></li>
<li><p><strong>G-PATH(경로/병목 Gate)</strong>: 최소 절단/대체경로 민감도, 병목 연쇄의 안정성, 임계목 정의 변화에 대한 불변성을 판정한다.</p></li>
<li><p><strong>G-CAP(처리량 상한 Gate)</strong>: 처리량 정의의 단일성, 상한 도출의 비순환성, 스케일링의 레짐 적합성을 판정한다.</p></li>
<li><p><strong>G-UP(스케일업 Gate)</strong>: 스케일 변환 규약의 잠금, 프록시의 의미(비사용 범위 포함), 레짐 외삽의 실패 조건을 판정한다.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-2">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 루트의 두 종류(필수/선택) 정의 및 포함 관계(선택 루트는 필수 루트 전제) 고정.</p></li>
<li><p>LOCK: 필수 루트 단계 묶음(정준 규약<span class="math inline">\(\rightarrow\)</span>공리<span class="math inline">\(\rightarrow\)</span>정류<span class="math inline">\(\rightarrow\)</span>코어<span class="math inline">\(\rightarrow\)</span>이산<span class="math inline">\(\rightarrow\)</span>사건<span class="math inline">\(\rightarrow\)</span>단위실현<span class="math inline">\(\rightarrow\)</span>질량·힘) 고정.</p></li>
<li><p>Gate: 필수 루트 Gate 종류(G-SYM, G-LOCK, G-REG, G-RECT, G-STR, G-RCROSS, G-REP) 선언.</p></li>
<li><p>Gate: 선택 루트 추가 Gate 종류(G-ANISO, G-SOC, G-PATH, G-CAP, G-UP) 선언.</p></li>
</ul>
<h2 data-number="2.4" id="입력lockrightarrow유도rightarrow검증gate-흐름도-파일레지스트리-개요"><span class="header-section-number">2.4</span> 0.3 “입력(LOCK)<span class="math inline">\(\rightarrow\)</span>유도<span class="math inline">\(\rightarrow\)</span>검증(Gate)” 흐름도 + 파일/레지스트리 개요</h2>
<h3 data-number="2.4.1" id="텍스트-흐름도ascii"><span class="header-section-number">2.4.1</span> 0.3.1 텍스트 흐름도(ASCII)</h3>
<p>본 이론서의 모든 결론은 다음의 단방향 파이프라인을 따른다. 파이프라인은 <strong>입력(LOCK)</strong>의 고정, <strong>유도(derived)</strong>의 생성, <strong>검증(Gate)</strong>의 판정, <strong>봉인(snapshot)</strong>의 순서로만 진행된다.</p>
<pre><code>┌──────────────────────────────────────────────────────────────────────┐
│  (A) 입력(LOCK)                                                      │
│      - canon_lock : 공리/정의/기호/단위/정준 수치                     │
│      - realization_lock : 단위실현(운영 닻)으로 고정된 길이/시간/에너지 │
│      - gate_lock : Gate 정의/문턱/판정식/교차채널 규약                 │
│      - protocol_lock : 코드/입력/시드/환경/로그 형식                  │
└───────────────┬──────────────────────────────────────────────────────┘
                │ (LOCK는 단일 출처(SSOT)에서만 읽는다)
                v
┌──────────────────────────────────────────────────────────────────────┐
│  (B) 유도(derived)                                                    │
│      - derived_claims : 명제/정리/수치 결과/비율 불변량                │
│      - derived_tables : 표(중간 계산 포함)                             │
│      - derived_figures : 그림(생성 스크립트와 파라미터 포함)           │
│      - dependency_dag : LOCK→유도 의존성 그래프                         │
└───────────────┬──────────────────────────────────────────────────────┘
                │ (유도는 LOCK 항목과 허용 변환만 사용한다)
                v
┌──────────────────────────────────────────────────────────────────────┐
│  (C) 검증(Gate)                                                       │
│      - gate_stack : Gate들의 스택(순서 포함)                           │
│      - gate_inputs : 검증에 사용된 입력/데이터/로그                    │
│      - gate_outputs : PASS/FAIL/INCONCLUSIVE + 근거 지표               │
│      - cross_checks : 교차채널 정합(RCROSS 등)                          │
└───────────────┬──────────────────────────────────────────────────────┘
                │ (Gate 판정이 PASS인 결과만 결론 자격을 획득한다)
                v
┌──────────────────────────────────────────────────────────────────────┐
│  (D) 봉인(registry_snapshot)                                          │
│      - registry_snapshot : 해당 릴리즈에서 사용된 레지스트리의 동결본  │
│      - manifest : 산출물 파일 목록/역할/버전/해시 참조                 │
│      - checksums : 전 파일 해시(sha256 등)                             │
│      - release_tag : 릴리즈 식별자(버전/날짜/변경요약)                 │
└──────────────────────────────────────────────────────────────────────┘</code></pre>
<h3 data-number="2.4.2" id="레지스트리registry의-목적과-단일-출처ssot"><span class="header-section-number">2.4.2</span> 0.3.2 레지스트리(Registry)의 목적과 단일 출처(SSOT)</h3>
<p>레지스트리는 문서 전체에서 “정의가 어디에 고정되어 있는가”를 물리적으로 구현하는 파일 집합이다. 레지스트리는 <strong>단일 출처(SSOT)</strong>이며, 유도 코드와 검증 코드는 레지스트리를 읽기만 하고 수정하지 않는다. 레지스트리 밖에서 동일 항목을 재정의하는 행위는 허용되지 않는다.</p>
<p>레지스트리는 다음 네 종류로 구성한다.</p>
<ol>
<li><p><strong>canon_lock</strong>: 공리/정의/기호/단위 규약, 정준 입력 수치, 지름/반지름 의미, 객체 정의(셀/코어/셸 등)를 포함한다.</p></li>
<li><p><strong>realization_lock</strong>: 운영 닻(단위실현)으로 결정된 길이/시간/에너지/질량 스케일 및 그 파생값을 포함한다.</p></li>
<li><p><strong>gate_lock</strong>: Gate의 종류, 판정식, 문턱값, 허용 오차, 교차채널 구성, PASS/FAIL/INCONCLUSIVE 출력 규약을 포함한다.</p></li>
<li><p><strong>protocol_lock</strong>: 실행 환경, 시드 정책, 입력 파일 형식, 로그 스키마, 그림/표 생성 규약, 파일명 규칙을 포함한다.</p></li>
</ol>
<h3 data-number="2.4.3" id="파일-트리artifact-package-개요"><span class="header-section-number">2.4.3</span> 0.3.3 파일 트리(artifact package) 개요</h3>
<p>재현 패키지는 다음의 최상위 트리를 갖는다. 각 디렉터리의 역할은 고정이며, 동일 역할 파일이 다른 위치에 중복 생성되는 것을 금지한다.</p>
<pre><code>bundle_root/
  registry/
    canon_lock.(yaml|json|toml)
    realization_lock.(yaml|json|toml)
    gate_lock.(yaml|json|toml)
    protocol_lock.(yaml|json|toml)
    symbols_table.(csv|tex)
    units_table.(csv|tex)
  derived/
    claims.(tex|json)
    tables/
      *.csv
      *.tex
    figures/
      *.pdf
    dag/
      dependency_dag.(json|dot|pdf)
  gate/
    gate_stack.(yaml|json)
    reports/
      gate_report_*.json
      gate_report_*.tex
    logs/
      *.log
      *.csv
  scripts/
    build_derived.(py|sh)
    run_gates.(py|sh)
    make_figures.(py|sh)
    utils/
  data/
    raw/
    processed/
  snapshot/
    registry_snapshot/
      (registry/의 동결본 전체)
    manifest.(json|yaml|csv)
    checksums.(txt|json)
    release_tag.(txt|json)</code></pre>
<p>위 트리에서 <code>snapshot/registry_snapshot/</code>은 해당 릴리즈에서 사용된 레지스트리의 <strong>동결본</strong>이며, 이후 레지스트리가 버전업되더라도 과거 결론의 근거를 보존한다.</p>
<h3 data-number="2.4.4" id="manifest의-개요파일-목록의-규격"><span class="header-section-number">2.4.4</span> 0.3.4 manifest의 개요(파일 목록의 규격)</h3>
<p>manifest는 패키지에 포함된 모든 파일을 “목록”으로 고정하는 문서이다. manifest는 다음 필드를 가진다(형식은 JSON/YAML/CSV 중 하나로 고정하며, 필드명은 동일하게 유지한다).</p>
<ol>
<li><p><strong>path</strong>: 번들 루트 기준 상대경로.</p></li>
<li><p><strong>role</strong>: 파일의 기능 분류. 예: <code>registry</code>, <code>derived</code>, <code>gate_report</code>, <code>script</code>, <code>data_raw</code>, <code>data_processed</code>, <code>figure</code>, <code>table</code>.</p></li>
<li><p><strong>content_type</strong>: <code>text/tex</code>, <code>application/pdf</code>, <code>text/csv</code> 등.</p></li>
<li><p><strong>producer</strong>: 생성 주체의 식별자. 예: <code>manual</code>, <code>script:make_figures</code>, <code>script:run_gates</code>.</p></li>
<li><p><strong>depends_on</strong>: 입력 의존 파일들의 경로 리스트(없으면 빈 리스트).</p></li>
<li><p><strong>lock_version</strong>: 해당 파일이 참조한 레지스트리 버전 식별자(예: <code>canon_lock_id</code>, <code>realization_lock_id</code>).</p></li>
<li><p><strong>hash_ref</strong>: checksums 항목을 참조하는 키(예: <code>sha256</code> 값 또는 체크섬 인덱스).</p></li>
<li><p><strong>bytes</strong>: 파일 크기(바이트).</p></li>
</ol>
<p>manifest는 “무엇이 포함되었는가”를 확정하며, 누락/중복/치환을 즉시 탐지하기 위한 기준점으로 사용된다.</p>
<h3 data-number="2.4.5" id="checksum의-개요내용-동일성의-규격"><span class="header-section-number">2.4.5</span> 0.3.5 checksum의 개요(내용 동일성의 규격)</h3>
<p>checksums는 번들에 포함된 모든 파일의 내용 동일성을 검증하기 위한 해시 목록이다. checksums는 다음 규약을 가진다.</p>
<ol>
<li><p><strong>알고리즘 고정</strong>: 기본 알고리즘은 <code>sha256</code>으로 고정한다. 필요 시 추가 알고리즘을 병기할 수 있으나, <code>sha256</code>은 반드시 포함한다.</p></li>
<li><p><strong>대상 고정</strong>: <code>bundle_root/</code> 하위의 모든 파일을 대상에 포함한다. 예외가 필요한 경우 예외 목록 파일(<code>checksum_exclusions</code>)을 별도로 두고, 그 자체도 checksums에 포함한다.</p></li>
<li><p><strong>표기 고정</strong>: 한 줄에 “해시값 공백 파일경로” 형식 또는 JSON 키-값 형식으로 고정한다.</p></li>
<li><p><strong>연결 고정</strong>: 각 파일은 manifest의 <code>hash_ref</code>로 checksums 항목을 참조한다. 즉, manifest와 checksums는 서로 교차 참조한다.</p></li>
</ol>
<p>checksums는 “파일명이 같음”이 아니라 “내용이 같음”을 판정하는 기준이며, Gate 보고서와 파생 결과의 무결성을 봉인한다.</p>
<h3 data-number="2.4.6" id="registry_snapshot의-개요근거의-동결본"><span class="header-section-number">2.4.6</span> 0.3.6 registry_snapshot의 개요(근거의 동결본)</h3>
<p>registry_snapshot은 특정 릴리즈가 참조한 레지스트리를 <strong>그 상태 그대로</strong> 복사하여 보존한 디렉터리이다. registry_snapshot은 다음 목적을 가진다.</p>
<ol>
<li><p><strong>재현 보장</strong>: 시간이 지나 레지스트리가 업데이트되어도, 과거 결론의 근거(정의/공리/문턱/운영 닻)가 동일하게 복원된다.</p></li>
<li><p><strong>의존성 고정</strong>: 파생 결과가 어떤 LOCK 버전에 의존했는지 물리적으로 고정된다(<code>lock_version</code> 필드와 결합).</p></li>
<li><p><strong>분기 관리</strong>: 버전업은 “기존 레지스트리 수정”이 아니라 “새 레지스트리 생성”으로만 발생하므로, 구버전 결론과 신버전 결론이 혼재되지 않는다.</p></li>
</ol>
<p>registry_snapshot은 <code>snapshot/registry_snapshot/</code> 아래에 위치하며, snapshot 내부의 manifest와 checksums에 반드시 포함되어 봉인된다.</p>
<h3 data-number="2.4.7" id="최소-스키마레지스트리-파일의-공통-필드"><span class="header-section-number">2.4.7</span> 0.3.7 최소 스키마(레지스트리 파일의 공통 필드)</h3>
<p>레지스트리 파일들은 형식이 서로 달라도 다음 공통 필드를 포함한다.</p>
<ol>
<li><p><strong>lock_id</strong>: 해당 레지스트리의 고유 식별자.</p></li>
<li><p><strong>created</strong>: 생성 시각(문자열).</p></li>
<li><p><strong>scope</strong>: 레지스트리가 적용되는 레짐/프로토콜 식별자(없으면 <code>global</code>).</p></li>
<li><p><strong>items</strong>: 잠금 항목들의 목록(각 항목은 이름, 단위, 값 또는 정의, 설명, 출처 파일 경로를 포함).</p></li>
<li><p><strong>invariants</strong>: 레지스트리가 강제하는 불변 조건(예: 지름/반지름 의미, 단위 차원, 기호 충돌 금지).</p></li>
<li><p><strong>change_log</strong>: 변경 기록(버전업 시에만 추가).</p></li>
</ol>
<p>공통 필드는 “파일이 무엇을 잠그는가”를 기계적으로 판독 가능하게 만들며, 유도/검증 스크립트의 입력 인터페이스를 고정한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-3">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 파이프라인 단계(A–D)와 산출물 위치( registry/derived/gate/snapshot )의 역할 고정.</p></li>
<li><p>LOCK: 레지스트리 4종(canon_lock/realization_lock/gate_lock/protocol_lock) 구성 및 SSOT 원칙 고정.</p></li>
<li><p>LOCK: manifest 필드(path/role/content_type/producer/depends_on/lock_version/hash_ref/bytes) 고정.</p></li>
<li><p>LOCK: checksums 규약(sha256 기본, 전 파일 포함, manifest와 교차참조) 고정.</p></li>
<li><p>Gate: Gate 판정에 사용된 입력/로그/보고서가 manifest+checksums로 봉인되어야 결론 자격을 갖는다는 연결 고정.</p></li>
</ul>
<p>=====================================</p>
<h1 data-number="3" id="거버넌스-no-tuning-lock-gate"><span class="header-section-number">3</span> 1. 거버넌스: No-Tuning / LOCK / Gate</h1>
<h2 class="unnumbered" id="전역-최상위-규칙의-선언">전역 최상위 규칙의 선언</h2>
<p>본 문서의 모든 정의, 모든 유도, 모든 수치 결과, 모든 비교, 모든 확장은 <strong>No-Tuning</strong>, <strong>LOCK</strong>, <strong>Gate</strong>의 세 규칙을 <strong>전역 최상위 규칙</strong>으로 갖는다.
전역 최상위 규칙이란, 문서의 어떤 절도 이 세 규칙을 예외 처리하거나 부분적으로 무시할 수 없음을 뜻한다. 전역 최상위 규칙은 문서의 구조적 일관성과 결론 자격을 부여하는 최소 조건이며, 세 규칙의 위반은 해당 문장(또는 해당 절)에서 산출된 결과의 결론 자격을 즉시 상실시키는 사건으로 취급된다.</p>
<h2 class="unnumbered" id="no-tuning의-선언사후조정-금지">No-Tuning의 선언(사후조정 금지)</h2>
<p>No-Tuning은 “결과를 본 뒤 입력을 바꾸어 결론을 맞추는 행위”를 금지하는 전역 규칙이다. No-Tuning은 다음 네 범주를 <strong>금지</strong>한다.</p>
<ol>
<li><p><strong>정의 사후 변경 금지</strong>: 기호의 의미(예: 지름/반지름), 객체의 정의(예: 셀, 코어, 셸), 단위의 해석, 계산 경계(포함/배제)의 기준을 결과를 본 뒤 변경하는 행위를 금지한다.</p></li>
<li><p><strong>입력값 사후 변경 금지</strong>: 정준 입력, 운영 닻, 상수, 문턱값, 허용오차, 프로토콜 파라미터를 결과를 본 뒤 변경하는 행위를 금지한다.</p></li>
<li><p><strong>선택 편향 금지</strong>: 여러 설정/여러 데이터/여러 실행 결과 중에서 결론을 강화하는 것만을 선택하여 제시하는 행위를 금지한다. 선택이 필요하면 선택 규칙 자체가 사전 등록되어야 하며, 선택 규칙은 LOCK 항목으로 고정되어야 한다.</p></li>
<li><p><strong>판정 규칙 사후 변경 금지</strong>: Gate의 판정식, 문턱, 교차채널 구성, PASS/FAIL 조건을 결과를 본 뒤 변경하는 행위를 금지한다.</p></li>
</ol>
<p>No-Tuning은 “변경 금지”가 아니라 “사후 변경 금지”이다. 즉, 변경은 <strong>새 버전</strong>으로서만 허용된다. 변경이 발생하면, 변경 이후의 모든 산출물은 <strong>새 LOCK 식별자</strong>에 귀속되며, 변경 이전에 산출된 결론은 변경 이전의 LOCK 식별자에 귀속된 채로 유지된다. 이 규칙은 과거 결론의 근거를 소급하여 재해석하는 행위를 구조적으로 차단한다.</p>
<h2 class="unnumbered" id="lock의-선언정준-고정과-단일-출처">LOCK의 선언(정준 고정과 단일 출처)</h2>
<p>LOCK은 “한 번 고정되면, 동일 버전 안에서 변하지 않는 항목”의 집합이다. LOCK은 문서의 모든 유도와 모든 검증이 참조하는 <strong>정준 기준</strong>이며, 다음 원칙을 갖는다.</p>
<ol>
<li><p><strong>단일 출처(SSOT)</strong>: LOCK 항목은 문서 내부의 특정 위치(또는 특정 레지스트리 항목)에서만 정의된다. 동일 항목을 다른 절에서 재정의하는 것은 금지된다.</p></li>
<li><p><strong>식별자 기반 귀속</strong>: 모든 유도 결과와 모든 Gate 판정은 참조한 LOCK 식별자를 반드시 가진다. 결론은 “내용”이 아니라 “내용+LOCK 식별자”에 귀속된다.</p></li>
<li><p><strong>버전업만 허용</strong>: LOCK 항목의 변경은 “수정”이 아니라 “새 LOCK 생성”으로만 발생한다. 새 LOCK은 새로운 식별자를 가지며, 기존 결론의 근거를 변경하지 않는다.</p></li>
<li><p><strong>범주 분리</strong>: LOCK은 성격에 따라 분리 보관되며, 서로 다른 성격의 항목을 혼합 잠금하지 않는다.</p></li>
</ol>
<p>본 문서는 LOCK을 최소한 다음 네 범주로 분리하여 고정한다.</p>
<ul>
<li><p><strong>canon_lock</strong>: 공리/정의/기호/단위 규약과 정준 입력 수치.</p></li>
<li><p><strong>realization_lock</strong>: 운영 닻(단위 실현)으로 고정된 길이/시간/에너지 및 그 파생값.</p></li>
<li><p><strong>gate_lock</strong>: Gate 종류, 판정식, 문턱값, 허용오차, 교차채널 구성, 출력 규약.</p></li>
<li><p><strong>protocol_lock</strong>: 실행 환경, 시드 정책, 입력 형식, 로그 스키마, 산출물 생성 규약.</p></li>
</ul>
<p>LOCK의 목적은 “값을 고정”하는 것만이 아니라, “정의가 어디에 고정되어 있는지”를 문서 전역에서 단 하나로 확정하는 데 있다. 따라서 LOCK이 없는 유도는 근거를 상실하며, LOCK이 없는 검증은 판정 자격을 상실한다.</p>
<h2 data-number="3.1" id="gate의-선언결론-자격-판정"><span class="header-section-number">3.1</span> 1.4 Gate의 선언(결론 자격 판정)</h2>
<p>Gate는 유도 결과에 결론 자격을 부여하는 판정 장치이다. Gate는 다음 규칙을 갖는다.</p>
<ol>
<li><p><strong>출력 형식 고정</strong>: Gate의 출력은 <code>PASS</code>, <code>FAIL</code>, <code>INCONCLUSIVE</code> 중 하나로만 표현된다.</p></li>
<li><p><strong>사전 등록</strong>: Gate의 판정식, 문턱값, 허용오차, 교차채널 구성, 로그 형식은 결과 산출 이전에 <strong>gate_lock</strong>에 고정되어야 한다.</p></li>
<li><p><strong>판정의 우선성</strong>: Gate가 <code>FAIL</code> 또는 <code>INCONCLUSIVE</code>인 결과는 결론 자격을 갖지 못하며, 이후 절에서 전제(근거)로 사용할 수 없다.</p></li>
<li><p><strong>스택 구성 허용</strong>: 하나의 결론은 단일 Gate가 아니라 여러 Gate의 스택을 통과해야 할 수 있다. 이때 스택의 순서와 구성은 사전 등록되어야 한다.</p></li>
<li><p><strong>로그 필수</strong>: Gate 판정은 반드시 입력, 계산, 중간 지표, 출력의 로그를 남겨야 하며, 로그는 <strong>protocol_lock</strong>이 고정한 형식으로 기록되어야 한다.</p></li>
</ol>
<p>Gate는 “일치”를 이유로 정당화를 수행하지 않는다. Gate는 오직 “사전 등록된 조건을 충족했는가”를 판정한다. 결론 자격은 Gate의 <code>PASS</code>에 의해 부여되며, 결론의 내용적 해석은 Gate가 아닌 LOCK과 유도의 범위에서만 발생한다.</p>
<h2 data-number="3.2" id="세-규칙의-결합-구조전역-우선순위"><span class="header-section-number">3.2</span> 1.5 세 규칙의 결합 구조(전역 우선순위)</h2>
<p>No-Tuning, LOCK, Gate는 서로 독립인 규칙이 아니라 결합된 구조를 이룬다.</p>
<ol>
<li><p>No-Tuning은 <strong>LOCK과 Gate의 생성 및 변경 방식</strong>을 지배한다. 결과를 본 뒤 LOCK 또는 Gate를 바꾸는 행위를 금지한다.</p></li>
<li><p>LOCK은 <strong>유도와 Gate의 입력의 정준성</strong>을 지배한다. 동일 버전에서 LOCK은 변하지 않으며, 모든 유도와 Gate는 LOCK을 참조한다.</p></li>
<li><p>Gate는 <strong>유도 결과의 결론 자격</strong>을 지배한다. Gate 판정이 결론 자격의 필요조건이며, <code>FAIL</code>/<code>INCONCLUSIVE</code>는 근거 사용을 금지한다.</p></li>
</ol>
<p>따라서 문서 전역에서 다음이 성립한다.</p>
<ul>
<li><p>LOCK이 고정되지 않은 상태에서의 유도 결과는 결론 자격을 갖지 않는다.</p></li>
<li><p>Gate가 사전 등록되지 않은 상태에서의 판정은 결론 자격을 부여할 수 없다.</p></li>
<li><p>결과를 본 뒤의 정의/입력/문턱/프로토콜 변경은 No-Tuning 위반이며, 해당 결과는 결론 자격을 즉시 상실한다.</p></li>
</ul>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-4">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 전역 최상위 규칙( No-Tuning/LOCK/Gate )을 문서 헌법 항목으로 고정.</p></li>
<li><p>LOCK: LOCK 범주( canon_lock/realization_lock/gate_lock/protocol_lock ) 분리 원칙 고정.</p></li>
<li><p>Gate: Gate 출력 형식(<code>PASS</code>/<code>FAIL</code>/<code>INCONCLUSIVE</code>) 고정.</p></li>
<li><p>Gate: <code>FAIL</code>/<code>INCONCLUSIVE</code> 결과의 근거 사용 금지 규정 고정.</p></li>
<li><p>LOCK<span class="math inline">\(\rightarrow\)</span>Gate: Gate의 판정식/문턱/스택/로그 형식은 gate_lock/protocol_lock에 사전 등록되어야 함을 고정.</p></li>
</ul>
<h2 data-number="3.3" id="no-tuning-규칙과-금지행위"><span class="header-section-number">3.3</span> 1.1 No-Tuning 규칙과 금지행위</h2>
<h3 data-number="3.3.1" id="no-tuning의-정의"><span class="header-section-number">3.3.1</span> 1.1.1 No-Tuning의 정의</h3>
<p>No-Tuning은 “산출물을 본 뒤, 그 산출물이 원하는 형태가 되도록 입력/정의/절차/판정 기준을 되돌려 조정하는 행위”를 금지하는 전역 규칙이다. 여기서 “산출물”은 수치값, 표, 그림, 로그, 통계, 도출된 정리, 또는 Gate의 PASS/FAIL 판정 결과를 포함한다.
No-Tuning의 적용 대상은 다음 네 층으로 고정한다.</p>
<ol>
<li><p><strong>정의층</strong>: 기호의 의미(예: 지름/반지름), 객체의 정의(예: 셀/코어/셸), 단위의 의미, 포함/배제 기준, 평균/투영 규약.</p></li>
<li><p><strong>입력층(LOCK)</strong>: 정준 입력 수치, 운영 닻(단위실현), 임계 문턱, 허용 오차, 프로토콜 파라미터, 시드 정책.</p></li>
<li><p><strong>유도층</strong>: 닫힘(closure) 선택, 알고리즘 선택, 경계조건/초기조건 선택, 계산 경로(중간 단계)의 선택.</p></li>
<li><p><strong>판정층(Gate)</strong>: 판정식, 문턱값, 교차채널 구성, PASS/FAIL 규칙, 로그 스키마.</p></li>
</ol>
<p>No-Tuning은 “변경 자체”를 금지하지 않는다. 동일 버전(동일 LOCK 식별자 집합) 안에서의 <strong>사후 변경</strong>을 금지한다. 변경이 필요하면 동일 버전 내부에서의 수정이 아니라 <strong>버전업(새 LOCK 식별자 생성)</strong>으로만 허용한다.</p>
<h3 data-number="3.3.2" id="금지행위-목록"><span class="header-section-number">3.3.2</span> 1.1.2 금지행위 목록</h3>
<p>No-Tuning 위반으로 판정되는 금지행위는 다음과 같이 범주화하여 열거한다. 범주 중 하나라도 성립하면 해당 산출물은 결론 자격을 상실한다.</p>
<h3 data-number="3.3.3" id="a-정의의미-튜닝definition-tuning"><span class="header-section-number">3.3.3</span> (A) 정의/의미 튜닝(Definition Tuning)</h3>
<ol>
<li><p>결과를 본 뒤, <strong>지름/반지름</strong> 또는 <strong>셀의 기하(큐브/구 등)</strong>의 의미를 바꾸어 같은 수치가 다른 기하량으로 해석되도록 만드는 행위.</p></li>
<li><p>결과를 본 뒤, 동일 기호(예: <span class="math inline">\(\delta\)</span>, <span class="math inline">\(\Phi\)</span> 등)의 의미를 다른 절에서 다르게 사용하거나, 의미를 교체하여 유도 사슬이 사실상 변형되도록 만드는 행위.</p></li>
<li><p>결과를 본 뒤, “포함/배제” 기준(예: 어떤 경로를 목(throat)으로 볼지, 어떤 접촉을 유효 접촉으로 볼지)을 변경하여 수치가 원하는 쪽으로 이동하게 만드는 행위.</p></li>
<li><p>결과를 본 뒤, 평균/투영/정류 규약(각도 평균, 진폭 제곱, 축 선택 등)을 변경하여 정류 상수나 사건율이 달라지게 만드는 행위.</p></li>
</ol>
<h3 data-number="3.3.4" id="b-입력값-튜닝value-tuning"><span class="header-section-number">3.3.4</span> (B) 입력값 튜닝(Value Tuning)</h3>
<ol>
<li><p>결과를 본 뒤, 정준 입력(앵커 길이, 기준 반경, 정류 상수 등)의 값을 바꾸어 목표 수치에 맞추는 행위.</p></li>
<li><p>결과를 본 뒤, 운영 닻(단위 실현에서 고정된 기준선/기준값)을 바꾸거나, 동일 닻을 다른 방식으로 해석하여 길이/시간/에너지 스케일이 변하도록 만드는 행위.</p></li>
<li><p>결과를 본 뒤, 임계 문턱값(예: FAIL을 PASS로 만들기 위한 문턱 이동)이나 허용 오차를 변경하는 행위.</p></li>
<li><p>결과를 본 뒤, 시드 또는 샘플 수를 변경하여 “PASS가 나올 때까지” 반복 실행한 뒤 그 실행만 남기는 행위.</p></li>
</ol>
<h3 data-number="3.3.5" id="c-닫힘모델-선택-튜닝closuremodel-tuning"><span class="header-section-number">3.3.5</span> (C) 닫힘/모델 선택 튜닝(Closure/Model Tuning)</h3>
<ol>
<li><p>결과를 본 뒤, 닫힘(closure)을 교체하거나, 동일 닫힘의 내부 선택(예: 어떤 경로를 대표로 택하는지)을 바꾸어 수치가 목표에 가까워지도록 만드는 행위.</p></li>
<li><p>결과를 본 뒤, 경계조건/초기조건을 바꾸어 결론이 바뀌는데도 이를 “동일 결론의 검증”으로 서술하는 행위.</p></li>
<li><p>결과를 본 뒤, 알고리즘(예: 임계목 추정, 그래프 구성, 완화 규칙)을 교체하면서도 변경을 LOCK 버전업으로 선언하지 않는 행위.</p></li>
</ol>
<h3 data-number="3.3.6" id="d-gate-튜닝gate-tuning"><span class="header-section-number">3.3.6</span> (D) Gate 튜닝(Gate Tuning)</h3>
<ol>
<li><p>결과를 본 뒤, Gate의 판정식, 문턱값, 교차채널 구성, PASS/FAIL 규칙을 변경하는 행위.</p></li>
<li><p>특정 결과가 FAIL이면 Gate를 “완화”하고, PASS이면 Gate를 “강화”하여 결론이 원하는 방향으로만 유지되도록 만드는 행위.</p></li>
<li><p>Gate 판정에 사용되는 지표를 교체하거나, 지표의 정의를 바꾸면서도 gate_lock 버전업 없이 동일 Gate로 서술하는 행위.</p></li>
</ol>
<h3 data-number="3.3.7" id="e-데이터선택-편향-튜닝selectionreporting-tuning"><span class="header-section-number">3.3.7</span> (E) 데이터/선택 편향 튜닝(Selection/Reporting Tuning)</h3>
<ol>
<li><p>여러 데이터/여러 실행/여러 샘플 중 PASS가 나온 것만 선택하여 제시하고, FAIL 또는 INCONCLUSIVE를 누락하는 행위.</p></li>
<li><p>사전 등록된 선택 규칙 없이, 결과를 본 뒤 “대표”를 선택하거나 “이상치”를 제거하여 결론을 강화하는 행위.</p></li>
<li><p>동일 조건에서 얻어진 음성 결과(negative result)를 “불필요”로 분류하여 보고/로그에서 제거하는 행위.</p></li>
</ol>
<h3 data-number="3.3.8" id="f-프로토콜코드환경-튜닝protocolcode-tuning"><span class="header-section-number">3.3.8</span> (F) 프로토콜/코드/환경 튜닝(Protocol/Code Tuning)</h3>
<ol>
<li><p>결과를 본 뒤, 코드(알고리즘/상수/정의)를 수정하면서도 그 수정이 어떤 LOCK 버전에 속하는지 식별자를 갱신하지 않는 행위.</p></li>
<li><p>실행 환경(라이브러리 버전, 컴파일 옵션, 난수 생성기 구현 등)을 바꾸면서도 protocol_lock에 기록하지 않는 행위.</p></li>
<li><p>로그 형식 또는 기록 항목을 바꾸어 불리한 지표가 남지 않게 만드는 행위.</p></li>
</ol>
<h3 data-number="3.3.9" id="g-비교-정당화-튜닝external-justification-tuning"><span class="header-section-number">3.3.9</span> (G) 비교-정당화 튜닝(External Justification Tuning)</h3>
<ol>
<li><p>외부의 정설 체계/표준 수치를 근거로 삼아, 내부 정의/입력/닫힘을 소급 조정하여 일치를 강제하는 행위.</p></li>
<li><p>“일치했으므로 내부 공리가 정당화된다”와 같은 정당화 문장을 결론으로 채택하는 행위(일치는 Gate의 판정 항목으로만 취급된다).</p></li>
</ol>
<h3 data-number="3.3.10" id="허용되는-변경예외의-형식-버전업만-허용"><span class="header-section-number">3.3.10</span> 1.1.3 허용되는 변경(예외)의 형식: 버전업만 허용</h3>
<p>동일 버전 내부에서 No-Tuning을 예외 처리하는 규정은 존재하지 않는다. 허용되는 변경은 오직 <strong>버전업</strong>의 형식으로만 존재한다. 버전업은 다음 조건을 모두 만족할 때만 성립한다.</p>
<ol>
<li><p><strong>새 LOCK 식별자 발급</strong>: 변경된 항목이 속한 레지스트리(canon_lock/realization_lock/gate_lock/protocol_lock) 중 해당 레지스트리의 <strong>새 lock_id</strong>를 생성한다.</p></li>
<li><p><strong>변경 기록 고정</strong>: 변경 이유(무엇이 왜 바뀌었는지), 변경 전/후의 항목, 영향받는 유도/검증 항목을 <strong>change_log</strong>로 고정한다.</p></li>
<li><p><strong>전면 재유도/재검증</strong>: 변경 이후의 결론은 변경 이후 레지스트리 버전으로 <strong>유도 전 과정을 재생성</strong>하고 <strong>Gate 전 과정을 재판정</strong>해야 한다.</p></li>
<li><p><strong>과거 결론의 보존</strong>: 변경 이전의 산출물은 이전 lock_id에 귀속된 채로 보존되며, 변경 이후의 해석으로 소급 수정되지 않는다.</p></li>
<li><p><strong>snapshot 봉인</strong>: registry_snapshot/manifest/checksums를 새 릴리즈로 봉인하여, 변경 이후 결과의 근거가 물리적으로 동결된다.</p></li>
</ol>
<p>따라서 “허용 예외”는 “같은 버전 안에서의 예외”가 아니라 “새 버전을 만드는 절차”로만 존재한다.</p>
<h3 data-number="3.3.11" id="위반-판정과-fail-라벨"><span class="header-section-number">3.3.11</span> 1.1.4 위반 판정과 FAIL 라벨</h3>
<p>No-Tuning 위반은 Gate 판정 체계에서 <strong>FAIL 라벨</strong>로 표기된다. FAIL 라벨은 위반의 유형을 분해하여 기록하며, 하나의 산출물에 복수 라벨이 부여될 수 있다. 라벨 체계는 다음과 같이 고정한다.</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">라벨</th>
<th style="text-align: left;">의미(위반 유형)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">FAIL-NT-DEF</td>
<td style="text-align: left;">정의/의미 변경(지름/반지름, 객체 정의, 기호 의미 교체 등)</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-NT-VAL</td>
<td style="text-align: left;">입력값 변경(정준 입력, 운영 닻, 문턱/허용오차, 시드 사후 변경)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FAIL-NT-CLS</td>
<td style="text-align: left;">닫힘/모델/알고리즘 사후 교체(버전업 없이 교체)</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-NT-GATE</td>
<td style="text-align: left;">Gate 판정식/문턱/규칙 사후 변경</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FAIL-NT-SEL</td>
<td style="text-align: left;">선택 편향(유리한 결과만 선택, 불리한 결과 누락, 사후 이상치 제거)</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-NT-PROT</td>
<td style="text-align: left;">프로토콜/코드/환경 변경 미기록 또는 식별자 불일치</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FAIL-NT-LOG</td>
<td style="text-align: left;">로그/스키마 변경으로 불리한 지표의 삭제 또는 비기록</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-NT-RETRO</td>
<td style="text-align: left;">과거 결론의 소급 재해석/소급 수정 시도</td>
</tr>
</tbody>
</table>
</div>
<p>FAIL-NT-*가 부여되면, 해당 산출물은 <strong>결론 자격을 즉시 상실</strong>한다. 또한 FAIL 산출물을 근거로 삼아 만들어진 모든 파생 산출물은 의존성 그래프를 따라 <strong>연쇄적으로 결론 자격을 상실</strong>한다.</p>
<h3 data-number="3.3.12" id="위반-발생-시-처리-규정fail-라벨의-전파"><span class="header-section-number">3.3.12</span> 1.1.5 위반 발생 시 처리 규정(FAIL 라벨의 전파)</h3>
<p>No-Tuning 위반이 확인된 경우, 처리 규정은 다음으로 고정한다.</p>
<ol>
<li><p><strong>격리(Quarantine)</strong>: FAIL 라벨이 부여된 산출물과 그 의존 파생물은 “결론 후보” 목록에서 제거되고, FAIL 상태로 격리된다(삭제가 아니라 상태 전환).</p></li>
<li><p><strong>FAIL 보고서 생성</strong>: 위반 유형(FAIL 라벨), 관련 레지스트리 식별자, 관련 산출물 경로, 발생 시점, 확인 근거(불일치 항목)를 포함하는 fail_report를 생성한다.</p></li>
<li><p><strong>근거 사용 금지</strong>: FAIL 산출물은 이후 절의 전제/근거로 사용될 수 없으며, 그 산출물을 전제로 하는 문장은 결론 문장으로 승격될 수 없다.</p></li>
<li><p><strong>회복 경로 제한</strong>: 결론 자격을 회복하려면 (i) 위반 이전 상태로 완전 회귀하거나, (ii) 변경 내용을 버전업으로 승격하여 새 lock_id로 전면 재유도/재검증을 수행해야 한다. 동일 버전 내부의 “부분 수정”은 회복 경로로 인정되지 않는다.</p></li>
<li><p><strong>봉인 일관성 유지</strong>: FAIL 상태 및 회복 시도는 manifest/checksums/registry_snapshot의 연속된 릴리즈 기록에 남아야 하며, FAIL 기록의 삭제/변조는 추가 위반(FAIL-NT-LOG 및 FAIL-NT-RETRO)으로 취급된다.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-5">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: No-Tuning의 적용 대상(정의층/입력층/유도층/판정층)과 금지행위 범주(A–G) 고정.</p></li>
<li><p>LOCK: 동일 버전 내부 예외 없음, 변경은 버전업(새 lock_id)으로만 허용 규정 고정.</p></li>
<li><p>Gate: No-Tuning 위반 FAIL 라벨 체계(FAIL-NT-*) 고정.</p></li>
<li><p>Gate: FAIL 라벨 부여 시 결론 자격 상실 및 의존 파생물로의 전파 규정 고정.</p></li>
<li><p>LOCK<span class="math inline">\(\rightarrow\)</span>Gate: fail_report 및 manifest/checksums/registry_snapshot에 의한 위반 기록 봉인 규정 고정.</p></li>
</ul>
<h2 data-number="3.4" id="lock-3종과-ssot"><span class="header-section-number">3.4</span> 1.2 LOCK 3종과 SSOT</h2>
<h3 data-number="3.4.1" id="lock과-ssot의-정의"><span class="header-section-number">3.4.1</span> 1.2.1 LOCK과 SSOT의 정의</h3>
<p>LOCK은 “문서 전역에서 기준으로 사용되는 항목을 한 번 고정하여, 동일 버전 내부에서 변경되지 않게 만드는 규약”이다. LOCK의 목적은 (i) 근거의 위치를 단 하나로 확정하고, (ii) 유도 결과가 무엇에 의존하는지 추적 가능하게 만들며, (iii) 사후조정(No-Tuning)을 구조적으로 차단하는 데 있다.
SSOT(Single Source of Truth)는 “동일 항목의 정의와 값이 문서 전역에서 오직 한 위치(한 레지스트리 항목)에만 존재한다”는 원칙이다. SSOT가 성립하면, 본문 각 절은 동일 항목을 다시 정의하지 않고 <em>참조</em>만 수행한다. SSOT가 붕괴하면 동일 용어가 서로 다른 의미로 사용되거나, 동일 값이 서로 다른 정의로 해석되어 유도와 검증이 동시에 성립할 수 없게 된다.</p>
<p>LOCK은 성격에 따라 다음의 3종으로 분리한다.</p>
<ol>
<li><p><strong>canon_lock</strong>: 공리/정의/기호/단위/정준 입력을 고정하는 LOCK.</p></li>
<li><p><strong>realization_lock</strong>: 단위 실현(운영 닻)으로 결정된 물리 스케일과 파생량을 고정하는 LOCK.</p></li>
<li><p><strong>analysis_lock</strong>: 유도 및 검증에서 사용되는 분석 절차(닫힘, 추정기, 알고리즘, 판정 구성, 로그 스키마)를 고정하는 LOCK.</p></li>
</ol>
<p>세 LOCK은 서로 다른 역할을 가지며, 혼합하여 잠그지 않는다. 예컨대 정준 정의를 단위 실현으로 조정하거나, 분석 절차를 정준 정의처럼 취급하는 행위는 LOCK 구조의 위반으로 취급된다.</p>
<h3 data-number="3.4.2" id="canon_lock의-정의정준-고정"><span class="header-section-number">3.4.2</span> 1.2.2 canon_lock의 정의(정준 고정)</h3>
<p>canon_lock은 문서 전체의 <strong>정준(표준)</strong>을 구성하는 항목을 고정한다. canon_lock의 항목은 “세계의 기본 단위와 의미” 및 “후속 유도에서 변하면 안 되는 기준”으로만 구성한다. canon_lock은 다음을 포함한다.</p>
<ol>
<li><p><strong>공리(Axioms)</strong>: 부피입자(VP)의 성질, 무한강성(Stone), 충만(Full Packing), 재밍 레짐 구분 등, 후속 유도의 출발점이 되는 선언.</p></li>
<li><p><strong>정의(Definitions)</strong>: 객체(셀/코어/셸/목/경로), 상태량(필요 시), 사건(event)과 사건율의 운영 정의, “지름/반지름” 의미, 기호의 의미(동일 기호-동일 의미).</p></li>
<li><p><strong>기호/단위 규약(Symbols/Units)</strong>: 각 기호의 단위 차원, 무차원 표기 규약, 표기 충돌 금지 규칙(예: 같은 기호를 두 의미로 사용 금지).</p></li>
<li><p><strong>정준 입력 수치(Canon Inputs)</strong>: 문서가 정준으로 채택하는 입력값(예: 기준 반경, 앵커 길이, 정류 상수의 정의 위치와 값), 그리고 각 입력값의 의미(무엇의 지름/무엇의 반경인지)를 포함한다.</p></li>
<li><p><strong>불변 조건(Invariants)</strong>: 어떤 절에서도 위반될 수 없는 불변 조건(예: 지름/반지름의 의미 불변, 정의의 포함/배제 기준 불변, 단위 차원 일치)을 포함한다.</p></li>
</ol>
<p>canon_lock에 포함된 항목은 “유도 대상”이 아니다. 즉, canon_lock에 들어간 항목은 문서 내부의 다른 계산으로 재추정하거나 재보정하지 않는다. canon_lock은 후속 유도의 입력이며, 후속 유도는 canon_lock을 바꾸지 않고 결과를 산출해야 한다.</p>
<h3 data-number="3.4.3" id="realization_lock의-정의단위-실현-고정"><span class="header-section-number">3.4.3</span> 1.2.3 realization_lock의 정의(단위 실현 고정)</h3>
<p>realization_lock은 무차원(또는 내부 단위)에서 정의된 세계를, 운영 닻을 통해 <strong>물리 단위</strong>로 실현하여 고정한 항목을 담는다. realization_lock은 “정의”가 아니라 “실현 결과”를 고정한다. realization_lock은 다음을 포함한다.</p>
<ol>
<li><p><strong>운영 닻(Operational Anchors)</strong>: 기준선/기준 사건/기준 비교 채널 등, 실현에 사용되는 닻의 목록과 닻이 고정되는 방식(입력 형식, 측정/기록 형식, 채널 구성).</p></li>
<li><p><strong>기본 스케일(Primary Scales)</strong>: 길이 스케일 <span class="math inline">\(a\)</span>, 시간 스케일 <span class="math inline">\(\Delta t\)</span> 등, 실현의 1차 산출물과 그 정의 위치(어떤 닻으로부터 어떻게 계산되는지의 식별자).</p></li>
<li><p><strong>파생 스케일(Derived Scales)</strong>: <span class="math inline">\(a\)</span>와 <span class="math inline">\(\Delta t\)</span>로부터 결정되는 파생량(예: 단위 에너지 <span class="math inline">\(U_{\mathrm{lat}}\)</span> 등)과, 파생량이 사용되는 절의 식별자.</p></li>
<li><p><strong>실현의 일관성 조건(Realization Invariants)</strong>: 동일 <span class="math inline">\(a\)</span>가 서로 다른 의미(지름/반지름, 셀 기하)로 해석되지 않도록 하는 의미 잠금, 교차정합에 필요한 조건, 허용되지 않는 재해석 규약.</p></li>
<li><p><strong>교차정합 구성(Cross-Consistency Spec)</strong>: 서로 독립인 채널 간의 정합을 요구하는 경우(예: 서로 다른 기준선 조합), 채널 목록과 정합 판정의 구성 식별자를 포함한다(판정식/문턱 자체는 analysis_lock에서 고정한다).</p></li>
</ol>
<p>realization_lock은 “값을 맞추기 위한 조정 도구”가 아니다. realization_lock은 이미 고정된 운영 닻과 고정된 분석 절차에 의해 산출된 <strong>결과값의 봉인</strong>이며, realization_lock을 바꾸는 행위는 곧 운영 닻 또는 분석 절차의 변경을 의미하므로 버전업으로만 처리된다.</p>
<h3 data-number="3.4.4" id="analysis_lock의-정의유도검증-절차-고정"><span class="header-section-number">3.4.4</span> 1.2.4 analysis_lock의 정의(유도/검증 절차 고정)</h3>
<p>analysis_lock은 유도와 검증에서 사용되는 <strong>절차적 선택</strong>을 고정한다. analysis_lock은 사후조정이 가장 쉽게 발생하는 지점(닫힘 선택, 알고리즘 선택, 판정 구성, 로그 스키마)을 잠그어 No-Tuning을 구조적으로 구현한다. analysis_lock은 다음을 포함한다.</p>
<ol>
<li><p><strong>닫힘(Closure) 정의와 선택 규칙</strong>: 여러 닫힘 후보가 있을 때 선택 규칙을 포함하여 잠근다. 닫힘의 정의, 입력, 출력, 실패 조건을 함께 고정한다.</p></li>
<li><p><strong>추정기/측도(Estimators/Metrics)</strong>: 임계목, 경로, 분포, 불변량 등을 계산하는 추정기의 수식/절차/정규화/평균 규약을 고정한다.</p></li>
<li><p><strong>알고리즘(Algorithms)</strong>: 그래프 구성, 완화, 탐색, 임계 판정, 샘플링, 부트스트랩/재표본(사용 시) 등 계산 알고리즘의 단계와 파라미터를 고정한다.</p></li>
<li><p><strong>Gate 스택의 구성(Composition)</strong>: 어떤 결론이 어떤 Gate들의 조합을 통과해야 하는지(스택 구성과 순서)를 고정한다. 단, Gate의 출력 형식과 “PASS/FAIL/INCONCLUSIVE”의 존재는 전역 규칙이며, analysis_lock에서는 결론별 적용 스택과 판정 지표의 정의를 고정한다.</p></li>
<li><p><strong>문턱/허용오차(Thresholds/Tolerances)</strong>: PASS/FAIL을 결정하는 문턱과 허용오차를 고정한다. 문턱은 결과를 본 뒤 이동될 수 없으며, 이동은 버전업으로만 허용된다.</p></li>
<li><p><strong>로그 스키마(Log Schema)</strong>: 입력, 중간 지표, 출력, 예외, 실패 라벨, 실행 환경 정보가 어떤 필드로 기록되는지의 스키마를 고정한다. 로그 스키마의 변경은 검증 가능성을 직접 훼손하므로 버전업으로만 허용된다.</p></li>
</ol>
<p>analysis_lock은 “계산이 어떻게 수행되었는가”를 봉인한다. 동일한 canon_lock과 realization_lock을 사용하더라도 analysis_lock이 달라지면 유도 결과와 Gate 판정은 달라질 수 있으므로, analysis_lock의 식별자는 모든 결론 문장에 포함되어야 한다.</p>
<h3 data-number="3.4.5" id="ssot의-구현-규약레지스트리-단일화"><span class="header-section-number">3.4.5</span> 1.2.5 SSOT의 구현 규약(레지스트리 단일화)</h3>
<p>SSOT는 문서의 서술 규칙이 아니라 <strong>파일/레지스트리 구조</strong>로 구현한다. SSOT 구현 규약은 다음과 같이 고정한다.</p>
<ol>
<li><p><strong>정의의 단일 위치</strong>: canon_lock, realization_lock, analysis_lock 각각의 항목은 해당 레지스트리 파일에서만 정의된다. 본문은 레지스트리의 항목명을 참조한다.</p></li>
<li><p><strong>항목의 식별 가능성</strong>: 모든 항목은 (i) 이름, (ii) 단위, (iii) 의미(지름/반지름 포함), (iv) 값 또는 정의식, (v) 적용 범위(scope), (vi) 변경 이력을 가진다.</p></li>
<li><p><strong>의존성의 명시</strong>: realization_lock과 analysis_lock은 canon_lock의 항목을 참조할 수 있으나, 그 반대 방향의 참조(실현 결과를 정준 입력으로 끌어올림)는 허용하지 않는다.</p></li>
<li><p><strong>중복 금지</strong>: 동일 항목의 복제본을 다른 파일에 생성하지 않는다. 필요한 경우 참조(링크)만 허용하며, 참조는 항목명과 lock_id로 이루어진다.</p></li>
</ol>
<p>SSOT 위반은 “정의 충돌” 또는 “값 충돌”로 기록되며, 해당 산출물은 결론 자격을 상실한다.</p>
<h3 data-number="3.4.6" id="변경-절차버전재검증"><span class="header-section-number">3.4.6</span> 1.2.6 변경 절차(버전/재검증)</h3>
<p>LOCK 변경은 동일 버전 내부에서의 수정이 아니라 <strong>버전업</strong>으로만 허용된다. 버전업은 다음 절차로 고정한다.</p>
<ol>
<li><p><strong>변경 대상의 명시</strong>: 변경이 canon_lock/realization_lock/analysis_lock 중 어디에 속하는지 명시하고, 변경 항목의 이름과 범위를 특정한다.</p></li>
<li><p><strong>새 버전 생성</strong>: 변경이 발생한 레지스트리에 대해 새 lock_id를 발급한다. 기존 lock_id는 보존되며 내용이 수정되지 않는다.</p></li>
<li><p><strong>변경 기록 고정</strong>: 변경 전/후의 항목, 변경 이유, 영향 범위(의존 결론 목록), 예상되는 실패 모드를 change_log로 고정한다.</p></li>
<li><p><strong>의존성 그래프 갱신</strong>: 변경 항목을 참조하는 모든 유도 결과와 검증 절차를 의존성 그래프에서 재계산 대상(재생성 대상)으로 표시한다.</p></li>
<li><p><strong>전면 재유도</strong>: 변경된 lock_id 조합(새 버전)을 입력으로 하여, 관련 derived 결과를 처음부터 다시 생성한다(중간 산출물 포함).</p></li>
<li><p><strong>전면 재검증</strong>: 재생성된 derived 결과에 대해, 해당 결론이 요구하는 Gate 스택을 처음부터 다시 수행하여 PASS/FAIL/INCONCLUSIVE를 재판정한다.</p></li>
<li><p><strong>봉인(snapshots)</strong>: 사용된 레지스트리(세 LOCK)의 동결본, 산출물 목록(manifest), 전체 파일 해시(checksum)를 생성하여 registry_snapshot으로 봉인한다.</p></li>
</ol>
<p>버전업 이전에 산출된 결론은 기존 lock_id 조합에 귀속되고, 버전업 이후 산출된 결론은 새 lock_id 조합에 귀속된다. 서로 다른 lock_id 조합의 결과를 혼합하여 하나의 결론으로 서술하는 행위는 금지된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-6">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: LOCK 3종(canon_lock/realization_lock/analysis_lock) 정의 및 역할 분리 고정.</p></li>
<li><p>LOCK: SSOT(정의의 단일 위치, 중복 금지, 의존성 방향) 구현 규약 고정.</p></li>
<li><p>LOCK: 버전업 절차(새 lock_id, change_log, 의존성 그래프 갱신, 봉인) 고정.</p></li>
<li><p>Gate: LOCK 변경 시 관련 결론의 Gate 스택 전면 재판정이 필요함을 연결 고정.</p></li>
<li><p>Gate: 서로 다른 lock_id 조합 결과의 혼합 서술 금지(결론 자격 상실) 연결 고정.</p></li>
</ul>
<h2 data-number="3.5" id="gate-pass.rules"><span class="header-section-number">3.5</span> 1.3 Gate &amp; PASS.rules</h2>
<h3 data-number="3.5.1" id="gate의-정의와-출력-규격"><span class="header-section-number">3.5.1</span> 1.3.1 Gate의 정의와 출력 규격</h3>
<p>Gate는 유도(derived) 산출물에 대해 <strong>결론 자격</strong>을 부여하거나 박탈하는 판정 장치이다. Gate는 산출물을 “옳다/그르다”로 서술하지 않고, 오직 <strong>사전 등록된 조건을 충족했는가</strong>를 판정한다. Gate는 다음의 출력 규격을 가진다.</p>
<ul>
<li><p><strong>PASS</strong>: 사전 등록된 판정식과 문턱값을 모두 만족한다.</p></li>
<li><p><strong>FAIL</strong>: 사전 등록된 판정식과 문턱값 중 하나 이상을 위반한다.</p></li>
<li><p><strong>INCONCLUSIVE</strong>: 입력/로그/범위/레짐 조건의 불충분 또는 모호성으로 인해 판정식을 적용할 수 없거나, 적용은 가능하나 결론 자격 부여에 필요한 최소 조건을 충족하지 못한다.</p></li>
</ul>
<p>Gate의 출력이 <code>FAIL</code> 또는 <code>INCONCLUSIVE</code>이면 해당 산출물은 결론 자격을 갖지 못하며, 그 산출물을 근거로 하는 파생 결론도 결론 자격을 가질 수 없다(의존성 전파). 결론 자격은 오직 Gate의 <code>PASS</code>로만 부여된다.</p>
<h3 data-number="3.5.2" id="gate의-분류분류-체계와-목적"><span class="header-section-number">3.5.2</span> 1.3.2 Gate의 분류(분류 체계와 목적)</h3>
<p>Gate는 “무엇을” 판정하는가에 따라 분류한다. Gate 분류는 <strong>analysis_lock</strong>에 고정되며, 각 Gate는 자신의 입력, 판정식, 문턱, 로그 스키마, 실패 라벨을 함께 가진다. Gate 분류는 다음의 3축(대상 축, 기능 축, 스택 축)으로 구성한다.</p>
<h3 data-number="3.5.3" id="a-대상-축-무엇을-판정하는가"><span class="header-section-number">3.5.3</span> (A) 대상 축: 무엇을 판정하는가</h3>
<ol>
<li><p><strong>정의/의미 대상 Gate(semantic)</strong>: 기호 의미, 단위 차원, 지름/반지름 의미, 객체 정의(셀/코어/셸/목/경로)의 일관성을 판정한다.</p></li>
<li><p><strong>잠금 무결성 대상 Gate(lock-integrity)</strong>: 참조되는 lock_id의 일관성, 레지스트리 스냅샷의 존재, 사후 변경 흔적의 부재를 판정한다.</p></li>
<li><p><strong>레짐 적합성 대상 Gate(regime)</strong>: 적용 범위(차원/경계조건/초기조건/스케일 창)가 사전 등록된 레짐 조건을 만족하는지 판정한다.</p></li>
<li><p><strong>구조 불변량 대상 Gate(structure)</strong>: 이산 구조(정수 분해, 상쇄 규약, 대칭, 합/차 불변량)의 보존 여부를 판정한다.</p></li>
<li><p><strong>수치 안정성 대상 Gate(numerical)</strong>: 수렴, 민감도, 반복 안정성, 로그 완결성, 계산 경로의 재현 가능성을 판정한다.</p></li>
<li><p><strong>교차정합 대상 Gate(cross-consistency)</strong>: 서로 독립인 채널/기준/입력 조합 간에 동일 결론이 유지되는지 판정한다(교차채널 정합).</p></li>
<li><p><strong>재현 대상 Gate(reproducibility)</strong>: 코드/입력/환경/시드/로그/산출물이 동일 규약으로 재실행 가능하며 동일 판정에 도달하는지 판정한다.</p></li>
<li><p><strong>No-Tuning 위반 대상 Gate(anti-tuning)</strong>: 사후 조정 행위가 발생했는지(정의/값/절차/문턱/선택 편향/로그 변조 등)를 판정한다.</p></li>
</ol>
<h3 data-number="3.5.4" id="b-기능-축-어떤-역할로-결론-자격을-결정하는가"><span class="header-section-number">3.5.4</span> (B) 기능 축: 어떤 역할로 결론 자격을 결정하는가</h3>
<ol>
<li><p><strong>자격 Gate(qualification)</strong>: 결론 문장 자체를 허용/금지하는 Gate. 자격 Gate가 <code>PASS</code>하지 않으면 결론 문장은 생성될 수 없다.</p></li>
<li><p><strong>한계 Gate(limitation)</strong>: 결론의 적용 범위와 한계를 확정하는 Gate. <code>PASS</code>는 범위 확정, <code>FAIL</code>은 범위 축소 또는 결론 자격 박탈로 연결된다.</p></li>
<li><p><strong>분해 Gate(decomposition)</strong>: 결과가 어디에서 붕괴했는지(정의/레짐/구조/수치/교차정합/재현/No-Tuning)를 라벨로 분해하여 기록하는 Gate.</p></li>
</ol>
<p>동일 Gate가 복수 기능을 동시에 수행할 수 있으나, 어떤 기능을 수행하는지(자격/한계/분해)는 gate_lock에 명시되어야 한다.</p>
<h3 data-number="3.5.5" id="c-스택-축-gate는-단독이-아니라-스택으로-동작한다"><span class="header-section-number">3.5.5</span> (C) 스택 축: Gate는 단독이 아니라 스택으로 동작한다</h3>
<p>하나의 결론은 단일 Gate가 아니라 Gate들의 <strong>스택</strong>을 통과해야 한다. 스택은 “먼저 통과해야 하는 Gate”와 “조건부로 수행되는 Gate”를 포함하며, 스택의 순서와 조건은 analysis_lock에 사전 등록된다. Gate 스택의 목적은 다음이다.</p>
<ol>
<li><p>정의/의미가 불안정한 상태에서 수치 Gate를 통과시키는 일을 방지한다.</p></li>
<li><p>레짐 조건이 충족되지 않은 결과를 교차정합으로 포장하는 일을 방지한다.</p></li>
<li><p>재현/스냅샷이 없는 결과를 결론으로 서술하는 일을 방지한다.</p></li>
<li><p>No-Tuning 위반을 최종 단계에서가 아니라 조기 단계에서 차단한다.</p></li>
</ol>
<h3 data-number="3.5.6" id="gate-id-체계표준-gate-목록과-역할"><span class="header-section-number">3.5.6</span> 1.3.3 Gate ID 체계(표준 Gate 목록과 역할)</h3>
<p>Gate는 식별자(gate_id)로 호출되며, gate_id는 분류와 목적을 내장한다. 아래 목록은 문서 전역에서 사용하는 <strong>표준 Gate</strong>의 이름 공간이다(추가 Gate는 동일 규약으로 확장된다).</p>
<h3 data-number="3.5.7" id="a-전역-기본-gate모든-결론에-공통"><span class="header-section-number">3.5.7</span> (A) 전역 기본 Gate(모든 결론에 공통)</h3>
<ul>
<li><p><strong>G-SYM</strong>: 기호 의미/단위 차원/지름-반지름 의미의 일관성.</p></li>
<li><p><strong>G-LOCK</strong>: lock_id 일치, 레지스트리 스냅샷 존재, 사후 변경 흔적 부재.</p></li>
<li><p><strong>G-REG</strong>: 레짐 조건(차원/경계조건/초기조건/스케일 창) 적합성.</p></li>
<li><p><strong>G-REP</strong>: 재현(코드/입력/환경/시드/로그/산출물) 가능성 및 동등 판정.</p></li>
<li><p><strong>G-NT</strong>: No-Tuning 위반 탐지(정의/값/절차/문턱/선택/로그 변조).</p></li>
</ul>
<h3 data-number="3.5.8" id="b-구조정류절차-gate결론-유형에-따라-선택"><span class="header-section-number">3.5.8</span> (B) 구조/정류/절차 Gate(결론 유형에 따라 선택)</h3>
<ul>
<li><p><strong>G-RECT</strong>: 정류 상수(정류 규약/정의 위치 단일화/재유도 금지) 무결성.</p></li>
<li><p><strong>G-STR</strong>: 구조 불변량(정수 분해, 상쇄, 대칭, 합/차 불변량) 보존.</p></li>
<li><p><strong>G-NUM</strong>: 수치 안정성(수렴, 민감도, 반복 안정성, 로그 완결성).</p></li>
<li><p><strong>G-RCROSS</strong>: 교차정합(독립 채널 간 정합, 기준선/기준 입력 조합 간 일관성).</p></li>
</ul>
<h3 data-number="3.5.9" id="c-확장-레짐-gate선택-루트에서만-사용"><span class="header-section-number">3.5.9</span> (C) 확장 레짐 Gate(선택 루트에서만 사용)</h3>
<ul>
<li><p><strong>G-ANISO</strong>: 이방성(회전 구동 입력 잠금, 방향 분포 안정성, 방향별 재현성).</p></li>
<li><p><strong>G-SOC</strong>: 이벤트 정의 잠금, 스케일 구간 존재, 분포 진단 로버스트성.</p></li>
<li><p><strong>G-PATH</strong>: 병목/경로 민감도, 대체경로 안정성, 임계목 정의 변화에 대한 불변성.</p></li>
<li><p><strong>G-CAP</strong>: 처리량 상한 정의 단일성, 상한 유도 비순환성, 스케일링 레짐 적합성.</p></li>
<li><p><strong>G-UP</strong>: 스케일업 규약 잠금, 프록시 의미(비사용 범위 포함), 외삽 실패 조건.</p></li>
</ul>
<h3 data-number="3.5.10" id="gate-기록의-표준-필드로그-스키마"><span class="header-section-number">3.5.10</span> 1.3.4 Gate 기록의 표준 필드(로그 스키마)</h3>
<p>모든 Gate 판정은 표준 필드를 갖는 기록으로 남는다. 기록 형식(JSON/YAML/CSV 중 하나)은 protocol_lock에 고정하되, 필드의 의미는 다음으로 고정한다.</p>
<ol>
<li><p><strong>gate_id</strong>: Gate 식별자.</p></li>
<li><p><strong>gate_version</strong>: Gate 정의 버전(analysis_lock의 식별자 포함).</p></li>
<li><p><strong>lock_refs</strong>: 참조된 lock_id 목록(canon/realization/analysis).</p></li>
<li><p><strong>scope</strong>: 적용 범위(레짐 ID 또는 조건식).</p></li>
<li><p><strong>inputs</strong>: Gate 판정에 사용된 입력(파일 경로, 파라미터, 요약값).</p></li>
<li><p><strong>metrics</strong>: 판정 지표(수치 배열/요약 통계/중간 산출물).</p></li>
<li><p><strong>thresholds</strong>: 문턱값/허용오차(사전 등록된 값의 참조).</p></li>
<li><p><strong>result</strong>: PASS/FAIL/INCONCLUSIVE.</p></li>
<li><p><strong>fail_labels</strong>: FAIL 또는 INCONCLUSIVE의 원인 라벨(복수 허용).</p></li>
<li><p><strong>artifacts</strong>: 생성된 산출물(보고서/그림/표/로그)의 경로 목록.</p></li>
<li><p><strong>timestamp</strong>: 실행 시각.</p></li>
</ol>
<p>Gate 기록은 snapshot(manifest/checksums/registry_snapshot)에 포함되어 봉인되어야 하며, 봉인되지 않은 Gate 기록은 결론 자격을 부여하지 않는다.</p>
<h3 data-number="3.5.11" id="pass.rules의-정의문장-허용-규칙"><span class="header-section-number">3.5.11</span> 1.3.5 PASS.rules의 정의(문장 허용 규칙)</h3>
<p>PASS.rules는 “어떤 Gate 조합이 <code>PASS</code>일 때, 어떤 형식의 문장을 결론으로 허용하는가”를 고정하는 규칙 집합이다. PASS.rules는 <strong>analysis_lock</strong>에 포함되며, 결과를 본 뒤 수정될 수 없다. PASS.rules는 다음의 두 층으로 구성한다.</p>
<ol>
<li><p><strong>결론 유형(Claim Type) 층</strong>: 결론을 유형별로 분류하고, 각 유형에 필요한 Gate 스택을 고정한다.</p></li>
<li><p><strong>문장 템플릿(Sentence Template) 층</strong>: 허용되는 결론 문장 형식과 금지되는 문장 형식을 고정한다.</p></li>
</ol>
<p>PASS.rules의 목적은 “PASS하지 않은 결과가 문장으로 흘러들어가는 것”과 “PASS한 결과가 과잉 해석 문장으로 부풀어 오르는 것”을 동시에 차단하는 데 있다.</p>
<h3 data-number="3.5.12" id="결론-유형claim-type-표준-분류"><span class="header-section-number">3.5.12</span> 1.3.6 결론 유형(Claim Type) 표준 분류</h3>
<p>PASS.rules에서 사용하는 결론 유형은 다음으로 고정한다. 각 유형은 “허용 문장”의 범위를 정의하며, 범위를 벗어나는 서술은 금지된다.</p>
<ol>
<li><p><strong>CT-DEF</strong>: 정의/공리/규약의 선언(LOCK 항목). 유도나 Gate의 대상이 아니라, lock_id로만 귀속된다.</p></li>
<li><p><strong>CT-DER-FORM</strong>: 유도된 형태(수식 구조, 관계식, 불변량의 형태). 수치 대입 없이 관계만 선언한다.</p></li>
<li><p><strong>CT-DER-NUM</strong>: 유도된 수치(단일 값 또는 표준 형태의 수치 목록). 단위/의미(지름/반지름 포함)와 함께 선언한다.</p></li>
<li><p><strong>CT-DER-RANGE</strong>: 유도된 범위(구간, 상/하한, 조건부 범위). 범위의 레짐 조건이 함께 선언되어야 한다.</p></li>
<li><p><strong>CT-STR</strong>: 구조 결론(정수 분해, 상쇄 규약, 대칭, 좌표 구조 등). 구조 불변량이 함께 선언되어야 한다.</p></li>
<li><p><strong>CT-REAL</strong>: 단위 실현 결론(운영 닻으로부터 <span class="math inline">\(a\)</span>, <span class="math inline">\(\Delta t\)</span> 등 산출). 교차정합 Gate를 포함한다.</p></li>
<li><p><strong>CT-XCROSS</strong>: 교차정합 결론(서로 독립 채널의 일관성). 교차채널 구성과 문턱이 함께 선언되어야 한다.</p></li>
<li><p><strong>CT-REP</strong>: 재현 결론(동일 패키지로 재실행 시 동일 판정). 재현 Gate의 로그와 체크섬이 함께 선언되어야 한다.</p></li>
<li><p><strong>CT-LIM</strong>: 한계/비적용 결론(어디까지 적용되고 어디서 붕괴하는가). <code>FAIL</code>/<code>INCONCLUSIVE</code>의 원인 라벨이 함께 선언되어야 한다.</p></li>
</ol>
<h3 data-number="3.5.13" id="gate-pass에-따른-문장-허용-템플릿표준"><span class="header-section-number">3.5.13</span> 1.3.7 Gate PASS에 따른 문장 허용 템플릿(표준)</h3>
<p>아래는 결론 유형별로 요구되는 Gate 스택과 허용 문장 형식을 고정한 표준 템플릿이다. 표에서 “필수”는 결론 문장 생성의 필요조건이며, “조건부”는 해당 유형에서만 요구된다.</p>
<div class="center">
<table style="width:92%;">
<colgroup>
<col style="width: 18%"/>
<col style="width: 40%"/>
<col style="width: 34%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">결론 유형</th>
<th style="text-align: left;">요구 Gate(<code>PASS</code>)</th>
<th style="text-align: left;">허용되는 결론 문장 형식(요약 템플릿)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">CT-DEF</td>
<td style="text-align: left;">(Gate 요구 없음; lock_id 귀속)</td>
<td style="text-align: left;">“[LOCK:{canon/realization/analysis}_lock_id]에서 다음을 정의한다: {정의/공리/규약}.”</td>
</tr>
<tr class="even">
<td style="text-align: left;">CT-DER-FORM</td>
<td style="text-align: left;">필수: G-SYM, G-LOCK, G-REG, G-NT</td>
<td style="text-align: left;">“[LOCK:{...}] 및 [DER:{derivation_id}]로부터 관계식 {식}이 도출된다.”</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CT-DER-NUM</td>
<td style="text-align: left;">필수: G-SYM, G-LOCK, G-REG, G-NT; 조건부: G-NUM</td>
<td style="text-align: left;">“[LOCK:{...}][DER:{...}][GATE:{...}]에 의해 {물리량}={값}{단위}로 고정된다.”</td>
</tr>
<tr class="even">
<td style="text-align: left;">CT-DER-RANGE</td>
<td style="text-align: left;">필수: G-SYM, G-LOCK, G-REG, G-NT; 조건부: G-NUM</td>
<td style="text-align: left;">“[REGIME:{조건}]에서 {물리량}<span class="math inline">\(\in\)</span>[{하한},{상한}]이며, 판정은 [GATE:{...}]를 통과한다.”</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CT-STR</td>
<td style="text-align: left;">필수: G-SYM, G-LOCK, G-REG, G-NT; 조건부: G-STR</td>
<td style="text-align: left;">“[STRUCT:{structure_id}]는 불변량 {목록}을 보존하며, 이는 [GATE:G-STR]의 PASS로 자격화된다.”</td>
</tr>
<tr class="even">
<td style="text-align: left;">CT-REAL</td>
<td style="text-align: left;">필수: G-SYM, G-LOCK, G-REG, G-NT; 조건부: G-RCROSS, G-NUM</td>
<td style="text-align: left;">“운영 닻 {anchor_id}로부터 {a, <span class="math inline">\(\Delta t\)</span>, <span class="math inline">\(\ldots\)</span>}가 산출되며, 교차정합은 [GATE:G-RCROSS]로 판정된다.”</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CT-XCROSS</td>
<td style="text-align: left;">필수: G-SYM, G-LOCK, G-REG, G-NT; 조건부: G-RCROSS</td>
<td style="text-align: left;">“채널 {A,B,…}가 동일 결론 {대상}에 대해 정합하며, 정합 조건은 {문턱}으로 고정되고 [GATE:G-RCROSS]를 통과한다.”</td>
</tr>
<tr class="even">
<td style="text-align: left;">CT-REP</td>
<td style="text-align: left;">필수: G-SYM, G-LOCK, G-REG, G-NT; 조건부: G-REP</td>
<td style="text-align: left;">“동일 패키지(Manifest+Checksums+Registry_Snapshot)로 재실행 시 동일 판정이 재현되며, 이는 [GATE:G-REP]의 PASS로 자격화된다.”</td>
</tr>
<tr class="odd">
<td style="text-align: left;">CT-LIM</td>
<td style="text-align: left;">필수: G-SYM, G-LOCK, G-NT</td>
<td style="text-align: left;">“{대상}은 [REGIME:{조건}]에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>이며, 원인 라벨은 {FAIL_LABELS}이다.”</td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="3.5.14" id="금지되는-결론-문장-패턴짧게"><span class="header-section-number">3.5.14</span> 1.3.8 금지되는 결론 문장 패턴(짧게)</h3>
<p>PASS.rules는 허용 템플릿뿐 아니라 금지 패턴을 포함한다. 금지 패턴은 다음과 같이 고정한다.</p>
<ol>
<li><p><strong>Gate 미표기 결론 금지</strong>: Gate 식별자 또는 판정 상태(<code>PASS</code>/<code>FAIL</code>/<code>INCONCLUSIVE</code>)가 없는 수치/법칙 진술.</p></li>
<li><p><strong>레짐 미표기 범위 확장 금지</strong>: 레짐 조건 없이 “항상/모든/보편”과 같은 범위 확장 표현.</p></li>
<li><p><strong>사후 정당화 금지</strong>: “일치했으므로 참” 또는 “FAIL이지만 해석으로는 옳다”와 같은 판정 무력화 표현.</p></li>
<li><p><strong>LOCK 미귀속 금지</strong>: lock_id를 잃은 정의/값/문턱/절차의 재서술.</p></li>
</ol>
<h3 data-number="3.5.15" id="pass.rules-표준-파일-템플릿기계-판독용"><span class="header-section-number">3.5.15</span> 1.3.9 PASS.rules 표준 파일 템플릿(기계 판독용)</h3>
<p>PASS.rules는 기계 판독 가능한 형태로 analysis_lock에 포함된다. 아래는 표준 항목 템플릿이다(키 이름과 구조는 고정된다).</p>
<pre><code>pass_rules:
  - rule_id: PR-CT-DER-NUM-001
    claim_type: CT-DER-NUM
    claim_id: (문서 내부 결론 식별자; 예: CL-13-05-mp)
    scope: (레짐 식별자 또는 조건식; 예: global | regime:R1 | condition:...)
    requires:
      gates_pass:
        - G-SYM
        - G-LOCK
        - G-REG
        - G-NT
        - (optional) G-NUM
      locks_present:
        - canon_lock
        - realization_lock
        - analysis_lock
      snapshot_required: true
      manifest_required: true
      checksums_required: true
    allows_sentences:
      - template_id: ST-CT-DER-NUM-01
        pattern: "[LOCK:{canon_id,real_id,ana_id}][DER:{der_id}][GATE:{gate_stack_id}] {Q} = {value} {unit}."
        requires_fields:
          - Q
          - value
          - unit
          - canon_id
          - real_id
          - ana_id
          - der_id
          - gate_stack_id
    forbids_sentences:
      - "Gate 표기 없이 수치 결론을 단정하는 문장"
      - "레짐 조건 없이 보편 범위를 선언하는 문장"
      - "사후 정당화 또는 FAIL 무력화 문장"
    on_fail:
      verdict: "결론 자격 박탈"
      label_prefix: "FAIL-PASSRULE"
      propagation: "dependency_dag로 연쇄 전파"</code></pre>
<p>위 템플릿에서 <code>requires.gates_pass</code>는 결론 생성의 필요조건이며, <code>allows_sentences</code>는 결론 문장으로 허용되는 형식을 고정한다. <code>snapshot/manifest/checksums</code> 요구는 “근거 봉인”을 결론 자격의 필요조건으로 고정한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-7">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: Gate 분류(대상/기능/스택) 및 표준 Gate ID 목록(G-SYM, G-LOCK, G-REG, G-REP, G-NT, G-RECT, G-STR, G-NUM, G-RCROSS 등) 고정.</p></li>
<li><p>LOCK: Gate 기록 표준 필드(gate_id, gate_version, lock_refs, scope, inputs, metrics, thresholds, result, fail_labels, artifacts, timestamp) 고정.</p></li>
<li><p>LOCK: PASS.rules(결론 유형 CT-*, Gate 요구, 허용/금지 문장 템플릿, 실패 처리) 템플릿을 analysis_lock 항목으로 고정.</p></li>
<li><p>Gate: Gate 출력 형식(PASS/FAIL/INCONCLUSIVE)과 <code>FAIL</code>/<code>INCONCLUSIVE</code>의 결론 자격 박탈 및 의존성 전파 규정 연결.</p></li>
<li><p>Gate: snapshot(manifest/checksums/registry_snapshot) 봉인 없는 판정은 결론 자격을 부여하지 않는다는 연결 고정.</p></li>
</ul>
<h1 data-number="4" id="표기용어스케일-계층"><span class="header-section-number">4</span> 2. 표기·용어·스케일 계층</h1>
<h2 class="unnumbered" id="목적과-최상위-원칙">목적과 최상위 원칙</h2>
<p>본 장은 문서 전역에서 사용되는 <strong>기호</strong>, <strong>단위</strong>, <strong>스케일(길이/시간/질량/에너지/힘 등)</strong>을 단일 레지스트리 체계로 고정하고, 서로 다른 절에서 동일 항목이 중복 정의되거나 의미가 충돌하는 사태를 구조적으로 차단한다.
본 장의 규약은 문서 전역 최상위 규칙으로 작동한다. 즉, 본 장에서 고정된 기호/단위/스케일 레지스트리 규약을 위반하는 유도, 수치, 표, 그림, 로그는 결론 자격을 가질 수 없다.</p>
<h2 class="unnumbered" id="기호단위스케일-레지스트리의-우선순위충돌-해소-순서">기호·단위·스케일 레지스트리의 우선순위(충돌 해소 순서)</h2>
<p>기호/단위/스케일이 충돌할 때, 충돌을 “해석”으로 봉합하는 규정은 존재하지 않는다. 충돌은 Gate에서 판정되며, 판정이 <code>FAIL</code> 또는 <code>INCONCLUSIVE</code>이면 해당 산출물은 결론 자격을 상실한다. 충돌 판정에 사용되는 우선순위(해소 순서)는 다음으로 고정한다.</p>
<ol>
<li><p><strong>1순위: 기호 레지스트리(Symbol Registry)</strong>
기호의 <em>의미</em>가 최우선이다. 여기서 의미는 (i) 기호가 가리키는 객체(셀/코어/셸/목/경로 등), (ii) 기하적 의미(지름/반지름, 중심/표면, 큐브/구 등), (iii) 수치가 귀속되는 측정 규약(어떤 길이의 정의인지), (iv) 허용되는 연산(합/곱/적분 등)의 범위를 포함한다.
기호 의미가 잠기지 않은 상태에서 단위나 스케일 수치를 부여하는 행위는 금지된다.</p></li>
<li><p><strong>2순위: 단위 레지스트리(Unit Registry)</strong>
단위는 기호 의미에 종속된다. 단위 레지스트리는 각 기호에 대해 차원(길이/시간/질량/무차원 등), 표기 방식(SI, 내부 무차원, 혼합 금지 규칙), 변환의 허용 여부를 고정한다.
단위가 기호 의미와 충돌하면(예: 길이로 정의된 기호에 시간이 부여되는 경우) 단위는 자동으로 무효이며, 충돌은 Gate에서 <code>FAIL</code>로 판정된다.</p></li>
<li><p><strong>3순위: 스케일 레지스트리(Scale Registry)</strong>
스케일 레지스트리는 기호와 단위가 잠긴 뒤에만 의미를 가진다. 스케일은 (i) <strong>정준 스케일(canonical scale)</strong>과 (ii) <strong>실현 스케일(realized scale)</strong>로 분리하여 고정한다.
정준 스케일은 정의(무엇의 스케일인가)를 고정하고, 실현 스케일은 그 정의가 운영 닻과 절차에 의해 수치로 고정된 결과를 고정한다.
동일 스케일의 수치가 목표 결과에 맞추어 이동될 수 있는 규정은 존재하지 않는다.</p></li>
</ol>
<p>따라서 “수치가 맞지 않는다”는 이유로 기호 의미를 바꾸거나(1순위 변경), 단위를 바꾸거나(2순위 변경), 스케일 수치를 바꾸는(3순위 변경) 행위는 동일 버전 내부에서 모두 금지된다. 변경은 오직 버전업(새 LOCK)으로만 존재한다.</p>
<h2 class="unnumbered" id="레지스트리의-단일-출처ssot와-분리-보관">레지스트리의 단일 출처(SSOT)와 분리 보관</h2>
<p>기호/단위/스케일은 서로 다른 레지스트리 파일로 분리 보관되며, 각 레지스트리는 SSOT로서 동작한다. SSOT 구현 규약은 다음으로 고정한다.</p>
<ol>
<li><p>동일 기호의 의미는 <strong>기호 레지스트리</strong>에만 존재한다.</p></li>
<li><p>동일 기호의 단위 차원과 표기 규약은 <strong>단위 레지스트리</strong>에만 존재한다.</p></li>
<li><p>동일 스케일의 정의 및 수치 귀속은 <strong>스케일 레지스트리</strong>에만 존재한다.</p></li>
<li><p>본문 절은 레지스트리 항목을 재정의하지 않고, 항목명과 lock_id로 참조한다.</p></li>
<li><p>레지스트리 밖에 복제된 정의/단위/수치는 허용되지 않으며, 발견 즉시 충돌로 판정한다.</p></li>
</ol>
<p>레지스트리의 분리 보관은 “정의(의미)”와 “단위(차원)”와 “수치(스케일)”가 서로를 소급하여 조정하는 사태를 방지하기 위한 구조적 장치이다.</p>
<h2 class="unnumbered" id="기호-레지스트리의-표준-필드의미의-봉인">기호 레지스트리의 표준 필드(의미의 봉인)</h2>
<p>기호 레지스트리는 각 기호에 대해 다음 표준 필드를 가진다. 필드의 존재는 필수이며, 누락 시 해당 기호는 사용 불가로 판정된다.</p>
<ol>
<li><p><strong>symbol</strong>: 기호 문자열(예: <code>a</code>, <code>D_anch</code>, <code>r_p</code>, <code>_rot</code> 등).</p></li>
<li><p><strong>entity</strong>: 기호가 가리키는 객체(예: 셀 길이, 코어 반경, 셸 좌표, 임계목 두께 등).</p></li>
<li><p><strong>geometry_meaning</strong>: 기하 의미(지름/반지름, 중심-표면, 큐브/구, 축/평면 등).</p></li>
<li><p><strong>definition</strong>: 정의 문장 또는 정의식(필요 시 식별자 포함).</p></li>
<li><p><strong>allowed_operations</strong>: 허용되는 연산 및 조합(예: 적분 가능한지, 평균 규약이 무엇인지, 절대값/제곱의 허용 여부).</p></li>
<li><p><strong>scope</strong>: 적용 범위(레짐 식별자 또는 조건식). 범위 밖 사용은 금지된다.</p></li>
<li><p><strong>notes</strong>: 충돌 방지 주석(동일 철자 유사 기호와의 구분, 금지되는 재해석 등).</p></li>
</ol>
<p>기호 레지스트리는 “같은 표기라도 다른 의미로 쓰이는” 상황을 금지한다. 동일 기호에 복수 의미를 부여할 수 없으며, 필요하면 기호를 분리하여 각각을 독립 항목으로 잠근다.</p>
<h2 data-number="4.1" id="단위-레지스트리의-표준-필드차원의-봉인"><span class="header-section-number">4.1</span> 2.5 단위 레지스트리의 표준 필드(차원의 봉인)</h2>
<p>단위 레지스트리는 각 기호에 대해 다음 표준 필드를 가진다.</p>
<ol>
<li><p><strong>symbol</strong>: 기호 레지스트리의 <code>symbol</code>과 1:1로 연결된다.</p></li>
<li><p><strong>dimension</strong>: 차원(길이/시간/질량/무차원 등) 또는 조합 차원(필요 시).</p></li>
<li><p><strong>unit_system</strong>: 표기 체계(예: SI, 내부 무차원). 혼합 가능 여부가 함께 명시된다.</p></li>
<li><p><strong>unit_name</strong>: 단위 표기(예: m, s, fm, pm 등). 표기 방식이 잠긴다.</p></li>
<li><p><strong>conversion_policy</strong>: 변환 허용 규칙(변환 가능/불가, 변환은 어디에서만 수행되는지).</p></li>
<li><p><strong>consistency_checks</strong>: 차원 일치 점검 규칙(식별자 또는 체크 항목).</p></li>
</ol>
<p>단위 레지스트리는 “의미가 먼저”라는 우선순위 아래에서만 유효하다. 따라서 단위 레지스트리는 기호 의미를 수정하지 않으며, 단위 충돌은 단위의 재해석으로 해소되지 않는다.</p>
<h2 data-number="4.2" id="스케일-레지스트리의-표준-필드정준실현의-분리"><span class="header-section-number">4.2</span> 2.6 스케일 레지스트리의 표준 필드(정준/실현의 분리)</h2>
<p>스케일 레지스트리는 스케일을 <strong>정준</strong>과 <strong>실현</strong>으로 분리하여 기록한다. 표준 필드는 다음과 같다.</p>
<ol>
<li><p><strong>scale_id</strong>: 스케일 식별자(예: <code>S-L-a</code>, <code>S-T-dt</code>, <code>S-L-Danch</code>, <code>S-L-rp</code>, <code>S-L-lrot</code> 등).</p></li>
<li><p><strong>symbol</strong>: 스케일이 귀속되는 기호(기호 레지스트리 항목과 연결).</p></li>
<li><p><strong>kind</strong>: <code>canonical</code> 또는 <code>realized</code> 또는 <code>derived</code>.</p></li>
<li><p><strong>definition</strong>: 스케일의 정의식(정준) 또는 산출식(실현/파생).</p></li>
<li><p><strong>value</strong>: 수치(실현/파생에서만 필수). 정준에서는 비워둔다.</p></li>
<li><p><strong>unit_ref</strong>: 단위 레지스트리 참조(단위 차원과의 결합).</p></li>
<li><p><strong>anchor_ref</strong>: 운영 닻 참조(실현에서만 필수). 어떤 닻과 어떤 절차로 실현되었는지의 식별자.</p></li>
<li><p><strong>dependencies</strong>: 의존 항목(다른 스케일, 닻, 절차)의 목록. 순환 의존은 금지된다.</p></li>
<li><p><strong>scope</strong>: 적용 범위(레짐 식별자 또는 조건식).</p></li>
</ol>
<p>스케일 레지스트리에서 <code>realized</code>는 “측정값”이 아니라 “운영 닻과 절차로 봉인된 결과값”이며, <code>derived</code>는 잠긴 스케일들로부터의 계산 결과이다. <code>derived</code>는 <code>canonical</code>을 수정하거나 대체하지 않는다.</p>
<h2 data-number="4.3" id="충돌의-판정과-버전업-절차해석-금지"><span class="header-section-number">4.3</span> 2.7 충돌의 판정과 버전업 절차(해석 금지)</h2>
<p>기호/단위/스케일 충돌은 해석으로 봉합되지 않으며, 다음 규정으로 처리한다.</p>
<ol>
<li><p><strong>충돌 발견</strong>: 동일 기호의 복수 의미, 단위 차원 불일치, 스케일의 정의-수치 귀속 불일치, 지름/반지름 의미 불명확, 큐브/구 해석 혼재 등.</p></li>
<li><p><strong>판정</strong>: 충돌은 Gate에서 <code>FAIL</code> 또는 <code>INCONCLUSIVE</code>로만 판정된다. 판정은 충돌 유형 라벨을 동반한다.</p></li>
<li><p><strong>격리</strong>: 충돌이 포함된 산출물과 그 파생 산출물은 결론 후보에서 제거된다(삭제가 아니라 상태 전환).</p></li>
<li><p><strong>버전업</strong>: 충돌을 해소하려면 해당 레지스트리(canon/realization/analysis)의 새 lock_id를 생성해야 한다. 새 lock_id에서 (i) 충돌 항목 수정, (ii) 의존성 갱신, (iii) 전면 재유도, (iv) 전면 재검증, (v) 스냅샷 봉인을 수행한다.</p></li>
<li><p><strong>혼합 금지</strong>: 서로 다른 lock_id 조합의 기호/단위/스케일을 혼합하여 하나의 결론을 구성하는 행위는 금지된다.</p></li>
</ol>
<p>따라서 “같은 값이 다른 의미로도 읽힐 수 있다”는 형태의 서술은 본 문서에서 결론 자격을 갖지 못한다. 의미가 하나로 잠기지 않으면 값은 결론이 아니다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-8">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 기호 레지스트리(의미 봉인) 1순위, 단위 레지스트리(차원 봉인) 2순위, 스케일 레지스트리(정준/실현 분리) 3순위 우선순위 고정.</p></li>
<li><p>LOCK: SSOT 구현(레지스트리 단일 위치, 본문 재정의 금지, 항목명+lock_id 참조) 규약 고정.</p></li>
<li><p>LOCK: 스케일 레지스트리의 <code>canonical/realized/derived</code> 분리 및 <code>anchor_ref</code> 귀속 규약 고정.</p></li>
<li><p>Gate: 기호/단위/스케일 충돌 판정(G-SYM) 및 충돌 시 <code>FAIL</code>/<code>INCONCLUSIVE</code> 처리(결론 자격 박탈) 연결 고정.</p></li>
<li><p>Gate: 충돌 해소는 버전업 후 전면 재유도/재검증을 요구한다는 연결 고정.</p></li>
</ul>
<h2 data-number="4.4" id="기호단위객체-표준"><span class="header-section-number">4.4</span> 2.1 기호·단위·객체 표준</h2>
<h3 data-number="4.4.1" id="표준의-범위"><span class="header-section-number">4.4.1</span> 2.1.1 표준의 범위</h3>
<p>본 절은 문서 전역에서 사용하는 (i) 기호(symbol), (ii) 단위(unit), (iii) 객체(object), (iv) 스케일(scale)의 표준을 고정한다.
표준의 목적은 동일한 표기(철자)가 서로 다른 의미를 갖는 사태, 동일한 의미가 서로 다른 표기로 분열되는 사태, 단위 차원이 불명확한 사태, 지름/반지름 및 기하 의미가 혼재되는 사태를 원천적으로 차단하는 데 있다.
본 절에서 고정된 표준은 이후 절에서 재정의되지 않으며, 본문에서 동일 항목을 다시 서술하는 대신 레지스트리 항목(항목명, 식별자)으로만 참조한다.</p>
<h3 data-number="4.4.2" id="기호-표준표기-규약"><span class="header-section-number">4.4.2</span> 2.1.2 기호 표준(표기 규약)</h3>
<p>기호는 문서 전체에서 다음 규약으로 고정한다.</p>
<h3 data-number="4.4.3" id="a-글꼴과-객체-유형"><span class="header-section-number">4.4.3</span> (A) 글꼴과 객체 유형</h3>
<ol>
<li><p><strong>스칼라(scalar)</strong>는 이탤릭 기호로 표기한다: <span class="math inline">\(a, r_0, r_p, \ell_{\mathrm{rot}}, \Delta t\)</span>.</p></li>
<li><p><strong>벡터(vector)</strong>는 굵은 이탤릭으로 표기한다: <span class="math inline">\(\mathbf{x}, \mathbf{v}, \mathbf{n}\)</span>.</p></li>
<li><p><strong>행렬/텐서(tensor)</strong>는 굵은 대문자 또는 이중선 규약 중 하나로 고정한다: <span class="math inline">\(\mathbf{M}\)</span> 또는 <span class="math inline">\(\mathbb{T}\)</span>. 본 문서에서는 굵은 대문자 규약을 기본으로 한다.</p></li>
<li><p><strong>집합(set)</strong>은 캘리그래픽으로 표기한다: <span class="math inline">\(\mathcal{V}\)</span> (부피입자 집합), <span class="math inline">\(\mathcal{E}\)</span> (이벤트 집합), <span class="math inline">\(\mathcal{G}\)</span> (그래프).</p></li>
<li><p><strong>함수(function)</strong>는 로만체로 표기한다: <span class="math inline">\(\mathrm{Gate}(\cdot)\)</span>, <span class="math inline">\(\mathrm{Rect}(\cdot)\)</span>, <span class="math inline">\(\mathrm{Hash}(\cdot)\)</span>.</p></li>
</ol>
<h3 data-number="4.4.4" id="b-인덱스와-첨자"><span class="header-section-number">4.4.4</span> (B) 인덱스와 첨자</h3>
<ol>
<li><p><strong>개체 인덱스</strong>는 아래첨자 정수로 표기한다: <span class="math inline">\(i, j, k\)</span>.</p></li>
<li><p><strong>성분 인덱스</strong>는 그리스 문자 또는 하첨자 좌표로 표기한다: <span class="math inline">\(\alpha, \beta\)</span> 또는 <span class="math inline">\(x,y,z\)</span>.</p></li>
<li><p><strong>객체 라벨 첨자</strong>는 로만체 약어로 표기한다: <span class="math inline">\(r_p\)</span> (proton core radius), <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> (rotation-driven length).</p></li>
<li><p><strong>레짐/스코프 첨자</strong>는 로만체로 표기한다: <span class="math inline">\(a_{\mathrm{sim}}\)</span> (내부 단위), <span class="math inline">\(a_{\mathrm{real}}\)</span> (단위 실현 후).</p></li>
<li><p><strong>평균/집계 표기</strong>는 오버바로 고정한다: <span class="math inline">\(\overline{X}\)</span>는 사전 등록된 평균 연산자에 의한 결과만 의미한다. 평균 연산자는 analysis_lock에서 고정된다.</p></li>
</ol>
<h3 data-number="4.4.5" id="c-예약-기호reserved-symbols"><span class="header-section-number">4.4.5</span> (C) 예약 기호(Reserved Symbols)</h3>
<p>기호 충돌을 방지하기 위해 다음 예약 규약을 고정한다.</p>
<ol>
<li><p><strong>정준 입력 스케일</strong>은 <span class="math inline">\(D_{\mathrm{anch}}, r_p, \ell_{\mathrm{rot}}\)</span> 등으로 표기하며, 정준 입력을 나타내는 기호는 다른 의미로 사용하지 않는다.</p></li>
<li><p><strong>단위 실현 스케일</strong>은 <span class="math inline">\(a, \Delta t\)</span>를 기본 기호로 사용하며, <span class="math inline">\(a\)</span>와 <span class="math inline">\(\Delta t\)</span>는 다른 의미(예: 면적, 가속도 등)로 사용하지 않는다.</p></li>
<li><p><strong>지름/반지름 의미</strong>는 기호의 의미 필드(geometry_meaning)로 잠긴다. 동일 기호가 지름과 반지름을 동시에 의미할 수 없다.</p></li>
<li><p><strong>무차원 수</strong>는 단위 필드에서 <code>dimensionless</code>로 지정된 항목만을 의미하며, 무차원 표기는 단위 혼합을 허용하지 않는다.</p></li>
</ol>
<h3 data-number="4.4.6" id="단위-표준차원과-표기-규약"><span class="header-section-number">4.4.6</span> 2.1.3 단위 표준(차원과 표기 규약)</h3>
<p>단위는 “기호 의미가 먼저 잠긴 뒤”에만 부여된다. 단위 표준은 다음 규약으로 고정한다.</p>
<h3 data-number="4.4.7" id="a-단위-체계의-분리"><span class="header-section-number">4.4.7</span> (A) 단위 체계의 분리</h3>
<ol>
<li><p><strong>정준 단위(canonical units)</strong>: 값이 아니라 의미를 고정하는 단계에서 사용된다. 정준 단위는 내부 무차원 또는 내부 길이/시간 단위로 기록될 수 있으며, 이 경우 단위 레지스트리에 <code>unit_system=internal</code>로 고정한다.</p></li>
<li><p><strong>실현 단위(realized units)</strong>: 운영 닻을 통해 수치가 확정된 후 사용된다. 실현 단위는 단위 레지스트리에 <code>unit_system=SI</code>로 고정하고, 표기는 <code>m, s</code> 및 하위 접두 표기를 허용한다.</p></li>
<li><p><strong>혼합 금지</strong>: 하나의 식 또는 하나의 표에서 internal과 SI를 혼합하지 않는다. 혼합이 필요한 경우, 변환 단계 자체를 별도의 유도 항목으로 분리하여 표시하고, 변환의 입력/출력 단위를 모두 잠근다.</p></li>
</ol>
<h3 data-number="4.4.8" id="b-차원-필드의-의무화"><span class="header-section-number">4.4.8</span> (B) 차원 필드의 의무화</h3>
<p>모든 기호는 단위 레지스트리에서 차원(dimension)을 의무적으로 가진다.</p>
<ol>
<li><p>길이 차원: <code>L</code></p></li>
<li><p>시간 차원: <code>T</code></p></li>
<li><p>질량 차원: <code>M</code></p></li>
<li><p>에너지 차원: <code>E</code></p></li>
<li><p>힘 차원: <code>F</code></p></li>
<li><p>무차원: <code>1</code></p></li>
</ol>
<p>차원 필드가 비어 있거나 충돌하는 경우, 해당 기호는 사용 불가로 판정한다.</p>
<h3 data-number="4.4.9" id="c-접두-표기와-고정-소수점-표기"><span class="header-section-number">4.4.9</span> (C) 접두 표기와 고정 소수점 표기</h3>
<p>실현 단위에서 길이와 시간은 접두 표기를 허용하되, 표기 규칙을 고정한다.</p>
<ol>
<li><p>접두 표기는 단위 레지스트리에서 승인된 목록만 사용한다.</p></li>
<li><p>과학적 표기는 <span class="math inline">\(x\times 10^n\)</span> 형태로 고정한다.</p></li>
<li><p>숫자 표기에서 유효숫자 규약은 analysis_lock에서 고정된 규칙을 따른다. 유효숫자 규약의 사후 변경은 금지되며, 변경은 버전업으로만 허용된다.</p></li>
</ol>
<h3 data-number="4.4.10" id="객체-표준객체-사전과-의미-잠금"><span class="header-section-number">4.4.10</span> 2.1.4 객체 표준(객체 사전과 의미 잠금)</h3>
<p>객체(object)는 “기호가 무엇을 가리키는가”를 결정하는 최상위 기준이다. 객체는 객체 사전(Object Registry)으로 고정한다. 객체 사전은 다음 규약을 갖는다.</p>
<h3 data-number="4.4.11" id="a-객체-id와-최소-필드"><span class="header-section-number">4.4.11</span> (A) 객체 ID와 최소 필드</h3>
<p>모든 객체는 <strong>객체 ID</strong>를 가지며, 다음 최소 필드를 가진다.</p>
<ol>
<li><p><strong>object_id</strong>: 예: <code>OBJ-VP</code>, <code>OBJ-CELL</code>, <code>OBJ-CORE</code>, <code>OBJ-SHELL</code>, <code>OBJ-THROAT</code>, <code>OBJ-PATH</code>, <code>OBJ-EVENT</code>.</p></li>
<li><p><strong>name</strong>: 객체의 이름(한글 명칭).</p></li>
<li><p><strong>definition</strong>: 객체의 정의(필요 시 정의식 포함).</p></li>
<li><p><strong>geometry_meaning</strong>: 객체가 가지는 길이 기호의 기하 의미(지름/반지름/간격/두께/격자상수 등).</p></li>
<li><p><strong>state_fields</strong>: 객체가 갖는 상태량(있으면 목록으로 고정).</p></li>
<li><p><strong>allowed_maps</strong>: 다른 객체/관측량으로의 허용 사상(허용되는 변환만 목록으로 고정).</p></li>
<li><p><strong>scope</strong>: 적용 범위(레짐).</p></li>
</ol>
<h3 data-number="4.4.12" id="b-핵심-객체의-표준-정의최소-선언"><span class="header-section-number">4.4.12</span> (B) 핵심 객체의 표준 정의(최소 선언)</h3>
<p>본 문서에서 필수적으로 등장하는 객체는 다음과 같이 표준 정의를 가진다.</p>
<ol>
<li><p><strong>부피입자(VP), <code>OBJ-VP</code></strong>: 공간을 구성하는 기본 단위. VP의 성질과 허용 규칙은 canon_lock의 공리/정의 항목으로 고정된다.</p></li>
<li><p><strong>셀(Cell), <code>OBJ-CELL</code></strong>: VP 집합을 묶는 기준 영역. 셀의 기하(예: 큐브 셀, 구형 시각화 셀)는 geometry_meaning 필드로 잠기며, 동일 셀 기호가 다른 기하를 동시에 의미할 수 없다.</p></li>
<li><p><strong>코어(Core), <code>OBJ-CORE</code></strong>: 중심 구조를 정의하는 객체. 코어의 반경/지름 기호는 지름-반지름 의미가 잠겨야 한다.</p></li>
<li><p><strong>셸(Shell), <code>OBJ-SHELL</code></strong>: 코어 외곽의 구조 객체. 셸 좌표 집합, 상쇄 규약, 생존 벡터 등의 구성 요소는 analysis_lock에서 절차와 함께 잠긴다.</p></li>
<li><p><strong>목(Throat), <code>OBJ-THROAT</code></strong>: 전역 연결에서 병목이 되는 미소 연결 요소. 목의 두께/간격/임계값 기호는 geometry_meaning이 필수이며, 임계목 추정기는 analysis_lock에서 고정된다.</p></li>
<li><p><strong>경로(Path), <code>OBJ-PATH</code></strong>: 목들의 연결로 이루어진 전역 전달 경로. 경로 선택 규칙과 대체경로 규칙은 analysis_lock에서 잠긴다.</p></li>
<li><p><strong>사건(Event), <code>OBJ-EVENT</code></strong>: 관측/로그 가능한 최소 사건 단위. 사건의 정의는 canon_lock에서, 사건율 추정과 집계는 analysis_lock에서 잠긴다.</p></li>
</ol>
<h3 data-number="4.4.13" id="길이시간질량-스케일-계층계층-레지스트리"><span class="header-section-number">4.4.13</span> 2.1.5 길이/시간/질량 스케일 계층(계층 레지스트리)</h3>
<p>스케일 계층은 “어떤 값이 입력인가, 어떤 값이 유도 결과인가, 어떤 값이 단위 실현 결과인가”를 분리하여 고정하는 체계이다. 스케일 계층은 길이/시간/질량에 대해 공통 구조를 갖는다.</p>
<h3 data-number="4.4.14" id="a-계층-타입"><span class="header-section-number">4.4.14</span> (A) 계층 타입</h3>
<p>각 스케일은 다음 타입 중 하나로 분류된다.</p>
<ol>
<li><p><strong>CAN-INPUT</strong>: 정준 입력. 값과 의미가 canon_lock에 고정된다.</p></li>
<li><p><strong>CAN-DERIVED</strong>: 정준 파생. CAN-INPUT에서 유도되며, 유도 규칙이 canon_lock 또는 analysis_lock에 고정된다.</p></li>
<li><p><strong>REAL-PRIMARY</strong>: 단위 실현 1차 산출. 운영 닻과 실현 규칙에 의해 realization_lock에 고정된다.</p></li>
<li><p><strong>REAL-DERIVED</strong>: 실현 파생. REAL-PRIMARY 및 잠긴 유도 규칙으로부터 파생되며, 결과는 realization_lock 또는 derived 레지스트리에 기록된다.</p></li>
<li><p><strong>OBS-REF</strong>: 관측 참조. 관측 프로토콜로부터 얻어진 기준 참조이며, 관측값 자체의 의미/프로토콜은 analysis_lock에 잠긴다.</p></li>
</ol>
<h3 data-number="4.4.15" id="b-길이-스케일-계층의-표준-항목"><span class="header-section-number">4.4.15</span> (B) 길이 스케일 계층의 표준 항목</h3>
<p>길이 스케일은 다음 표준 항목을 가진다. 아래 항목의 존재는 레지스트리에서 강제된다(값의 유무는 타입에 따라 달라진다).</p>
<div class="center">
<table style="width:90%;">
<colgroup>
<col style="width: 16%"/>
<col style="width: 18%"/>
<col style="width: 18%"/>
<col style="width: 38%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">항목</th>
<th style="text-align: left;">타입</th>
<th style="text-align: left;">기하 의미</th>
<th style="text-align: left;">귀속 객체/설명</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(D_{\mathrm{anch}}\)</span></td>
<td style="text-align: left;">CAN-INPUT</td>
<td style="text-align: left;">지름 또는 길이(잠금)</td>
<td style="text-align: left;"><code>OBJ-CELL</code> 또는 정준 셀 길이(의미 잠금 필수)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(r_0\)</span></td>
<td style="text-align: left;">CAN-DERIVED</td>
<td style="text-align: left;">반경(잠금)</td>
<td style="text-align: left;"><span class="math inline">\(r_0:=D_{\mathrm{anch}}/2\)</span>로 고정(지름-반지름 의미 잠금)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(r_p\)</span></td>
<td style="text-align: left;">CAN-INPUT</td>
<td style="text-align: left;">반경(잠금)</td>
<td style="text-align: left;"><code>OBJ-CORE</code> 기준 반경(의미 잠금 필수)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\ell_{\mathrm{rot}}\)</span></td>
<td style="text-align: left;">CAN-INPUT 또는 OBS-REF</td>
<td style="text-align: left;">길이(잠금)</td>
<td style="text-align: left;"><code>OBJ-CELL</code>/<code>OBJ-THROAT</code> 회전 구동 입력(채택 타입은 lock으로 고정)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(a\)</span></td>
<td style="text-align: left;">REAL-PRIMARY</td>
<td style="text-align: left;">길이(잠금)</td>
<td style="text-align: left;"><code>OBJ-VP</code> 또는 셀 내부 기본 길이 단위(단위 실현 산출)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\delta_{\mathrm{gap}}\)</span></td>
<td style="text-align: left;">REAL-DERIVED</td>
<td style="text-align: left;">간격/두께(잠금)</td>
<td style="text-align: left;"><code>OBJ-THROAT</code> 임계목 간격(추정기 잠금)</td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="4.4.16" id="c-시간-스케일-계층의-표준-항목"><span class="header-section-number">4.4.16</span> (C) 시간 스케일 계층의 표준 항목</h3>
<p>시간 스케일은 다음 표준 항목을 가진다.</p>
<div class="center">
<table style="width:90%;">
<colgroup>
<col style="width: 16%"/>
<col style="width: 18%"/>
<col style="width: 18%"/>
<col style="width: 38%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">항목</th>
<th style="text-align: left;">타입</th>
<th style="text-align: left;">의미</th>
<th style="text-align: left;">귀속 객체/설명</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(\Delta t\)</span></td>
<td style="text-align: left;">REAL-PRIMARY</td>
<td style="text-align: left;">시간 틱(잠금)</td>
<td style="text-align: left;"><code>OBJ-EVENT</code> 또는 셀 기반 시간 단위(단위 실현 산출)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(T_{\mathrm{p}}\)</span></td>
<td style="text-align: left;">REAL-DERIVED 또는 CAN-DERIVED</td>
<td style="text-align: left;">빌드 시간(잠금)</td>
<td style="text-align: left;">정준 사건율과 구조 규약으로부터 도출되는 빌드 시간</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(T_{\mathrm{n}}\)</span></td>
<td style="text-align: left;">REAL-DERIVED 또는 CAN-DERIVED</td>
<td style="text-align: left;">보조 시간(잠금)</td>
<td style="text-align: left;"><span class="math inline">\(T_{\mathrm{p}}\)</span>와 함께 정의되는 보조 시간 스케일(정의 위치 잠금)</td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="4.4.17" id="d-질량-스케일-계층의-표준-항목"><span class="header-section-number">4.4.17</span> (D) 질량 스케일 계층의 표준 항목</h3>
<p>질량 스케일은 “질량”이라는 이름의 수치가 등장하더라도, 그 수치가 어떤 내부 정의로부터 도출되었는지를 계층으로 고정한다.</p>
<div class="center">
<table style="width:90%;">
<colgroup>
<col style="width: 16%"/>
<col style="width: 18%"/>
<col style="width: 18%"/>
<col style="width: 38%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">항목</th>
<th style="text-align: left;">타입</th>
<th style="text-align: left;">의미</th>
<th style="text-align: left;">귀속 객체/설명</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(m_p\)</span></td>
<td style="text-align: left;">REAL-DERIVED</td>
<td style="text-align: left;">질량 스케일(잠금)</td>
<td style="text-align: left;"><code>OBJ-CORE</code> 질량 스케일(유도 규칙+Gate 필요)</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(m_e\)</span></td>
<td style="text-align: left;">REAL-DERIVED</td>
<td style="text-align: left;">질량 스케일(잠금)</td>
<td style="text-align: left;"><code>OBJ-EVENT</code> 또는 셸-생존 구조 기반 질량 스케일(유도 규칙+Gate 필요)</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(m_H\)</span></td>
<td style="text-align: left;">REAL-DERIVED</td>
<td style="text-align: left;">질량 스케일(잠금)</td>
<td style="text-align: left;">격자 단위 에너지 및 기하 저항 규약으로부터 도출되는 질량 스케일(유도 규칙+Gate 필요)</td>
</tr>
</tbody>
</table>
</div>
<p>질량 스케일 항목은 값만으로 결론 자격을 갖지 않는다. 질량 스케일은 (i) 의미 잠금, (ii) 유도 규칙 잠금, (iii) Gate 판정을 함께 가져야 결론 자격을 획득한다.</p>
<h3 data-number="4.4.18" id="기호-재사용-금지-규칙오버로딩-금지"><span class="header-section-number">4.4.18</span> 2.1.6 기호 재사용 금지 규칙(오버로딩 금지)</h3>
<p>본 문서에서 기호 재사용(오버로딩)은 전역 금지 규칙이다. “기호 재사용”은 다음 중 하나라도 성립하는 경우를 의미한다.</p>
<ol>
<li><p>동일 기호가 서로 다른 객체(<code>OBJ-*</code>)에 귀속되는 경우.</p></li>
<li><p>동일 기호가 서로 다른 기하 의미(지름/반지름/간격/두께/격자상수 등)를 갖는 경우.</p></li>
<li><p>동일 기호가 서로 다른 차원(<code>L</code>, <code>T</code>, <code>M</code>, <code>1</code> 등)을 갖는 경우.</p></li>
<li><p>동일 기호가 서로 다른 계층 타입(CAN-INPUT vs REAL-PRIMARY 등)을 동시에 갖는 경우.</p></li>
<li><p>동일 기호가 서로 다른 평균/집계 규약(예: <span class="math inline">\(\overline{X}\)</span>의 평균 연산자)이 적용되는 경우.</p></li>
</ol>
<p>오버로딩이 필요한 상황은 “필요”로 인정되지 않는다. 의미가 다르면 기호를 분리한다. 기호 분리는 다음 규약으로 고정한다.</p>
<ol>
<li><p><strong>객체 첨자 분리</strong>: 동일 철자를 유지할 경우, 객체 라벨 첨자를 부여하여 분리한다(예: <span class="math inline">\(r_p\)</span>, <span class="math inline">\(r_0\)</span>, <span class="math inline">\(r_{\mathrm{cell}}\)</span>).</p></li>
<li><p><strong>레짐 첨자 분리</strong>: 레짐이 다르면 레짐 첨자로 분리한다(예: <span class="math inline">\(a_{\mathrm{sim}}\)</span>, <span class="math inline">\(a_{\mathrm{real}}\)</span>). 단, 이 경우에도 의미와 차원은 동일해야 한다.</p></li>
<li><p><strong>완전 분리</strong>: 의미와 차원이 달라질 경우에는 철자 자체를 변경하여 완전 분리한다(예: <span class="math inline">\(\delta_{\mathrm{rect}}\)</span>와 <span class="math inline">\(\delta_{\mathrm{gap}}\)</span>처럼 용도 첨자를 고정).</p></li>
</ol>
<p>기호 오버로딩이 발견되면 해당 산출물은 기호 Gate에서 <code>FAIL</code>로 판정되며, 결과는 결론 자격을 상실한다. 오버로딩 해소는 동일 버전 내부에서의 “해석”으로 허용되지 않으며, 레지스트리 항목의 수정이 필요한 경우 버전업으로만 허용된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-9">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 기호 표준(글꼴/인덱스/예약 기호)과 객체 사전(Object Registry)의 최소 필드(object_id, geometry_meaning 등) 고정.</p></li>
<li><p>LOCK: 단위 표준(단위 체계 분리, 차원 필드 의무화, 혼합 금지) 고정.</p></li>
<li><p>LOCK: 스케일 계층 타입(CAN-INPUT, CAN-DERIVED, REAL-PRIMARY, REAL-DERIVED, OBS-REF) 및 길이/시간/질량 표준 항목 체계 고정.</p></li>
<li><p>Gate: 기호 오버로딩(의미/객체/차원/계층 충돌) 판정은 G-SYM에서 <code>FAIL</code>로 처리됨을 연결 고정.</p></li>
<li><p>Gate: 오버로딩 해소는 버전업 후 전면 재유도/재검증을 요구하며, 동일 버전 내 해석 봉합은 불가함을 연결 고정.</p></li>
</ul>
<h2 data-number="4.5" id="canon-입력정준"><span class="header-section-number">4.5</span> 2.2 CANON 입력(정준)</h2>
<h3 data-number="4.5.1" id="정준-입력의-정의"><span class="header-section-number">4.5.1</span> 2.2.1 정준 입력의 정의</h3>
<p>정준 입력(CANON 입력)은 문서 전역에서 <em>근거의 출발점</em>으로 취급되는 입력 항목의 집합이다. 정준 입력은 다음 성질을 동시에 만족해야 한다.</p>
<ol>
<li><p><strong>의미 잠금</strong>: 항목이 무엇을 의미하는지(객체 귀속, 지름/반지름 등 기하 의미, 포함/배제 기준)가 단 하나로 고정된다.</p></li>
<li><p><strong>단위 잠금</strong>: 항목의 차원과 단위 표기가 고정된다. 단위가 필요한 항목은 단위가 잠긴다.</p></li>
<li><p><strong>값 잠금</strong>: 값이 주어지는 항목은 값이 고정된다(정확도/유효숫자 규약 포함).</p></li>
<li><p><strong>범위 잠금</strong>: 적용되는 레짐(전역/특정 레짐)이 고정된다. 범위 밖에서는 참조할 수 없다.</p></li>
<li><p><strong>단일 출처(SSOT)</strong>: 정준 입력은 <code>canon_lock</code> 레지스트리의 단일 위치에만 존재한다. 본문은 재정의하지 않고 항목명과 식별자만 참조한다.</p></li>
</ol>
<p>정준 입력은 “유도 대상”이 아니다. 정준 입력은 유도의 <em>입력</em>이며, 정준 입력을 유도 결과로 대체하거나 유도 결과로 정준 입력을 소급 수정하는 행위는 금지된다.</p>
<h3 data-number="4.5.2" id="정준-입력-항목-목록과-분류"><span class="header-section-number">4.5.2</span> 2.2.2 정준 입력 항목 목록과 분류</h3>
<p>본 문서에서 정준 입력으로 분류되는 항목은 다음 다섯 가지이다.</p>
<ol>
<li><p><span class="math inline">\(D_{\mathrm{anch}}\)</span> : 정준 앵커 길이(앵커 셀의 대표 길이).</p></li>
<li><p><span class="math inline">\(r_p\)</span> : 정준 반경(양성자 코어 반경으로 정의).</p></li>
<li><p><span class="math inline">\(\pi\)</span> : 원주율(무차원 상수).</p></li>
<li><p><span class="math inline">\(\delta\)</span> : 정류 계수(무차원 상수).</p></li>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span> : 회전 구동 길이(참고 정준 입력).</p></li>
</ol>
<p>이 다섯 항목은 성격이 서로 다르므로, “정준 입력” 내부에서 다음의 하위 분류를 추가로 고정한다.</p>
<ul>
<li><p><strong>CANON-PRIMARY</strong>: 물리적 길이/반경처럼 값과 단위가 함께 고정되는 1차 정준 입력.</p></li>
<li><p><strong>CANON-CONST</strong>: 무차원 상수처럼 값이 전역적으로 고정되는 정준 상수.</p></li>
<li><p><strong>CANON-REF</strong>: 특정 레짐에서만 참조되는 참고 정준 입력(기본 사슬의 필수 입력으로 승격되지 않음).</p></li>
</ul>
<h3 data-number="4.5.3" id="각-항목의-의미-잠금객체-귀속과-기하-의미"><span class="header-section-number">4.5.3</span> 2.2.3 각 항목의 의미 잠금(객체 귀속과 기하 의미)</h3>
<p>정준 입력은 “값”보다 먼저 “의미”가 잠겨야 한다. 각 항목의 객체 귀속과 기하 의미는 다음으로 고정한다.</p>
<h3 data-number="4.5.4" id="a-d_mathrmanch-정준-앵커-길이"><span class="header-section-number">4.5.4</span> (A) <span class="math inline">\(D_{\mathrm{anch}}\)</span> : 정준 앵커 길이</h3>
<p><span class="math inline">\(D_{\mathrm{anch}}\)</span>는 <code>OBJ-CELL</code>(셀) 또는 셀과 동치로 취급되는 정준 기하 객체의 대표 길이로 정의한다. <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 <strong>기하 의미(지름/반지름/모서리 길이)</strong>는 <code>canon_lock</code>의 <code>geometry_meaning</code> 필드에서 <strong>단 하나로</strong> 고정된다.
<span class="math inline">\(D_{\mathrm{anch}}\)</span>는 “정준 앵커”이므로, 어떤 절에서도 <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 의미를 재해석하여 다른 기하량으로 치환하지 않는다. <span class="math inline">\(D_{\mathrm{anch}}\)</span>로부터 반경형 파생량이 필요하면 별도의 기호로 다음과 같이 <strong>파생 정의</strong>를 둔다.
<span class="math display">\[r_0 := \frac{D_{\mathrm{anch}}}{2}.\]</span>
여기서 <span class="math inline">\(r_0\)</span>는 <strong>파생 기호</strong>이며, <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 의미 잠금이 먼저 성립해야만 사용될 수 있다.</p>
<h3 data-number="4.5.5" id="b-r_p-정준-반경코어-반경"><span class="header-section-number">4.5.5</span> (B) <span class="math inline">\(r_p\)</span> : 정준 반경(코어 반경)</h3>
<p><span class="math inline">\(r_p\)</span>는 <code>OBJ-CORE</code>(코어)의 반경으로 정의한다. <span class="math inline">\(r_p\)</span>는 <strong>반경</strong>으로 잠기며, 지름으로 재해석될 수 없다.
<span class="math inline">\(r_p\)</span>의 값은 정준 입력 값으로 고정되며, 단위는 <strong>길이</strong>로 고정된다. 표기 단위는 레지스트리에서 승인된 접두 표기(예: fm 등) 중 하나로 고정한다.
<span class="math inline">\(r_p\)</span>는 코어 기하 및 사건율 유도에서 결론 자격의 출발점으로 사용되며, <span class="math inline">\(r_p\)</span>를 다른 값으로 바꾸거나 다른 의미로 치환하는 행위는 동일 버전 내부에서 금지된다.</p>
<h3 data-number="4.5.6" id="c-pi-원주율"><span class="header-section-number">4.5.6</span> (C) <span class="math inline">\(\pi\)</span> : 원주율</h3>
<p><span class="math inline">\(\pi\)</span>는 무차원 상수이며, 값은 전역적으로 고정된다. <span class="math inline">\(\pi\)</span>는 “측정값”이 아니라 정의된 상수이므로, 어떤 절에서도 <span class="math inline">\(\pi\)</span>를 추정하거나 보정하지 않는다.
<span class="math inline">\(\pi\)</span>는 정류 계수 및 기하 비율의 정의에 사용되며, <span class="math inline">\(\pi\)</span>가 등장하는 모든 유도는 <span class="math inline">\(\pi\)</span>를 <strong>정준 상수</strong>로만 참조한다.</p>
<h3 data-number="4.5.7" id="d-delta-정류-계수"><span class="header-section-number">4.5.7</span> (D) <span class="math inline">\(\delta\)</span> : 정류 계수</h3>
<p><span class="math inline">\(\delta\)</span>는 무차원 정류 계수로 정의한다. <span class="math inline">\(\delta\)</span>의 정의는 <strong>단일 위치</strong>에서 다음과 같이 고정한다.
<span class="math display">\[\delta := \frac{1}{\pi^2}.\]</span>
이 정의는 <code>canon_lock</code>에 고정되며, 이후 절에서는 <span class="math inline">\(\delta\)</span>를 재유도하지 않는다.
<span class="math inline">\(\delta\)</span>를 다른 평균 규약 또는 다른 투영 규약으로부터 다시 계산하여 값을 변경하는 행위는 금지된다. <span class="math inline">\(\delta\)</span>의 사용은 <strong>정의된 형태 그대로</strong>로 제한되며, 필요한 경우 다른 정류 계수는 <strong>새 기호</strong>로 분리하여 별도 항목으로 잠가야 한다.</p>
<h3 data-number="4.5.8" id="e-ell_mathrmrot-회전-구동-길이참고-정준-입력"><span class="header-section-number">4.5.8</span> (E) <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> : 회전 구동 길이(참고 정준 입력)</h3>
<p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 회전 구동 레짐에서 사용되는 길이 입력으로 정의한다. <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 기하 의미는 <strong>지름</strong>으로 잠긴다(지름/반지름 혼용 금지). <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 다음의 상태로 분류된다.</p>
<ul>
<li><p><strong>CANON-REF(참고 정준 입력)</strong>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 회전 구동/이방성/스핀 지표 등 특정 확장 레짐에서만 참조된다.</p></li>
<li><p><strong>필수 사슬 비참여</strong>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 기본 필수 유도 사슬(정준<span class="math inline">\(\rightarrow\)</span>사건<span class="math inline">\(\rightarrow\)</span>단위실현<span class="math inline">\(\rightarrow\)</span>질량/힘)의 <em>필수 입력</em>으로 자동 승격되지 않는다.</p></li>
</ul>
<p>따라서 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 <span class="math inline">\(D_{\mathrm{anch}}\)</span>로 대체하거나, <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>로부터 <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 의미를 재정의하는 행위는 금지된다. 승격이 필요하면 2.2.6의 버전업 절차를 따른다.</p>
<h3 data-number="4.5.9" id="값단위-잠금표준-표기와-유효숫자"><span class="header-section-number">4.5.9</span> 2.2.4 값/단위 잠금(표준 표기와 유효숫자)</h3>
<p>정준 입력의 값과 단위 표기는 다음 규약으로 잠근다.</p>
<ol>
<li><p><span class="math inline">\(D_{\mathrm{anch}}\)</span>와 <span class="math inline">\(r_p\)</span>와 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 길이 차원(<code>L</code>)으로 잠긴다.</p></li>
<li><p><span class="math inline">\(\pi\)</span>와 <span class="math inline">\(\delta\)</span>는 무차원(<code>1</code>)으로 잠긴다.</p></li>
<li><p>값이 주어지는 항목은 레지스트리에서 <strong>표준 과학적 표기</strong>(<span class="math inline">\(x\times 10^n\)</span>) 또는 <strong>고정 소수점 표기</strong> 중 하나로 고정된다.</p></li>
<li><p>유효숫자/반올림 규약은 <code>analysis_lock</code>의 <code>numeric_format</code> 항목으로 고정되며, 동일 버전 내부에서 변경되지 않는다.</p></li>
</ol>
<p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 값이 주어지는 경우(예: <span class="math inline">\(\ell_{\mathrm{rot}}=\lrot\)</span>)에는 <strong>지름</strong> 의미와 단위(예: pm)를 동시에 잠근다. 값만 기록하고 의미를 잠그지 않는 기록은 허용되지 않는다.</p>
<h3 data-number="4.5.10" id="정준-입력의-참조-규칙본문-사용-규칙"><span class="header-section-number">4.5.10</span> 2.2.5 정준 입력의 참조 규칙(본문 사용 규칙)</h3>
<p>정준 입력은 본문에서 다음 규칙으로만 사용된다.</p>
<ol>
<li><p>본문은 정준 입력을 <strong>재정의하지 않는다</strong>. 본문은 <code>canon_lock</code>의 항목명(예: <code>D_anch</code>, <code>rp</code>, <code>pi</code>, <code>delta</code>, <code>l_rot</code>)과 <code>lock_id</code>를 참조한다.</p></li>
<li><p>정준 입력이 등장하는 모든 수식/표/그림/로그는 해당 입력의 <strong>의미 잠금 정보</strong>(<code>geometry_meaning</code>, <code>entity</code>, <code>object_id</code>)를 함께 참조해야 한다.</p></li>
<li><p>정준 입력이 요구되는 절은 <strong>레짐 조건(scope)</strong>을 함께 선언해야 한다. 예컨대 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 회전 구동 레짐에서만 참조 가능하며, 전역 절에서의 무조건 참조는 금지된다.</p></li>
<li><p>동일한 절에서 <span class="math inline">\(\pi\)</span>와 <span class="math inline">\(\delta\)</span>가 함께 등장하는 경우, <span class="math inline">\(\delta\)</span>는 언제나 <span class="math inline">\(\delta:=1/\pi^2\)</span>의 정의를 <em>참조</em>하는 방식으로만 사용되며, 독립 상수처럼 임의 설정될 수 없다.</p></li>
</ol>
<h3 data-number="4.5.11" id="변경-절차버전업과-재검증"><span class="header-section-number">4.5.11</span> 2.2.6 변경 절차(버전업과 재검증)</h3>
<p>정준 입력의 변경은 동일 버전 내부에서 허용되지 않는다. 변경은 오직 버전업으로만 수행된다. 버전업 절차는 다음으로 고정한다.</p>
<ol>
<li><p>변경 대상 항목의 범주를 명시한다: <code>canon_lock</code> 항목 변경(정준 입력 변경).</p></li>
<li><p>새 <code>canon_lock</code>의 <code>lock_id</code>를 발급한다. 기존 <code>lock_id</code>는 보존되며 내용이 수정되지 않는다.</p></li>
<li><p>변경 전/후의 (i) 의미(<code>entity</code>, <code>geometry_meaning</code>, <code>object_id</code>), (ii) 값, (iii) 단위를 change_log에 고정한다.</p></li>
<li><p>변경 항목에 의존하는 모든 유도 결과를 의존성 그래프에서 재생성 대상으로 표시한다.</p></li>
<li><p>해당 결과에 요구되는 Gate 스택을 전면 재수행하여 PASS/FAIL/INCONCLUSIVE를 재판정한다.</p></li>
<li><p>새 버전의 레지스트리 스냅샷, manifest, checksums를 봉인한다.</p></li>
</ol>
<p>특히 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 필수 입력으로 승격하거나, <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 의미를 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 의미와 결합하여 변경하는 경우는 <strong>정준 입력 구조 자체의 변경</strong>이므로 반드시 버전업과 전면 재검증을 요구한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-10">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 정준 입력 항목(<span class="math inline">\(D_{\mathrm{anch}}, r_p, \pi, \delta, \ell_{\mathrm{rot}}\)</span>)의 의미/단위/값/범위 잠금 규약을 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(\delta:=1/\pi^2\)</span> 정의의 단일 위치(재유도 금지) 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 상태를 CANON-REF로 고정(필수 사슬 자동 승격 금지).</p></li>
<li><p>Gate: 기호/의미/단위 충돌은 G-SYM에서 <code>FAIL</code>로 판정되어 결론 자격을 박탈함을 연결.</p></li>
<li><p>Gate: 정준 입력 변경은 버전업 후 전면 재검증(G-LOCK, G-REG, 필요 시 G-RCROSS/G-REP 포함)을 요구함을 연결.</p></li>
</ul>
<h2 data-number="4.6" id="realization-입력"><span class="header-section-number">4.6</span> 2.3 REALIZATION 입력</h2>
<h3 data-number="4.6.1" id="realization-입력의-정의"><span class="header-section-number">4.6.1</span> 2.3.1 REALIZATION 입력의 정의</h3>
<p>REALIZATION 입력은 내부 단위(무차원 또는 내부 길이/시간 단위)로 기술된 세계를, 외부 단위(길이/시간)로 <em>실현</em>하기 위해 고정되는 항목의 집합이다. REALIZATION 입력은 <code>realization_lock</code>에 포함되며, 동일 <code>lock_id</code> 내부에서 변경되지 않는다.
REALIZATION 입력은 “정준 입력”이 아니라 “실현 결과” 또는 “실현에 사용되는 기준”으로서 취급된다. 따라서 REALIZATION 입력은 (i) 의미(무엇의 길이/무엇의 시간인지), (ii) 단위, (iii) 수치, (iv) 실현 절차의 귀속(어떤 기준과 어떤 판정 규칙으로 고정되었는지)을 함께 잠가야 한다.</p>
<h3 data-number="4.6.2" id="내부-좌표계와-실현-사상길이시간-변환"><span class="header-section-number">4.6.2</span> 2.3.2 내부 좌표계와 실현 사상(길이/시간 변환)</h3>
<p>내부 좌표를 다음과 같이 정의한다.</p>
<ul>
<li><p>내부 길이 좌표: <span class="math inline">\(\tilde{x}\)</span> (무차원 또는 내부 단위), 내부 길이의 기본 단위는 “1”로 취급한다.</p></li>
<li><p>내부 시간 좌표: <span class="math inline">\(\tilde{t}\)</span> (무차원 또는 내부 단위), 내부 시간의 기본 단위는 “1”로 취급한다.</p></li>
</ul>
<p>실현 사상은 다음으로 고정한다.
<span class="math display">\[x \;:=\; a\,\tilde{x},
\qquad
t \;:=\; \Delta t\,\tilde{t},
\label{eq:realization_map_xt}\]</span>
여기서 <span class="math inline">\(x\)</span>는 실현된 길이(길이 차원), <span class="math inline">\(t\)</span>는 실현된 시간(시간 차원)이다.
따라서 내부 속도 <span class="math inline">\(\tilde{v}\)</span>와 실현 속도 <span class="math inline">\(v\)</span>는
<span class="math display">\[\tilde{v} \;:=\; \frac{d\tilde{x}}{d\tilde{t}},
\qquad
v \;:=\; \frac{dx}{dt}
\;=\;
\frac{a}{\Delta t}\,\tilde{v}
\label{eq:realization_map_v}\]</span>
로 연결된다. 이때 <span class="math inline">\(a/\Delta t\)</span>는 실현 속도 단위(길이/시간)의 기본 배율이며, 이 배율의 고정이 곧 실현의 핵심이다.</p>
<h3 data-number="4.6.3" id="a의-의미-고정실현-길이-스케일"><span class="header-section-number">4.6.3</span> 2.3.3 <span class="math inline">\(a\)</span>의 의미 고정(실현 길이 스케일)</h3>
<p><span class="math inline">\(a\)</span>는 실현된 기본 길이 스케일이다. <span class="math inline">\(a\)</span>의 의미는 다음과 같이 고정한다.</p>
<ol>
<li><p><span class="math inline">\(a\)</span>는 <strong>부피입자(VP) 기본 지름</strong>으로 정의한다.</p></li>
<li><p><span class="math inline">\(a\)</span>의 기하 의미는 <strong>지름</strong>으로 잠기며, 반경으로 재해석되지 않는다.</p></li>
<li><p><span class="math inline">\(a\)</span>의 차원은 길이(<code>L</code>)로 잠기며, 단위 표기는 실현 단위 체계(<code>SI</code>)로 잠긴다.</p></li>
<li><p><span class="math inline">\(a\)</span>의 수치는 <code>realization_lock</code>에 다음 값으로 고정된다.
<span class="math display">\[a \;=\; \aVP.
  \label{eq:a_value_lock}\]</span></p></li>
</ol>
<p><span class="math inline">\(a\)</span>로부터 반경이 필요한 경우에는 다음 파생 기호를 별도로 정의하여 사용한다.
<span class="math display">\[r_a \;:=\; \frac{a}{2}.
\label{eq:ra_derived}\]</span>
<span class="math inline">\(r_a\)</span>는 파생량이며, <span class="math inline">\(a\)</span>의 의미를 바꾸는 장치가 아니다.</p>
<h3 data-number="4.6.4" id="delta-t의-의미-고정실현-시간-틱"><span class="header-section-number">4.6.4</span> 2.3.4 <span class="math inline">\(\Delta t\)</span>의 의미 고정(실현 시간 틱)</h3>
<p><span class="math inline">\(\Delta t\)</span>는 실현된 기본 시간 틱이다. <span class="math inline">\(\Delta t\)</span>의 의미는 다음과 같이 고정한다.</p>
<ol>
<li><p><span class="math inline">\(\Delta t\)</span>는 내부 시간 좌표 <span class="math inline">\(\tilde{t}\)</span>의 1 단위를 실현 시간 <span class="math inline">\(t\)</span>로 변환하는 배율로 정의한다(식 <a data-reference="eq:realization_map_xt" data-reference-type="eqref" href="#eq:realization_map_xt">[eq:realization_map_xt]</a>).</p></li>
<li><p><span class="math inline">\(\Delta t\)</span>의 차원은 시간(<code>T</code>)으로 잠기며, 단위 표기는 실현 단위 체계(<code>SI</code>)로 잠긴다.</p></li>
<li><p><span class="math inline">\(\Delta t\)</span>의 수치는 <code>realization_lock</code>에 다음 값으로 고정된다.
<span class="math display">\[\Delta t \;=\; 1.86\times 10^{-21}\ \mathrm{s}.
  \label{eq:dt_value_lock}\]</span></p></li>
</ol>
<p><span class="math inline">\(\Delta t\)</span>는 “수치 안정화를 위한 계산 스텝”과 동일시되지 않는다. 계산 스텝이 별도로 존재하는 경우, 그 스텝은 <code>analysis_lock</code>의 프로토콜 파라미터로 잠기며 <span class="math inline">\(\Delta t\)</span>와 분리된다. <span class="math inline">\(\Delta t\)</span>는 실현 사상(<a data-reference="eq:realization_map_xt" data-reference-type="eqref" href="#eq:realization_map_xt">[eq:realization_map_xt]</a>)의 고정 배율로서만 사용된다.</p>
<h3 data-number="4.6.5" id="c_mathrmref의-의미-고정실현-기준-속도-상수"><span class="header-section-number">4.6.5</span> 2.3.5 <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 의미 고정(실현 기준 속도 상수)</h3>
<p><span class="math inline">\(c_{\mathrm{ref}}\)</span>는 실현 과정에서 사용되는 <strong>기준 속도 상수</strong>이다. <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 의미는 다음으로 고정한다.</p>
<ol>
<li><p><span class="math inline">\(c_{\mathrm{ref}}\)</span>는 “실현 속도 단위 <span class="math inline">\(a/\Delta t\)</span>”를 고정하기 위한 외부 기준 채널의 상수로 정의한다.</p></li>
<li><p><span class="math inline">\(c_{\mathrm{ref}}\)</span>는 길이/시간 차원(<code>L/T</code>)으로 잠기며, 단위 표기는 <code>m/s</code>로 잠긴다.</p></li>
<li><p><span class="math inline">\(c_{\mathrm{ref}}\)</span>는 <code>realization_lock</code>에 “값”과 “기준 채널 식별자”를 함께 기록한다. 값만 기록하고 채널/절차를 기록하지 않는 잠금은 허용되지 않는다.</p></li>
<li><p><span class="math inline">\(c_{\mathrm{ref}}\)</span>는 내부에서 유도되는 전파 지표(예: 내부 속도 <span class="math inline">\(\tilde{v}\)</span>의 특정 값)와 <strong>동일시하지 않는다</strong>. 내부 전파 지표는 유도 결과이며, <span class="math inline">\(c_{\mathrm{ref}}\)</span>는 실현 기준이다. 두 항목의 연결은 오직 실현 사상(<a data-reference="eq:realization_map_v" data-reference-type="eqref" href="#eq:realization_map_v">[eq:realization_map_v]</a>)의 배율 <span class="math inline">\(a/\Delta t\)</span>를 통해서만 이루어진다.</p></li>
</ol>
<p>따라서 <span class="math inline">\(c_{\mathrm{ref}}\)</span>가 실현 입력으로 채택된 경우, 실현 속도 배율은
<span class="math display">\[\frac{a}{\Delta t}
\quad\text{(실현 속도 단위)}
\label{eq:a_over_dt}\]</span>
로 고정되며, 이 배율의 고정은 <span class="math inline">\(a\)</span>와 <span class="math inline">\(\Delta t\)</span> 및 <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 의미 잠금이 동시에 성립할 때만 유효하다.</p>
<h3 data-number="4.6.6" id="realization-입력의-잠금-규칙실현값의-성격"><span class="header-section-number">4.6.6</span> 2.3.6 REALIZATION 입력의 잠금 규칙(실현값의 성격)</h3>
<p>REALIZATION 입력(<span class="math inline">\(a\)</span>, <span class="math inline">\(\Delta t\)</span>, <span class="math inline">\(c_{\mathrm{ref}}\)</span>)은 다음 규칙으로 잠긴다.</p>
<ol>
<li><p><strong>의미-단위-값 동시 잠금</strong>: 세 항목 모두 (i) 객체 귀속, (ii) 기하 의미(지름/반지름 등), (iii) 차원 및 단위 표기, (iv) 수치가 동시에 잠겨야 한다.</p></li>
<li><p><strong>SSOT</strong>: 실현값은 <code>realization_lock</code>의 단일 위치에만 존재한다. 본문은 항목명과 <code>lock_id</code>로만 참조한다.</p></li>
<li><p><strong>실현 절차 귀속</strong>: <span class="math inline">\(a\)</span>와 <span class="math inline">\(\Delta t\)</span>와 <span class="math inline">\(c_{\mathrm{ref}}\)</span>는 “어떤 기준 채널/어떤 교차정합/어떤 문턱”으로 고정되었는지를 함께 가져야 한다. 이 절차 정보는 <code>analysis_lock</code>의 Gate 구성 및 프로토콜 규약과 교차 참조된다.</p></li>
<li><p><strong>재해석 금지</strong>: <span class="math inline">\(a\)</span>를 반경으로 읽거나, <span class="math inline">\(\Delta t\)</span>를 계산 스텝으로 바꾸거나, <span class="math inline">\(c_{\mathrm{ref}}\)</span>를 내부 유도 지표로 소급 동일시하는 재해석은 동일 버전 내부에서 금지된다.</p></li>
</ol>
<p>위 규칙 중 하나라도 위반되면 실현 사상(<a data-reference="eq:realization_map_xt" data-reference-type="eqref" href="#eq:realization_map_xt">[eq:realization_map_xt]</a>) 자체가 붕괴하므로, 해당 산출물은 결론 자격을 상실한다.</p>
<h3 data-number="4.6.7" id="실현값-변경-절차버전업과-전면-재판정"><span class="header-section-number">4.6.7</span> 2.3.7 실현값 변경 절차(버전업과 전면 재판정)</h3>
<p>실현값(<span class="math inline">\(a\)</span>, <span class="math inline">\(\Delta t\)</span>, <span class="math inline">\(c_{\mathrm{ref}}\)</span>)의 변경은 동일 버전 내부에서 허용되지 않는다. 변경은 오직 <strong>버전업</strong>으로만 수행되며, 절차는 다음으로 고정한다.</p>
<ol>
<li><p><strong>변경 대상 명시</strong>: 변경이 <span class="math inline">\(a\)</span>/<span class="math inline">\(\Delta t\)</span>/<span class="math inline">\(c_{\mathrm{ref}}\)</span> 중 무엇인지, 그리고 변경이 (i) 의미, (ii) 단위, (iii) 값, (iv) 기준 채널/절차 중 무엇을 포함하는지 명시한다.</p></li>
<li><p><strong>새 realization_lock 생성</strong>: 새 <code>realization_lock_id</code>를 발급한다. 기존 <code>realization_lock_id</code>는 보존되며 내용이 수정되지 않는다.</p></li>
<li><p><strong>change_log 고정</strong>: 변경 전/후 항목(의미/단위/값/채널 식별자), 변경 이유, 영향을 받는 파생량 목록을 <code>change_log</code>로 고정한다.</p></li>
<li><p><strong>의존성 그래프 갱신</strong>: <span class="math inline">\(a\)</span> 또는 <span class="math inline">\(\Delta t\)</span>에 의존하는 모든 파생량(길이/시간/속도 배율, 에너지 스케일, 질량 스케일, 힘 스케일 등)을 재생성 대상으로 표시한다.</p></li>
<li><p><strong>전면 재유도</strong>: 변경된 실현값을 입력으로 관련 derived 산출물을 처음부터 다시 생성한다(중간 산출물 포함).</p></li>
<li><p><strong>전면 재판정</strong>: 실현값의 교차정합, 잠금 무결성, 재현성, No-Tuning 위반 여부를 포함하는 Gate 스택을 처음부터 다시 수행하여 PASS/FAIL/INCONCLUSIVE를 재판정한다.</p></li>
<li><p><strong>봉인</strong>: 새 버전의 레지스트리 스냅샷(<code>registry_snapshot</code>), 산출물 목록(<code>manifest</code>), 전체 파일 해시(<code>checksums</code>)를 생성하여 동결한다.</p></li>
</ol>
<p>버전업 이전의 결론은 기존 <code>realization_lock_id</code> 조합에 귀속되며, 버전업 이후의 결론은 새 <code>realization_lock_id</code> 조합에 귀속된다. 서로 다른 <code>realization_lock_id</code>의 결과를 혼합하여 하나의 결론으로 서술하는 행위는 금지된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-11">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(a\)</span>의 의미(부피입자 지름), 단위(SI), 값(<a data-reference="eq:a_value_lock" data-reference-type="eqref" href="#eq:a_value_lock">[eq:a_value_lock]</a>)을 <code>realization_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(\Delta t\)</span>의 의미(실현 시간 틱), 단위(SI), 값(<a data-reference="eq:dt_value_lock" data-reference-type="eqref" href="#eq:dt_value_lock">[eq:dt_value_lock]</a>)을 <code>realization_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 의미(실현 기준 속도 상수), 단위(<code>m/s</code>), 기준 채널 귀속을 <code>realization_lock</code>에 고정.</p></li>
<li><p>Gate: 실현값의 자격은 G-SYM/G-LOCK 및 교차정합 Gate(예: G-RCROSS), 재현 Gate(G-REP), No-Tuning Gate(G-NT)의 PASS를 필요조건으로 연결.</p></li>
<li><p>Gate: 실현값 변경은 버전업 후 전면 재유도/전면 재판정을 요구하며, 혼합 서술은 결론 자격 상실로 연결됨을 고정.</p></li>
</ul>
<h2 data-number="4.7" id="지름반지름셀-기하-혼동-방지"><span class="header-section-number">4.7</span> 2.4 지름/반지름/셀 기하 혼동 방지</h2>
<h3 data-number="4.7.1" id="목적"><span class="header-section-number">4.7.1</span> 2.4.1 목적</h3>
<p>본 절은 길이 기호가 지름/반지름/셀 대표길이(모서리/직경 등)로 혼용되는 것을 원천 차단하기 위해, (i) 지름/반지름/셀 기하의 표준 정의, (ii) 표준 표기 규약, (iii) 파생(변환) 허용 규칙, (iv) 혼동(모호/충돌) 탐지 시 즉시 <code>FAIL</code> 처리 규칙을 잠근다.</p>
<h3 data-number="4.7.2" id="표준-정의-반지름지름"><span class="header-section-number">4.7.2</span> 2.4.2 표준 정의: 반지름/지름</h3>
<p>본 문서에서 “반지름”과 “지름”은 다음 정의로 고정한다. 정의는 기하학적 의미(geometry_meaning) 필드로 잠기며, 동일 기호가 두 의미를 동시에 가질 수 없다.</p>
<h3 data-number="4.7.3" id="a-반지름radius"><span class="header-section-number">4.7.3</span> (A) 반지름(radius)</h3>
<p>반지름은 특정 중심(또는 기준점)에서 특정 경계(또는 기준 경계면)까지의 거리로 정의한다. 반지름 기호는 다음 규약을 가진다.</p>
<ol>
<li><p>반지름은 기호명에 <strong><span class="math inline">\(r\)</span></strong>를 사용한다: <span class="math inline">\(r_0, r_p, r_a\)</span> 등.</p></li>
<li><p>반지름의 geometry_meaning은 <code>radius</code>로 잠긴다.</p></li>
<li><p>반지름은 “지름의 절반”이라는 관례적 관계로부터 정의되지 않는다. 반지름은 객체 정의와 함께 직접 정의되며, 지름과의 관계는 별도의 파생 정의로만 연결된다.</p></li>
</ol>
<h3 data-number="4.7.4" id="b-지름diameter"><span class="header-section-number">4.7.4</span> (B) 지름(diameter)</h3>
<p>지름은 동일 객체에서 서로 마주 보는 두 경계(또는 기준 경계면) 사이의 거리로 정의한다. 지름 기호는 다음 규약을 가진다.</p>
<ol>
<li><p>지름은 기호명에 <strong><span class="math inline">\(D\)</span></strong>를 사용한다: <span class="math inline">\(D_{\mathrm{anch}}, D_a\)</span> 등.</p></li>
<li><p>지름의 geometry_meaning은 <code>diameter</code>로 잠긴다.</p></li>
<li><p>지름은 “반지름의 두 배”라는 관례적 관계로부터 정의되지 않는다. 지름은 객체 정의와 함께 직접 정의되며, 반지름과의 관계는 별도의 파생 정의로만 연결된다.</p></li>
</ol>
<h3 data-number="4.7.5" id="c-반지름지름-연결파생-정의만-허용"><span class="header-section-number">4.7.5</span> (C) 반지름–지름 연결(파생 정의만 허용)</h3>
<p>반지름과 지름의 연결은 다음과 같이 <strong>파생 정의</strong>로만 허용한다.
<span class="math display">\[r \;:=\; \frac{D}{2},
\qquad
D \;:=\; 2r.
\label{eq:rd_relation}\]</span>
식 <a data-reference="eq:rd_relation" data-reference-type="eqref" href="#eq:rd_relation">[eq:rd_relation]</a>는 “기호 의미 변환”이 아니라 “새 기호의 파생”을 의미한다. 즉, 특정 절에서 <span class="math inline">\(D\)</span>가 지름으로 잠겼다면, 반지름이 필요할 때는 반드시 <strong>새 기호</strong> <span class="math inline">\(r:=D/2\)</span>를 도입하여 사용해야 하며, 이후 해당 절에서는 <span class="math inline">\(D\)</span>를 반지름처럼 사용하지 않는다. 마찬가지로 <span class="math inline">\(r\)</span>가 반지름으로 잠겼다면, 지름이 필요할 때는 반드시 <strong>새 기호</strong> <span class="math inline">\(D:=2r\)</span>를 도입하여 사용해야 하며, 이후 해당 절에서는 <span class="math inline">\(r\)</span>를 지름처럼 사용하지 않는다.</p>
<h3 data-number="4.7.6" id="표준-정의-셀cell과-셀-기하"><span class="header-section-number">4.7.6</span> 2.4.3 표준 정의: 셀(cell)과 셀 기하</h3>
<p>본 문서에서 “셀”은 VP 집합을 묶는 기준 영역이며, 셀은 <strong>객체</strong>로서 정의된다. 셀은 “어떤 기하로 모델링되는가”가 반드시 함께 잠겨야 하며, 셀 기하가 잠기지 않은 셀 길이/셀 반경/셀 지름은 사용 불가이다.</p>
<h3 data-number="4.7.7" id="a-셀-객체의-필수-필드"><span class="header-section-number">4.7.7</span> (A) 셀 객체의 필수 필드</h3>
<p>셀 객체 <code>OBJ-CELL</code>은 다음 필드를 필수로 가진다.</p>
<ol>
<li><p><strong>cell_id</strong>: 셀의 식별자.</p></li>
<li><p><strong>cell_geometry</strong>: 셀 기하 타입.</p></li>
<li><p><strong>cell_length_symbol</strong>: 셀 대표 길이로 사용하는 기호.</p></li>
<li><p><strong>geometry_meaning</strong>: 셀 대표 길이의 기하 의미(모서리 길이, 지름, 반지름 등).</p></li>
<li><p><strong>definition</strong>: 셀과 셀 대표 길이의 정의식.</p></li>
<li><p><strong>scope</strong>: 적용 레짐.</p></li>
</ol>
<h3 data-number="4.7.8" id="b-셀-기하-타입의-표준-목록열거형"><span class="header-section-number">4.7.8</span> (B) 셀 기하 타입의 표준 목록(열거형)</h3>
<p>셀 기하 타입은 다음 열거형 중 하나로 잠근다.</p>
<ol>
<li><p><strong><code>CELL-CUBE</code></strong>: 셀은 큐브이며, 셀 대표 길이는 모서리 길이로 정의된다.</p></li>
<li><p><strong><code>CELL-SPHERE-VIS</code></strong>: 셀은 시각화 또는 보조 정의를 위해 구형으로 사용되며, 셀 대표 길이는 지름 또는 반지름으로 정의된다(둘 중 하나만 선택하여 잠김).</p></li>
<li><p><strong><code>CELL-OTHER</code></strong>: 위 두 타입 이외의 기하를 사용할 경우, 그 기하의 정의(경계, 대표 길이, 측정 규약)를 <strong>추가 필드</strong>로 완전 명시하여 잠근다.</p></li>
</ol>
<p><code>CELL-OTHER</code>는 “모호한 자유도”가 아니다. <code>CELL-OTHER</code>를 사용하면, 해당 셀 기하 정의가 본문 내에서 완결되어야 하며, 대표 길이의 의미와 변환 관계가 모두 잠겨야 한다.</p>
<h3 data-number="4.7.9" id="c-큐브-셀의-대표-길이-표준cell-cube"><span class="header-section-number">4.7.9</span> (C) 큐브 셀의 대표 길이 표준(<code>CELL-CUBE</code>)</h3>
<p>큐브 셀의 대표 길이는 모서리 길이로 정의한다.</p>
<ol>
<li><p>큐브 셀 대표 길이 기호는 <span class="math inline">\(L_{\mathrm{cell}}\)</span> 또는 <span class="math inline">\(D_{\mathrm{anch}}\)</span> 등으로 정의할 수 있으나, 어떤 기호를 쓰더라도 geometry_meaning을 <strong><code>edge</code></strong>로 잠가야 한다.</p></li>
<li><p>큐브 셀에서 “반경” 또는 “지름”을 도입하려면, 반드시 파생 기호로 도입한다. 예를 들어, 큐브의 대각선 또는 등가 구(시각화)와 연결하려면, 그 연결 규칙을 analysis_lock(절차) 또는 canon_lock(정의) 중 하나에 고정하고, 파생 기호를 별도로 만든다.</p></li>
</ol>
<p>큐브 셀 대표 길이를 반지름이나 지름으로 해석하는 행위는 금지된다.</p>
<h3 data-number="4.7.10" id="d-구형-셀의-대표-길이-표준cell-sphere-vis"><span class="header-section-number">4.7.10</span> (D) 구형 셀의 대표 길이 표준(<code>CELL-SPHERE-VIS</code>)</h3>
<p>구형 셀의 대표 길이는 지름 또는 반지름 중 하나로만 정의하며, 둘을 동시에 사용하지 않는다.</p>
<ol>
<li><p>구형 셀 대표 길이를 지름으로 정의하는 경우: 기호를 <span class="math inline">\(D_{\mathrm{cell}}\)</span>로 두고 geometry_meaning=<code>diameter</code>로 잠근다.</p></li>
<li><p>구형 셀 대표 길이를 반지름으로 정의하는 경우: 기호를 <span class="math inline">\(r_{\mathrm{cell}}\)</span>로 두고 geometry_meaning=<code>radius</code>로 잠근다.</p></li>
<li><p>구형 셀의 지름/반지름을 동시에 쓰려면, 반드시 파생 정의(식 <a data-reference="eq:rd_relation" data-reference-type="eqref" href="#eq:rd_relation">[eq:rd_relation]</a>)로 연결된 <strong>별도 기호</strong>를 도입해야 한다.</p></li>
</ol>
<p><code>CELL-SPHERE-VIS</code>는 셀 기하의 선택이며, 동일 절 안에서 <code>CELL-CUBE</code>와 의미를 혼합하여 하나의 셀 대표 길이를 양쪽처럼 쓰는 행위는 금지된다.</p>
<h3 data-number="4.7.11" id="혼동-방지-규칙잠금-규칙"><span class="header-section-number">4.7.11</span> 2.4.4 혼동 방지 규칙(잠금 규칙)</h3>
<p>본 절은 혼동 방지 규칙을 다음으로 잠근다. 규칙 위반은 즉시 <code>FAIL</code>로 판정된다.</p>
<h3 data-number="4.7.12" id="r1-의미-잠금-의무"><span class="header-section-number">4.7.12</span> (R1) 의미 잠금 의무</h3>
<p>길이 기호는 사용 전에 반드시 다음 세 가지를 동시에 가진다.</p>
<ol>
<li><p><strong>object_id</strong> (어떤 객체의 길이인가)</p></li>
<li><p><strong>geometry_meaning</strong> (지름/반지름/모서리/간격/두께 등)</p></li>
<li><p><strong>dimension</strong> (길이 차원)</p></li>
</ol>
<p>셋 중 하나라도 누락되면 그 기호는 사용 불가이며, 그 기호가 포함된 식/표/그림/로그는 즉시 <code>FAIL</code>로 판정된다.</p>
<h3 data-number="4.7.13" id="r2-동일-기호의-단일-의미-원칙오버로딩-금지"><span class="header-section-number">4.7.13</span> (R2) 동일 기호의 단일 의미 원칙(오버로딩 금지)</h3>
<p>동일 기호(동일 철자)는 문서 전역에서 단 하나의 (object_id, geometry_meaning, dimension) 삼중항만 가질 수 있다.
동일 철자가 다른 삼중항으로 등장하는 순간, 충돌은 해석으로 봉합되지 않으며 즉시 <code>FAIL</code>이다.</p>
<h3 data-number="4.7.14" id="r3-파생-변환의-명시-원칙암묵-변환-금지"><span class="header-section-number">4.7.14</span> (R3) 파생 변환의 명시 원칙(암묵 변환 금지)</h3>
<p>지름<span class="math inline">\(\leftrightarrow\)</span>반지름 변환, 큐브<span class="math inline">\(\leftrightarrow\)</span>구형 연결, 대표 길이<span class="math inline">\(\leftrightarrow\)</span>파생 길이 변환은 모두 <strong>명시된 파생 기호</strong>를 통해서만 허용한다.</p>
<ol>
<li><p>“<span class="math inline">\(D\)</span>를 <span class="math inline">\(r\)</span>처럼 사용” 또는 “<span class="math inline">\(r\)</span>을 <span class="math inline">\(D\)</span>처럼 사용”은 금지된다.</p></li>
<li><p>“셀 대표 길이를 상황에 따라 지름/반지름/모서리로 바꾸는” 행위는 금지된다.</p></li>
<li><p>변환이 필요하면 반드시 새 기호를 도입하고, 그 새 기호는 변환식과 함께 레지스트리에 등록되어야 한다.</p></li>
</ol>
<h3 data-number="4.7.15" id="r4-지름반지름셀-기하의-교차-혼합-금지"><span class="header-section-number">4.7.15</span> (R4) 지름/반지름/셀 기하의 교차 혼합 금지</h3>
<p>동일 절에서 다음 혼합은 금지된다.</p>
<ol>
<li><p>동일 셀 대표 길이를 <code>edge</code>로 잠근 뒤, 같은 기호를 <code>diameter</code> 또는 <code>radius</code>로 사용하는 혼합.</p></li>
<li><p><code>CELL-CUBE</code>로 잠긴 셀에서, 별도 파생 정의 없이 <code>CELL-SPHERE-VIS</code>의 지름/반지름 정의를 같은 기호에 부여하는 혼합.</p></li>
<li><p>서로 다른 셀 기하 타입을 하나의 유도 사슬에서 “동일 셀”처럼 합성하여 사용하는 혼합.</p></li>
</ol>
<h3 data-number="4.7.16" id="혼동-탐지-시-즉시-fail-규칙게이트-판정"><span class="header-section-number">4.7.16</span> 2.4.5 혼동 탐지 시 즉시 FAIL 규칙(게이트 판정)</h3>
<p>혼동(모호/충돌)의 탐지는 Gate에서 수행되며, 탐지 즉시 <code>FAIL</code>이다. 혼동 판정은 결과의 해석과 무관하며, 오직 정의/잠금의 무결성만을 판정한다.</p>
<h3 data-number="4.7.17" id="a-즉시-fail-조건"><span class="header-section-number">4.7.17</span> (A) 즉시 FAIL 조건</h3>
<p>다음 중 하나라도 성립하면 즉시 <code>FAIL</code>이다.</p>
<ol>
<li><p><strong>RD-AMB(반지름/지름 모호)</strong>: 어떤 기호가 반지름인지 지름인지 레지스트리에서 판정되지 않는다(geometry_meaning 누락 또는 다중값).</p></li>
<li><p><strong>RD-CONFLICT(반지름/지름 충돌)</strong>: 동일 기호가 어떤 곳에서는 <code>radius</code>, 다른 곳에서는 <code>diameter</code>로 사용된다.</p></li>
<li><p><strong>CELL-AMB(셀 기하 모호)</strong>: 셀 기하 타입(<code>CELL-CUBE</code>/<code>CELL-SPHERE-VIS</code>/<code>CELL-OTHER</code>)이 잠기지 않았다.</p></li>
<li><p><strong>CELL-CONFLICT(셀 기하 충돌)</strong>: 동일 셀 대표 길이 기호가 서로 다른 셀 기하 타입의 대표 길이로 사용된다.</p></li>
<li><p><strong>IMPLICIT-CONV(암묵 변환)</strong>: 파생 기호 없이 <span class="math inline">\(D\leftrightarrow r\)</span> 변환 또는 큐브<span class="math inline">\(\leftrightarrow\)</span>구형 연결이 식/표/그림/로그에서 암묵적으로 수행된다.</p></li>
<li><p><strong>DIM-MISMATCH(차원 충돌)</strong>: 길이로 잠긴 기호가 다른 차원으로 사용되거나, 단위 표기가 바뀌어도 기록/변환 단계가 존재하지 않는다.</p></li>
</ol>
<h3 data-number="4.7.18" id="b-fail-라벨표준-라벨"><span class="header-section-number">4.7.18</span> (B) FAIL 라벨(표준 라벨)</h3>
<p>혼동 판정의 FAIL 라벨은 다음으로 고정한다(복수 라벨 허용).</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">라벨</th>
<th style="text-align: left;">의미</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">FAIL-GEO-RD-AMB</td>
<td style="text-align: left;">반지름/지름 의미가 잠기지 않음(모호)</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-GEO-RD-CONF</td>
<td style="text-align: left;">동일 기호가 반지름/지름으로 충돌 사용됨</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FAIL-GEO-CELL-AMB</td>
<td style="text-align: left;">셀 기하 타입이 잠기지 않음(모호)</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-GEO-CELL-CONF</td>
<td style="text-align: left;">셀 기하 타입 또는 대표 길이 의미가 충돌함</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FAIL-GEO-IMPL</td>
<td style="text-align: left;">파생 기호 없이 암묵 변환이 수행됨</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-GEO-DIM</td>
<td style="text-align: left;">단위/차원 불일치 또는 변환 단계 누락</td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="4.7.19" id="c-즉시-fail의-전파-규칙"><span class="header-section-number">4.7.19</span> (C) 즉시 FAIL의 전파 규칙</h3>
<p><code>FAIL</code>이 발생하면 다음이 즉시 성립한다.</p>
<ol>
<li><p>해당 식/표/그림/로그를 포함하는 산출물은 결론 자격을 상실한다.</p></li>
<li><p>의존성 그래프에서 해당 산출물을 입력으로 사용하는 모든 파생 산출물은 결론 자격을 연쇄적으로 상실한다.</p></li>
<li><p><code>FAIL</code> 상태는 “수정”으로 해소되지 않으며, 해소는 버전업(레지스트리 수정 후 전면 재유도/재판정)으로만 이루어진다.</p></li>
</ol>
<h3 data-number="4.7.20" id="혼동-해소의-유일한-경로버전업"><span class="header-section-number">4.7.20</span> 2.4.6 혼동 해소의 유일한 경로(버전업)</h3>
<p>혼동을 해소하기 위한 절차는 다음으로 고정한다.</p>
<ol>
<li><p>충돌 항목(기호 의미/셀 기하/단위/파생 정의)의 위치를 레지스트리에서 특정한다.</p></li>
<li><p>해당 레지스트리(canon_lock 또는 analysis_lock 또는 realization_lock)의 새 <code>lock_id</code>를 발급한다.</p></li>
<li><p>충돌을 제거하는 방식으로 항목을 수정한다(기호 분리, geometry_meaning 단일화, 셀 기하 타입 단일화, 파생 기호의 추가 등).</p></li>
<li><p>수정된 <code>lock_id</code> 조합으로 관련 유도를 전면 재생성하고, 관련 Gate를 전면 재판정한다.</p></li>
<li><p>새 레지스트리 스냅샷, manifest, checksums를 봉인한다.</p></li>
</ol>
<p>동일 버전 내부에서의 “해석” 또는 “문장 수정”은 혼동 해소로 인정되지 않는다. 혼동은 정의/잠금의 문제이며, 정의/잠금이 바뀌지 않으면 혼동은 남아 있기 때문이다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-12">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 반지름/지름/셀 기하의 표준 정의(geometry_meaning=<code>radius</code>/<code>diameter</code>/<code>edge</code> 등)와 셀 기하 타입(<code>CELL-CUBE</code>, <code>CELL-SPHERE-VIS</code>, <code>CELL-OTHER</code>) 열거형 고정.</p></li>
<li><p>LOCK: 파생 변환(지름<span class="math inline">\(\leftrightarrow\)</span>반지름)은 새 기호 도입으로만 허용(암묵 변환 금지) 규약 고정.</p></li>
<li><p>Gate: 혼동 탐지 즉시 <code>FAIL</code> 및 FAIL 라벨(FAIL-GEO-*) 부여 규약 고정.</p></li>
<li><p>Gate: <code>FAIL</code>의 결론 자격 박탈 및 의존성 전파 규칙 고정.</p></li>
<li><p>LOCK<span class="math inline">\(\rightarrow\)</span>Gate: 혼동 해소는 버전업 후 전면 재유도/전면 재판정으로만 가능함을 연결 고정.</p></li>
</ul>
<h1 data-number="5" id="공리와-프리미티브부피입자격자양자셀"><span class="header-section-number">5</span> 3. 공리와 프리미티브(부피입자/격자/양자셀)</h1>
<h2 class="unnumbered" id="장의-선언-프리미티브에서-시작하는-단일-골격">장의 선언: 프리미티브에서 시작하는 단일 골격</h2>
<p>본 장은 문서 전역에서 사용되는 세계의 최소 구성요소를 <strong>프리미티브</strong>로 고정한다. 프리미티브는 (i) 부피입자(VP), (ii) 기판(Stone) 레짐, (iii) 셀(Cell, Anchor Cell)이며, 이 셋의 관계를 다음과 같이 단일 골격으로 고정한다.
<span class="math display">\[\text{VP 공리 세트}
\;\Longrightarrow\;
\text{허용 배치(충만/비침투/접촉 제약)}
\;\Longrightarrow\;
\text{격자/그래프(인접성의 정의)}
\;\Longrightarrow\;
\text{셀 정의(집계/카운팅/좌표계)}
\;\Longrightarrow\;
\text{후속 유도(정류/사건/실현/질량/힘)}.
\label{eq:primitive_chain}\]</span>
식 <a data-reference="eq:primitive_chain" data-reference-type="eqref" href="#eq:primitive_chain">[eq:primitive_chain]</a>에서 오른쪽으로 진행하는 항목은 왼쪽 항목에 <em>의존</em>하며, 반대 방향으로의 소급 해석(오른쪽 결과로 왼쪽 정의를 바꾸는 행위)은 허용되지 않는다.</p>
<h2 class="unnumbered" id="vp-공리-세트최소-공리의-고정">VP 공리 세트(최소 공리의 고정)</h2>
<p>부피입자(VP)는 공간을 구성하는 기본 단위이며, VP의 성질은 다음 공리 세트로 고정한다. 각 공리는 서로 다른 의미를 가지며, 공리 간 중복 서술을 금지한다.</p>
<h3 data-number="5.0.1" id="vp-a1-stone-공리-무한강성압축-불가과-동일성"><span class="header-section-number">5.0.1</span> (VP-A1) Stone 공리: 무한강성(압축 불가)과 동일성</h3>
<p>모든 VP는 “기판(Stone)” 성질을 갖는다. Stone 성질은 다음으로 고정한다.</p>
<ol>
<li><p><strong>압축 불가</strong>: VP는 내부 부피가 변하지 않는다. 동일 VP의 내부 부피는 상태 변화나 배치 변화에 의해 감소하거나 증가하지 않는다.</p></li>
<li><p><strong>비침투</strong>: 서로 다른 두 VP는 동일 공간을 동시에 점유할 수 없다. 즉, VP의 점유 영역은 서로 겹치지 않는다.</p></li>
<li><p><strong>동일성</strong>: VP는 동일한 기본 단위로 취급되며, VP 사이의 “종류” 차이를 기본 공리로 도입하지 않는다. 차이는 오직 배치, 접촉, 국소 상태 변수(후속 절에서 정의)로만 표현된다.</p></li>
</ol>
<p>이 공리는 “강성”의 의미를 물리적 법칙으로 도입하는 것이 아니라, <strong>허용되는 배치의 집합</strong>을 제한하는 제약으로 도입한다. 즉, Stone 공리는 “가능한 구성”의 영역을 먼저 고정한다.</p>
<h3 data-number="5.0.2" id="vp-a2-충만-공리-공간의-충만-점유"><span class="header-section-number">5.0.2</span> (VP-A2) 충만 공리: 공간의 충만 점유</h3>
<p>공간은 VP로 충만하게 점유된다. 충만 공리는 다음으로 고정한다.</p>
<ol>
<li><p><strong>충만 점유</strong>: 관심 영역(셀 또는 도메인) 내부의 공간은 VP의 점유 영역들의 합으로 표현된다.</p></li>
<li><p><strong>결함의 위치</strong>: 충만을 위반하는 “빈 공간”은 기본 자유도로 도입하지 않는다. 대신 결함, 목(throat), 간격(gap), 결손(deficit)은 <strong>배치와 인접성의 결과로 정의되는 국소 구조량</strong>으로만 등장한다(후속 절에서 객체로 정의).</p></li>
<li><p><strong>경계의 취급</strong>: 경계는 “VP 외부”를 뜻하는 것이 아니라, 도메인 선택(셀 선택)에 의해 도입되는 절차적 경계로 고정한다. 경계의 종류(닫힘/열림/구동)는 프로토콜의 일부로 잠긴다.</p></li>
</ol>
<h3 data-number="5.0.3" id="vp-a3-국소-규칙-공리-접촉-기반-배치와-국소-갱신"><span class="header-section-number">5.0.3</span> (VP-A3) 국소 규칙 공리: 접촉 기반 배치와 국소 갱신</h3>
<p>VP의 변화는 국소 규칙으로만 정의한다. 국소 규칙 공리는 다음으로 고정한다.</p>
<ol>
<li><p><strong>접촉 기반</strong>: VP 간 상호작용은 “접촉” 또는 “근접”의 관계로만 표현된다. 접촉은 인접성(adjacency)으로 환원되며, 인접성은 그래프 또는 격자 구조를 통해 기록된다.</p></li>
<li><p><strong>국소 갱신</strong>: 변화(재배열, 구동, 완화)는 국소적으로 발생하며, 갱신 규칙은 프로토콜로 잠긴다. 갱신은 “허용 배치 집합”을 벗어나는 방식으로 정의되지 않는다.</p></li>
<li><p><strong>상태 변수의 자리</strong>: VP가 갖는 내부 상태 변수(예: 위상, 방향, 국소 지표 등)는 본 공리에서 <em>자리만</em> 확보한다. 구체적인 상태 변수의 목록과 의미는 이후 절에서 별도로 정의하여 잠근다.</p></li>
</ol>
<h3 data-number="5.0.4" id="vp-a4-인접성-공리-격자그래프의-1차-객체화"><span class="header-section-number">5.0.4</span> (VP-A4) 인접성 공리: 격자/그래프의 1차 객체화</h3>
<p>배치는 인접성 구조로 외부화된다. 인접성 공리는 다음으로 고정한다.</p>
<ol>
<li><p><strong>인접 그래프</strong>: 도메인 내부의 VP 집합 <span class="math inline">\(\mathcal{V}\)</span>에 대해, 인접성 관계로 간선 집합 <span class="math inline">\(\mathcal{E}\)</span>를 정의하여 그래프 <span class="math inline">\(\mathcal{G}=(\mathcal{V},\mathcal{E})\)</span>를 구성한다.</p></li>
<li><p><strong>격자/네트워크</strong>: “격자”는 규칙적 배열을 뜻하는 용어가 아니라, 인접 그래프가 도메인 내부에서 전달(연결)을 제공하는 <strong>네트워크 객체</strong>를 뜻하는 용어로 고정한다.</p></li>
<li><p><strong>측정의 자리</strong>: 거리, 두께, 간격 등의 길이량은 인접성 구조와 셀 정의를 결합하여 <em>파생</em>된다. 길이량은 인접성 자체를 정의하는 공리로 먼저 주어지지 않는다.</p></li>
</ol>
<h3 data-number="5.0.5" id="vp-n1-유효-강성은-관측-시간에-의존한다-동적-강성-재밍-언재밍"><span class="header-section-number">5.0.5</span> (VP-N1) 유효 강성은 관측 시간에 의존한다: 동적 강성, 재밍, 언재밍</h3>
<p>Stone 공리(VP-A1)는 <em>개별 VP의 내부 부피가 변하지 않는다</em>는 제약을 잠근다.
그러나 실험에서 보고되는 “강성(stiffness)” 또는 “저항(stress response)”은
대개 <em>VP 집합이 주어진 시간척도에서 재배열할 수 있는지</em>에 의해 결정된다.
즉, <strong>정적 강성</strong>이 아니라 <strong>동적 강성</strong>이 관측량의 실체이며,
동일한 구성도 관측 시간/구동률에 따라 “부드러움”과 “딱딱함”이 서로 다른 레짐으로 나타날 수 있다.</p>
<p>이를 최소한의 운영변수로 정리하기 위해, 완화 시간 <span class="math inline">\(\tau_{\rm relax}\)</span>와 관측 시간 <span class="math inline">\(\tau_{\rm obs}\)</span>를 도입하고
다음 무차원 수를 레짐 라벨로 사용한다.
<span class="math display">\[\mathrm{De} \;\equiv\; \frac{\tau_{\rm relax}}{\tau_{\rm obs}}.
  \label{eq:deborah_like}\]</span>
<strong>레짐 해석:</strong>
<span class="math inline">\(\mathrm{De}\ll 1\)</span>이면 VP 집합이 관측 시간 내에 재배열하여 하중을 분산할 수 있으므로 “유체형(soft)” 응답이 나타나고,
<span class="math inline">\(\mathrm{De}\gg 1\)</span>이면 재배열이 억제되어 강성 네트워크가 유지되므로 “고체형(hard)” 응답이 나타난다.
이 문서의 재밍/비재밍 레짐은 이러한 시간척도 의존성을 포함하는 형태로 사용될 수 있으며,
특정 결론에서 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 등 프로토콜 입력을 함께 기록하는 이유도 여기에 있다.</p>
<h4 data-number="5.0.5.1" id="eggshell껍데기-전이-최소-상태-기계개념"><span class="header-section-number">5.0.5.1</span> Eggshell(껍데기) 전이: 최소 상태 기계(개념)</h4>
<p>본 문서에서 “임계”는 하나의 수치가 아니라 <em>레짐 전환</em>으로 정의한다.
VP 집합의 응답은 다음과 같은 최소 시퀀스로 요약할 수 있다.</p>
<ul>
<li><p><strong>[A] 유연 레짐(Elastic-fluid):</strong> 재배열 가능(<span class="math inline">\(\mathrm{De}\lesssim 1\)</span>). 화학/열 등 저속 구동에서 “부드러움”이 관측된다.</p></li>
<li><p><strong>[B] 재밍 레짐(Jammed-solid):</strong> 강성 네트워크가 도메인을 가로지르며(<span class="math inline">\(\mathrm{De}\gg 1\)</span>), 외부에서는 “질량/코어”로 관측된다.</p></li>
<li><p><strong>[C] 언재밍(껍데기 붕괴):</strong> 요구 강성(또는 곡률요구량)이 항복 한계를 넘으면 강성 백본이 파괴되어 비재밍 채널이 열린다.</p></li>
<li><p><strong>[D] 유입/유출(Flux channel):</strong> 열린 채널을 통해 입자/결손 흐름이 급격히 재분배된다(프로토콜에 따라 속도 상한이 설정됨).</p></li>
<li><p><strong>[E] 자가복구(Re-jamming):</strong> 하중이 완화되면 다시 재밍 네트워크가 형성되어 레짐이 닫힌다.</p></li>
</ul>
<p>이 시퀀스는 <em>정확한 미시 계산으로 강성을 산출</em>하기보다,
<em>관측된 임계(항복/포화) 조건</em>을 프로토콜과 함께 잠그고(LOCK),
그 위에서 유도와 Gate 판정을 수행하는 접근을 정당화한다.
따라서 본 문서에서 <span class="math inline">\(c^2\)</span>, <span class="math inline">\(g_\star\)</span>, <span class="math inline">\(g^\ast\)</span> 같은 임계 스케일이 등장할 때에는
<strong>항상 해당 프로토콜(시간창/구동률/형상)를 함께 기록</strong>해야 하며,
그 기록이 없으면 결과는 <code>INCONCLUSIVE</code>로 취급한다.</p>
<h4 data-number="5.0.5.2" id="최소-닫힘closure-언재밍-트리거와-자가복구-방정식"><span class="header-section-number">5.0.5.2</span> 최소 닫힘(closure): 언재밍 트리거와 자가복구 방정식</h4>
<p>위 개념 시퀀스를 <em>검증 가능한 서술</em>로 바꾸기 위해, 본 문서는 다음 최소 운영식을 닫힘(closure) 후보로 제안한다.</p>
<p>첫째, “껍데기” 붕괴(언재밍)의 트리거는 프로토콜로 정의된 <em>요구량(demand)</em> <span class="math inline">\(\Psi_{\rm req}(t)\)</span>가
항복 임계 <span class="math inline">\(\Psi_{\rm yield}\)</span>를 초과할 때로 고정한다.
<span class="math display">\[\Psi_{\rm req}(t) &gt; \Psi_{\rm yield} \;\Rightarrow\; \text{unjamming / channel open}.
  \label{eq:unjamming_trigger}\]</span>
여기서 <span class="math inline">\(\Psi_{\rm req}\)</span>는 응력, 에너지 밀도, 곡률 요구량, 사건율 등 중 <em>단 하나의 정의</em>로
(타입/차원/단위와 함께) <code>analysis_lock</code>에 잠기며,
<span class="math inline">\(\Psi_{\rm yield}\)</span> 역시 <em>동일 프로토콜</em>에서 함께 잠긴다(사후 조정 금지).</p>
<p>또한 이후 “포화(항복)” 서술(예: 부록 G)과 기호를 일치시키기 위해,
항복이 적용된 <em>유효 요구량</em>을 다음과 같이 둘 수 있다.
<span class="math display">\[\Psi_{\rm eff}(t) := \min\bigl(\Psi_{\rm req}(t),\ \Psi_{\rm yield}\bigr)
  \label{eq:psi_eff_clamp}\]</span>
따라서 정의상 <span class="math inline">\(\Psi_{\rm eff}(t)\le \Psi_{\rm yield}\)</span> 이다.</p>
<p>둘째, 재밍 네트워크의 “건전도”를 나타내는 거시 상태변수 <span class="math inline">\(\xi(t)\in[0,1]\)</span>을 도입한다
(<span class="math inline">\(\xi=1\)</span>: jammed, <span class="math inline">\(\xi=0\)</span>: fully unjammed).
자가복구(re-jamming)는 1차 완화 방정식으로 닫으며, 가장 단순한 형태는 다음의 구간별 동역학이다.
<span class="math display">\[\dot \xi(t)=
  \begin{cases}
    -\dfrac{\xi(t)}{\tau_{\rm break}}, &amp; \Psi_{\rm req}(t)&gt;\Psi_{\rm yield},\\[6pt]
    +\dfrac{1-\xi(t)}{\tau_{\rm heal}}, &amp; \Psi_{\rm req}(t)\le \Psi_{\rm yield}.
  \end{cases}
  \label{eq:g_dynamics_piecewise}\]</span>
여기서 <span class="math inline">\(\tau_{\rm break},\tau_{\rm heal}\)</span>은 레짐/환경/결함 분포에 따라 달라지는 시간척도이며
<code>analysis_lock</code>에 잠긴다.
필요하다면 유효 강성(또는 저항)은
<span class="math inline">\(K_{\rm eff}(t)=K_{\rm soft}+(K_{\rm jam}-K_{\rm soft})\,\xi(t)\)</span>처럼
<span class="math inline">\(\xi(t)\)</span>에 의해 선형 혼합되는 형태로 연결할 수 있으며,
3.2의 강성 지시변수 <span class="math inline">\(\chi_{\mathrm{ST}}\)</span>를
<span class="math inline">\(\chi_{\mathrm{ST}}=\mathbf{1}[\xi\ge \xi_{\rm th}]\)</span> 같은 문턱 함수로 닫는 것도 가능하다
(문턱 <span class="math inline">\(\xi_{\rm th}\)</span>는 프로토콜로 잠김).</p>
<p>셋째, Eggshell 단계 [D]의 “유입/유출(Flux channel)”을 4.1의 flux 정의와 연결하려면,
채널 개방 지시변수
<span class="math display">\[\chi_{\rm open}(t):=\mathbf{1}[\Psi_{\rm req}(t)&gt;\Psi_{\rm yield}]
  \label{eq:chi_open_def}\]</span>
을 도입하고, 절단면 flux <span class="math inline">\(J\)</span> (정의 <a data-reference="eq:flux_def" data-reference-type="eqref" href="#eq:flux_def">[eq:flux_def]</a>)에 대해 최소한
<span class="math display">\[|J| \le c_{\mathrm{ref}}\,\chi_{\rm open}
  \label{eq:flux_cap_cref}\]</span>
을 운영 규약(상한)으로 고정할 수 있다.
이는 “빛의 속도로 유입”을 <em>동일시(=)</em>가 아니라 <em>상한(<span class="math inline">\(\le\)</span>)</em>으로 취급하는 최소 서술이며,
<span class="math inline">\(\chi_{\rm open}=0\)</span>인 레짐에서의 flux 존재/부재는 프로토콜 정의에 의해 별도로 판정된다.</p>
<p>본 닫힘은 미시 규칙의 대체가 아니라, <em>동적 강성(시간척도 의존)과 재밍–언재밍 전이를 실험적으로 판정 가능한 형태로 기술하기 위한 최소 모델</em>이다.
즉, 위 식들의 목적은 “소수점 자리”가 아니라 “어떤 조건에서 전이가 일어나며(Trigger), 전이 후 얼마나 빨리 복구하는지(Time-scale)”를
측정 가능한 파라미터로 분리해 기록하는 데 있다.</p>
<h2 class="unnumbered" id="기판stone-레짐과-vp-공리의-관계">기판(Stone) 레짐과 VP 공리의 관계</h2>
<p>기판(Stone)은 VP-A1에서 도입된 무한강성의 다른 이름이며, 본 문서에서 기판은 “추가 실체”가 아니다. 기판은 다음을 의미한다.</p>
<ol>
<li><p>VP가 압축되지 않는다는 제약이 <strong>전역적으로 적용되는 레짐</strong>을 “Stone 레짐”으로 부른다.</p></li>
<li><p>Stone 레짐에서는 “부피 변화”를 자유도로 취급하지 않으며, 모든 유도는 배치(인접성)와 국소 갱신 규칙으로만 진행된다.</p></li>
<li><p>Stone 레짐의 적용 범위(언제 Stone 레짐을 가정하는가)는 레짐 선언으로 잠기며, 레짐 밖으로의 확장은 별도 절에서 닫힘(closure)로만 도입된다.</p></li>
</ol>
<p>따라서 “기판”은 공리의 집합을 간단히 지칭하는 약어이며, 기판을 도입했다고 하여 새로운 근거 체계를 끌어오지 않는다.</p>
<h2 class="unnumbered" id="셀cell-정의-집계좌표계로서의-1차-객체">셀(Cell) 정의: 집계/좌표계로서의 1차 객체</h2>
<p>셀(Cell)은 VP의 배치를 기술하기 위해 도입되는 <strong>집계 단위</strong>이자 <strong>좌표계의 기준</strong>이다. 셀은 VP-A1~VP-A4를 위배하지 않는 범위에서만 정의된다. 셀 정의의 핵심은 다음 세 항목을 잠그는 것이다.</p>
<ol>
<li><p><strong>셀의 객체 귀속</strong>: 셀은 객체 <code>OBJ-CELL</code>로 고정하며, 셀은 VP 집합을 묶는 도메인 선택을 의미한다.</p></li>
<li><p><strong>셀 기하</strong>: 셀의 기하 타입(예: 큐브 셀 등)을 잠그고, 셀 대표 길이의 의미(모서리 길이/지름/반지름)를 단 하나로 잠근다.</p></li>
<li><p><strong>셀 대표 길이</strong>: 셀 대표 길이(예: <span class="math inline">\(D_{\mathrm{anch}}\)</span> 또는 그와 동등한 표기)는 canon_lock의 정준 입력으로 잠기며, 이후 절에서 값이나 의미가 재해석되지 않는다.</p></li>
</ol>
<p>셀은 “VP의 성질”이 아니라 “VP 배치를 기술하는 방식”이다. 즉, 셀은 공리의 근거가 아니라 <strong>공리로 제한된 세계를 기술하는 도구</strong>로서만 존재한다.</p>
<h2 data-number="5.1" id="vp-공리와-셀-정의의-결합-무엇이-먼저이고-무엇이-파생인가"><span class="header-section-number">5.1</span> 3.5 VP 공리와 셀 정의의 결합: 무엇이 먼저이고 무엇이 파생인가</h2>
<p>VP 공리 세트와 셀 정의의 결합 관계는 다음 우선순위로 고정한다.</p>
<ol>
<li><p><strong>1순위(VP 공리)</strong>: 허용 배치 집합(압축 불가, 비침투, 충만, 국소 갱신, 인접성)이 먼저 고정된다.</p></li>
<li><p><strong>2순위(셀 정의)</strong>: 셀은 허용 배치 집합 안에서 도메인을 선택하고, 집계와 좌표화를 수행한다.</p></li>
<li><p><strong>3순위(파생량)</strong>: 셀 내부에서 카운팅, 분포, 경로, 목, 사건 집계 등이 정의되고, 길이/시간/에너지/질량 등의 파생 유도가 진행된다.</p></li>
</ol>
<p>따라서 다음 형태의 소급은 금지된다.</p>
<ul>
<li><p>파생 결과(예: 어떤 수치)가 원하는 형태가 되도록 셀의 기하 의미(지름/반지름/모서리)를 바꾸는 소급.</p></li>
<li><p>파생 결과를 근거로 VP 공리(압축 불가, 비침투, 충만)를 부분적으로 완화하거나 재해석하는 소급.</p></li>
<li><p>인접성 정의(그래프 구성 규약)를 결과에 맞춰 교체하면서도 버전업을 수행하지 않는 소급.</p></li>
</ul>
<p>허용되는 변화는 버전업(새 lock_id)으로만 존재하며, 버전업 후에는 VP 공리<span class="math inline">\(\rightarrow\)</span>셀<span class="math inline">\(\rightarrow\)</span>파생량<span class="math inline">\(\rightarrow\)</span>Gate 판정을 전면 재수행해야 한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-13">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: VP 공리 세트(VP-A1~VP-A4) 및 기판(Stone) 레짐의 의미를 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: 셀(<code>OBJ-CELL</code>)의 객체 정의, 셀 기하 타입, 셀 대표 길이 의미를 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: VP 공리<span class="math inline">\(\rightarrow\)</span>인접성<span class="math inline">\(\rightarrow\)</span>셀<span class="math inline">\(\rightarrow\)</span>파생량의 우선순위(소급 금지)를 전역 규약으로 고정.</p></li>
<li><p>Gate: 기호 의미/지름-반지름/셀 기하 혼동은 G-SYM에서 즉시 <code>FAIL</code>로 판정됨.</p></li>
<li><p>Gate: lock_id 혼합 또는 소급 변경은 G-LOCK 및 G-NT에서 <code>FAIL</code>로 판정됨.</p></li>
</ul>
<h2 data-number="5.2" id="vp-공리최소-가정"><span class="header-section-number">5.2</span> 3.1 VP 공리(최소 가정)</h2>
<h3 data-number="5.2.1" id="공리-표기a와-정의-표기d"><span class="header-section-number">5.2.1</span> 3.1.1 공리 표기([A])와 정의 표기([D])</h3>
<p>본 절에서 <strong>[A]</strong>는 공리(Axiom)를 의미한다. 공리는 이론 전개에서 <em>더 이상 유도되지 않는</em> 출발점이며, 동일 버전 내부에서 변경되지 않는다.
본 절에서 <strong>[D]</strong>는 정의(Definition)를 의미한다. 정의는 이후 모든 문장의 의미를 고정하는 언어적 <span class="math inline">\(\cdot\)</span>형식적 약속이며, 정의가 바뀌면 동일 기호가 다른 대상을 가리키게 되므로 동일 버전 내부에서 변경되지 않는다.
본 절은 부피입자(VP) 세계의 최소 가정으로서 <strong>무한강성</strong>, <strong>충만</strong>, <strong>국소 규칙</strong>을 [A]로 고정하고, 이 공리들이 사용되는 필수 용어들을 [D]로 고정한다. 또한 본 절의 공리 세트에 <em>추가로 끼워 넣기 쉬운</em> 가정들을 금지 예시로 명시한다.</p>
<h3 data-number="5.2.2" id="d-프리미티브-객체와-기본-용어-정의"><span class="header-section-number">5.2.2</span> 3.1.2 [D] 프리미티브 객체와 기본 용어 정의</h3>
<h4 data-number="5.2.2.1" id="d-1-부피입자vp"><span class="header-section-number">5.2.2.1</span> [D-1] 부피입자(VP)</h4>
<p>부피입자(Volume Particle, VP)란 공간의 기본 구성 단위이다. VP는 “점”이나 “좌표”가 아니라 <strong>점유 영역</strong>을 갖는 객체로 정의한다. VP의 집합을 <span class="math inline">\(\mathcal{V}\)</span>로 표기한다.</p>
<h4 data-number="5.2.2.2" id="d-2-점유-영역과-배치configuration"><span class="header-section-number">5.2.2.2</span> [D-2] 점유 영역과 배치(configuration)</h4>
<p>도메인(아래 [D-4]) 내부에서 각 VP <span class="math inline">\(i\in\mathcal{V}\)</span>는 점유 영역 <span class="math inline">\(\Omega_i\)</span>를 가진다.
배치(configuration)란 <span class="math inline">\(\{\Omega_i\}_{i\in\mathcal{V}}\)</span>의 집합으로 정의한다. 배치는 “허용 배치”와 “비허용 배치”로 구분되며, 그 구분 기준은 [A]에 의해 결정된다.</p>
<h4 data-number="5.2.2.3" id="d-3-비침투non-overlap"><span class="header-section-number">5.2.2.3</span> [D-3] 비침투(non-overlap)</h4>
<p>서로 다른 VP <span class="math inline">\(i\neq j\)</span>에 대해 점유 영역의 교집합이 공집합인 성질을 비침투라 정의한다.
<span class="math display">\[\Omega_i \cap \Omega_j = \varnothing \quad (i\neq j).\]</span>
비침투는 “힘”이나 “운동 방정식”이 아니라 <strong>허용 배치의 조건</strong>으로만 사용된다.</p>
<h4 data-number="5.2.2.4" id="d-4-도메인domain과-경계boundary"><span class="header-section-number">5.2.2.4</span> [D-4] 도메인(domain)과 경계(boundary)</h4>
<p>도메인 <span class="math inline">\(\mathcal{D}\)</span>는 유도와 집계를 수행하는 유한한 관심 영역이다. 도메인의 선택은 절차적 선택이며, 도메인은 VP의 성질을 바꾸지 않는다.
경계(boundary)는 도메인 선택으로 도입되는 구분선이며, 경계의 성격(닫힘/열림/구동)은 공리가 아니라 프로토콜로 분류된다.</p>
<h4 data-number="5.2.2.5" id="d-5-충만full-packing"><span class="header-section-number">5.2.2.5</span> [D-5] 충만(Full Packing)</h4>
<p>도메인 내부에서 VP의 점유 영역들의 합집합이 도메인을 “채운다”는 성질을 충만이라 정의한다. 본 절에서 “채운다”는 말은 <strong>새로운 빈 공간 자유도</strong>를 도입하지 않는다는 의미로 고정한다. 즉, 도메인 내부의 빈 공간은 독립 객체가 아니라 <strong>배치와 인접성의 결과로 정의되는 구조량</strong>으로만 취급된다.</p>
<h4 data-number="5.2.2.6" id="d-6-접촉contact과-인접성adjacency"><span class="header-section-number">5.2.2.6</span> [D-6] 접촉(contact)과 인접성(adjacency)</h4>
<p>두 VP <span class="math inline">\(i,j\)</span>가 “접촉한다”는 것은, 사전 고정된 접촉 판정 규약(거리 기반, 표면 기반 등 중 하나)을 만족할 때로 정의한다. 접촉 판정 규약 자체는 <strong>정의 항목</strong>이며, 결과를 보고 바뀌지 않는다.
인접성은 접촉의 이산 기록이다. 인접성 그래프를 <span class="math inline">\(\mathcal{G}=(\mathcal{V},\mathcal{E})\)</span>로 정의하며, <span class="math inline">\((i,j)\in\mathcal{E}\)</span>는 <span class="math inline">\(i\)</span>와 <span class="math inline">\(j\)</span>가 인접함을 의미한다.</p>
<h4 data-number="5.2.2.7" id="d-7-국소-이웃neighborhood"><span class="header-section-number">5.2.2.7</span> [D-7] 국소 이웃(neighborhood)</h4>
<p>VP <span class="math inline">\(i\)</span>의 국소 이웃을 다음과 같이 정의한다.
<span class="math display">\[\mathcal{N}(i) := \{\, j\in\mathcal{V}\;|\;(i,j)\in\mathcal{E}\,\}.\]</span>
국소 이웃은 “어떤 정보가 국소인가”를 결정하는 최소 단위이다.</p>
<h4 data-number="5.2.2.8" id="d-8-국소-갱신local-update과-전역-갱신global-update"><span class="header-section-number">5.2.2.8</span> [D-8] 국소 갱신(local update)과 전역 갱신(global update)</h4>
<p>국소 갱신이란 특정 VP <span class="math inline">\(i\)</span>와 그 이웃 <span class="math inline">\(\mathcal{N}(i)\)</span>에만 의존하여 배치의 일부를 변경하는 연산을 말한다. 이를 연산자 <span class="math inline">\(\mathcal{U}_i\)</span>로 표기한다.
전역 갱신은 국소 갱신들의 유한한 합성으로 표현되는 갱신이다:
<span class="math display">\[\mathcal{U}_{\mathrm{global}}
=
\mathcal{U}_{i_K}\circ\cdots\circ\mathcal{U}_{i_2}\circ\mathcal{U}_{i_1}.\]</span>
여기서 합성 순서와 선택 규칙은 프로토콜로 고정되며, 결과를 보고 임의로 교체되지 않는다.</p>
<h3 data-number="5.2.3" id="a-vp-공리최소-가정-고정"><span class="header-section-number">5.2.3</span> 3.1.3 [A] VP 공리(최소 가정) 고정</h3>
<h3 data-number="5.2.4" id="a-1-무한강성stone-부피-불변과-비침투"><span class="header-section-number">5.2.4</span> [A-1] 무한강성(Stone): 부피 불변과 비침투</h3>
<p>무한강성 공리는 다음 두 문장으로 고정한다.</p>
<ol>
<li><p><strong>부피 불변</strong>: 모든 VP는 내부 부피가 변하지 않는다. 즉, 어떤 허용 배치에서든 각 VP의 점유 영역 <span class="math inline">\(\Omega_i\)</span>의 “부피 측도”는 동일하게 유지된다. 이 성질은 배치 변화, 갱신, 구동의 여부와 무관하게 유지된다.</p></li>
<li><p><strong>비침투</strong>: 모든 허용 배치에서 VP의 점유 영역들은 서로 겹치지 않는다([D-3]). 비침투는 결과를 보고 완화되지 않으며, 비침투를 위반하는 배치는 <strong>비허용</strong>으로 판정되어 유도/검증의 입력으로 사용될 수 없다.</p></li>
</ol>
<p>이 공리는 “강성”을 동역학적 법칙으로 도입하지 않는다. 무한강성은 허용 배치 집합을 제한하는 <strong>제약 공리</strong>이며, 이후 어떤 절에서도 “강성 값을 조정”하는 방식으로 해석되지 않는다.</p>
<h3 data-number="5.2.5" id="a-2-충만full-packing-빈-공간의-독립-자유도-금지"><span class="header-section-number">5.2.5</span> [A-2] 충만(Full Packing): 빈 공간의 독립 자유도 금지</h3>
<p>충만 공리는 다음으로 고정한다.</p>
<ol>
<li><p>도메인 <span class="math inline">\(\mathcal{D}\)</span> 내부에서 공간은 VP로 충만하게 점유된다([D-5]). 즉, 도메인 내부의 “비점유 공간”을 독립 객체(또는 독립 장)로 추가하지 않는다.</p></li>
<li><p>도메인 내부에서 나타나는 간격(gap), 결손(deficit), 목(throat)과 같은 구조는 “빈 공간 자체”가 아니라 <strong>VP 배치와 인접성으로부터 파생되는 구조량</strong>으로만 정의된다.</p></li>
</ol>
<p>따라서 충만 공리는 “공간은 VP + (추가 매질)”과 같은 혼합 세계를 금지한다. 추가 매질을 도입하면 충만의 의미가 바뀌므로, 동일 버전 내부에서 허용되지 않는다.</p>
<h3 data-number="5.2.6" id="a-3-국소-규칙local-rule-국소-이웃-의존-갱신"><span class="header-section-number">5.2.6</span> [A-3] 국소 규칙(Local Rule): 국소 이웃 의존 갱신</h3>
<p>국소 규칙 공리는 다음으로 고정한다.</p>
<ol>
<li><p><strong>국소성</strong>: 모든 변화(재배열, 완화, 구동, 전달)는 국소 이웃 <span class="math inline">\(\mathcal{N}(i)\)</span>에만 의존하는 국소 갱신들의 합성으로 표현된다([D-8]).</p></li>
<li><p><strong>허용 배치 보존</strong>: 국소 갱신 <span class="math inline">\(\mathcal{U}_i\)</span>는 [A-1]과 [A-2]를 위반하는 배치를 생성할 수 없다. 즉, 갱신은 비침투와 충만 제약을 보존하는 방식으로만 정의된다.</p></li>
<li><p><strong>규칙의 사전 고정</strong>: 국소 갱신의 선택 규칙(어떤 <span class="math inline">\(i\)</span>를 선택하는가), 합성 순서, 반복 조건, 종료 조건은 프로토콜로 고정되며, 산출 결과를 보고 바뀌지 않는다.</p></li>
</ol>
<p>국소 규칙 공리는 “전역에서 한 번에 결정되는 규칙”을 금지한다. 전역에서 한 번에 결정되는 규칙을 도입하면, 무엇이 국소 정보이고 무엇이 전역 정보인지가 소급적으로 조정될 수 있으므로 No-Tuning을 구조적으로 위반하게 된다.</p>
<h3 data-number="5.2.7" id="d-공리로부터-즉시-고정되는-귀결허용비허용의-판정"><span class="header-section-number">5.2.7</span> 3.1.4 [D] 공리로부터 즉시 고정되는 귀결(허용/비허용의 판정)</h3>
<p>본 절의 공리는 다음의 판정 기준을 즉시 제공한다.</p>
<ol>
<li><p>위반(부피 불변 또는 비침투 위반)은 즉시 <strong>비허용 배치</strong>이다.</p></li>
<li><p>위반(빈 공간을 독립 자유도로 추가하거나, gap/throat/deficit을 독립 객체로 취급)은 즉시 <strong>비허용 기술</strong>이다.</p></li>
<li><p>위반(국소 이웃에 의해 기술되지 않는 전역 갱신, 또는 규칙의 사후 변경)은 즉시 <strong>비허용 절차</strong>이다.</p></li>
</ol>
<p>위 판정은 “해석”으로 완화되지 않는다. 판정은 정의와 공리에 의해 자동으로 결정되며, 판정에 불복하는 방식으로 공리의 의미를 바꾸는 행위는 동일 버전 내부에서 금지된다.</p>
<h3 data-number="5.2.8" id="금지되는-추가-가정-예시짧게"><span class="header-section-number">5.2.8</span> 3.1.5 금지되는 추가 가정 예시(짧게)</h3>
<p>다음은 본 절의 최소 공리 세트에 <em>추가로</em> 끼워 넣기 쉬우나, 동일 버전 내부에서 금지되는 추가 가정의 예시이다. 아래 예시는 “무엇이 금지인지”를 명확히 하기 위한 최소 열거이며, 이 열거 자체가 새로운 공리를 도입하지 않는다.</p>
<ol>
<li><p><strong>거리만의 함수로 주어지는 보편 상호작용 가정</strong>: VP 쌍 <span class="math inline">\((i,j)\)</span>에 대해 어떤 보편 함수 <span class="math inline">\(f(d_{ij})\)</span>를 추가로 가정하여, 이후 모든 유도의 근거로 사용하는 행위.</p></li>
<li><p><strong>전역 연속장 도입 가정</strong>: 도메인 전역에 정의된 연속장(스칼라장/벡터장 등)을 1차 근거로 도입하여, VP 배치를 그 장의 부차적 결과로 취급하는 행위.</p></li>
<li><p><strong>평형/최적화 목표의 공리화</strong>: “항상 어떤 전역 목적함수가 최소/최대”라는 형태의 전역 원리를 추가로 가정하여, 국소 규칙을 그 목표에 맞게 소급 구성하는 행위.</p></li>
<li><p><strong>확률분포의 공리화</strong>: 초기조건이나 갱신 과정에서 특정 분포(예: 특정 형태의 잡음, 특정 형태의 무작위성)를 1차 공리로 고정하여, 이후 결과를 그 분포의 산물로 정당화하는 행위.</p></li>
<li><p><strong>등방성/균질성의 자동 공리화</strong>: “모든 방향에서 동일” 또는 “모든 위치에서 동일”을 기본 공리로 추가하여, 실제 배치/인접성에서 발생하는 방향성/결함성을 소거하는 행위.</p></li>
<li><p><strong>셀 기하의 암묵 공리화</strong>: 셀을 큐브/구 등 특정 기하로 두는 선택을 “공리”로 승격시키면서, 그 선택이 파생 결과에 미치는 영향을 분리 기록하지 않는 행위.</p></li>
</ol>
<p>위 항목 중 어느 하나라도 채택이 필요하면, 해당 가정은 공리로 무단 편입될 수 없으며, 반드시 (i) 정의 또는 닫힘의 형태로 명시되고, (ii) 적용 범위가 잠기며, (iii) Gate 판정 대상이 되어야 한다. 동일 버전 내부에서 “조용히 추가”하는 것은 금지된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-14">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: [A-1] 무한강성(부피 불변, 비침투), [A-2] 충만(빈 공간 독립 자유도 금지), [A-3] 국소 규칙(국소 이웃 의존 갱신) 공리 세트를 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: [D-1]~[D-8] 용어(점유 영역, 인접성 그래프, 국소 이웃, 국소/전역 갱신) 정의를 <code>canon_lock</code>에 고정.</p></li>
<li><p>Gate: 공리 위반 배치/절차는 <code>FAIL</code>로 판정되며 결론 자격을 즉시 상실함(공리 Gate, G-REG/G-NT 스택에 포함).</p></li>
<li><p>Gate: 정의/의미 충돌(오버로딩, 암묵 변환)은 G-SYM에서 즉시 <code>FAIL</code>로 판정됨.</p></li>
<li><p>Gate: 사후 추가 가정(전역 목적함수, 보편 상호작용, 연속장, 분포 공리화 등)은 No-Tuning 위반으로 <code>FAIL</code> 라벨을 부여함(G-NT).</p></li>
</ul>
<h2 data-number="5.3" id="재밍-격자와-point-j"><span class="header-section-number">5.3</span> 3.2 재밍 격자와 Point-J</h2>
<h3 data-number="5.3.1" id="강성-붕괴로서의-유동성fluidity-as-failure-rate"><span class="header-section-number">5.3.1</span> 3.2.1 강성 붕괴로서의 유동성(Fluidity as Failure Rate)</h3>
<p>본 이론에서 VP는 무한강성(Stone)을 가지므로, 입자 자체의 연성/점성을 새로운 공리로 추가하지 않는다.
관측되는 “유동성”은 물질의 고유 물성이 아니라, <strong>강성 네트워크(재밍 격자)의 붕괴와 복구 사건(event)</strong>의 통계로 정의한다.
즉, 유체/고체는 별개의 물질상(추가 공리)로 선언하지 않고, 동일한 VP 공리 위에서 <strong>강성 실패율</strong>로 판정한다.</p>
<h4 data-number="5.3.1.1" id="정의-유동성-지수-phi-failure-rate"><span class="header-section-number">5.3.1.1</span> 정의: 유동성 지수 <span class="math inline">\(\phi\)</span> (Failure rate)</h4>
<p>프로토콜 <span class="math inline">\(\mathcal{P}\)</span> 및 관측 시간창 <span class="math inline">\(W=[t_0,t_0+\Delta t]\)</span>를 고정한다(LOCK).
<span class="math inline">\(W\)</span>에서 총 갱신/관측 횟수를 <span class="math inline">\(N_{\mathrm{total}}(W)\)</span>로 두고, 각 단계 <span class="math inline">\(n=1,\ldots,N_{\mathrm{total}}(W)\)</span>마다 재밍 격자 <span class="math inline">\(\mathfrak{J}_n\)</span>을 구성한다.
이때 3.2.3.3에서 정의되는 강성 지시변수 <span class="math inline">\(\chi_{\mathrm{ST}}(\mathfrak{J}_n)\)</span>를 사용하여 “비강성(언재밍) 사건”의 총수를
<span class="math display">\[N_{\mathrm{unjam}}(W)
:=\sum_{n=1}^{N_{\mathrm{total}}(W)} \mathbf{1}\!\left[\chi_{\mathrm{ST}}\!\left(\mathfrak{J}_n\right)=0\right]
\label{eq:unjam_count_by_chiST}\]</span>
로 정의한다(사건 인덱스 <span class="math inline">\(n\)</span>과 <span class="math inline">\(\mathfrak{J}_n\)</span>의 구성 규약은 <span class="math inline">\(\mathcal{P}\)</span>에 포함되어야 한다).
이제 유동성 지수는 다음과 같이 정의한다.
<span class="math display">\[\phi(\mathcal{P};W):=\frac{N_{\mathrm{unjam}}(W)}{N_{\mathrm{total}}(W)}\in[0,1]
\label{eq:fluidity_phi_def}\]</span></p>
<p><strong>[LOCK]</strong> 본 <span class="math inline">\(\phi\)</span> 정의의 <strong>프로토콜/시간창/판정함수</strong> 보고 스키마는
<code>04_vp_whitepaper/LOCK/fluidity_phi_lock.json</code>에 봉인한다.</p>
<h4 data-number="5.3.1.2" id="해석-때리면-버티고-밀면-흐른다"><span class="header-section-number">5.3.1.2</span> 해석: “때리면 버티고, 밀면 흐른다”</h4>
<p><span class="math inline">\(\phi\)</span>는 관측 시간창과 구동률에 의존한다.
고속 충격처럼 <span class="math inline">\(\tau_{\rm obs}\)</span>가 짧으면 재배열이 억제되어 (Deborah-like <a data-reference="eq:deborah_like" data-reference-type="eqref" href="#eq:deborah_like">[eq:deborah_like]</a>에서 <span class="math inline">\(\mathrm{De}\gg 1\)</span>),
<span class="math inline">\(W\)</span>에서 <span class="math inline">\(\chi_{\mathrm{ST}}=1\)</span>이 유지되어 <span class="math inline">\(\phi\approx 0\)</span>인 “고체형” 응답이 나타난다.
반대로 저속 구동에서는 재배열/슬립 사건이 누적되어 (<span class="math inline">\(\mathrm{De}\ll 1\)</span>),
<span class="math inline">\(\chi_{\mathrm{ST}}=0\)</span>이 되는 사건이 반복되어 <span class="math inline">\(\phi\)</span>가 커지고 “유체형” 응답이 나타난다.
또한 큰 하중에서 항복 조건 <a data-reference="eq:unjamming_trigger" data-reference-type="eqref" href="#eq:unjamming_trigger">[eq:unjamming_trigger]</a>가 충족되면, <span class="math inline">\(\phi\)</span>가 급증하는 언재밍(채널 개방) 전이가 발생할 수 있다.</p>
<h4 data-number="5.3.1.3" id="목적과-전제"><span class="header-section-number">5.3.1.3</span> 목적과 전제</h4>
<p>본 절은 부피입자(VP) 배치를 <strong>인접성 구조</strong>로 외부화하여, 도메인 내부에서 “전역 전달(연결)”이 성립하는 상태와 성립하지 않는 상태를 <strong>레짐</strong>으로 구분하고, 그 경계를 <strong>Point-J</strong>로 정의한다.
본 절에서 사용하는 “강성/비강성”은 연속체 모형의 탄성계수와 같은 외부 개념을 근거로 하지 않는다. 본 절에서의 강성/비강성은 오직 <strong>(i) 인접성 그래프</strong>, <strong>(ii) 도메인 경계 집합</strong>, <strong>(iii) 사전 등록된 판정 규약</strong>으로만 정의되는 <strong>구조적 레짐</strong>이다.</p>
<h3 data-number="5.3.2" id="재밍-격자jamming-lattice의-정의"><span class="header-section-number">5.3.2</span> 3.2.2 재밍 격자(jamming lattice)의 정의</h3>
<h4 data-number="5.3.2.1" id="도메인과-경계-집합"><span class="header-section-number">5.3.2.1</span> 3.2.2.1 도메인과 경계 집합</h4>
<p>도메인 <span class="math inline">\(\mathcal{D}\)</span>는 셀 또는 셀들의 합으로 구성된 유한 영역으로 정의한다. 도메인에는 “두 개의 대향 경계 집합”을 지정한다.
<span class="math display">\[\partial\mathcal{D}^{-},\ \partial\mathcal{D}^{+}\subset \partial\mathcal{D},
\qquad
\partial\mathcal{D}^{-}\cap \partial\mathcal{D}^{+}=\varnothing.
\label{eq:domain_boundaries}\]</span>
<span class="math inline">\(\partial\mathcal{D}^{-}\)</span>와 <span class="math inline">\(\partial\mathcal{D}^{+}\)</span>는 도메인의 경계 <span class="math inline">\(\partial\mathcal{D}\)</span> 위에서 선택된 두 부분집합이며, 전역 전달 여부를 판정하는 기준으로만 사용된다. 경계 집합의 선택 규칙(어떤 면을 <span class="math inline">\(\partial\mathcal{D}^{-}\)</span>로 둘지 등)은 <code>analysis_lock</code>에 잠긴 절차로 고정된다.</p>
<h4 data-number="5.3.2.2" id="접촉-판정과-접촉-그래프"><span class="header-section-number">5.3.2.2</span> 3.2.2.2 접촉 판정과 접촉 그래프</h4>
<p>VP 집합을 <span class="math inline">\(\mathcal{V}\)</span>라 하고, 각 VP를 <span class="math inline">\(i\in\mathcal{V}\)</span>로 표기한다. 두 VP <span class="math inline">\(i,j\)</span>에 대해 “접촉” 판정 함수 <span class="math inline">\(C(i,j)\)</span>를 다음과 같이 정의한다.
<span class="math display">\[C(i,j)\in\{0,1\},
\qquad
C(i,j)=1\ \Longleftrightarrow\ i \text{와 } j \text{는 사전 등록된 접촉 규약을 만족한다}.
\label{eq:contact_predicate}\]</span>
접촉 규약은 (i) 거리 기반, (ii) 표면 기반, (iii) 완화 후 지속 접촉 기반 등 중 하나로 정의될 수 있으나, 어떤 규약을 사용하든 <strong>규약 자체가 정의로 잠겨야 하며</strong> 결과를 본 뒤 교체될 수 없다.</p>
<p>접촉 그래프(접촉 네트워크) <span class="math inline">\(\mathcal{G}_c\)</span>를 다음과 같이 정의한다.
<span class="math display">\[\mathcal{G}_c := (\mathcal{V}, \mathcal{E}_c),
\qquad
\mathcal{E}_c := \{(i,j)\ |\ i\neq j,\ C(i,j)=1\}.
\label{eq:contact_graph}\]</span>
접촉 그래프는 배치(configuration)의 이산 외부화이며, 이후 레짐 판정은 <span class="math inline">\(\mathcal{G}_c\)</span>를 기반으로 수행된다.</p>
<h4 data-number="5.3.2.3" id="도메인-경계에-접하는-노드-집합"><span class="header-section-number">5.3.2.3</span> 3.2.2.3 도메인 경계에 접하는 노드 집합</h4>
<p>경계 집합 <span class="math inline">\(\partial\mathcal{D}^{-}, \partial\mathcal{D}^{+}\)</span>에 접하는 VP 노드 집합을 다음과 같이 정의한다.
<span class="math display">\[\mathcal{V}^{-} := \{\, i\in\mathcal{V}\ |\ i \text{가 } \partial\mathcal{D}^{-}\text{에 접한다}\,\},
\qquad
\mathcal{V}^{+} := \{\, i\in\mathcal{V}\ |\ i \text{가 } \partial\mathcal{D}^{+}\text{에 접한다}\,\}.
\label{eq:boundary_nodes}\]</span>
“접한다”의 판정(예: VP 점유 영역이 경계를 교차하는지, 경계로부터 임계 거리 이내인지 등)은 <code>analysis_lock</code>에 잠긴 규약으로 고정한다. <span class="math inline">\(\mathcal{V}^{-}\)</span>와 <span class="math inline">\(\mathcal{V}^{+}\)</span>는 전역 전달의 출발/도착 노드 집합으로 사용된다.</p>
<h4 data-number="5.3.2.4" id="재밍-격자"><span class="header-section-number">5.3.2.4</span> 3.2.2.4 재밍 격자</h4>
<p>본 절에서 “재밍 격자”는 다음 네 요소의 묶음으로 정의한다.
<span class="math display">\[\mathfrak{J}
:=
\bigl(\mathcal{D},\ \mathcal{G}_c,\ \mathcal{V}^{-},\ \mathcal{V}^{+}\bigr).
\label{eq:jamming_lattice}\]</span>
재밍 격자 <span class="math inline">\(\mathfrak{J}\)</span>는 (i) 도메인, (ii) 접촉 그래프, (iii) 대향 경계에 접하는 노드 집합을 동시에 포함한다. 강성/비강성 레짐 및 Point-J는 <span class="math inline">\(\mathfrak{J}\)</span> 위에서만 정의된다.</p>
<h3 data-number="5.3.3" id="강성비강성-레짐의-정의"><span class="header-section-number">5.3.3</span> 3.2.3 강성/비강성 레짐의 정의</h3>
<h4 data-number="5.3.3.1" id="전역-전달과-스패닝의-정의"><span class="header-section-number">5.3.3.1</span> 3.2.3.1 전역 전달과 “스패닝”의 정의</h4>
<p>접촉 그래프 <span class="math inline">\(\mathcal{G}_c\)</span>에서 <span class="math inline">\(\mathcal{V}^{-}\)</span>의 어떤 노드에서 출발하여 <span class="math inline">\(\mathcal{V}^{+}\)</span>의 어떤 노드에 도달하는 경로(path)가 존재하면, 이를 “전역 전달(스패닝 연결)”이 성립한다고 정의한다. 이를 지시변수로 다음과 같이 정의한다.
<span class="math display">\[\chi_{\mathrm{span}}(\mathfrak{J})
:=
\begin{cases}
1, &amp; \exists\ i\in\mathcal{V}^{-},\ \exists\ j\in\mathcal{V}^{+}\ \text{s.t.}\ i\leadsto j\ \text{in }\mathcal{G}_c,\\
0, &amp; \text{otherwise}.
\end{cases}
\label{eq:chi_span}\]</span>
여기서 <span class="math inline">\(i\leadsto j\)</span>는 <span class="math inline">\(\mathcal{G}_c\)</span> 상에서 <span class="math inline">\(i\)</span>에서 <span class="math inline">\(j\)</span>로의 경로가 존재함을 뜻한다.</p>
<h4 data-number="5.3.3.2" id="병목-민감도단일-절단와-강성-백본의-정의"><span class="header-section-number">5.3.3.2</span> 3.2.3.2 병목 민감도(단일 절단)와 “강성 백본”의 정의</h4>
<p>스패닝 연결 <span class="math inline">\(\chi_{\mathrm{span}}=1\)</span>만으로는 “강성”을 정의하지 않는다. 스패닝 연결이 단 하나의 간선 또는 단 하나의 노드에 의해 유지되는 경우(사슬형 연결)는 국소 결손에 의해 즉시 붕괴할 수 있으며, 본 절에서는 이를 강성으로 취급하지 않는다.
따라서 “병목 민감도”를 정의한다. 두 경계 노드 집합 <span class="math inline">\(\mathcal{V}^{-},\mathcal{V}^{+}\)</span> 사이의 최소 절단 크기(min-cut)를 다음과 같이 정의한다.
<span class="math display">\[\kappa_{\min}(\mathfrak{J})
:=
\min\bigl\{\, |\mathcal{C}|\ \big|\ \mathcal{C}\subseteq \mathcal{E}_c,\
\text{$\mathcal{E}_c\setminus\mathcal{C}$에서 }\mathcal{V}^{-}\text{와 }\mathcal{V}^{+}\text{가 분리된다}\,\bigr\}.
\label{eq:kappa_min}\]</span>
<span class="math inline">\(\kappa_{\min}\)</span>은 “몇 개의 간선을 끊으면 전역 전달이 끊기는가”를 나타내는 구조 지표이다. <span class="math inline">\(\kappa_{\min}\)</span>의 계산 알고리즘(정확/근사, 가중/비가중 등)은 <code>analysis_lock</code>에 잠긴다.</p>
<p>강성 백본(backbone) <span class="math inline">\(\mathcal{B}\)</span>는 다음 조건을 만족하는 접촉 그래프의 부분그래프(subgraph)로 정의한다.
<span class="math display">\[\mathcal{B} := (\mathcal{V}_B, \mathcal{E}_B)\subseteq (\mathcal{V},\mathcal{E}_c)
\label{eq:backbone_def}\]</span>
이며,</p>
<ol>
<li><p>(<strong>스패닝</strong>) <span class="math inline">\(\mathcal{B}\)</span>에서 <span class="math inline">\(\mathcal{V}^{-}\cap\mathcal{V}_B\)</span>와 <span class="math inline">\(\mathcal{V}^{+}\cap\mathcal{V}_B\)</span>가 경로로 연결된다.</p></li>
<li><p>(<strong>병목 하한</strong>) <span class="math inline">\(\mathcal{B}\)</span>에 대해 정의된 <span class="math inline">\(\kappa_{\min}(\mathcal{B})\)</span>가 사전 등록된 정수 하한 <span class="math inline">\(\kappa_{\mathrm{ST}}\)</span>를 만족한다:
<span class="math display">\[\kappa_{\min}(\mathcal{B}) \ge \kappa_{\mathrm{ST}}.
  \label{eq:kappa_threshold}\]</span></p></li>
<li><p>(<strong>최대성</strong>) 위 두 조건을 만족하는 부분그래프들 중에서, 사전 등록된 “최대성 규약”(예: 간선 수 최대, 노드 수 최대, 또는 특정 점수 최대)을 만족하는 것을 <span class="math inline">\(\mathcal{B}\)</span>로 선택한다.</p></li>
</ol>
<p><span class="math inline">\(\kappa_{\mathrm{ST}}\)</span>와 최대성 규약은 <code>analysis_lock</code>에 잠긴다. 본 절에서는 정의만을 고정하며, 특정 값(예: <span class="math inline">\(\kappa_{\mathrm{ST}}=2\)</span> 등)을 공리로 강제하지 않는다.</p>
<h4 data-number="5.3.3.3" id="강성-레짐stiff-regime의-정의"><span class="header-section-number">5.3.3.3</span> 3.2.3.3 강성 레짐(stiff regime)의 정의</h4>
<p>강성 레짐은 다음 지시변수로 정의한다.
<span class="math display">\[\chi_{\mathrm{ST}}(\mathfrak{J})
:=
\begin{cases}
1, &amp; \exists\ \mathcal{B}\ \text{s.t.}\ \mathcal{B}\ \text{가 \eqref{eq:backbone_def}--\eqref{eq:kappa_threshold}를 만족한다},\\
0, &amp; \text{otherwise}.
\end{cases}
\label{eq:chi_ST}\]</span>
즉, <strong>강성 레짐</strong>은 <span class="math inline">\(\chi_{\mathrm{ST}}(\mathfrak{J})=1\)</span>인 재밍 격자의 집합으로 정의한다. 강성 레짐의 핵심은 “전역 전달의 존재”뿐 아니라 “병목 하한을 만족하는 백본의 존재”이다.</p>
<h4 data-number="5.3.3.4" id="비강성-레짐non-stiff-regime의-정의"><span class="header-section-number">5.3.3.4</span> 3.2.3.4 비강성 레짐(non-stiff regime)의 정의</h4>
<p>비강성 레짐은 강성 레짐의 여집합으로 정의한다.
<span class="math display">\[\chi_{\mathrm{ST}}(\mathfrak{J})=0
\quad\Longleftrightarrow\quad
\text{비강성 레짐}.
\label{eq:nonstiff_def}\]</span>
비강성 레짐은 다음 두 경우를 포함한다.</p>
<ol>
<li><p>(<strong>비스패닝</strong>) <span class="math inline">\(\chi_{\mathrm{span}}(\mathfrak{J})=0\)</span>인 경우: 전역 전달 경로 자체가 존재하지 않는다.</p></li>
<li><p>(<strong>병목 붕괴</strong>) <span class="math inline">\(\chi_{\mathrm{span}}(\mathfrak{J})=1\)</span>이지만, 어떤 부분그래프에서도 <a data-reference="eq:kappa_threshold" data-reference-type="eqref" href="#eq:kappa_threshold">[eq:kappa_threshold]</a>의 병목 하한을 만족하지 못하는 경우: 전역 전달은 있으나 구조적으로 취약하여 “강성 백본”이 성립하지 않는다.</p></li>
</ol>
<p>따라서 비강성 레짐은 “연결이 전혀 없음”과 “연결은 있으나 병목 하한이 없음”을 함께 포함하는 레짐으로 고정한다.</p>
<h3 data-number="5.3.4" id="스위치-관측량정의만"><span class="header-section-number">5.3.4</span> 3.2.4 스위치 관측량(정의만)</h3>
<p>본 절에서 “스위치 관측량”은 강성/비강성 레짐의 전이를 판정하기 위해 정의되는 관측량(또는 계산량)이다. 스위치 관측량은 다음 세 종류로 정의한다.</p>
<h4 data-number="5.3.4.1" id="차-스위치-레짐-지시변수"><span class="header-section-number">5.3.4.1</span> 3.2.4.1 1차 스위치: 레짐 지시변수</h4>
<p>1차 스위치 관측량은 강성 레짐 지시변수 <span class="math inline">\(\chi_{\mathrm{ST}}\)</span>이다(식 <a data-reference="eq:chi_ST" data-reference-type="eqref" href="#eq:chi_ST">[eq:chi_ST]</a>).
<span class="math inline">\(\chi_{\mathrm{ST}}=0\)</span>이면 비강성 레짐, <span class="math inline">\(\chi_{\mathrm{ST}}=1\)</span>이면 강성 레짐으로 분류한다. 이 분류는 정의이며, 수치적 근사나 해석으로 완화되지 않는다.</p>
<h4 data-number="5.3.4.2" id="차-스위치-최소-절단-크기"><span class="header-section-number">5.3.4.2</span> 3.2.4.2 2차 스위치: 최소 절단 크기</h4>
<p>2차 스위치 관측량은 최소 절단 크기 <span class="math inline">\(\kappa_{\min}\)</span>이다(식 <a data-reference="eq:kappa_min" data-reference-type="eqref" href="#eq:kappa_min">[eq:kappa_min]</a>).
<span class="math inline">\(\kappa_{\min}\)</span>은 정수이며, 값이 클수록 경계 간 전달이 단일 간선 제거에 덜 민감함을 의미한다. 본 절은 <span class="math inline">\(\kappa_{\min}\)</span>의 물리적 해석을 추가로 도입하지 않고, 오직 구조 지표로서만 정의한다.</p>
<h4 data-number="5.3.4.3" id="차-스위치-백본-존재-및-백본-크기"><span class="header-section-number">5.3.4.3</span> 3.2.4.3 3차 스위치: 백본 존재 및 백본 크기</h4>
<p>3차 스위치 관측량은 강성 백본 <span class="math inline">\(\mathcal{B}\)</span>의 존재 여부 및 크기이다.
<span class="math display">\[N_B := |\mathcal{V}_B|,
\qquad
E_B := |\mathcal{E}_B|.
\label{eq:backbone_size}\]</span>
<span class="math inline">\(\mathcal{B}\)</span>의 선택 규약이 잠긴 경우에만 <span class="math inline">\(N_B, E_B\)</span>는 비교 가능한 관측량이 된다. 선택 규약이 바뀌면 동일한 배치에서도 백본이 달라질 수 있으므로, 선택 규약은 <code>analysis_lock</code>에 잠겨야 한다.</p>
<h3 data-number="5.3.5" id="point-j의-정의"><span class="header-section-number">5.3.5</span> 3.2.5 Point-J의 정의</h3>
<p>Point-J는 “조절변수(control parameter)를 변화시켰을 때 강성 스위치가 전이하는 경계”로 정의한다. 이를 위해 조절변수 <span class="math inline">\(u\)</span>와 배치의 족 <span class="math inline">\(\{\mathfrak{J}(u)\}\)</span>를 정의한다.</p>
<h4 data-number="5.3.5.1" id="조절변수-u의-정의예시-집합"><span class="header-section-number">5.3.5.1</span> 3.2.5.1 조절변수 <span class="math inline">\(u\)</span>의 정의(예시 집합)</h4>
<p>조절변수 <span class="math inline">\(u\)</span>는 재밍 격자 <span class="math inline">\(\mathfrak{J}\)</span>의 구조를 단조적으로 변화시키는 내부 지표로 정의된다. 본 문서에서 허용되는 조절변수의 예시는 다음과 같다(택일 또는 병행 가능).</p>
<ol>
<li><p><strong>접촉 밀도 지표</strong>:
<span class="math display">\[\bar{z} := \frac{2|\mathcal{E}_c|}{|\mathcal{V}|},
  \label{eq:mean_degree}\]</span>
즉 평균 차수(평균 접촉 수)를 조절변수로 둔다.</p></li>
<li><p><strong>임계목 기반 지표</strong>: 목(throat) 객체가 정의된 경우, 임계목 관련 지표(예: 임계목 두께의 대표값, 임계목의 개수, 병목 연쇄 지표 등)를 <span class="math inline">\(u\)</span>로 둔다. 단, 목 정의와 추정기는 <code>analysis_lock</code>에 사전 등록되어야 한다.</p></li>
<li><p><strong>점유 기반 지표</strong>: 셀 정의가 잠긴 경우, 도메인 내부 점유 집계(카운팅)로부터 얻어지는 단조 지표를 <span class="math inline">\(u\)</span>로 둔다. 점유 지표의 정의(무엇을 카운트하는가, 어떤 셀 기하를 쓰는가)는 <code>canon_lock</code>과 <code>analysis_lock</code>에 잠겨야 한다.</p></li>
</ol>
<p>본 절은 <span class="math inline">\(u\)</span>의 특정 선택을 공리로 강제하지 않는다. 선택된 <span class="math inline">\(u\)</span>는 반드시 <code>analysis_lock</code>에 잠기며, 결과를 본 뒤 교체될 수 없다.</p>
<h4 data-number="5.3.5.2" id="point-j전이점의-정의"><span class="header-section-number">5.3.5.2</span> 3.2.5.2 Point-J(전이점)의 정의</h4>
<p>조절변수 <span class="math inline">\(u\)</span>에 대해 재밍 격자의 족 <span class="math inline">\(\{\mathfrak{J}(u)\}\)</span>가 주어졌다고 하자. Point-J는 다음으로 정의한다.
<span class="math display">\[u_J := \inf\{\, u\ |\ \chi_{\mathrm{ST}}(\mathfrak{J}(u))=1\,\}.
\label{eq:pointJ_def}\]</span>
즉, <span class="math inline">\(\chi_{\mathrm{ST}}\)</span>가 <span class="math inline">\(0\)</span>에서 <span class="math inline">\(1\)</span>로 전이하는 최소의 <span class="math inline">\(u\)</span>를 Point-J의 위치로 정의한다.
실제 절차에서 <span class="math inline">\(u\)</span>가 이산 샘플로만 주어지는 경우(예: <span class="math inline">\(u_1&lt;u_2&lt;\cdots&lt;u_K\)</span>), Point-J는 다음 이산 정의로 잠긴다.
<span class="math display">\[u_J := u_{k^\ast},
\qquad
k^\ast := \min\{\, k\ |\ \chi_{\mathrm{ST}}(\mathfrak{J}(u_k))=1\,\}.
\label{eq:pointJ_discrete}\]</span>
이때 “최초 전이”를 어떻게 판정할지(예: 반복 실행에서 안정적으로 <span class="math inline">\(1\)</span>인지, 또는 일정 비율 이상 <span class="math inline">\(1\)</span>인지 등)는 <code>analysis_lock</code>의 Gate 규약으로 잠겨야 하며, 결과를 본 뒤 수정될 수 없다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-15">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 접촉 판정 <span class="math inline">\(C(i,j)\)</span>, 접촉 그래프 <span class="math inline">\(\mathcal{G}_c\)</span>, 경계 집합 <span class="math inline">\(\partial\mathcal{D}^{\pm}\)</span> 및 경계 노드 <span class="math inline">\(\mathcal{V}^{\pm}\)</span> 정의를 <code>canon_lock</code>/<code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 강성 백본 정의(최소 절단 <span class="math inline">\(\kappa_{\min}\)</span>, 하한 <span class="math inline">\(\kappa_{\mathrm{ST}}\)</span>, 최대성 규약) 및 스위치 관측량 <span class="math inline">\(\chi_{\mathrm{ST}}\)</span>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 레짐 판정은 구조 Gate(G-STR)와 레짐 Gate(G-REG)의 PASS를 필요조건으로 연결(정의/경계/프로토콜 불일치 시 <code>FAIL</code>).</p></li>
<li><p>Gate: 접촉/경계/기호 의미 충돌은 G-SYM에서 즉시 <code>FAIL</code>; 사후 변경은 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: Point-J 판정 절차(이산 정의, 반복 안정 조건, 문턱)는 gate_lock에 사전 등록되어야 하며, 미등록 또는 변경 시 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
</ul>
<h2 data-number="5.4" id="양자셀anchor-cell-정의"><span class="header-section-number">5.4</span> 3.3 양자셀(Anchor Cell) 정의</h2>
<h3 data-number="5.4.1" id="양자셀의-지위정준-도메인"><span class="header-section-number">5.4.1</span> 3.3.1 양자셀의 지위(정준 도메인)</h3>
<p>양자셀(Anchor Cell)은 VP 집합의 배치를 <em>집계</em>하고 <em>좌표화</em>하기 위해 고정되는 최소 도메인이다. 양자셀은 다음 세 항목을 동시에 잠금(LOCK)할 때에만 정의가 성립한다.</p>
<ol>
<li><p>셀 객체의 식별(<code>OBJ-CELL</code>)과 셀 기하 타입(<code>CELL-CUBE</code> 또는 <code>CELL-SPHERE-VIS</code>).</p></li>
<li><p>셀 대표 길이 기호 <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 의미(지름/반지름/모서리 등)와 단위 차원(길이).</p></li>
<li><p>셀 내부 좌표계의 범위(도메인 경계)와 포함/배제 규칙(카운팅 규칙 포함).</p></li>
</ol>
<p>본 절에서 양자셀의 정준 기하는 <code>CELL-CUBE</code>로 고정하고, <code>CELL-SPHERE-VIS</code>는 시각화 목적의 변환으로만 허용한다. 시각화 변환은 <strong>정준 유도</strong>에 직접 참여할 수 없으며, 참여시키려면 별도 LOCK(버전업)과 Gate 판정을 요구한다.</p>
<h3 data-number="5.4.2" id="정준-양자셀-큐브cell-cube"><span class="header-section-number">5.4.2</span> 3.3.2 정준 양자셀: 큐브(<code>CELL-CUBE</code>)</h3>
<p>정준 양자셀의 기하 타입을 다음으로 고정한다.
<span class="math display">\[\mathrm{cell\_geometry} := \texttt{CELL-CUBE}.
\label{eq:cell_geom_cube}\]</span>
정준 양자셀의 대표 길이 <span class="math inline">\(D_{\mathrm{anch}}\)</span>는 <code>CELL-CUBE</code>에서 <strong>모서리 길이(edge length)</strong>로 정의한다. 즉,
<span class="math display">\[\mathrm{geometry\_meaning}(D_{\mathrm{anch}}) := \texttt{edge}.
\label{eq:Danch_edge_lock}\]</span>
정준 양자셀 도메인 <span class="math inline">\(\mathcal{D}_{\square}\)</span>를 다음과 같이 정의한다.
<span class="math display">\[\mathcal{D}_{\square}
:=
\left\{\mathbf{x}\in\mathbb{R}^3\ \big|\ 0\le x&lt; D_{\mathrm{anch}},\ 0\le y&lt; D_{\mathrm{anch}},\ 0\le z&lt; D_{\mathrm{anch}}\right\}.
\label{eq:anchor_cube_domain}\]</span>
정준 양자셀의 부피는 기하학적 정의로서
<span class="math display">\[V_{\square} := |\mathcal{D}_{\square}| = D_{\mathrm{anch}}^{3}
\label{eq:Vcube}\]</span>
로 고정한다. <span class="math inline">\(V_{\square}\)</span>는 정준 정의의 파생량이며, <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 의미가 잠기지 않으면 <span class="math inline">\(V_{\square}\)</span>는 사용 불가이다.</p>
<h3 data-number="5.4.3" id="r_0-d_mathrmanch2의-고정반길이-스케일"><span class="header-section-number">5.4.3</span> 3.3.3 <span class="math inline">\(r_0 := D_{\mathrm{anch}}/2\)</span>의 고정(반길이 스케일)</h3>
<p>정준 양자셀 대표 길이로부터 반길이 스케일 <span class="math inline">\(r_0\)</span>를 다음 <strong>파생 정의</strong>로 고정한다.
<span class="math display">\[r_0 := \frac{D_{\mathrm{anch}}}{2}.
\label{eq:r0_def}\]</span>
여기서 <span class="math inline">\(r_0\)</span>의 의미는 다음으로 잠긴다.</p>
<ol>
<li><p><span class="math inline">\(r_0\)</span>는 <strong>정준 양자셀 모서리 길이의 절반</strong>이며, <strong>반지름(radius)</strong>이라는 기하 의미를 자동으로 갖지 않는다.</p></li>
<li><p><span class="math inline">\(r_0\)</span>는 길이 차원(<code>L</code>)으로 잠기며, 단위 표기는 <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 단위 표기와 동일 계열로 잠긴다.</p></li>
<li><p><span class="math inline">\(r_0\)</span>는 정준 유도에서 자유롭게 사용 가능한 파생 길이 스케일이지만, 어떤 절에서도 <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 의미(모서리 길이)를 바꾸는 대체물로 사용되지 않는다.</p></li>
</ol>
<p>따라서 “<span class="math inline">\(r_0\)</span>는 구의 반지름이다”와 같은 문장은 <strong>별도의 시각화 변환이 잠겼을 때에만</strong> 제한적으로 성립한다(아래 3.3.4). 잠기지 않은 상태에서 <span class="math inline">\(r_0\)</span>를 구의 반지름으로 사용하는 것은 정의 충돌이며 즉시 <code>FAIL</code>이다.</p>
<h3 data-number="5.4.4" id="시각화-양자셀-구cell-sphere-vis"><span class="header-section-number">5.4.4</span> 3.3.4 시각화 양자셀: 구(<code>CELL-SPHERE-VIS</code>)</h3>
<p><code>CELL-SPHERE-VIS</code>는 정준 셀(<code>CELL-CUBE</code>)을 <strong>시각화 목적</strong>으로만 구형 도메인으로 대응시키는 변환 규칙이다. 시각화 셀은 정준 셀을 <em>대체</em>하지 않으며, 정준 유도에서 사용되는 셀은 항상 <a data-reference="eq:cell_geom_cube" data-reference-type="eqref" href="#eq:cell_geom_cube">[eq:cell_geom_cube]</a>의 큐브 도메인이다.</p>
<h4 data-number="5.4.4.1" id="시각화-모드의-잠금이산-선택"><span class="header-section-number">5.4.4.1</span> 3.3.4.1 시각화 모드의 잠금(이산 선택)</h4>
<p>시각화 변환은 결과를 보고 임의 조정될 수 없으므로, 시각화 모드는 다음 이산 집합 중 <strong>하나</strong>로만 선택하여 <code>analysis_lock</code>에 잠근다.
<span class="math display">\[\mathrm{vis\_mode}\in\left\{\texttt{VIS-EQUAL-DIAMETER},\ \texttt{VIS-EQUAL-VOLUME}\right\}.
\label{eq:vis_mode}\]</span>
두 모드는 서로 다른 구형 도메인을 생성하며, 동일 절/동일 산출물에서 혼합 사용할 수 없다.</p>
<h4 data-number="5.4.4.2" id="시각화-구-도메인의-표준-정의"><span class="header-section-number">5.4.4.2</span> 3.3.4.2 시각화 구 도메인의 표준 정의</h4>
<p>시각화 구 도메인을 다음과 같이 정의한다.
<span class="math display">\[\mathcal{D}_{\circ}(r_{\mathrm{vis}})
:=
\left\{\mathbf{x}\in\mathbb{R}^3\ \big|\ \|\mathbf{x}-\mathbf{x}_c\| &lt; r_{\mathrm{vis}}\right\},
\label{eq:anchor_sphere_domain}\]</span>
여기서 <span class="math inline">\(\mathbf{x}_c\)</span>는 시각화 중심이며(기하 중심), <span class="math inline">\(r_{\mathrm{vis}}\)</span>는 시각화 구의 반지름이다. <span class="math inline">\(\mathbf{x}_c\)</span>의 선택은 시각화 배치의 좌표 원점 선택이며, 정준 유도에 영향을 주지 않는다. 시각화 반지름 <span class="math inline">\(r_{\mathrm{vis}}\)</span>는 아래 변환 규칙으로부터만 정의된다.</p>
<h4 data-number="5.4.4.3" id="변환-규칙-1-동일-지름-모드vis-equal-diameter"><span class="header-section-number">5.4.4.3</span> 3.3.4.3 변환 규칙 1: 동일 지름 모드(<code>VIS-EQUAL-DIAMETER</code>)</h4>
<p>동일 지름 모드는 정준 셀 대표 길이 <span class="math inline">\(D_{\mathrm{anch}}\)</span>를 시각화 구의 <strong>지름</strong>으로 대응시키는 규칙이다. 이 모드에서 다음을 잠근다.
<span class="math display">\[D_{\mathrm{vis}} := D_{\mathrm{anch}},
\qquad
r_{\mathrm{vis}} := \frac{D_{\mathrm{vis}}}{2}.
\label{eq:vis_equal_diameter}\]</span>
식 <a data-reference="eq:vis_equal_diameter" data-reference-type="eqref" href="#eq:vis_equal_diameter">[eq:vis_equal_diameter]</a>로부터 즉시
<span class="math display">\[r_{\mathrm{vis}} = \frac{D_{\mathrm{anch}}}{2} = r_0
\label{eq:rvis_equals_r0}\]</span>
가 성립한다. 단, 이는 <strong>시각화 모드가 <code>VIS-EQUAL-DIAMETER</code>로 잠겼을 때에만</strong> 허용되는 등식이다. 이 모드가 잠기지 않은 상태에서 <span class="math inline">\(r_0\)</span>를 구의 반지름으로 동일시하는 것은 금지된다.</p>
<h4 data-number="5.4.4.4" id="변환-규칙-2-동일-부피-모드vis-equal-volume"><span class="header-section-number">5.4.4.4</span> 3.3.4.4 변환 규칙 2: 동일 부피 모드(<code>VIS-EQUAL-VOLUME</code>)</h4>
<p>동일 부피 모드는 시각화 구의 부피가 정준 큐브 셀의 부피와 같도록 대응시키는 규칙이다. 이 모드에서 다음을 잠근다.
<span class="math display">\[V_{\circ} := |\mathcal{D}_{\circ}(r_{\mathrm{vis}})| = \frac{4}{3}\pi r_{\mathrm{vis}}^{3},
\qquad
V_{\circ} \equiv V_{\square} = D_{\mathrm{anch}}^{3}.
\label{eq:vis_equal_volume_condition}\]</span>
따라서 시각화 반지름은 다음으로 고정된다.
<span class="math display">\[r_{\mathrm{vis}}
:=
\left(\frac{3}{4\pi}\right)^{\!1/3} D_{\mathrm{anch}}.
\label{eq:rvis_equal_volume}\]</span>
이 모드에서 <span class="math inline">\(r_0=D_{\mathrm{anch}}/2\)</span>는 여전히 <strong>정준 반길이 스케일</strong>로만 존재하며, <span class="math inline">\(r_{\mathrm{vis}}\)</span>와 동일시될 수 없다. 즉,
<span class="math display">\[r_{\mathrm{vis}} \neq r_0
\quad\text{(일반적으로 성립하며, 동일시 금지)}.
\label{eq:rvis_not_r0_rule}\]</span>
동일 부피 모드에서 구의 지름을 사용해야 하면 별도 파생 기호로
<span class="math display">\[D_{\mathrm{vis}} := 2 r_{\mathrm{vis}}
\label{eq:Dvis_from_rvis}\]</span>
를 도입하여 사용한다. 이때 <span class="math inline">\(D_{\mathrm{vis}}\)</span>는 <span class="math inline">\(D_{\mathrm{anch}}\)</span>와 다른 기호이며, 동일 철자 또는 동일 기호로 혼용될 수 없다.</p>
<h3 data-number="5.4.5" id="역변환-규칙시각화-구-rightarrow-정준-큐브"><span class="header-section-number">5.4.5</span> 3.3.5 역변환 규칙(시각화 구 <span class="math inline">\(\rightarrow\)</span> 정준 큐브)</h3>
<p>시각화 도메인으로부터 정준 셀 대표 길이를 재구성하는 역변환은 <strong>시각화 모드에 의해 단일하게 결정</strong>되어야 한다. 역변환은 다음으로 고정한다.</p>
<h3 data-number="5.4.6" id="a-vis-equal-diameter의-역변환"><span class="header-section-number">5.4.6</span> (A) <code>VIS-EQUAL-DIAMETER</code>의 역변환</h3>
<p><span class="math display">\[D_{\mathrm{anch}} := D_{\mathrm{vis}},
\qquad
r_0 := \frac{D_{\mathrm{anch}}}{2}.
\label{eq:inv_equal_diameter}\]</span></p>
<h3 data-number="5.4.7" id="b-vis-equal-volume의-역변환"><span class="header-section-number">5.4.7</span> (B) <code>VIS-EQUAL-VOLUME</code>의 역변환</h3>
<p><span class="math display">\[D_{\mathrm{anch}} := \left(\frac{4\pi}{3}\right)^{\!1/3} r_{\mathrm{vis}},
\qquad
r_0 := \frac{D_{\mathrm{anch}}}{2}.
\label{eq:inv_equal_volume}\]</span>
역변환은 <strong>시각화 산출물의 라벨링</strong> 및 <strong>그림의 축 표기</strong>에만 사용된다. 역변환을 사용하여 정준 입력(<span class="math inline">\(D_{\mathrm{anch}}\)</span>)을 사후 조정하거나 재정의하는 행위는 금지된다.</p>
<h3 data-number="5.4.8" id="혼동-금지-규칙즉시-fail"><span class="header-section-number">5.4.8</span> 3.3.6 혼동 금지 규칙(즉시 FAIL)</h3>
<p>본 절의 정의가 성립하려면 다음 혼동 금지 규칙이 항상 만족되어야 하며, 위반 즉시 <code>FAIL</code>이다.</p>
<ol>
<li><p><strong>기호 의미 충돌 금지</strong>: <span class="math inline">\(D_{\mathrm{anch}}\)</span>는 <code>CELL-CUBE</code>에서 <code>edge</code>로 잠겨야 하며, 동일 문맥에서 <code>diameter</code> 또는 <code>radius</code>로 사용될 수 없다.</p></li>
<li><p><strong>모드 혼합 금지</strong>: 동일 산출물(동일 lock_id 조합)에서 <code>VIS-EQUAL-DIAMETER</code>와 <code>VIS-EQUAL-VOLUME</code>을 동시에 사용하거나 교차 사용하지 않는다.</p></li>
<li><p><strong><span class="math inline">\(r_0\)</span> 동일시 조건</strong>: <span class="math inline">\(r_0\)</span>를 구 반지름으로 동일시하는 등식 <a data-reference="eq:rvis_equals_r0" data-reference-type="eqref" href="#eq:rvis_equals_r0">[eq:rvis_equals_r0]</a>는 <code>VIS-EQUAL-DIAMETER</code>가 잠겼을 때만 허용된다. 그 외 모드에서 <span class="math inline">\(r_0=r_{\mathrm{vis}}\)</span>를 사용하면 즉시 <code>FAIL</code>이다.</p></li>
<li><p><strong>암묵 변환 금지</strong>: 큐브<span class="math inline">\(\leftrightarrow\)</span>구 변환은 반드시 <a data-reference="eq:vis_equal_diameter" data-reference-type="eqref" href="#eq:vis_equal_diameter">[eq:vis_equal_diameter]</a> 또는 <a data-reference="eq:vis_equal_volume_condition" data-reference-type="eqref" href="#eq:vis_equal_volume_condition">[eq:vis_equal_volume_condition]</a>–<a data-reference="eq:rvis_equal_volume" data-reference-type="eqref" href="#eq:rvis_equal_volume">[eq:rvis_equal_volume]</a>의 명시된 파생 기호로만 수행한다. 동일 기호의 의미를 바꾸어 암묵 변환을 수행하면 즉시 <code>FAIL</code>이다.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-16">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 정준 셀 기하 <code>CELL-CUBE</code> 및 <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 의미(<code>edge</code>)를 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(r_0:=D_{\mathrm{anch}}/2\)</span> 파생 정의를 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: 시각화 모드 <code>VIS-EQUAL-DIAMETER</code>/<code>VIS-EQUAL-VOLUME</code>의 이산 선택을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 지름/반지름/셀 기하 혼동, 모드 혼합, 암묵 변환은 G-SYM에서 즉시 <code>FAIL</code>로 판정.</p></li>
<li><p>Gate: lock_id 혼합 또는 사후 모드 변경은 G-LOCK 및 G-NT에서 <code>FAIL</code>로 판정.</p></li>
</ul>
<h2 data-number="5.5" id="ell_mathrmrot-처리참고값"><span class="header-section-number">5.5</span> 3.4 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 처리(참고값)</h2>
<h3 data-number="5.5.1" id="ell_mathrmrot의-정의와-잠금-필드"><span class="header-section-number">5.5.1</span> 3.4.1 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 정의와 잠금 필드</h3>
<p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 회전 구동(또는 회전 선택) 프로토콜에서 도입되는 길이 스케일로 정의한다. <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 값 자체보다 먼저 다음의 의미 필드가 잠겨야 한다.</p>
<ol>
<li><p><strong>객체 귀속(object_id)</strong>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>가 어느 객체의 길이인지(예: <code>OBJ-CELL</code>, <code>OBJ-CORE</code>, <code>OBJ-THROAT</code> 중 하나)를 단 하나로 고정한다.</p></li>
<li><p><strong>기하 의미(geometry_meaning)</strong>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 <strong>지름</strong>으로 잠근다. 즉,
<span class="math display">\[\mathrm{geometry\_meaning}(\ell_{\mathrm{rot}}):=\texttt{diameter}.\]</span>
반지름으로의 재해석은 허용되지 않으며, 반지름이 필요하면 반드시 파생 기호
<span class="math display">\[r_{\mathrm{rot}} := \frac{\ell_{\mathrm{rot}}}{2}\]</span>
를 별도로 도입하여 사용한다.</p></li>
<li><p><strong>차원/단위(dimension/unit)</strong>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 길이 차원(<code>L</code>)으로 잠기며, 단위 표기는 레지스트리에 승인된 길이 단위(예: pm 등) 중 하나로 잠긴다.</p></li>
<li><p><strong>프로토콜 귀속(protocol_id)</strong>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>가 어떤 회전 구동 프로토콜에서 정의/추출되었는지(구동 방식, 샘플링, 추정기, 종료 조건)를 식별자로 잠근다. 값만 있고 프로토콜 귀속이 없는 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 사용 불가이다.</p></li>
<li><p><strong>스코프(scope)</strong>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 회전 구동 레짐(또는 회전 선택 레짐)에서만 참조할 수 있으며, 스코프 밖 참조는 금지된다.</p></li>
</ol>
<p>위 필드 중 하나라도 누락되면 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 정의가 성립하지 않으며, <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>가 등장하는 식/표/그림/로그는 즉시 <code>FAIL</code>로 판정된다.</p>
<h3 data-number="5.5.2" id="현재-상태-참고값canon-ref"><span class="header-section-number">5.5.2</span> 3.4.2 현재 상태: “참고값(CANON-REF)”</h3>
<p>본 문서에서 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 현재 지위는 <strong>참고값</strong>이다. 즉, <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 정준 입력 중에서도 다음 분류로 고정한다.
<span class="math display">\[\ell_{\mathrm{rot}} \in \texttt{CANON-REF}.
\label{eq:lrot_canon_ref}\]</span>
<code>CANON-REF</code>의 의미는 다음과 같다.</p>
<ol>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 <strong>필수 유도 사슬</strong>의 입력으로 자동 승격되지 않는다.</p></li>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 사용하여 <span class="math inline">\(D_{\mathrm{anch}}\)</span>, <span class="math inline">\(r_p\)</span>, <span class="math inline">\(\delta\)</span>, <span class="math inline">\(\pi\)</span> 등의 정준 입력의 의미 또는 값을 재정의하는 행위는 금지된다.</p></li>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 사용하여 단위 실현 입력(<span class="math inline">\(a\)</span>, <span class="math inline">\(\Delta t\)</span>, <span class="math inline">\(c_{\mathrm{ref}}\)</span>)을 조정하거나 재해석하는 행위는 금지된다.</p></li>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>가 포함된 결론은 <strong>확장 레짐 결론</strong>으로만 존재하며, 확장 레짐 Gate를 통과하지 못하면 결론 자격이 부여되지 않는다.</p></li>
</ol>
<p>따라서 현재 버전에서 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 “있을 수 있는 입력”이지만 “반드시 필요한 입력”이 아니며, 기본 결론(정준<span class="math inline">\(\rightarrow\)</span>사건<span class="math inline">\(\rightarrow\)</span>실현<span class="math inline">\(\rightarrow\)</span>질량/힘)의 근거를 구성하지 않는다.</p>
<h3 data-number="5.5.3" id="참고값-사용-규칙허용되는-사용과-금지되는-사용"><span class="header-section-number">5.5.3</span> 3.4.3 참고값 사용 규칙(허용되는 사용과 금지되는 사용)</h3>
<p>현재 상태(<code>CANON-REF</code>)에서 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 사용 규칙을 다음으로 고정한다.</p>
<h4 data-number="5.5.3.1" id="허용되는-사용확장-레짐-내부에서만"><span class="header-section-number">5.5.3.1</span> 3.4.3.1 허용되는 사용(확장 레짐 내부에서만)</h4>
<p>다음 형태의 사용은 허용된다. 단, 스코프가 회전 구동 레짐으로 잠겨 있어야 하며, 관련 Gate를 통과해야 한다.</p>
<ol>
<li><p><strong>무차원 비율 구성</strong>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 다른 길이 스케일과 조합하여 무차원 비율(예: <span class="math inline">\(\ell_{\mathrm{rot}}/D_{\mathrm{anch}}\)</span>, <span class="math inline">\(\ell_{\mathrm{rot}}/r_p\)</span> 등)을 구성하는 행위.</p></li>
<li><p><strong>회전 구동 이방성 지표의 입력</strong>: 방향 분포, 패브릭, 임계목 방향 의존성 등 회전 구동 확장 절에서 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 프로토콜 입력으로 사용하는 행위.</p></li>
<li><p><strong>스위치 관측량의 레짐 라벨</strong>: 재밍/비재밍 전이 또는 병목 전이의 주변에서, “회전 구동 조건”의 라벨로 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 함께 기록하는 행위(라벨은 결론이 아니라 조건 기록이다).</p></li>
</ol>
<h4 data-number="5.5.3.2" id="금지되는-사용참고값-지위에서의-금지"><span class="header-section-number">5.5.3.2</span> 3.4.3.2 금지되는 사용(참고값 지위에서의 금지)</h4>
<p>다음 형태의 사용은 즉시 금지되며, 발견 즉시 <code>FAIL</code>이다.</p>
<ol>
<li><p><strong>정준 입력의 대체</strong>: <span class="math inline">\(D_{\mathrm{anch}}\)</span> 또는 <span class="math inline">\(r_p\)</span>의 의미/값을 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>로 대체하거나, <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>로부터 <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 의미를 재정의하는 행위.</p></li>
<li><p><strong>단위 실현의 조정</strong>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 사용하여 <span class="math inline">\(a\)</span>, <span class="math inline">\(\Delta t\)</span>, <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 의미 또는 값을 조정하는 행위.</p></li>
<li><p><strong>사후 선택/사후 보정</strong>: 여러 후보 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 중 결론이 유리해지는 값을 선택하거나, 추정기/문턱을 이동하여 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 원하는 값으로 만드는 행위.</p></li>
<li><p><strong>의미 재해석</strong>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 지름으로 잠근 상태에서 반지름처럼 사용하거나, 셀 기하(큐브/구) 변환을 암묵적으로 수행하여 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 기하 의미를 바꾸는 행위.</p></li>
</ol>
<h3 data-number="5.5.4" id="채택승격-절차-참고값-rightarrow-정준-입력canon-primary로의-전환"><span class="header-section-number">5.5.4</span> 3.4.4 채택(승격) 절차: 참고값 <span class="math inline">\(\rightarrow\)</span> 정준 입력(CANON-PRIMARY)로의 전환</h3>
<p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 참고값이 아니라 정준 입력(필수 사슬 입력)으로 <strong>채택</strong>하려면, 동일 버전 내부에서의 수정이 아니라 <strong>LOCK 버전업</strong>으로만 허용된다. 채택은 다음 절차로 고정한다.</p>
<h4 data-number="5.5.4.1" id="채택-선언승격-타입의-명시"><span class="header-section-number">5.5.4.1</span> 3.4.4.1 채택 선언(승격 타입의 명시)</h4>
<p>채택은 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 분류를 다음 중 하나로 승격하는 선언이다.
<span class="math display">\[\ell_{\mathrm{rot}}:\ \texttt{CANON-REF}\ \longrightarrow\ \texttt{CANON-PRIMARY}.
\label{eq:lrot_promotion}\]</span>
<code>CANON-PRIMARY</code>는 필수 유도 사슬에 직접 참여하는 정준 입력을 뜻한다. 승격 시점에는 반드시 다음을 함께 명시한다.</p>
<ol>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 객체 귀속(object_id) 확정.</p></li>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 기하 의미(지름) 확정.</p></li>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 값/단위/유효숫자 규약 확정.</p></li>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 적용 범위(scope) 확정(전역인지, 특정 레짐인지).</p></li>
</ol>
<h4 data-number="5.5.4.2" id="lock-버전업새-lock_id-발급"><span class="header-section-number">5.5.4.2</span> 3.4.4.2 LOCK 버전업(새 lock_id 발급)</h4>
<p>승격은 <code>canon_lock</code>의 변경이므로 새 <code>canon_lock_id</code>를 발급한다. 또한 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>가 들어가는 계산 절차/판정 절차가 바뀌므로, 필요한 경우 <code>analysis_lock_id</code>도 함께 버전업한다. 버전업은 다음을 포함한다.</p>
<ol>
<li><p><strong>change_log 고정</strong>: 승격 사유, 변경 전/후 분류, 영향을 받는 절(의존 결론 목록)을 기록한다.</p></li>
<li><p><strong>기호 레지스트리 갱신</strong>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 의미 필드(object_id, geometry_meaning, scope, unit) 및 파생 기호(<span class="math inline">\(r_{\mathrm{rot}}\)</span> 등)를 단일 출처로 갱신한다.</p></li>
<li><p><strong>의존성 그래프 갱신</strong>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 입력으로 참조하는 모든 유도 결과를 재생성 대상으로 표시한다.</p></li>
</ol>
<h4 data-number="5.5.4.3" id="전면-재유도-및-전면-재판정재검증"><span class="header-section-number">5.5.4.3</span> 3.4.4.3 전면 재유도 및 전면 재판정(재검증)</h4>
<p>새 lock_id 조합에서 다음이 필수로 수행되어야 한다.</p>
<ol>
<li><p><strong>전면 재유도</strong>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>가 입력으로 참여하는 유도 사슬을 처음부터 다시 생성한다(중간 산출물 포함).</p></li>
<li><p><strong>전면 재판정</strong>: 해당 결론이 요구하는 Gate 스택을 처음부터 다시 수행하여 PASS/FAIL/INCONCLUSIVE를 재판정한다.</p></li>
<li><p><strong>봉인</strong>: 새 <code>registry_snapshot</code>, <code>manifest</code>, <code>checksums</code>를 생성하여 새 버전을 동결한다.</p></li>
</ol>
<p>승격 이후 결론은 새 lock_id 조합에만 귀속되며, 승격 이전 결론과 혼합 서술될 수 없다.</p>
<h3 data-number="5.5.5" id="영향-범위-선언승격-전후"><span class="header-section-number">5.5.5</span> 3.4.5 영향 범위 선언(승격 전/후)</h3>
<p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 지위는 문서 전역의 영향 범위를 직접 결정한다. 영향 범위는 다음으로 선언한다.</p>
<h4 data-number="5.5.5.1" id="현재참고값-영향-범위"><span class="header-section-number">5.5.5.1</span> 3.4.5.1 현재(참고값) 영향 범위</h4>
<p>현재 지위(<code>CANON-REF</code>)에서 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 영향 범위는 다음으로 제한된다.</p>
<ol>
<li><p>회전 구동 확장 레짐(이방성/방향 분포/패브릭/임계목 방향 의존성 등)에서만 사용된다.</p></li>
<li><p>기본 필수 유도 사슬(정준 입력 <span class="math inline">\(D_{\mathrm{anch}}, r_p, \delta, \pi\)</span> 및 실현 입력 <span class="math inline">\(a, \Delta t, c_{\mathrm{ref}}\)</span>로부터 진행되는 결론)에는 개입하지 않는다.</p></li>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>가 포함된 결과는 “확장 결론”으로 라벨링되며, 확장 Gate를 통과한 범위에서만 결론 자격을 가진다.</p></li>
</ol>
<h4 data-number="5.5.5.2" id="채택승격-이후-영향-범위"><span class="header-section-number">5.5.5.2</span> 3.4.5.2 채택(승격) 이후 영향 범위</h4>
<p>승격(<code>CANON-PRIMARY</code>)이 이루어지면 영향 범위는 다음으로 확장된다.</p>
<ol>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 필수 유도 사슬에 참여할 수 있으며, 이 경우 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>에 의존하는 모든 결론(길이/시간/질량/힘 계열 중 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>가 들어가는 항목)은 새 lock_id로 재생성/재판정되어야 한다.</p></li>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>가 어떤 객체의 지름인지에 따라(셀/코어/목 등), 셀 정의(Anchor Cell), 이산 구조(코어/셸), 사건 집계, 레짐 지도(강성/비강성 전이) 중 일부가 직접 영향을 받는다. 영향 대상의 목록은 change_log의 의존성 그래프 항목으로 고정된다.</p></li>
<li><p>승격 이후에도 금지되는 행위가 있다. <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 승격은 <span class="math inline">\(D_{\mathrm{anch}}\)</span>와 <span class="math inline">\(r_p\)</span>의 의미를 자동으로 대체하지 않으며, 대체가 필요하면 별도의 정준 입력 구조 변경(추가 버전업)과 Gate를 요구한다.</p></li>
</ol>
<h3 data-number="5.5.6" id="혼동-및-위반-시-즉시-fail-규칙"><span class="header-section-number">5.5.6</span> 3.4.6 혼동 및 위반 시 즉시 FAIL 규칙</h3>
<p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>와 관련된 다음 위반은 즉시 <code>FAIL</code>로 판정한다.</p>
<ol>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 geometry_meaning(지름)이 잠기지 않았거나, 반지름으로 혼용되는 경우.</p></li>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 객체 귀속(object_id)이 누락되거나, 동일 문맥에서 복수 객체로 혼용되는 경우.</p></li>
<li><p><span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 사용하여 정준 입력 또는 실현 입력의 의미/값을 사후 조정하는 경우.</p></li>
<li><p>승격 없이(버전업 없이) <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 필수 유도 사슬의 입력으로 사용한 경우.</p></li>
<li><p>승격 후에도 서로 다른 lock_id 조합(구버전/신버전)의 결과를 혼합하여 하나의 결론으로 서술한 경우.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-17">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 현재 지위(<code>CANON-REF</code>)와 사용 스코프(회전 구동 확장 레짐 한정)를 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 의미 필드(object_id, geometry_meaning=<code>diameter</code>, unit, protocol_id, scope) 동시 잠금 규약 고정.</p></li>
<li><p>Gate: 참고값 지위에서 정준/실현 입력을 조정하거나 의미를 재해석하면 G-NT/G-SYM에서 즉시 <code>FAIL</code>.</p></li>
<li><p>Gate: 채택(승격)은 <code>canon_lock</code> 버전업과 전면 재유도/전면 재판정(G-LOCK 포함)을 필요조건으로 연결.</p></li>
<li><p>Gate: 승격 전/후 결과 혼합은 G-LOCK에서 <code>FAIL</code>로 판정.</p></li>
</ul>
<h1 data-number="6" id="의미층-사상11과-닫힘closure-시스템"><span class="header-section-number">6</span> 4. 의미층 사상(1:1)과 닫힘(Closure) 시스템</h1>
<h2 class="unnumbered" id="장의-선언-의미층semantic-layers과-닫힘closure의-역할">장의 선언: 의미층(semantic layers)과 닫힘(closure)의 역할</h2>
<p>본 장은 문서 전역에서 사용되는 “의미층 사상(1:1)”과 “닫힘(closure)”을 단일 체계로 고정한다.
의미층 사상은 “어떤 기호가 무엇을 의미하는가”를 층별로 분리하여 1:1로 대응시키는 규약이며, 닫힘은 공리와 정의만으로는 결정되지 않는 선택(결정 규칙)을 명시적으로 봉인하는 규약이다.
본 장의 규약은 후속 모든 유도(정류, 사건, 단위 실현, 질량, 힘, 확장 레짐)의 <strong>전제</strong>이며, 본 장을 위반하는 유도와 검증은 결론 자격을 가질 수 없다.</p>
<h2 class="unnumbered" id="의미층-사상11의-전역-원칙">의미층 사상(1:1)의 전역 원칙</h2>
<p>의미층 사상은 다음 원칙으로 고정한다.</p>
<ol>
<li><p><strong>1기호-1의미-1단위</strong>: 동일 기호는 문서 전역에서 단 하나의 의미(객체 귀속 + 기하 의미 + 연산 허용 범위)와 단 하나의 단위 차원을 가진다.</p></li>
<li><p><strong>층 분리</strong>: “정의층”에서 정의된 의미는 “관측층”으로 이동할 때 자동 변환되지 않는다. 변환은 반드시 사상(map)으로 명시되어야 한다.</p></li>
<li><p><strong>1:1 대응</strong>: 한 층의 항목은 다른 층의 항목과 1:1로만 연결된다. 1:N 또는 N:1 연결이 필요하면, 그 연결은 새로운 중간 객체 또는 새로운 변환 규칙으로 분해되어야 한다.</p></li>
<li><p><strong>사상의 잠금</strong>: 사상 규칙은 <code>analysis_lock</code> 또는 <code>canon_lock</code>에 잠기며, 결과를 본 뒤 교체될 수 없다.</p></li>
</ol>
<p>따라서 “의미의 도약”(정의 없이 다른 의미로 해석), “단위의 도약”(차원 변환을 암묵 수행), “객체의 도약”(다른 객체에 귀속시키는 소급)은 금지된다.</p>
<h2 class="unnumbered" id="의미층의-표준-4층-구조">의미층의 표준 4층 구조</h2>
<p>본 문서에서 의미층은 다음 4층으로 고정한다. 각 층의 항목은 레지스트리로 봉인되며, 층 간 이동은 사상으로만 허용된다.</p>
<ol>
<li><p><strong>L0(프리미티브 층)</strong>: VP, 도메인, 접촉, 인접성, 셀, 이벤트 등 공리/정의로 고정되는 프리미티브 객체.</p></li>
<li><p><strong>L1(구조/조합 층)</strong>: 접촉 그래프, 백본, 목(throat), 경로(path), 정수 구조(코어/셸), 상쇄 규약 등 이산 구조 항목.</p></li>
<li><p><strong>L2(집계/관측량 층)</strong>: 카운트, 분포, 지시변수, 임계 지표, 사건율, 스위치 관측량, 교차정합 지표 등 집계된 관측량(또는 계산량).</p></li>
<li><p><strong>L3(실현/수치 층)</strong>: 실현된 길이/시간/질량/힘 등 단위가 붙은 수치 결과 및 표준 보고 형식.</p></li>
</ol>
<p>층 L0–L3의 항목들은 서로 혼용되지 않으며, L2 또는 L3의 항목으로 L0 정의를 소급 수정하지 않는다.</p>
<h2 data-number="6.1" id="사상semantic-mapping의-표준-템플릿"><span class="header-section-number">6.1</span> 4.4 1:1 사상(semantic mapping)의 표준 템플릿</h2>
<p>의미층 사상은 레지스트리 항목으로서 다음 템플릿을 가진다. 이 템플릿은 <code>analysis_lock</code>에 포함되어야 하며, 누락 시 해당 사상은 사용 불가이다.</p>
<pre><code>semantic_maps:
  - map_id: MAP-L1toL2-THROAT-001
    from_layer: L1
    to_layer: L2
    from_item:
      object_id: OBJ-THROAT
      symbol: delta_gap
      meaning: (간격/두께/임계목 등, 단일 의미)
      unit_dimension: L (또는 1)
    to_item:
      quantity_id: Q-THROAT-DELTAEFF
      symbol: delta_eff
      meaning: (집계된 임계목 대표값의 정의)
      unit_dimension: L (또는 1)
    rule:
      definition: (집계 규칙, 평균/중앙값/최소절단 기반 등)
      algorithm_id: ALG-THROAT-EST-001
      parameters_locked_by: analysis_lock_id
    scope: (레짐 식별자)
    failure_modes:
      - FM-SCOPE
      - FM-NONUNIQUE
      - FM-NUMERIC
    required_gates:
      - G-SYM
      - G-LOCK
      - G-REG
      - (optional) G-NUM</code></pre>
<p>위 템플릿에서 <code>failure_modes</code>와 <code>required_gates</code>는 필수 필드이다. 사상은 “규칙”만으로 성립하지 않으며, 실패모드와 검증 조건이 함께 잠겨야 한다.</p>
<h2 data-number="6.2" id="닫힘closure의-정의"><span class="header-section-number">6.2</span> 4.5 닫힘(Closure)의 정의</h2>
<p>닫힘(closure)은 공리/정의만으로 결정되지 않는 선택을 <strong>명시적 규칙</strong>으로 봉인하는 장치이다. 닫힘은 다음 성질을 갖는다.</p>
<ol>
<li><p><strong>선택의 명시화</strong>: 닫힘은 “무엇을 선택했는가”를 문장과 수식으로 명시한다. 선택이 필요 없는 곳에는 닫힘을 도입하지 않는다.</p></li>
<li><p><strong>입력/출력의 선언</strong>: 닫힘은 입력과 출력의 타입(층, 단위, 객체 귀속)을 명시한다. 입력/출력 타입이 불명확하면 닫힘은 사용 불가이다.</p></li>
<li><p><strong>적용 범위(레짐)</strong>: 닫힘은 특정 레짐에서만 유효할 수 있으며, 레짐은 잠겨야 한다.</p></li>
<li><p><strong>실패모드 내장</strong>: 닫힘은 실패모드(정의 불능, 비유일성, 수치 불안정, 레짐 위반, 교차정합 실패 등)를 목록으로 가진다.</p></li>
<li><p><strong>Gate 필수</strong>: 닫힘은 Gate 판정 없이 결론을 생성할 수 없다. 닫힘이 들어간 결론은 해당 닫힘에 지정된 Gate 스택의 PASS를 결론 자격의 필요조건으로 갖는다.</p></li>
</ol>
<h2 data-number="6.3" id="닫힘-dag의존성-그래프의-전역-원칙"><span class="header-section-number">6.3</span> 4.6 닫힘 DAG(의존성 그래프)의 전역 원칙</h2>
<p>닫힘은 서로 의존할 수 있으나, 의존성은 반드시 <strong>DAG(순환 없는 방향 그래프)</strong>이어야 한다. 닫힘 DAG는 다음 원칙으로 고정한다.</p>
<ol>
<li><p><strong>단방향</strong>: 닫힘은 위상 정렬 가능한 방향을 가지며, 뒤에 있는 닫힘의 출력이 앞 닫힘의 입력을 소급 변경할 수 없다.</p></li>
<li><p><strong>순환 금지</strong>: 닫힘의 출력이 다시 자신의 입력을 결정하는 형태(직접 또는 간접)의 순환 의존은 금지된다.</p></li>
<li><p><strong>SSOT</strong>: 닫힘 정의는 <code>analysis_lock</code>의 단일 위치에만 존재한다. 본문은 닫힘을 재정의하지 않는다.</p></li>
<li><p><strong>결론 귀속</strong>: 닫힘이 포함된 모든 결론은 사용된 닫힘들의 목록(closure_ids)과 닫힘 DAG 버전(analysis_lock_id)을 함께 가진다.</p></li>
</ol>
<p>닫힘 DAG의 목적은 “필요한 선택”을 숨기지 않고, 선택이 결론에 미치는 영향을 추적 가능하게 만드는 데 있다.</p>
<h2 data-number="6.4" id="실패모드failure-modes의-표준-분류"><span class="header-section-number">6.4</span> 4.7 실패모드(Failure Modes)의 표준 분류</h2>
<p>실패모드는 “이 닫힘/사상이 언제 붕괴하는가”를 기록하는 표준 라벨 체계이다. 실패모드는 사후 기록이 아니라 사전 등록 항목이며, 다음 분류로 고정한다.</p>
<ol>
<li><p><strong>FM-SYM</strong>: 기호/의미/단위 충돌 또는 오버로딩.</p></li>
<li><p><strong>FM-SCOPE</strong>: 레짐/스코프 위반(적용 범위 밖 사용).</p></li>
<li><p><strong>FM-NONUNIQUE</strong>: 해가 비유일(선택 규칙 없이는 다중 해).</p></li>
<li><p><strong>FM-NODEF</strong>: 정의 불능(입력이 누락되었거나, 정의식이 닫히지 않음).</p></li>
<li><p><strong>FM-NUMERIC</strong>: 수치 불안정(수렴 실패, 민감도 폭발, 반복 불일치).</p></li>
<li><p><strong>FM-XCROSS</strong>: 교차정합 실패(독립 채널 간 불일치).</p></li>
<li><p><strong>FM-REP</strong>: 재현 실패(재실행 시 동일 판정 불가).</p></li>
<li><p><strong>FM-NT</strong>: 사후조정(No-Tuning) 위반 탐지.</p></li>
</ol>
<p>실패모드는 “결과가 마음에 들지 않는다”가 아니라 “정의/절차/판정이 성립하지 않는다”를 의미한다. 실패모드가 발생하면 해당 결론은 <code>FAIL</code> 또는 <code>INCONCLUSIVE</code>로 판정되어 결론 자격을 상실한다.</p>
<h2 data-number="6.5" id="검증이-필수인-이유닫힘사상의-결론-자격-조건"><span class="header-section-number">6.5</span> 4.8 검증이 필수인 이유(닫힘/사상의 결론 자격 조건)</h2>
<p>의미층 사상과 닫힘은 “선택”을 포함하므로, 선택의 정당화는 외부 근거가 아니라 <strong>사전 등록된 Gate의 통과 여부</strong>로만 부여된다. 따라서 다음이 전역 규칙으로 성립한다.</p>
<ol>
<li><p>Gate가 없는 닫힘/사상은 결론을 생성할 수 없다.</p></li>
<li><p>실패모드가 정의되지 않은 닫힘/사상은 사용 불가이다.</p></li>
<li><p>닫힘 DAG 버전이 기록되지 않은 결론은 근거를 잃으므로 결론 자격을 갖지 못한다.</p></li>
</ol>
<p>본 장에서 고정된 “의미층 1:1”, “닫힘 DAG”, “실패모드”, “Gate 필수”는 후속 장에서 반복 설명되지 않으며, 각 절의 마지막 LOCK/Gate 연결에서 필요한 항목만 참조한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-18">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 의미층 4층(L0–L3) 및 1:1 사상 템플릿(semantic_maps) 구조를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 닫힘(closure) 정의, 입력/출력 타입 선언, 적용 범위, 실패모드 내장 규약을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 닫힘 의존성 그래프는 DAG(순환 금지)여야 하며, 닫힘 정의는 SSOT로만 존재함을 고정.</p></li>
<li><p>Gate: 닫힘/사상은 지정된 Gate 스택의 <code>PASS</code> 없이는 결론 자격을 부여할 수 없음을 연결 고정.</p></li>
<li><p>Gate: 실패모드(FM-*) 발생 시 <code>FAIL</code>/<code>INCONCLUSIVE</code> 판정 및 결론 자격 박탈 규정 연결 고정.</p></li>
</ul>
<h2 data-number="6.6" id="의미층-사상-pressurefluxdeficitcharge"><span class="header-section-number">6.6</span> 4.1 의미층 사상: pressure/flux/deficit/charge</h2>
<h3 data-number="6.6.1" id="공통-전제-층l0l3과-운영-기록의-최소-형식"><span class="header-section-number">6.6.1</span> 4.1.1 공통 전제: 층(L0–L3)과 운영 기록의 최소 형식</h3>
<p>본 절에서 정의하는 pressure/flux/deficit/charge는 모두 다음 의미층 구조를 따른다.</p>
<ol>
<li><p>L0(프리미티브): VP, 도메인(셀), 접촉/인접성, 국소 갱신(사건) 등.</p></li>
<li><p>L1(구조): 접촉 그래프, 경계 집합, 절단면, 목/경로, 코어/셸 구조 등.</p></li>
<li><p>L2(집계 관측량): 카운트/지표/율/경사(미분형) 등(단위 없는 중간량 포함).</p></li>
<li><p>L3(실현 수치): 길이 <span class="math inline">\(a\)</span>, 시간 <span class="math inline">\(\Delta t\)</span>, 에너지 단위 <span class="math inline">\(U_{\mathrm{lat}}\)</span> 등으로 단위가 붙은 최종 수치.</p></li>
</ol>
<p>각 양은 L1<span class="math inline">\(\rightarrow\)</span>L2<span class="math inline">\(\rightarrow\)</span>L3의 1:1 사상으로만 정의되며, 다른 층의 의미를 소급 변경하는 변환은 금지된다.</p>
<p>또한 본 절에서 사용하는 공통 운영 기록(로그)은 다음 최소 필드를 갖는다. 이 기록 형식은 <code>analysis_lock</code>에 잠기며, 누락 시 해당 양은 계산 불가로 판정된다.</p>
<ol>
<li><p>셀 도메인: <span class="math inline">\(\mathcal{D}_{\square}\)</span> 및 대표 길이 <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 잠금(셀 기하=<code>CELL-CUBE</code>, <span class="math inline">\(D_{\mathrm{anch}}\)</span> 의미=<code>edge</code>).</p></li>
<li><p>접촉 그래프: <span class="math inline">\(\mathcal{G}_c=(\mathcal{V},\mathcal{E}_c)\)</span> 및 접촉 판정 <span class="math inline">\(C(i,j)\in\{0,1\}\)</span>의 잠금.</p></li>
<li><p>사건 로그: 사건 집합 <span class="math inline">\(\mathcal{E}\)</span>, 사건 인덱스 <span class="math inline">\(e\in\mathcal{E}\)</span>, 사건 시각(틱) <span class="math inline">\(n(e)\in\mathbb{Z}\)</span>, 사건 전/후 배치 식별자, 사건에 관여한 VP 부분집합 <span class="math inline">\(\mathcal{V}(e)\subseteq\mathcal{V}\)</span>.</p></li>
<li><p>절단면/경계의 정의: 경계 집합 <span class="math inline">\(\partial\mathcal{D}^{\pm}\)</span> 또는 절단면 <span class="math inline">\(\Sigma\)</span>의 기하 정의(평면/곡면/방향 법선 포함) 및 해당 정의의 잠금.</p></li>
</ol>
<h3 data-number="6.6.2" id="표준-기호타입차원단위와-11-운영-정의-표"><span class="header-section-number">6.6.2</span> 4.1.2 표준 기호(타입/차원/단위)와 1:1 운영 정의 표</h3>
<p>pressure/flux/deficit/charge의 표준 항목은 다음 표로 잠근다. 표의 각 행은 하나의 항목을 뜻하며, 항목은 (기호, 타입, 차원, 단위, 운영 절차)의 조합으로만 의미를 갖는다.</p>
<div class="center">
<table style="width:88%;">
<colgroup>
<col style="width: 12%"/>
<col style="width: 10%"/>
<col style="width: 10%"/>
<col style="width: 12%"/>
<col style="width: 44%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">명칭</th>
<th style="text-align: left;">기호</th>
<th style="text-align: left;">타입</th>
<th style="text-align: left;">차원/단위</th>
<th style="text-align: left;">1:1 운영 절차(요약)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">pressure</td>
<td style="text-align: left;"><span class="math inline">\(P\)</span></td>
<td style="text-align: left;">스칼라</td>
<td style="text-align: left;"><span class="math inline">\([E L^{-3}]\)</span>, <span class="math inline">\(U_{\mathrm{lat}}/a^{3}\)</span></td>
<td style="text-align: left;">경계 압축 프로토콜 <span class="math inline">\(\rightarrow\)</span> 최소 완화 비용 <span class="math inline">\(W(\epsilon)\)</span> <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(P:=\lim_{\epsilon\to0^+}W(\epsilon)/\Delta V(\epsilon)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">flux</td>
<td style="text-align: left;"><span class="math inline">\(J\)</span></td>
<td style="text-align: left;">스칼라 또는 벡터(방향 포함 시)</td>
<td style="text-align: left;"><span class="math inline">\([L T^{-1}]\)</span> 또는 <span class="math inline">\([\text{token}\,A^{-1}T^{-1}]\)</span></td>
<td style="text-align: left;">절단면 <span class="math inline">\(\Sigma\)</span>와 사건의 횡단 부호 <span class="math inline">\(s_\Sigma(e)\)</span> <span class="math inline">\(\rightarrow\)</span> 순횡단 수 <span class="math inline">\(\Delta N_\Sigma\)</span> <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(J:=a^{3}\Delta N_\Sigma/(A_\Sigma\Delta T)\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">deficit</td>
<td style="text-align: left;"><span class="math inline">\(\mathcal{D}_{\mathrm{def}}\)</span></td>
<td style="text-align: left;">스칼라</td>
<td style="text-align: left;"><span class="math inline">\([1]\)</span> (기본), 필요 시 <span class="math inline">\([L^{-3}]\)</span></td>
<td style="text-align: left;">접촉 차수 <span class="math inline">\(z_i\)</span> <span class="math inline">\(\rightarrow\)</span> 기준 차수 <span class="math inline">\(z_{\mathrm{ref}}\)</span> <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(d_i:=\max(0,z_{\mathrm{ref}}-z_i)\)</span> <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(\mathcal{D}_{\mathrm{def}}:=\frac{1}{|\mathcal{V}|}\sum_i d_i\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">charge</td>
<td style="text-align: left;"><span class="math inline">\(Q\)</span></td>
<td style="text-align: left;">스칼라(부호 포함)</td>
<td style="text-align: left;"><span class="math inline">\([Q]\)</span> (독립 차원), 단위 <span class="math inline">\(q_0\)</span></td>
<td style="text-align: left;">셸(7) 상쇄 규약 <span class="math inline">\(\rightarrow\)</span> 생존 벡터 <span class="math inline">\(\mathbf{V}\)</span> <span class="math inline">\(\rightarrow\)</span> 부호 지표 <span class="math inline">\(q:=\mathrm{sgn}(\mathbf{V}\cdot\mathbf{n}_Q)\)</span> <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\(Q:=q_0 q\)</span></td>
</tr>
</tbody>
</table>
</div>
<p>표의 “요약”은 정의의 축약이 아니라 절차의 이름만을 적은 것이다. 각 항목의 완전한 절차는 아래 절들에서 단계별로 고정한다.</p>
<h3 data-number="6.6.3" id="pressure의-11-정의경계-압축-rightarrow-비용-rightarrow-압력"><span class="header-section-number">6.6.3</span> 4.1.3 pressure의 1:1 정의(경계 압축 <span class="math inline">\(\rightarrow\)</span> 비용 <span class="math inline">\(\rightarrow\)</span> 압력)</h3>
<h4 data-number="6.6.3.1" id="l1-입력구조-경계와-압축-연산자"><span class="header-section-number">6.6.3.1</span> 4.1.3.1 L1 입력(구조): 경계와 압축 연산자</h4>
<p>정준 셀 도메인 <span class="math inline">\(\mathcal{D}_{\square}\)</span>에서, 압축 방향을 단위 법선 <span class="math inline">\(\mathbf{n}_P\)</span>로 잠근다. 큐브 셀에서는 다음 선택 중 하나를 <code>analysis_lock</code>에 잠근다.
<span class="math display">\[\mathbf{n}_P \in \{\hat{\mathbf{x}},\hat{\mathbf{y}},\hat{\mathbf{z}}\},
\qquad
\partial\mathcal{D}^{-},\partial\mathcal{D}^{+}\ \text{는 }\mathbf{n}_P\text{에 수직인 대향 면으로 잠금}.
\label{eq:pressure_normal_lock}\]</span></p>
<p>압축량 <span class="math inline">\(\epsilon&gt;0\)</span>에 대해 “압축 도메인”을 다음과 같이 정의한다.
<span class="math display">\[\mathcal{D}_{\square}(\epsilon)
:=
\left\{\mathbf{x}\in\mathcal{D}_{\square}\ \big|\ \mathbf{x}\cdot\mathbf{n}_P &lt; D_{\mathrm{anch}}-\epsilon\right\}
\quad\text{(대향 한 면을 $\epsilon$만큼 이동하여 도메인 부피를 감소)}.
\label{eq:compressed_domain}\]</span>
도메인 부피 감소량은
<span class="math display">\[\Delta V(\epsilon) := |\mathcal{D}_{\square}|-|\mathcal{D}_{\square}(\epsilon)| = A_{\square}\,\epsilon,
\qquad
A_{\square}:=D_{\mathrm{anch}}^{2}.
\label{eq:deltaV_cube}\]</span>
여기서 <span class="math inline">\(A_{\square}\)</span>는 압축 방향에 수직인 셀 면적이며, 셀 기하(큐브)와 <span class="math inline">\(D_{\mathrm{anch}}\)</span> 잠금이 성립할 때만 사용 가능하다.</p>
<p>압축 연산자 <span class="math inline">\(\mathcal{C}_\epsilon\)</span>를 다음과 같이 정의한다. <span class="math inline">\(\mathcal{C}_\epsilon\)</span>는 도메인 경계의 이동과 그에 따른 배치의 사상(좌표 변환)을 포함한다.
<span class="math display">\[\mathcal{C}_\epsilon:\ \{\Omega_i\}_{i\in\mathcal{V}}\ \mapsto\ \{\Omega_i^{(\epsilon)}\}_{i\in\mathcal{V}},
\label{eq:compression_operator}\]</span>
단, <span class="math inline">\(\mathcal{C}_\epsilon\)</span> 적용 후의 배치 <span class="math inline">\(\{\Omega_i^{(\epsilon)}\}\)</span>가 비침투/충만/국소 규칙을 만족한다는 보장은 없다. 따라서 압축 연산자는 항상 완화(아래 4.1.3.2)와 결합되어야 한다.</p>
<h4 data-number="6.6.3.2" id="l1rightarrowl2-사상-최소-완화-비용-wepsilon"><span class="header-section-number">6.6.3.2</span> 4.1.3.2 L1<span class="math inline">\(\rightarrow\)</span>L2 사상: 최소 완화 비용 <span class="math inline">\(W(\epsilon)\)</span></h4>
<p>완화 연산자(국소 갱신 합성) <span class="math inline">\(\mathcal{R}\)</span>을 다음과 같이 정의한다.
<span class="math display">\[\mathcal{R}:\ \{\Omega_i^{(\epsilon)}\}\ \mapsto\ \{\Omega_i^{(\epsilon,\mathrm{rel})}\},
\label{eq:relax_operator}\]</span>
여기서 <span class="math inline">\(\{\Omega_i^{(\epsilon,\mathrm{rel})}\}\)</span>는 비침투와 충만 및 국소 규칙을 만족하는 <em>허용 배치</em>여야 한다. 완화는 국소 갱신들의 합성으로만 구성되며(3.1의 국소 규칙), 완화 규칙(갱신 선택, 종료 조건, 실패 조건)은 <code>analysis_lock</code>에 잠겨야 한다.</p>
<p>완화 비용은 “사전 등록된 비용 단위”로만 정의한다. 비용 단위는 다음 두 요소로 구성된다.</p>
<ol>
<li><p>국소 갱신 1회의 비용 단위: <span class="math inline">\(U_{\mathrm{lat}}\)</span> (에너지 단위)로 잠금.</p></li>
<li><p>비용 계수: 국소 갱신 유형별 가중치 <span class="math inline">\(\omega_{\mathrm{upd}}\)</span>를 <code>analysis_lock</code>에 잠금(기본값은 1로 잠금 가능).</p></li>
</ol>
<p>압축량 <span class="math inline">\(\epsilon\)</span>에 대한 최소 완화 비용을 다음과 같이 정의한다.
<span class="math display">\[W(\epsilon)
:=
U_{\mathrm{lat}}\,
\min_{\mathcal{R}}
\left(\sum_{k=1}^{N_{\mathrm{upd}}(\epsilon)} \omega_{\mathrm{upd}}(k)\right),
\label{eq:work_definition}\]</span>
여기서 최소화는 “허용 배치로 복귀”라는 조건 하에서 수행되며, 최소화 규칙(탐색 방식, 중복 제거, 정지 기준)은 <code>analysis_lock</code>에 잠긴다. 완화가 실패하여 허용 배치로 복귀하지 못하면 <span class="math inline">\(W(\epsilon)\)</span>은 정의되지 않으며, 이는 실패모드로 기록된다.</p>
<h4 data-number="6.6.3.3" id="l2rightarrowl3-사상-압력-p의-정의"><span class="header-section-number">6.6.3.3</span> 4.1.3.3 L2<span class="math inline">\(\rightarrow\)</span>L3 사상: 압력 <span class="math inline">\(P\)</span>의 정의</h4>
<p>pressure는 다음의 극한으로 정의한다.
<span class="math display">\[P
:=
\lim_{\epsilon\to 0^+}\frac{W(\epsilon)}{\Delta V(\epsilon)}.
\label{eq:pressure_def}\]</span>
큐브 셀의 경우 <a data-reference="eq:deltaV_cube" data-reference-type="eqref" href="#eq:deltaV_cube">[eq:deltaV_cube]</a>를 대입하여
<span class="math display">\[P
=
\lim_{\epsilon\to 0^+}\frac{W(\epsilon)}{A_{\square}\epsilon}
=
\lim_{\epsilon\to 0^+}\frac{W(\epsilon)}{D_{\mathrm{anch}}^{2}\epsilon}.
\label{eq:pressure_cube}\]</span>
<span class="math inline">\(P\)</span>의 차원은 <span class="math inline">\([E L^{-3}]\)</span>로 잠기며, 단위는 <span class="math inline">\(U_{\mathrm{lat}}/a^3\)</span>로 잠긴다. 여기서 <span class="math inline">\(a\)</span>는 실현 길이 스케일이며, <span class="math inline">\(U_{\mathrm{lat}}\)</span>는 실현 에너지 단위이다. 이 단위 체계는 <code>realization_lock</code>에 잠겨야 한다.</p>
<h4 data-number="6.6.3.4" id="pressure-정의의-실패모드정의-불능-조건"><span class="header-section-number">6.6.3.4</span> 4.1.3.4 pressure 정의의 실패모드(정의 불능 조건)</h4>
<p>pressure 정의가 성립하지 않는 조건(실패모드)은 다음으로 고정한다.</p>
<ol>
<li><p><strong>FM-SYM</strong>: <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 의미(셀 모서리) 또는 셀 기하(큐브)가 잠기지 않음.</p></li>
<li><p><strong>FM-NODEF</strong>: 완화가 허용 배치로 복귀하지 못하여 <span class="math inline">\(W(\epsilon)\)</span>이 정의되지 않음.</p></li>
<li><p><strong>FM-NONUNIQUE</strong>: 완화 최소화 규칙이 잠기지 않아 “최소”가 기계적으로 정의되지 않음.</p></li>
<li><p><strong>FM-NUMERIC</strong>: 작은 <span class="math inline">\(\epsilon\)</span> 구간에서 <span class="math inline">\(W(\epsilon)/\epsilon\)</span>이 안정적으로 수렴하지 않음(수렴 판정 규칙은 Gate로 잠금).</p></li>
</ol>
<h3 data-number="6.6.4" id="flux의-11-정의절단면-sigma-rightarrow-횡단-부호-rightarrow-유속"><span class="header-section-number">6.6.4</span> 4.1.4 flux의 1:1 정의(절단면 <span class="math inline">\(\Sigma\)</span> <span class="math inline">\(\rightarrow\)</span> 횡단 부호 <span class="math inline">\(\rightarrow\)</span> 유속)</h3>
<h4 data-number="6.6.4.1" id="l1-입력구조-절단면-방향-측정-창"><span class="header-section-number">6.6.4.1</span> 4.1.4.1 L1 입력(구조): 절단면, 방향, 측정 창</h4>
<p>도메인 <span class="math inline">\(\mathcal{D}_{\square}\)</span> 내부에 방향을 가진 절단면 <span class="math inline">\(\Sigma\)</span>를 정의한다. 절단면은 다음 3요소를 동시에 잠근다.</p>
<ol>
<li><p>절단면의 기하 정의(평면/곡면 방정식 또는 메시).</p></li>
<li><p>절단면의 단위 법선 <span class="math inline">\(\mathbf{n}_\Sigma\)</span> (방향 잠금).</p></li>
<li><p>절단면의 면적 <span class="math inline">\(A_\Sigma\)</span> (계산 규약 잠금).</p></li>
</ol>
<p>측정 시간 창은 틱 구간 <span class="math inline">\([n_1,n_2)\)</span>로 정의하며, 실현 시간 길이는
<span class="math display">\[\Delta T := (n_2-n_1)\Delta t
\label{eq:deltaT}\]</span>
로 잠긴다. <span class="math inline">\(\Delta t\)</span>는 <code>realization_lock</code>에 잠겨야 한다.</p>
<h4 data-number="6.6.4.2" id="l1rightarrowl2-사상-사건의-횡단-부호-s_sigmae"><span class="header-section-number">6.6.4.2</span> 4.1.4.2 L1<span class="math inline">\(\rightarrow\)</span>L2 사상: 사건의 횡단 부호 <span class="math inline">\(s_\Sigma(e)\)</span></h4>
<p>절단면 <span class="math inline">\(\Sigma\)</span>에 대해 “측면 판정 함수” <span class="math inline">\(\sigma_\Sigma(i)\in\{-1,+1\}\)</span>를 정의한다.
<span class="math display">\[\sigma_\Sigma(i)=
\begin{cases}
+1, &amp; \Omega_i \text{의 대표점(잠금된 대표점 규약)이 }\Sigma\text{의 }+\text{측에 위치},\\
-1, &amp; \Omega_i \text{의 대표점이 }\Sigma\text{의 }-\text{측에 위치}.
\end{cases}
\label{eq:side_function}\]</span>
대표점 규약(예: 점유 영역 중심, 선택된 표지점 등)은 <code>analysis_lock</code>에 잠긴다.</p>
<p>사건 <span class="math inline">\(e\)</span>의 전/후 배치에서 <span class="math inline">\(\sigma_\Sigma\)</span>의 변화로부터 사건의 횡단 부호를 정의한다.
<span class="math display">\[s_\Sigma(e)
:=
\frac{1}{2}\sum_{i\in\mathcal{V}(e)}
\Bigl(\sigma_\Sigma^{\mathrm{post}}(i)-\sigma_\Sigma^{\mathrm{pre}}(i)\Bigr).
\label{eq:crossing_sign}\]</span>
정의상 <span class="math inline">\(s_\Sigma(e)\in\mathbb{Z}\)</span>이며, 사건이 절단면을 횡단하지 않으면 <span class="math inline">\(s_\Sigma(e)=0\)</span>이 된다. 사건 로그가 전/후 배치를 갖지 않으면 <span class="math inline">\(s_\Sigma(e)\)</span>는 정의 불능이다.</p>
<p>측정 창 <span class="math inline">\([n_1,n_2)\)</span>에서 순횡단 수를 다음으로 정의한다.
<span class="math display">\[\Delta N_\Sigma
:=
\sum_{e:\ n_1\le n(e)&lt;n_2} s_\Sigma(e).
\label{eq:deltaN}\]</span>
<span class="math inline">\(\Delta N_\Sigma\)</span>는 L2의 순수 집계량이다(단위 없음).</p>
<h4 data-number="6.6.4.3" id="l2rightarrowl3-사상-유속토큰-플럭스-j"><span class="header-section-number">6.6.4.3</span> 4.1.4.3 L2<span class="math inline">\(\rightarrow\)</span>L3 사상: 유속(토큰 플럭스) <span class="math inline">\(J\)</span></h4>
<p>flux는 “토큰”의 흐름으로 정의한다. 토큰의 크기는 VP 단위 부피 <span class="math inline">\(a^3\)</span>로 잠근다. 따라서 flux는 다음으로 정의한다.
<span class="math display">\[J
:=
\frac{a^{3}}{A_\Sigma\,\Delta T}\,\Delta N_\Sigma.
\label{eq:flux_def}\]</span>
이 정의에서 <span class="math inline">\(a\)</span>는 실현 길이 스케일이고, <span class="math inline">\(\Delta T\)</span>는 <a data-reference="eq:deltaT" data-reference-type="eqref" href="#eq:deltaT">[eq:deltaT]</a>로 정의되며, <span class="math inline">\(A_\Sigma\)</span>는 절단면의 실현 면적이다.
<span class="math inline">\(J\)</span>의 차원은 <span class="math inline">\([L T^{-1}]\)</span>로 잠기며, 이는 토큰 부피(길이<span class="math inline">\(^3\)</span>)를 면적(길이<span class="math inline">\(^2\)</span>)과 시간으로 나눈 결과로 고정된다.</p>
<p>방향을 포함한 flux 벡터가 필요하면 다음으로 정의한다.
<span class="math display">\[\mathbf{J}
:=
J\,\mathbf{n}_\Sigma.
\label{eq:flux_vector}\]</span>
이때 <span class="math inline">\(\mathbf{n}_\Sigma\)</span>가 잠기지 않으면 <span class="math inline">\(\mathbf{J}\)</span>는 정의 불능이다.</p>
<h4 data-number="6.6.4.4" id="flux-정의의-실패모드정의-불능-조건"><span class="header-section-number">6.6.4.4</span> 4.1.4.4 flux 정의의 실패모드(정의 불능 조건)</h4>
<p>flux 정의가 성립하지 않는 조건(실패모드)은 다음으로 고정한다.</p>
<ol>
<li><p><strong>FM-NODEF</strong>: 사건 로그에 전/후 배치가 없거나, <span class="math inline">\(\mathcal{V}(e)\)</span>가 누락되어 <span class="math inline">\(s_\Sigma(e)\)</span>가 정의되지 않음.</p></li>
<li><p><strong>FM-SYM</strong>: 절단면 <span class="math inline">\(\Sigma\)</span>의 방향 또는 면적 <span class="math inline">\(A_\Sigma\)</span>가 잠기지 않음.</p></li>
<li><p><strong>FM-SCOPE</strong>: 절단면이 도메인 <span class="math inline">\(\mathcal{D}_{\square}\)</span>와 일관되게 정의되지 않음(도메인 밖 정의 또는 셀 기하 혼합).</p></li>
<li><p><strong>FM-NUMERIC</strong>: 대표점 규약이 잠기지 않거나, 동일 사건에서 대표점 선택이 불안정하여 <span class="math inline">\(s_\Sigma(e)\)</span>가 재현되지 않음.</p></li>
</ol>
<h3 data-number="6.6.5" id="deficit의-11-정의접촉-결손-구조-결손의-운영량"><span class="header-section-number">6.6.5</span> 4.1.5 deficit의 1:1 정의(접촉 결손: 구조 결손의 운영량)</h3>
<h4 data-number="6.6.5.1" id="l1-입력구조-접촉-차수-z_i"><span class="header-section-number">6.6.5.1</span> 4.1.5.1 L1 입력(구조): 접촉 차수 <span class="math inline">\(z_i\)</span></h4>
<p>접촉 그래프 <span class="math inline">\(\mathcal{G}_c=(\mathcal{V},\mathcal{E}_c)\)</span>에서 각 VP <span class="math inline">\(i\)</span>의 접촉 차수(차수)를 다음으로 정의한다.
<span class="math display">\[z_i := |\mathcal{N}(i)|,
\qquad
\mathcal{N}(i):=\{\,j\in\mathcal{V}\ |\ (i,j)\in\mathcal{E}_c\,\}.
\label{eq:degree_deficit}\]</span>
접촉 판정 <span class="math inline">\(C(i,j)\)</span>가 잠기지 않으면 <span class="math inline">\(z_i\)</span>는 정의 불능이다.</p>
<h4 data-number="6.6.5.2" id="l1rightarrowl2-사상-기준-차수-z_mathrmref와-결손-d_i"><span class="header-section-number">6.6.5.2</span> 4.1.5.2 L1<span class="math inline">\(\rightarrow\)</span>L2 사상: 기준 차수 <span class="math inline">\(z_{\mathrm{ref}}\)</span>와 결손 <span class="math inline">\(d_i\)</span></h4>
<p>deficit은 “기준 접촉 수준 대비 결손”으로 정의한다. 기준 차수 <span class="math inline">\(z_{\mathrm{ref}}\)</span>는 <code>analysis_lock</code>에 다음 규약으로 잠긴다.</p>
<ol>
<li><p><span class="math inline">\(z_{\mathrm{ref}}\in\mathbb{Z}_{\ge 0}\)</span>.</p></li>
<li><p><span class="math inline">\(z_{\mathrm{ref}}\)</span>는 접촉 판정 규약, 차원(2D/3D), 도메인 경계 처리 규약에 종속될 수 있으며, 종속성은 스코프(scope)로 잠긴다.</p></li>
<li><p><span class="math inline">\(z_{\mathrm{ref}}\)</span>의 선택은 사후 보정으로 변경될 수 없으며, 변경은 버전업으로만 허용된다.</p></li>
</ol>
<p>각 VP의 결손을 다음으로 정의한다.
<span class="math display">\[d_i := \max\bigl(0,\ z_{\mathrm{ref}}-z_i\bigr).
\label{eq:di_def}\]</span>
셀 단위 결손을 다음으로 정의한다.
<span class="math display">\[\mathcal{D}_{\mathrm{def}}
:=
\frac{1}{|\mathcal{V}|}\sum_{i\in\mathcal{V}} d_i.
\label{eq:deficit_cell}\]</span>
<span class="math inline">\(\mathcal{D}_{\mathrm{def}}\)</span>는 L2의 무차원 결손 지표이다.</p>
<h4 data-number="6.6.5.3" id="l2rightarrowl3-사상-결손-밀도필요-시"><span class="header-section-number">6.6.5.3</span> 4.1.5.3 L2<span class="math inline">\(\rightarrow\)</span>L3 사상: 결손 밀도(필요 시)</h4>
<p>결손을 공간 밀도로 사용할 경우 다음을 파생 정의로 고정한다.
<span class="math display">\[\rho_{\mathrm{def}}
:=
\frac{1}{V_{\square}}\sum_{i\in\mathcal{V}} d_i
=
\frac{|\mathcal{V}|}{V_{\square}}\ \mathcal{D}_{\mathrm{def}},
\qquad
V_{\square}:=D_{\mathrm{anch}}^{3}.
\label{eq:deficit_density}\]</span>
<span class="math inline">\(\rho_{\mathrm{def}}\)</span>의 차원은 <span class="math inline">\([L^{-3}]\)</span>로 잠기며, <span class="math inline">\(V_{\square}\)</span>는 셀 기하(큐브)와 <span class="math inline">\(D_{\mathrm{anch}}\)</span> 의미 잠금이 성립할 때만 사용 가능하다. 결손 밀도는 <em>선택적 파생량</em>이며, 사용 여부는 <code>analysis_lock</code>에 잠긴다.</p>
<h4 data-number="6.6.5.4" id="deficit-정의의-실패모드정의-불능-조건"><span class="header-section-number">6.6.5.4</span> 4.1.5.4 deficit 정의의 실패모드(정의 불능 조건)</h4>
<p>deficit 정의가 성립하지 않는 조건(실패모드)은 다음으로 고정한다.</p>
<ol>
<li><p><strong>FM-SYM</strong>: 접촉 판정 규약이 잠기지 않아 <span class="math inline">\(z_i\)</span>가 정의되지 않음.</p></li>
<li><p><strong>FM-SCOPE</strong>: <span class="math inline">\(z_{\mathrm{ref}}\)</span>의 스코프(차원/경계 처리/프로토콜)가 잠기지 않아 기준이 붕괴함.</p></li>
<li><p><strong>FM-NONUNIQUE</strong>: <span class="math inline">\(z_{\mathrm{ref}}\)</span>가 동일 버전 내부에서 이동하거나 복수 값으로 혼용됨.</p></li>
<li><p><strong>FM-NUMERIC</strong>: 접촉 그래프 구성 규약이 잠기지 않아 <span class="math inline">\(z_i\)</span>가 재현되지 않음.</p></li>
</ol>
<h3 data-number="6.6.6" id="charge의-11-정의셸-상쇄-rightarrow-생존-벡터-rightarrow-부호"><span class="header-section-number">6.6.6</span> 4.1.6 charge의 1:1 정의(셸 상쇄 <span class="math inline">\(\rightarrow\)</span> 생존 벡터 <span class="math inline">\(\rightarrow\)</span> 부호)</h3>
<h4 data-number="6.6.6.1" id="l1-입력구조-셸-벡터-집합과-상쇄-규약"><span class="header-section-number">6.6.6.1</span> 4.1.6.1 L1 입력(구조): 셸 벡터 집합과 상쇄 규약</h4>
<p>charge는 “셸 구조에서 남는 방향성의 부호”로 정의한다. 이를 위해 셸 벡터 집합을 다음으로 정의한다.
<span class="math display">\[\mathcal{S} := \{\mathbf{s}_k\}_{k=1}^{7},
\qquad
\mathbf{s}_k \in \mathbb{R}^3.
\label{eq:shell_vectors}\]</span>
<span class="math inline">\(\mathbf{s}_k\)</span>의 좌표계, 스케일(내부 단위), 벡터의 생성 규약(어떤 구조량을 벡터로 담는지)은 <code>analysis_lock</code>에 잠겨야 한다.</p>
<p>상쇄 규약은 다음을 동시에 잠근다.</p>
<ol>
<li><p>7개 중 6개를 상쇄 항으로 배정하는 규칙(예: 쌍/사중 묶음 등)과 그 고정 순서.</p></li>
<li><p>상쇄 판정(두 벡터가 상쇄되는 조건)의 기준(내적/각도/성분 규약 등).</p></li>
<li><p>남는 1개(또는 남는 합)의 정의 방식(생존 벡터).</p></li>
</ol>
<p>상쇄 규약이 잠기지 않으면 charge는 정의 불능이다.</p>
<h4 data-number="6.6.6.2" id="l1rightarrowl2-사상-생존-벡터-mathbfv와-부호-지표-q"><span class="header-section-number">6.6.6.2</span> 4.1.6.2 L1<span class="math inline">\(\rightarrow\)</span>L2 사상: 생존 벡터 <span class="math inline">\(\mathbf{V}\)</span>와 부호 지표 <span class="math inline">\(q\)</span></h4>
<p>생존 벡터를 다음으로 정의한다.
<span class="math display">\[\mathbf{V}
:=
\sum_{k=1}^{7}\mathbf{s}_k,
\label{eq:survival_vector}\]</span>
단, <a data-reference="eq:survival_vector" data-reference-type="eqref" href="#eq:survival_vector">[eq:survival_vector]</a>는 “상쇄 규약에 의해 상쇄 항들이 서로 상쇄된 후의 잔차”와 동치인 표현으로만 사용한다. 실제 계산에서 상쇄 항을 명시적으로 구성하는 경우, 상쇄 구성은 <code>analysis_lock</code>에 잠긴다.</p>
<p>부호 판정 축(전하 축) <span class="math inline">\(\mathbf{n}_Q\)</span>를 다음과 같이 잠근다.
<span class="math display">\[\mathbf{n}_Q \in \{\hat{\mathbf{x}},\hat{\mathbf{y}},\hat{\mathbf{z}}\}\ \text{또는 사전 등록된 단위 벡터},
\qquad
\|\mathbf{n}_Q\|=1.
\label{eq:charge_axis}\]</span>
<span class="math inline">\(\mathbf{n}_Q\)</span>는 결과를 본 뒤 선택될 수 없으며, 선택 규칙은 <code>analysis_lock</code>에 잠긴다.</p>
<p>부호 지표를 다음으로 정의한다.
<span class="math display">\[q
:=
\mathrm{sgn}\!\left(\mathbf{V}\cdot\mathbf{n}_Q\right),
\qquad
\mathrm{sgn}(x)=
\begin{cases}
+1,&amp; x&gt;0,\\
0,&amp; x=0,\\
-1,&amp; x&lt;0.
\end{cases}
\label{eq:q_sign}\]</span>
여기서 <span class="math inline">\(q=0\)</span>은 “부호 판정 불능 또는 중립”을 뜻하며, <span class="math inline">\(q=0\)</span>이 결론으로 사용 가능한지 여부(허용/금지)는 <code>analysis_lock</code>의 PASS.rules에 의해 잠긴다.</p>
<h4 data-number="6.6.6.3" id="l2rightarrowl3-사상-전하-q와-전하-밀도"><span class="header-section-number">6.6.6.3</span> 4.1.6.3 L2<span class="math inline">\(\rightarrow\)</span>L3 사상: 전하 <span class="math inline">\(Q\)</span>와 전하 밀도</h4>
<p>전하 단위 <span class="math inline">\(q_0\)</span>를 <code>canon_lock</code>에 다음과 같이 잠근다.
<span class="math display">\[q_0 \ \text{는 전하 차원 }[Q]\text{의 기본 단위이며, 값은 }q_0:=1\ \text{(단위계 내부)}.
\label{eq:q0_lock}\]</span>
전하는 다음으로 정의한다.
<span class="math display">\[Q := q_0\,q.
\label{eq:charge_def}\]</span>
전하의 공간 밀도가 필요한 경우 다음 파생 정의를 사용한다.
<span class="math display">\[\rho_Q := \frac{Q}{V_{\square}},
\qquad
V_{\square}:=D_{\mathrm{anch}}^{3}.
\label{eq:charge_density}\]</span>
<span class="math inline">\(\rho_Q\)</span>의 차원은 <span class="math inline">\([Q L^{-3}]\)</span>로 잠긴다.</p>
<h4 data-number="6.6.6.4" id="charge-정의의-실패모드정의-불능-조건"><span class="header-section-number">6.6.6.4</span> 4.1.6.4 charge 정의의 실패모드(정의 불능 조건)</h4>
<p>charge 정의가 성립하지 않는 조건(실패모드)은 다음으로 고정한다.</p>
<ol>
<li><p><strong>FM-STR</strong>: 셸 벡터 생성 규약 또는 상쇄 규약이 잠기지 않음(구조 불명).</p></li>
<li><p><strong>FM-SYM</strong>: <span class="math inline">\(\mathbf{n}_Q\)</span> 또는 좌표계 정의가 잠기지 않음(방향 의미 불명).</p></li>
<li><p><strong>FM-NONUNIQUE</strong>: 상쇄 규약이 다중 해를 허용하여 <span class="math inline">\(\mathbf{V}\)</span>가 비유일함.</p></li>
<li><p><strong>FM-SCOPE</strong>: 셸(7) 구조가 해당 레짐에서 정의되지 않는데도 charge를 호출함.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-19">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: pressure/flux/deficit/charge의 기호/타입/차원/단위 및 운영 절차(1:1 사상)를 <code>analysis_lock</code>의 <code>semantic_maps</code>로 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 셀 의미(<code>CELL-CUBE</code>, <code>edge</code>), <span class="math inline">\(a,\Delta t,U_{\mathrm{lat}},q_0\)</span>의 단위계 귀속을 각 LOCK(<code>canon</code>/<code>realization</code>)에 고정.</p></li>
<li><p>Gate: 의미 충돌(기호/단위/셀 기하/지름-반지름)은 G-SYM에서 즉시 <code>FAIL</code>.</p></li>
<li><p>Gate: 절차 미잠금(접촉 판정/완화 규칙/상쇄 규약/대표점 규약)은 G-LOCK 및 G-STR에서 <code>FAIL</code> 또는 <code>INCONCLUSIVE</code>.</p></li>
<li><p>Gate: 사후조정(문턱 이동, 규약 교체, 선택 편향)은 G-NT에서 <code>FAIL</code> 라벨을 부여.</p></li>
</ul>
<h2 data-number="6.7" id="closure-타입스택dag-규칙"><span class="header-section-number">6.7</span> 4.2 Closure 타입·스택·DAG 규칙</h2>
<h3 data-number="6.7.1" id="닫힘closure의-위치와-목적"><span class="header-section-number">6.7.1</span> 4.2.1 닫힘(Closure)의 위치와 목적</h3>
<p>닫힘(closure)은 공리([A])와 정의([D])만으로는 결정되지 않는 선택을 <strong>명시적 규칙</strong>으로 봉인하는 장치이다. 닫힘은 “추가 가정”이 아니라 “선택 규칙의 문서화”이며, 닫힘이 존재하는 이유는 다음 두 가지로 고정한다.</p>
<ol>
<li><p><strong>결정 불능의 해소</strong>: 입력이 주어져도 출력이 다중 해이거나 비유일한 경우, 그 중 어떤 해를 사용할지 결정하는 규칙이 필요하다.</p></li>
<li><p><strong>절차의 봉인</strong>: 동일 입력에 대해 알고리즘/추정기/경계 처리/정규화에 따라 출력이 달라질 수 있으므로, 절차를 잠그지 않으면 동일 결론이 성립할 수 없다.</p></li>
</ol>
<p>따라서 닫힘은 항상 (i) 입력/출력 타입, (ii) 선택 규칙(가정), (iii) 적용 범위(레짐), (iv) 실패모드, (v) Gate 스택을 포함해야 하며, 이 다섯 요소 중 하나라도 빠지면 닫힘은 사용 불가이다.</p>
<h3 data-number="6.7.2" id="closure-타입표준-분류"><span class="header-section-number">6.7.2</span> 4.2.2 Closure 타입(표준 분류)</h3>
<p>본 문서에서 닫힘은 “무엇을 닫는가”에 따라 다음 표준 타입으로 분류한다. 타입은 <code>analysis_lock</code>에 잠기며, 닫힘 ID는 타입을 포함하는 이름 공간을 따른다.</p>
<h3 data-number="6.7.3" id="cl-s-의미층-사상-닫힘semantic-map-closure"><span class="header-section-number">6.7.3</span> (CL-S) 의미층 사상 닫힘(Semantic-map Closure)</h3>
<p>L1<span class="math inline">\(\rightarrow\)</span>L2 또는 L2<span class="math inline">\(\rightarrow\)</span>L3 사상에서 선택이 필요한 경우의 닫힘이다. 예: 목(throat)의 대표값을 평균으로 둘지 최소절단으로 둘지, 사건 집계 창을 어떻게 둘지 등.</p>
<h3 data-number="6.7.4" id="cl-g-그래프경로-닫힘graphpath-closure"><span class="header-section-number">6.7.4</span> (CL-G) 그래프/경로 닫힘(Graph/Path Closure)</h3>
<p>접촉 그래프 구성, 임계목 정의, 경로 선택, 백본 선택, 최소절단 계산 방식 등 그래프 기반 선택을 닫는 닫힘이다. 예: 경계 노드 정의, 가중치 부여, 동치 규칙 등.</p>
<h3 data-number="6.7.5" id="cl-r-레짐-닫힘regime-closure"><span class="header-section-number">6.7.5</span> (CL-R) 레짐 닫힘(Regime Closure)</h3>
<p>어떤 적용 범위에서 어떤 규칙이 유효한지(재밍/비재밍, 회전 구동/비구동, 선형/비선형 등)를 닫는 닫힘이다. 레짐 조건을 바꾸면 동일 결론이 유지되지 않으므로 레짐 닫힘은 모든 결론의 전제이다.</p>
<h3 data-number="6.7.6" id="cl-n-수치-안정-닫힘numerical-closure"><span class="header-section-number">6.7.6</span> (CL-N) 수치 안정 닫힘(Numerical Closure)</h3>
<p>수렴, 종료 조건, 민감도, 반복 횟수, 허용 오차, 스텝 정책 등 수치 절차를 닫는 닫힘이다. 이 닫힘은 결과를 “얻기 위해”가 아니라 결과가 “동일하게 재현되도록” 하기 위해 존재한다.</p>
<h3 data-number="6.7.7" id="cl-x-교차정합-닫힘cross-consistency-closure"><span class="header-section-number">6.7.7</span> (CL-X) 교차정합 닫힘(Cross-consistency Closure)</h3>
<p>서로 독립인 채널/기준/입력 조합이 동일 결론으로 정합되는지를 판정하는 교차정합 규칙을 닫는 닫힘이다. 교차정합 닫힘은 문턱값, 비교량, 판정 방식의 선택을 포함한다.</p>
<h3 data-number="6.7.8" id="cl-p-프로토콜-닫힘protocol-closure"><span class="header-section-number">6.7.8</span> (CL-P) 프로토콜 닫힘(Protocol Closure)</h3>
<p>입력 파일 형식, 로그 스키마, 시드 정책, 환경 고정 등 실행 규약을 닫는 닫힘이다. 프로토콜 닫힘은 재현 Gate의 전제이며, 스냅샷 봉인의 전제이다.</p>
<h3 data-number="6.7.9" id="closure-id-규칙식별자와-네임스페이스"><span class="header-section-number">6.7.9</span> 4.2.3 Closure ID 규칙(식별자와 네임스페이스)</h3>
<p>각 닫힘은 <strong>closure_id</strong>로 식별한다. closure_id는 다음 형식으로 고정한다.
<span class="math display">\[\texttt{CL-}\langle\texttt{TYPE}\rangle\texttt{-}\langle\texttt{TOPIC}\rangle\texttt{-}\langle\texttt{NNN}\rangle,
\label{eq:closure_id_format}\]</span>
여기서</p>
<ul>
<li><p><code>TYPE</code>은 <code>S,G,R,N,X,P</code> 중 하나,</p></li>
<li><p><code>TOPIC</code>은 닫힘이 다루는 주제(예: <code>THROAT</code>, <code>BACKBONE</code>, <code>EVENTWIN</code>, <code>ANCHOR</code>, <code>RCROSS</code> 등),</p></li>
<li><p><code>NNN</code>은 001부터 증가하는 일련번호이다.</p></li>
</ul>
<p>동일 <code>TYPE</code>과 <code>TOPIC</code>에 대해 복수 닫힘이 공존할 수 있으나, 동일 결론(claim_id)에서 동시에 채택될 수 있는 닫힘은 <strong>하나</strong>로 제한된다(동일 토픽에서의 다중 채택 금지). 다중 채택이 필요하면 토픽을 분해하여 서로 다른 토픽으로 분리해야 한다.</p>
<h3 data-number="6.7.10" id="닫힘의-입출력-타입-규칙층차원객체-귀속"><span class="header-section-number">6.7.10</span> 4.2.4 닫힘의 입출력 타입 규칙(층/차원/객체 귀속)</h3>
<p>닫힘은 입력과 출력의 타입을 명시해야 한다. 타입은 다음 네 요소로 구성된다.</p>
<ol>
<li><p><strong>층(layer)</strong>: L0/L1/L2/L3 중 어디에 속하는지.</p></li>
<li><p><strong>객체 귀속(object_id)</strong>: 어떤 객체의 양인지(예: <code>OBJ-THROAT</code>, <code>OBJ-PATH</code>, <code>OBJ-EVENT</code> 등).</p></li>
<li><p><strong>기호(symbol)</strong>: 본문에서 사용되는 기호(단일 의미로 잠김).</p></li>
<li><p><strong>차원/단위(dimension/unit)</strong>: 무차원(1) 또는 길이/시간/질량/에너지/힘 등 차원과 단위 체계(SI/internal).</p></li>
</ol>
<p>닫힘의 입력/출력 타입이 불명확하거나, 동일 기호가 서로 다른 타입으로 등장하면 정의 충돌이며 닫힘은 사용 불가이다.</p>
<h3 data-number="6.7.11" id="닫힘의-가정-필드선택-규칙의-명시"><span class="header-section-number">6.7.11</span> 4.2.5 닫힘의 “가정” 필드(선택 규칙의 명시)</h3>
<p>닫힘이 포함하는 “가정(assumptions)”은 다음 규약으로 고정한다.</p>
<ol>
<li><p>가정은 <strong>선택 규칙</strong>의 형태로만 존재한다. 즉, “무엇을 선택했는가”를 기계적으로 판독 가능한 문장으로 기록한다.</p></li>
<li><p>가정은 “추가 실체”를 도입하지 않는다. (예: 새로운 연속장, 새로운 전역 목적함수, 새로운 확률분포의 공리화 등은 닫힘의 범위를 벗어난다.)</p></li>
<li><p>가정은 적용 범위(scope)를 반드시 가진다. 범위가 없는 가정은 전역 가정으로 오해될 수 있으므로 금지된다.</p></li>
<li><p>가정은 결과를 본 뒤 변경될 수 없다. 변경은 버전업(새 analysis_lock_id)으로만 허용된다.</p></li>
</ol>
<h3 data-number="6.7.12" id="gate-스택필수과-passfail-판정-연결"><span class="header-section-number">6.7.12</span> 4.2.6 Gate 스택(필수)과 PASS/FAIL 판정 연결</h3>
<p>모든 닫힘은 자신이 요구하는 Gate 스택을 가진다. Gate 스택의 목적은 닫힘이 포함하는 선택이 결론 자격을 얻기 위한 <strong>필수 조건</strong>이 되게 만드는 것이다. Gate 스택은 다음 규약으로 고정한다.</p>
<ol>
<li><p><strong>필수 기본 Gate</strong>: 모든 닫힘은 최소한 G-SYM, G-LOCK, G-REG, G-NT를 요구한다.</p></li>
<li><p><strong>타입별 추가 Gate</strong>: 닫힘 타입에 따라 다음 Gate를 추가로 요구한다.</p>
<ul>
<li><p>CL-S: (필요 시) G-NUM</p></li>
<li><p>CL-G: (필요 시) G-STR, G-NUM</p></li>
<li><p>CL-R: (필요 시) G-REG(강화), G-STR</p></li>
<li><p>CL-N: G-NUM</p></li>
<li><p>CL-X: G-RCROSS, (필요 시) G-NUM</p></li>
<li><p>CL-P: G-REP</p></li>
</ul></li>
<li><p><strong>판정의 우선성</strong>: 닫힘이 요구하는 Gate 중 하나라도 <code>FAIL</code> 또는 <code>INCONCLUSIVE</code>이면, 닫힘을 사용하는 결론은 결론 자격을 얻지 못한다.</p></li>
<li><p><strong>실패모드 라벨링</strong>: <code>FAIL</code>/<code>INCONCLUSIVE</code>의 원인은 실패모드(FM-*) 또는 No-Tuning 위반(FAIL-NT-*) 라벨로 분해되어 기록된다.</p></li>
</ol>
<h3 data-number="6.7.13" id="closure-dag-규칙순환-의존-금지"><span class="header-section-number">6.7.13</span> 4.2.7 Closure DAG 규칙(순환 의존 금지)</h3>
<p>닫힘은 서로 의존할 수 있으나, 의존성은 반드시 DAG(순환 없는 방향 그래프)이어야 한다. 닫힘 DAG 규칙은 다음으로 고정한다.</p>
<h4 data-number="6.7.13.1" id="노드와-간선"><span class="header-section-number">6.7.13.1</span> 4.2.7.1 노드와 간선</h4>
<p>닫힘 집합을 <span class="math inline">\(\mathcal{C}\)</span>라 하고, 각 닫힘을 <span class="math inline">\(c\in\mathcal{C}\)</span>로 표기한다. 닫힘 DAG는 다음으로 정의한다.
<span class="math display">\[\mathcal{G}_{\mathrm{CL}} := (\mathcal{C}, \mathcal{E}_{\mathrm{CL}}),
\label{eq:closure_dag_def}\]</span>
여기서 <span class="math inline">\((c_i,c_j)\in\mathcal{E}_{\mathrm{CL}}\)</span>는 “닫힘 <span class="math inline">\(c_j\)</span>가 <span class="math inline">\(c_i\)</span>의 출력에 의존한다”를 의미한다.</p>
<h4 data-number="6.7.13.2" id="순환-금지acyclic-조건"><span class="header-section-number">6.7.13.2</span> 4.2.7.2 순환 금지(acyclic) 조건</h4>
<p>DAG 조건은 다음으로 고정한다.
<span class="math display">\[\text{$\mathcal{G}_{\mathrm{CL}}$에는 유향 순환이 존재하지 않는다}.
\label{eq:acyclic_rule}\]</span>
즉, <span class="math inline">\(c_1\to c_2\to\cdots\to c_k\to c_1\)</span> 형태의 경로가 존재하면 그 닫힘 집합은 사용 불가이다.</p>
<h4 data-number="6.7.13.3" id="순환-발생의-대표-패턴금지"><span class="header-section-number">6.7.13.3</span> 4.2.7.3 순환 발생의 대표 패턴(금지)</h4>
<p>순환은 다음 대표 패턴에서 발생한다. 이 패턴은 금지 규칙으로 고정한다.</p>
<ol>
<li><p><strong>문턱-출력 순환</strong>: 어떤 닫힘의 출력이 Gate 문턱을 결정하고, 그 문턱이 다시 같은 닫힘의 출력 선택을 바꾸는 경우.</p></li>
<li><p><strong>채널-정합 순환</strong>: 교차정합 닫힘에서 선택된 채널이 출력에 의해 다시 선택/제외되는 경우.</p></li>
<li><p><strong>레짐-선택 순환</strong>: 레짐 닫힘이 출력 지표로 레짐을 재분류하고, 그 재분류가 다시 닫힘 선택을 바꾸는 경우.</p></li>
<li><p><strong>사후 선택 순환</strong>: 여러 후보 해 중 “좋은” 해를 선택하는 규칙이 출력 값에 의존하는 경우(사후조정의 형태).</p></li>
</ol>
<p>위 패턴이 나타나면 닫힘 정의는 <code>analysis_lock</code>에서 거부되며, 결론은 자동으로 <code>FAIL</code> 또는 <code>INCONCLUSIVE</code>로 판정된다.</p>
<h4 data-number="6.7.13.4" id="위상-정렬과-실행-순서"><span class="header-section-number">6.7.13.4</span> 4.2.7.4 위상 정렬과 실행 순서</h4>
<p>DAG가 성립하면 닫힘들은 위상 정렬 가능한 순서를 갖는다. 실행 순서를 <span class="math inline">\(\prec\)</span>로 표기하면,
<span class="math display">\[c_i \prec c_j \quad \Longleftrightarrow \quad (c_i,c_j)\in\mathcal{E}_{\mathrm{CL}} \ \text{또는 그로부터 유도되는 선행 관계}.
\label{eq:toposort_rule}\]</span>
유도 및 Gate 실행은 반드시 <span class="math inline">\(\prec\)</span> 순서를 따른다. 순서를 어기면 의존 입력이 존재하지 않으므로 정의 불능이며 <code>INCONCLUSIVE</code>로 판정된다.</p>
<h3 data-number="6.7.14" id="닫힘-양식표준-템플릿"><span class="header-section-number">6.7.14</span> 4.2.8 닫힘 양식(표준 템플릿)</h3>
<p>아래는 닫힘을 레지스트리에 기록하는 표준 양식이다. 키 구조와 필드는 고정되며, 누락 시 닫힘은 사용 불가이다.</p>
<pre><code>closures:
  - closure_id: CL-G-THROAT-001
    type: CL-G
    topic: THROAT
    version: (analysis_lock_id 내에서의 로컬 버전)
    scope: (레짐 식별자 또는 조건식)
    inputs:
      - layer: L1
        object_id: OBJ-THROAT
        symbol: delta_gap
        dimension: L
        unit_system: internal
    outputs:
      - layer: L2
        quantity_id: Q-THROAT-DELTAEFF
        symbol: delta_eff
        dimension: L
        unit_system: internal
    assumptions:
      - "임계목은 접촉 그래프에서 최소 절단 기반으로 정의한다"
      - "가중치 규약은 W_THROAT를 따른다"
      - "대표값은 중앙값이 아니라 최소 절단 대표값으로 고정한다"
    algorithm:
      algorithm_id: ALG-THROAT-EST-001
      parameters_locked_by: analysis_lock_id
    dag:
      depends_on: [CL-R-REGIME-001, CL-P-PROTO-001]
    failure_modes:
      - FM-SYM
      - FM-SCOPE
      - FM-NONUNIQUE
      - FM-NUMERIC
    required_gates:
      - G-SYM
      - G-LOCK
      - G-REG
      - G-STR
      - G-NUM
      - G-NT
    pass_rules_hook:
      claim_types_allowed_on_pass: [CT-DER-FORM, CT-DER-NUM, CT-LIM]
      claim_types_forbidden_on_fail: [CT-DER-NUM, CT-XCROSS, CT-REP]</code></pre>
<p>위 템플릿에서 <code>dag.depends_on</code>은 닫힘 DAG의 간선 정보이며, <code>failure_modes</code>와 <code>required_gates</code>는 필수이다. <code>pass_rules_hook</code>은 PASS.rules에 연결되는 선언이며, “어떤 Gate PASS 시 어떤 문장 허용”의 문장 자격을 닫힘 단위로 연결한다.</p>
<h3 data-number="6.7.15" id="닫힘-스택closure-stack과-결론-귀속"><span class="header-section-number">6.7.15</span> 4.2.9 닫힘 스택(Closure Stack)과 결론 귀속</h3>
<p>하나의 결론(claim_id)은 하나 이상의 닫힘을 사용한다. 이를 닫힘 스택이라 부르며, 닫힘 스택은 다음 규약으로 고정한다.</p>
<ol>
<li><p>닫힘 스택은 <strong>순서</strong>를 갖는다. 순서는 닫힘 DAG의 위상 정렬에 의해 결정된다.</p></li>
<li><p>결론은 <strong>closure_ids</strong> 목록을 반드시 포함한다. 목록이 없는 결론은 근거를 잃으므로 결론 자격을 갖지 못한다.</p></li>
<li><p>닫힘 스택 중 하나라도 Gate에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>이면, 해당 결론은 결론 자격을 얻지 못한다.</p></li>
<li><p>서로 다른 <code>analysis_lock_id</code>의 닫힘 스택을 혼합하여 하나의 결론을 구성하는 행위는 금지된다.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-20">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 닫힘 타입(CL-S/CL-G/CL-R/CL-N/CL-X/CL-P), closure_id 형식, 입출력 타입(층/객체/기호/차원) 규약을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 닫힘 템플릿(closures: ...), 실패모드(FM-*), required_gates 필드의 의무화를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 닫힘 의존성 그래프 <span class="math inline">\(\mathcal{G}_{\mathrm{CL}}\)</span>는 DAG이어야 하며 순환 의존이 금지됨을 고정.</p></li>
<li><p>Gate: 닫힘이 요구하는 Gate 스택의 <code>PASS</code> 없이는 결론 자격이 부여되지 않음을 연결 고정.</p></li>
<li><p>Gate: 순환 의존, 사후 선택, 문턱 이동 등은 G-NT 또는 G-LOCK에서 <code>FAIL</code>로 판정됨을 연결 고정.</p></li>
</ul>
<h2 data-number="6.8" id="레짐맵적용-범위"><span class="header-section-number">6.8</span> 4.3 레짐맵(적용 범위)</h2>
<h3 data-number="6.8.1" id="레짐regime의-정의"><span class="header-section-number">6.8.1</span> 4.3.1 레짐(Regime)의 정의</h3>
<p>레짐은 “어떤 조건에서 어떤 정의/닫힘/판정이 유효한가”를 좌표로 표기한 것이다. 레짐은 단일 문장(예: “강성 레짐”)으로 서술되지 않으며, 반드시 레짐 좌표축의 값들로 구성된 튜플로 정의된다. 레짐은 다음 형태로 고정한다.
<span class="math display">\[\mathcal{R}
:=
\bigl(
R_{\mathrm{dim}},
R_{\mathrm{cell}},
R_{\mathrm{drive}},
R_{\mathrm{span}},
R_{\kappa},
R_{\mathrm{scale}},
R_{\mathrm{bc}},
R_{\mathrm{init}},
R_{\mathrm{obs}}
\bigr).
\label{eq:regime_tuple}\]</span>
여기서 각 성분은 아래 4.3.2에서 정의되는 레짐 좌표축 값이며, 레짐 좌표축은 <code>analysis_lock</code>에 잠긴다.</p>
<h3 data-number="6.8.2" id="레짐-좌표축좌표계의-표준"><span class="header-section-number">6.8.2</span> 4.3.2 레짐 좌표축(좌표계의 표준)</h3>
<p>본 절은 레짐 좌표축을 다음 9축으로 고정한다. 각 축은 값의 열거형 또는 운영 판정식(지시변수/임계 지표)으로 정의되며, “해석”으로 대체되지 않는다.</p>
<h3 data-number="6.8.3" id="a-차원-축-r_mathrmdim"><span class="header-section-number">6.8.3</span> (A) 차원 축 <span class="math inline">\(R_{\mathrm{dim}}\)</span></h3>
<p>차원 축은 도메인/접촉 그래프/절단면의 정의가 수행되는 차원을 의미한다.
<span class="math display">\[R_{\mathrm{dim}}\in\{\texttt{DIM-2},\ \texttt{DIM-3}\}.
\label{eq:reg_dim}\]</span>
차원은 <code>canon_lock</code>의 객체 정의 및 <code>analysis_lock</code>의 프로토콜에 의해 잠기며, 동일 산출물에서 혼합될 수 없다.</p>
<h3 data-number="6.8.4" id="b-셀-기하-축-r_mathrmcell"><span class="header-section-number">6.8.4</span> (B) 셀 기하 축 <span class="math inline">\(R_{\mathrm{cell}}\)</span></h3>
<p>셀 기하 축은 Anchor Cell의 정준 기하 타입을 의미한다.
<span class="math display">\[R_{\mathrm{cell}}\in\{\texttt{CELL-CUBE}\},
\label{eq:reg_cell}\]</span>
정준 레짐에서 <code>CELL-CUBE</code>만 허용한다. <code>CELL-SPHERE-VIS</code>는 시각화 변환이며 레짐 좌표축의 값이 아니다. 시각화 변환은 별도 <code>analysis_lock</code>의 <code>vis_mode</code>로만 잠기며, 정준 레짐을 대체하지 않는다.</p>
<h3 data-number="6.8.5" id="c-구동-축-r_mathrmdrive"><span class="header-section-number">6.8.5</span> (C) 구동 축 <span class="math inline">\(R_{\mathrm{drive}}\)</span></h3>
<p>구동 축은 배치 갱신(국소 갱신 합성)이 어떤 구동 조건을 포함하는지를 의미한다.
<span class="math display">\[R_{\mathrm{drive}}\in\{\texttt{DRV-NONE},\ \texttt{DRV-ROT}\}.
\label{eq:reg_drive}\]</span>
<code>DRV-ROT</code>은 회전 구동 입력(예: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>)의 존재 및 해당 프로토콜 잠금(구동 방식/종료 조건/샘플링)이 충족될 때만 성립한다. <code>DRV-ROT</code>의 성립 조건은 <code>analysis_lock</code>에 잠겨야 하며, 결과를 본 뒤 구동 축을 재분류하는 행위는 금지된다.</p>
<h3 data-number="6.8.6" id="d-스패닝-축-r_mathrmspan"><span class="header-section-number">6.8.6</span> (D) 스패닝 축 <span class="math inline">\(R_{\mathrm{span}}\)</span></h3>
<p>스패닝 축은 접촉 그래프가 도메인 대향 경계 집합을 연결하는지의 지시변수로 정의한다.
<span class="math display">\[R_{\mathrm{span}}\in\{\texttt{SPAN-0},\ \texttt{SPAN-1}\},
\qquad
R_{\mathrm{span}}:=\texttt{SPAN-}\chi_{\mathrm{span}}(\mathfrak{J}),
\label{eq:reg_span}\]</span>
여기서 <span class="math inline">\(\chi_{\mathrm{span}}(\mathfrak{J})\in\{0,1\}\)</span>는 3.2에서 정의된 스패닝 지시변수이다. 경계 집합과 경계 노드 정의가 잠기지 않으면 <span class="math inline">\(R_{\mathrm{span}}\)</span>은 정의 불능이며 레짐 선언 자체가 성립하지 않는다.</p>
<h3 data-number="6.8.7" id="e-병목-축-r_kappa"><span class="header-section-number">6.8.7</span> (E) 병목 축 <span class="math inline">\(R_{\kappa}\)</span></h3>
<p>병목 축은 최소 절단 크기(또는 그에 준하는 병목 지표)의 구간 분류로 정의한다.
<span class="math display">\[R_{\kappa}\in\{\texttt{KAPPA-0},\ \texttt{KAPPA-1},\ \texttt{KAPPA-GE2}\},
\label{eq:reg_kappa_enum}\]</span>
여기서 <span class="math inline">\(R_{\kappa}\)</span>는 다음 규칙으로 고정한다.
<span class="math display">\[\kappa_{\min}(\mathfrak{J})
\ \mapsto\
R_{\kappa}:=
\begin{cases}
\texttt{KAPPA-0}, &amp; \kappa_{\min}=0,\\
\texttt{KAPPA-1}, &amp; \kappa_{\min}=1,\\
\texttt{KAPPA-GE2}, &amp; \kappa_{\min}\ge 2.
\end{cases}
\label{eq:reg_kappa_map}\]</span>
<span class="math inline">\(\kappa_{\min}\)</span>의 계산 알고리즘(정확/근사, 가중/비가중, 경계 처리)은 <code>analysis_lock</code>에 잠긴다. 알고리즘이 잠기지 않으면 <span class="math inline">\(R_{\kappa}\)</span>는 정의 불능이다.</p>
<h3 data-number="6.8.8" id="f-스케일-창-축-r_mathrmscale"><span class="header-section-number">6.8.8</span> (F) 스케일 창 축 <span class="math inline">\(R_{\mathrm{scale}}\)</span></h3>
<p>스케일 창 축은 “해당 산출물이 어떤 내부 스케일 범위에서 집계/평가되었는가”를 의미한다. 스케일 창은 내부 무차원 지표 <span class="math inline">\(s\)</span>의 구간으로 잠근다.
<span class="math display">\[R_{\mathrm{scale}}\in\{\texttt{SCALE-LONG},\ \texttt{SCALE-MID},\ \texttt{SCALE-SHORT}\},
\label{eq:reg_scale_enum}\]</span>
여기서 <span class="math inline">\(s\)</span>는 <code>analysis_lock</code>에 잠긴 하나의 내부 지표(예: 그래프 거리 기반 길이, 경로 길이 기반 길이, 격자 인덱스 기반 길이 등)로 정의되며, 구간 분할 경계값
<span class="math display">\[0&lt;s_1&lt;s_2
\label{eq:scale_thresholds}\]</span>
은 <code>analysis_lock</code>에 문턱값으로 잠긴다. 스케일 창은 다음으로 고정한다.
<span class="math display">\[R_{\mathrm{scale}}:=
\begin{cases}
\texttt{SCALE-LONG}, &amp; s\ge s_2,\\
\texttt{SCALE-MID}, &amp; s_1\le s &lt; s_2,\\
\texttt{SCALE-SHORT}, &amp; 0&lt; s &lt; s_1.
\end{cases}
\label{eq:reg_scale_map}\]</span>
스케일 창 분류는 결과를 본 뒤 재분류될 수 없다.</p>
<h3 data-number="6.8.9" id="g-경계조건-축-r_mathrmbc"><span class="header-section-number">6.8.9</span> (G) 경계조건 축 <span class="math inline">\(R_{\mathrm{bc}}\)</span></h3>
<p>경계조건 축은 도메인 경계 처리의 타입을 의미한다.
<span class="math display">\[R_{\mathrm{bc}}\in\{\texttt{BC-CLOSED},\ \texttt{BC-OPEN},\ \texttt{BC-DRIVEN}\}.
\label{eq:reg_bc}\]</span>
<code>BC-DRIVEN</code>은 <code>DRV-ROT</code> 등 구동 축과 결합될 수 있으나 동일시되지 않는다. 경계조건은 프로토콜의 일부이며 <code>protocol_lock</code> 또는 <code>analysis_lock</code>에 잠겨야 한다.</p>
<h3 data-number="6.8.10" id="h-초기조건-축-r_mathrminit"><span class="header-section-number">6.8.10</span> (H) 초기조건 축 <span class="math inline">\(R_{\mathrm{init}}\)</span></h3>
<p>초기조건 축은 초기 배치(접촉 그래프/결손/결함 분포 등)의 분류이다.
<span class="math display">\[R_{\mathrm{init}}\in\{\texttt{INIT-RAW},\ \texttt{INIT-RELAXED},\ \texttt{INIT-PREJ}\}.
\label{eq:reg_init}\]</span>
<code>INIT-RELAXED</code>는 사전 등록된 완화 프로토콜을 통과하여 허용 배치가 확정된 초기조건을 의미한다. <code>INIT-PREJ</code>는 Point-J 주변을 샘플링하기 위해 사전 등록된 조절변수 창으로 초기조건을 생성한 경우를 의미하며, 생성 규칙과 창은 <code>analysis_lock</code>에 잠겨야 한다.</p>
<h3 data-number="6.8.11" id="i-관측집계-축-r_mathrmobs"><span class="header-section-number">6.8.11</span> (I) 관측/집계 축 <span class="math inline">\(R_{\mathrm{obs}}\)</span></h3>
<p>관측/집계 축은 사건 로그와 집계 창의 규약을 의미한다.
<span class="math display">\[R_{\mathrm{obs}}\in\{\texttt{OBS-EVENT},\ \texttt{OBS-STATIC},\ \texttt{OBS-HYBRID}\}.
\label{eq:reg_obs}\]</span>
<code>OBS-EVENT</code>는 사건 기반 집계(틱, 사건 전/후 배치)를 필수로 포함하는 관측 레짐을 의미한다. <code>OBS-STATIC</code>은 단일 배치의 구조 지표(접촉 차수, 절단, 경로 등)만을 집계하는 레짐을 의미한다. <code>OBS-HYBRID</code>는 두 방식을 함께 사용하되, 각 집계의 1:1 사상이 잠긴 경우만 성립한다.</p>
<h3 data-number="6.8.12" id="레짐-id와-레짐-선언의-표준-형식"><span class="header-section-number">6.8.12</span> 4.3.3 레짐 ID와 레짐 선언의 표준 형식</h3>
<p>레짐은 문자열 식별자 <code>regime_id</code>로 호출되며, <code>regime_id</code>는 <a data-reference="eq:regime_tuple" data-reference-type="eqref" href="#eq:regime_tuple">[eq:regime_tuple]</a>의 값들이 레지스트리에 고정되어 있을 때에만 유효하다. 레지스트리의 표준 템플릿은 다음으로 고정한다.</p>
<pre><code>regimes:
  - regime_id: R-BASE-001
    coords:
      dim: DIM-3
      cell: CELL-CUBE
      drive: DRV-NONE
      span: SPAN-1
      kappa: KAPPA-GE2
      scale: SCALE-LONG
      bc: BC-CLOSED
      init: INIT-RELAXED
      obs: OBS-EVENT
    allowed_closure_stacks:
      - stack_id: CS-BASE-CORE-001
        closures: [ ... ]
    forbidden_extrapolations:
      - "drive: DRV-ROT"
      - "dim: DIM-2"</code></pre>
<p><code>coords</code>가 누락되거나, 좌표축 값이 레지스트리의 열거형과 일치하지 않으면 레짐 선언은 무효이며, 해당 산출물은 <code>INCONCLUSIVE</code>로 판정된다.</p>
<h3 data-number="6.8.13" id="허용-closure-스택레짐별-허용-목록"><span class="header-section-number">6.8.13</span> 4.3.4 허용 closure 스택(레짐별 허용 목록)</h3>
<p>레짐은 “허용되는 닫힘 스택”을 함께 가진다. 허용 closure 스택은 (i) 사용 가능한 닫힘들의 목록, (ii) 스택 순서(닫힘 DAG의 위상 정렬), (iii) 레짐 추가 Gate 요구조건을 포함한다.
허용 closure 스택은 다음 규칙으로 고정한다.</p>
<ol>
<li><p>동일 <code>regime_id</code>에서 결론을 생성하는 모든 유도는 해당 레짐의 허용 closure 스택 중 하나를 선택하여 사용해야 한다.</p></li>
<li><p>허용 목록에 없는 닫힘을 사용하면 즉시 <code>FAIL</code>이다(레짐 위반).</p></li>
<li><p>허용 스택은 닫힘 DAG를 만족해야 하며, DAG를 위반하는 스택은 등록될 수 없다.</p></li>
<li><p>허용 스택의 변경은 <code>analysis_lock</code> 버전업으로만 가능하다.</p></li>
</ol>
<h4 data-number="6.8.13.1" id="기본-레짐의-허용-스택-예시정준-사슬"><span class="header-section-number">6.8.13.1</span> 4.3.4.1 기본 레짐의 허용 스택 예시(정준 사슬)</h4>
<p>정준 사슬(정준<span class="math inline">\(\rightarrow\)</span>구조<span class="math inline">\(\rightarrow\)</span>사건<span class="math inline">\(\rightarrow\)</span>실현<span class="math inline">\(\rightarrow\)</span>파생)의 최소 허용 스택은 다음 형태로 고정한다(항목명은 예시이며, 실제 사용은 closure_id로만 이루어진다).
<span class="math display">\[\texttt{CS-BASE-CORE-001}:
\bigl[
\texttt{CL-R-REGIME-001},
\texttt{CL-P-PROTO-001},
\texttt{CL-G-CONTACT-001},
\texttt{CL-G-BOUNDARY-001},
\texttt{CL-G-BACKBONE-001},
\texttt{CL-S-EVENTMAP-001},
\texttt{CL-N-CONV-001},
\texttt{CL-X-RCROSS-001}
\bigr].
\label{eq:closure_stack_base}\]</span>
각 닫힘의 입출력 타입과 실패모드 및 Gate 요구는 4.2의 닫힘 템플릿 규약을 따른다. 위 스택은 다음을 의미한다.</p>
<ul>
<li><p>레짐 좌표축이 먼저 잠기고(<code>CL-R-REGIME-001</code>),</p></li>
<li><p>프로토콜/로그가 봉인되며(<code>CL-P-PROTO-001</code>),</p></li>
<li><p>접촉 그래프와 경계 정의가 고정되고(<code>CL-G-CONTACT-001</code>, <code>CL-G-BOUNDARY-001</code>),</p></li>
<li><p>강성 백본(또는 병목 지표)이 선택 규약으로 고정되며(<code>CL-G-BACKBONE-001</code>),</p></li>
<li><p>사건 집계 사상이 고정되고(<code>CL-S-EVENTMAP-001</code>),</p></li>
<li><p>수치 수렴/안정 규약이 고정되며(<code>CL-N-CONV-001</code>),</p></li>
<li><p>실현 또는 교차정합이 요구되면 교차정합 닫힘이 고정된다(<code>CL-X-RCROSS-001</code>).</p></li>
</ul>
<h4 data-number="6.8.13.2" id="회전-구동-레짐의-허용-스택-예시확장"><span class="header-section-number">6.8.13.2</span> 4.3.4.2 회전 구동 레짐의 허용 스택 예시(확장)</h4>
<p>회전 구동 레짐(<code>DRV-ROT</code>)에서는 <a data-reference="eq:closure_stack_base" data-reference-type="eqref" href="#eq:closure_stack_base">[eq:closure_stack_base]</a>에 다음 닫힘들이 <em>추가</em>되며, 추가 닫힘을 포함하지 않은 결론은 회전 구동 레짐에서 자격을 얻을 수 없다.
<span class="math display">\[\texttt{CS-ROT-EXT-001}:
\bigl[
\texttt{CL-R-REGIME-ROT-001},
\texttt{CL-P-PROTO-ROT-001},
\texttt{CL-G-CONTACT-001},
\texttt{CL-G-BOUNDARY-001},
\texttt{CL-G-ANISO-AXIS-001},
\texttt{CL-S-ANISO-MAP-001},
\texttt{CL-N-CONV-001},
\texttt{CL-X-RCROSS-001}
\bigr].
\label{eq:closure_stack_rot}\]</span>
여기서 <code>CL-G-ANISO-AXIS-001</code>은 방향축/방향분포의 선택 규약을 잠그는 닫힘이고, <code>CL-S-ANISO-MAP-001</code>은 방향 의존 관측량의 1:1 사상을 잠그는 닫힘이다. 회전 구동 레짐에서 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>가 참고값(<code>CANON-REF</code>)인지 승격값(<code>CANON-PRIMARY</code>)인지에 따라 <code>CL-R-REGIME-ROT-001</code>의 입력 항목과 실패모드가 달라지며, 이는 <code>canon_lock</code> 버전과 함께 귀속된다.</p>
<h4 data-number="6.8.13.3" id="비강성-레짐의-허용-스택-예시제한"><span class="header-section-number">6.8.13.3</span> 4.3.4.3 비강성 레짐의 허용 스택 예시(제한)</h4>
<p>비강성 레짐에서는 강성 백본의 존재를 전제로 하는 닫힘을 사용할 수 없다. 따라서 다음 제한이 레짐 정의에 포함된다.
<span class="math display">\[R_{\mathrm{span}}=\texttt{SPAN-0}
\ \ \text{또는}\ \
R_{\kappa}\in\{\texttt{KAPPA-0},\texttt{KAPPA-1}\}
\ \Longrightarrow\
\texttt{CL-G-BACKBONE-001}\ \text{사용 금지}.
\label{eq:nonstiff_forbid_backbone}\]</span>
이 경우 허용 스택은 다음 형태로 고정된다.
<span class="math display">\[\texttt{CS-NONSTIFF-001}:
\bigl[
\texttt{CL-R-REGIME-001},
\texttt{CL-P-PROTO-001},
\texttt{CL-G-CONTACT-001},
\texttt{CL-G-BOUNDARY-001},
\texttt{CL-S-STATMAP-001},
\texttt{CL-N-CONV-001}
\bigr].
\label{eq:closure_stack_nonstiff}\]</span>
비강성 레짐에서 강성 관련 결론을 산출하려면, 그 결론은 “강성 결론”이 아니라 “강성 실패 또는 한계 결론”(CT-LIM)이어야 하며, 실패모드 라벨이 동반되어야 한다.</p>
<h3 data-number="6.8.14" id="레짐-밖-외삽-금지extrapolation-ban"><span class="header-section-number">6.8.14</span> 4.3.5 레짐 밖 외삽 금지(Extrapolation Ban)</h3>
<p>레짐 밖 외삽은 “레짐 <span class="math inline">\(\mathcal{R}\)</span>에서 유도되고 Gate를 통과한 결론을, 레짐 좌표축 값이 다른 레짐 <span class="math inline">\(\mathcal{R}'\)</span>에 대해 동일 결론으로 서술하는 행위”로 정의한다. 레짐 밖 외삽은 다음 조건 중 하나라도 성립하면 발생한다.</p>
<ol>
<li><p><strong>좌표축 불일치</strong>: <span class="math inline">\(\mathcal{R}\)</span>과 <span class="math inline">\(\mathcal{R}'\)</span> 사이에 하나 이상의 좌표축 값 불일치가 존재한다.</p></li>
<li><p><strong>허용 스택 불일치</strong>: <span class="math inline">\(\mathcal{R}'\)</span>에서 허용되지 않는 닫힘이 결론 생성에 포함되어 있다.</p></li>
<li><p><strong>레짐 Gate 미통과</strong>: <span class="math inline">\(\mathcal{R}'\)</span>로의 전이를 정당화하는 Gate(레짐 적합성/교차정합/재현)가 수행되지 않았다.</p></li>
</ol>
<p>외삽은 해석으로 완화되지 않으며, 다음 규정으로 즉시 처리된다.</p>
<h4 data-number="6.8.14.1" id="외삽-금지의-문장-규칙"><span class="header-section-number">6.8.14.1</span> 4.3.5.1 외삽 금지의 문장 규칙</h4>
<p>레짐 밖 외삽이 포함된 문장은 결론 자격을 얻을 수 없다. 외삽 금지 문장 규칙은 다음으로 고정한다.</p>
<ol>
<li><p>결론 문장은 반드시 <code>regime_id</code>를 포함해야 한다. <code>regime_id</code>가 없는 결론 문장은 <code>INCONCLUSIVE</code>로 판정된다.</p></li>
<li><p>결론 문장에 등장하는 레짐 좌표축 값은 레지스트리의 <code>coords</code>와 일치해야 한다. 불일치 시 즉시 <code>FAIL</code>이다.</p></li>
<li><p>다른 레짐으로의 일반화를 서술하려면, 반드시 그 레짐에 대한 별도의 <code>regime_id</code>와 허용 스택 및 Gate 판정을 새로 제시해야 한다.</p></li>
<li><p>레짐 밖에 대해서는 결론 문장이 아니라 한계 문장(CT-LIM)만 허용된다. 한계 문장은 <code>FAIL</code>/<code>INCONCLUSIVE</code>의 원인 라벨을 포함해야 한다.</p></li>
</ol>
<h4 data-number="6.8.14.2" id="외삽-위반의-fail-라벨"><span class="header-section-number">6.8.14.2</span> 4.3.5.2 외삽 위반의 FAIL 라벨</h4>
<p>레짐 밖 외삽이 탐지되면 다음 FAIL 라벨을 부여한다.</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">라벨</th>
<th style="text-align: left;">의미</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">FAIL-REG-NOID</td>
<td style="text-align: left;">결론에 <code>regime_id</code> 누락</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-REG-MISMATCH</td>
<td style="text-align: left;">선언된 <code>regime_id</code>와 좌표축 값 불일치</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FAIL-REG-STACK</td>
<td style="text-align: left;">레짐에서 허용되지 않는 closure 스택 사용</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-REG-EXTRAP</td>
<td style="text-align: left;">레짐 밖 일반화/외삽 문장 포함</td>
</tr>
<tr class="odd">
<td style="text-align: left;">INCON-REG-UNDEF</td>
<td style="text-align: left;">레짐 좌표 또는 판정 지표가 정의 불능(잠금 누락)</td>
</tr>
</tbody>
</table>
</div>
<p><code>FAIL-REG-*</code>가 부여되면 해당 산출물은 결론 자격을 상실하며, 의존성 그래프를 따라 파생 산출물에도 연쇄적으로 결론 자격 상실이 전파된다.</p>
<h3 data-number="6.8.15" id="레짐-전이transition의-허용-조건"><span class="header-section-number">6.8.15</span> 4.3.6 레짐 전이(transition)의 허용 조건</h3>
<p>레짐 전이는 “<span class="math inline">\(\mathcal{R}\to\mathcal{R}'\)</span>” 형태로 기록되며, 전이는 다음 두 경우로만 허용된다.</p>
<ol>
<li><p><strong>좌표축 값이 동일한 범위에서의 세분화</strong>: 동일 레짐 내에서 스케일 창(<span class="math inline">\(R_{\mathrm{scale}}\)</span>) 또는 관측 축(<span class="math inline">\(R_{\mathrm{obs}}\)</span>)처럼 사전 등록된 축에 대해 하위 분류를 추가하는 경우. 이때도 하위 레짐은 새 <code>regime_id</code>로 등록되어야 한다.</p></li>
<li><p><strong>독립 결론의 병렬 제시</strong>: 서로 다른 레짐에서 각각 독립적으로 결론을 생성하고, 결론을 혼합하지 않은 채 병렬로 나열하는 경우. 병렬 제시는 교차정합 닫힘(<code>CL-X-*</code>)이 요구될 수 있으며, 요구 여부는 <code>analysis_lock</code>에 잠겨야 한다.</p></li>
</ol>
<p>레짐 전이를 “하나의 결론”으로 합성하려면, 합성 규칙 자체가 닫힘으로 잠겨야 하며, 합성에 대한 Gate 스택이 사전 등록되어야 한다. 합성 규칙이 없는 전이는 외삽으로 간주되어 금지된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-21">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 레짐 튜플 <a data-reference="eq:regime_tuple" data-reference-type="eqref" href="#eq:regime_tuple">[eq:regime_tuple]</a> 및 9개 좌표축(차원/셀/구동/스패닝/병목/스케일창/경계/초기/관측)과 열거형 값을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 레짐별 허용 closure 스택(closure_ids, stack_id)과 스택 변경은 버전업으로만 가능함을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 비강성 레짐에서 백본 기반 닫힘 금지 규칙 <a data-reference="eq:nonstiff_forbid_backbone" data-reference-type="eqref" href="#eq:nonstiff_forbid_backbone">[eq:nonstiff_forbid_backbone]</a>을 레짐 정의에 포함하여 고정.</p></li>
<li><p>Gate: 레짐 적합성(G-REG) 및 스택 적합성 판정 실패 시 <code>FAIL-REG-*</code> 라벨을 부여하고 결론 자격을 박탈함을 연결 고정.</p></li>
<li><p>Gate: 레짐 밖 외삽 탐지 시 <code>FAIL-REG-EXTRAP</code>로 즉시 <code>FAIL</code>, 의존성 전파로 파생 결론까지 자격 상실을 연결 고정.</p></li>
</ul>
<h1 data-number="7" id="기하학-정류-상수유일-출처"><span class="header-section-number">7</span> 5. 기하학 정류 상수(유일 출처)</h1>
<h2 class="unnumbered" id="목적과-범위">목적과 범위</h2>
<p>본 장은 기하학 정류 상수 <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\delta\)</span>를 문서 전역의 <strong>유일 출처</strong>로서 정의하고, 그 사용 규칙을 고정한다.
유일 출처란, (i) <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>의 정의식, (ii) <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>의 유도(정류 규약), (iii) <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>의 레지스트리 잠금 위치가 문서 전역에서 오직 한 곳에만 존재함을 뜻한다.
본 장의 밖에서 <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>를 다시 유도하거나, 동일 기호를 다른 의미로 재사용하거나, 다른 규약으로 재정의하는 행위는 금지된다.</p>
<h2 class="unnumbered" id="정류-상수의-정의예약-기호">정류 상수의 정의(예약 기호)</h2>
<p>정류 상수는 다음 두 항목으로 고정한다.
<span class="math display">\[\alpha := \frac{2}{\pi},
\qquad
\delta := \frac{1}{\pi^2}.
\label{eq:rect_alpha_delta_def}\]</span>
여기서 <span class="math inline">\(\pi\)</span>는 무차원 상수로 잠기며, <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>는 무차원 상수로 잠긴다.
또한 <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>는 <strong>정류 상수로 예약된 기호</strong>이며, 다른 의미로 재사용될 수 없다. 특히 다음 규칙을 전역 규칙으로 고정한다.</p>
<ol>
<li><p><span class="math inline">\(\delta\)</span>는 정류 상수로 예약된다. 간격/목/두께/결손 등 다른 의미의 델타는 반드시 첨자 또는 다른 기호로 분리한다(예: <span class="math inline">\(\delta_{\mathrm{gap}},\ \delta_{\mathrm{throat}}\)</span> 등).</p></li>
<li><p><span class="math inline">\(\alpha\)</span>는 정류 상수로 예약된다. 다른 의미의 알파는 반드시 첨자 또는 다른 기호로 분리한다(예: <span class="math inline">\(\alpha_{\mathrm{aniso}}\)</span> 등).</p></li>
<li><p>예약 기호의 위반(동일 기호의 다의 사용)은 의미층 사상 이전 단계에서 즉시 무효이며, 해석으로 봉합되지 않는다.</p></li>
</ol>
<h2 class="unnumbered" id="유일-출처ssot-규칙">유일 출처(SSOT) 규칙</h2>
<p><span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>의 유일 출처 규칙을 다음으로 고정한다.</p>
<ol>
<li><p><strong>정의식의 단일 위치</strong>: 식 <a data-reference="eq:rect_alpha_delta_def" data-reference-type="eqref" href="#eq:rect_alpha_delta_def">[eq:rect_alpha_delta_def]</a>는 <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>의 정의식으로서 문서 전체에서 단 한 번만 등장한다. 이후 절에서는 동일 식을 재기입하지 않으며, 참조만 수행한다.</p></li>
<li><p><strong>유도의 단일 위치</strong>: <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>가 특정 정류 규약(각도 평균/투영/제곱 규약 등)에서 산출된다는 유도는 본 장 내부(후속 절들)에서 단 한 번만 수행된다. 본 장 밖에서는 유도 재현을 금지한다.</p></li>
<li><p><strong>레지스트리 단일 출처</strong>: <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>는 <code>canon_lock</code>의 <code>rectification_constants</code> 항목으로 잠기며, 동일 항목이 다른 레지스트리 또는 본문 다른 위치에 복제될 수 없다.</p></li>
<li><p><strong>버전 귀속</strong>: <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>의 정의/유도/규약은 <code>canon_lock_id</code>에 귀속된다. 동일 기호를 동일 값으로 쓰더라도, 다른 <code>canon_lock_id</code>를 혼합하여 하나의 결론으로 서술하는 행위는 금지된다.</p></li>
</ol>
<h2 data-number="7.1" id="재사용-규칙참조-방식과-결론-문장-형식"><span class="header-section-number">7.1</span> 5.4 재사용 규칙(참조 방식과 결론 문장 형식)</h2>
<p>본 장 밖에서 <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>를 사용할 때는 다음 재사용 규칙을 따른다.</p>
<ol>
<li><p><strong>참조 우선</strong>: <span class="math inline">\(\alpha\)</span> 또는 <span class="math inline">\(\delta\)</span>가 포함된 모든 유도/표/그림/로그는 해당 항목이 <code>canon_lock</code>의 어떤 <code>lock_id</code>에 의해 잠겨 있는지의 참조를 포함해야 한다.</p></li>
<li><p><strong>치환 금지</strong>: <span class="math inline">\(\alpha\)</span>를 <span class="math inline">\(\frac{2}{\pi}\)</span>로, <span class="math inline">\(\delta\)</span>를 <span class="math inline">\(\frac{1}{\pi^2}\)</span>로 식 안에서 임의로 치환하여 “유도처럼” 보이게 만드는 행위를 금지한다. 치환이 필요하면, 치환 단계는 “단순 대입”으로만 표기하고, 정류 유도와 혼합하지 않는다.</p></li>
<li><p><strong>정류 규약의 분리</strong>: <span class="math inline">\(\alpha\)</span> 또는 <span class="math inline">\(\delta\)</span>를 포함하는 식에서 평균/투영/제곱 등의 연산이 등장하면, 그 연산 규약(평균 대상, 측정 창, 정규화 방식)은 별도 닫힘(closure)로 잠겨야 한다. 규약이 잠기지 않은 상태에서 <span class="math inline">\(\alpha,\delta\)</span>를 사용하면 정의가 성립하지 않는다.</p></li>
<li><p><strong>상수의 역할 제한</strong>: <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>는 정류 상수로서만 사용된다. <span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>를 새로운 의미(예: 다른 계수, 다른 보정항)로 재해석하여 사용하는 행위는 금지된다.</p></li>
</ol>
<h2 data-number="7.2" id="위반-유형과-즉시-무효-규칙"><span class="header-section-number">7.2</span> 5.5 위반 유형과 즉시 무효 규칙</h2>
<p><span class="math inline">\(\alpha\)</span>와 <span class="math inline">\(\delta\)</span>의 유일 출처 및 재사용 규칙 위반은 해석으로 봉합되지 않으며, 다음 위반 유형 중 하나라도 발생하면 해당 산출물은 즉시 무효이다.</p>
<ol>
<li><p>동일 문서 버전에서 <span class="math inline">\(\alpha\)</span> 또는 <span class="math inline">\(\delta\)</span>의 정의식을 다른 형태로 다시 제시하거나(재정의), 다른 규약으로 다시 유도하는 행위(재유도).</p></li>
<li><p><span class="math inline">\(\delta\)</span>를 간격/목/두께 등의 의미로 사용하거나, 다른 델타(예: <span class="math inline">\(\delta_{\mathrm{gap}}\)</span>)를 정류 상수 <span class="math inline">\(\delta\)</span>로 축약하는 행위(기호 오버로딩).</p></li>
<li><p><span class="math inline">\(\alpha\)</span> 또는 <span class="math inline">\(\delta\)</span>가 참조해야 할 <code>canon_lock_id</code>가 누락되거나, 서로 다른 <code>canon_lock_id</code>의 값을 혼합하여 사용하는 행위(잠금 혼합).</p></li>
<li><p>평균/투영/제곱 규약이 잠기지 않은 상태에서 <span class="math inline">\(\alpha\)</span> 또는 <span class="math inline">\(\delta\)</span>를 포함하는 결론을 생성하는 행위(절차 미잠금).</p></li>
</ol>
<p>위반이 발생하면, 해당 산출물은 결론 자격을 상실하며, 의존성 그래프를 따라 파생 산출물에도 결론 자격 상실이 전파된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-22">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(\alpha:=2/\pi\)</span>, <span class="math inline">\(\delta:=1/\pi^2\)</span> 정의와 예약 기호 규칙을 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: 정류 상수의 유일 출처(정의식/유도/규약 단일 위치) 및 레지스트리 단일 출처(SSOT) 규칙을 고정.</p></li>
<li><p>Gate: 정류 상수 무결성 Gate(G-RECT)는 재정의/재유도/치환-유도 혼합을 즉시 <code>FAIL</code>로 판정.</p></li>
<li><p>Gate: 기호 의미 충돌(G-SYM) 및 lock_id 혼합(G-LOCK)은 즉시 <code>FAIL</code>로 판정.</p></li>
<li><p>Gate: 평균/투영/제곱 규약 미잠금은 절차 미잠금으로 <code>INCONCLUSIVE</code> 또는 <code>FAIL</code>로 판정.</p></li>
</ul>
<h2 data-number="7.3" id="alpha2pi-유도"><span class="header-section-number">7.3</span> 5.1 <span class="math inline">\(\alpha=2/\pi\)</span> 유도</h2>
<h3 data-number="7.3.1" id="정류-문제의-정의방향-성분-rightarrow-스칼라-유효량"><span class="header-section-number">7.3.1</span> 5.1.1 정류 문제의 정의(방향 성분 <span class="math inline">\(\rightarrow\)</span> 스칼라 유효량)</h3>
<p>본 절에서 <span class="math inline">\(\alpha\)</span>는 “방향(또는 위상) 성분을 스칼라 유효량으로 정류(rectify)하는 계수”로 정의되는 상수이다. <span class="math inline">\(\alpha\)</span>의 유도는 다음의 최소 구성요소를 필요로 한다.</p>
<h4 data-number="7.3.1.1" id="d-5.1-1-위상phase-변수"><span class="header-section-number">7.3.1.1</span> [D-5.1-1] 위상(phase) 변수</h4>
<p>위상 변수 <span class="math inline">\(\theta\)</span>를 다음 집합 위의 변수로 정의한다.
<span class="math display">\[\theta \in [0,2\pi).
\label{eq:alpha_phase_domain}\]</span>
<span class="math inline">\(\theta\)</span>는 내부 상태의 방향성을 나타내는 최소 각변수이며, <span class="math inline">\(\theta\)</span>의 의미(어떤 축에 대한 각도인가)는 <code>analysis_lock</code>의 좌표계 정의로 잠긴다. 본 절의 유도는 <span class="math inline">\(\theta\)</span>가 <a data-reference="eq:alpha_phase_domain" data-reference-type="eqref" href="#eq:alpha_phase_domain">[eq:alpha_phase_domain]</a>의 전주기를 갖는 각변수라는 사실만을 사용한다.</p>
<h4 data-number="7.3.1.2" id="d-5.1-2-방향-성분투영과-부호의-발생"><span class="header-section-number">7.3.1.2</span> [D-5.1-2] 방향 성분(투영)과 부호의 발생</h4>
<p>스칼라 유효량으로 변환하기 전의 “방향 성분”을 다음 형식으로 정의한다.
<span class="math display">\[X_{\parallel}(\theta) := X_{0}\cos\theta,
\label{eq:alpha_projection}\]</span>
여기서 <span class="math inline">\(X_{0}\ge 0\)</span>는 크기 스케일(비부호 스케일)이며, <span class="math inline">\(\cos\theta\)</span>는 <span class="math inline">\(\theta\)</span>에 따른 부호(방향)에 의해 <span class="math inline">\(\pm\)</span>가 발생하는 최소 투영 함수이다.
정의 <a data-reference="eq:alpha_projection" data-reference-type="eqref" href="#eq:alpha_projection">[eq:alpha_projection]</a>은 “어떤 물리량이 반드시 코사인 투영을 따른다”는 주장으로 사용되지 않는다. 본 문서에서 <span class="math inline">\(\cos\theta\)</span>는 <strong>전주기에서 부호가 바뀌는 최소 투영 함수</strong>로서의 <em>정의 선택</em>이며, 다른 투영 함수를 채택하려면 다른 정류 상수를 <em>새 기호</em>로 정의하여 별도 레지스트리 항목으로 잠가야 한다.</p>
<h4 data-number="7.3.1.3" id="d-5.1-3-정류rectification-연산자"><span class="header-section-number">7.3.1.3</span> [D-5.1-3] 정류(rectification) 연산자</h4>
<p>정류는 “부호로 인해 상쇄되는 방향 성분을 크기 관점의 유효량으로 환원”하는 연산으로 정의한다. 이를 위해 절댓값 연산을 포함한 정류 연산자를 다음과 같이 정의한다.
<span class="math display">\[\mathrm{Rect}[X_{\parallel}](\theta) := |X_{\parallel}(\theta)|.
\label{eq:alpha_rect_operator_pointwise}\]</span>
정류된 스칼라 유효량 <span class="math inline">\(X_{\mathrm{rect}}\)</span>는 전주기 평균으로 정의한다(평균 규약은 아래에서 잠김).
<span class="math display">\[X_{\mathrm{rect}}
:= \left\langle \mathrm{Rect}[X_{\parallel}] \right\rangle
= \left\langle |X_{0}\cos\theta| \right\rangle.
\label{eq:alpha_rect_average_def}\]</span>
여기서 <span class="math inline">\(\langle\cdot\rangle\)</span>은 <a data-reference="eq:alpha_phase_domain" data-reference-type="eqref" href="#eq:alpha_phase_domain">[eq:alpha_phase_domain]</a>의 전주기 평균 연산자이다.</p>
<h3 data-number="7.3.2" id="전주기-평균-연산자정준-측도-정의"><span class="header-section-number">7.3.2</span> 5.1.2 전주기 평균 연산자(정준 측도) 정의</h3>
<p><span class="math inline">\(\theta\)</span>에 대한 평균은 전주기에서의 정준 측도에 의해 정의한다.</p>
<h4 data-number="7.3.2.1" id="d-5.1-4-정준-측도"><span class="header-section-number">7.3.2.1</span> [D-5.1-4] 정준 측도</h4>
<p>정준 측도 <span class="math inline">\(d\mu(\theta)\)</span>를 다음으로 정의한다.
<span class="math display">\[d\mu(\theta) := \frac{d\theta}{2\pi},
\qquad
\int_{0}^{2\pi} d\mu(\theta) = 1.
\label{eq:alpha_uniform_measure}\]</span>
정의 <a data-reference="eq:alpha_uniform_measure" data-reference-type="eqref" href="#eq:alpha_uniform_measure">[eq:alpha_uniform_measure]</a>는 전주기 위에서의 평균 규약을 고정하기 위한 <strong>정의(규약)</strong>이며, 결과를 본 뒤 다른 가중(비균등 측도)을 도입하는 행위는 금지된다. 비균등 측도가 필요하면, 그 측도는 별도의 닫힘(closure)로 정의되어야 하며, 해당 닫힘은 실패모드 및 Gate 스택과 함께 <code>analysis_lock</code>에 잠겨야 한다.</p>
<h4 data-number="7.3.2.2" id="d-5.1-5-전주기-평균-연산자"><span class="header-section-number">7.3.2.2</span> [D-5.1-5] 전주기 평균 연산자</h4>
<p>정준 측도에 따른 전주기 평균 연산자를 다음으로 정의한다.
<span class="math display">\[\left\langle f(\theta) \right\rangle
:= \int_{0}^{2\pi} f(\theta)\, d\mu(\theta)
= \frac{1}{2\pi}\int_{0}^{2\pi} f(\theta)\, d\theta.
\label{eq:alpha_average_operator}\]</span>
이 정의는 본 장(정류 상수 유일 출처)에서만 고정되며, 이후 절에서는 참조만 수행한다.</p>
<h3 data-number="7.3.3" id="langle-costheta-rangle의-완전-계산"><span class="header-section-number">7.3.3</span> 5.1.3 <span class="math inline">\(\langle |\cos\theta| \rangle\)</span>의 완전 계산</h3>
<p>정의 <a data-reference="eq:alpha_rect_average_def" data-reference-type="eqref" href="#eq:alpha_rect_average_def">[eq:alpha_rect_average_def]</a>와 <a data-reference="eq:alpha_average_operator" data-reference-type="eqref" href="#eq:alpha_average_operator">[eq:alpha_average_operator]</a>를 결합하면,
<span class="math display">\[X_{\mathrm{rect}}
= \left\langle |X_{0}\cos\theta| \right\rangle
= X_{0}\left\langle |\cos\theta| \right\rangle
= X_{0}\cdot \frac{1}{2\pi}\int_{0}^{2\pi} |\cos\theta|\, d\theta.
\label{eq:alpha_rect_reduce}\]</span>
따라서 핵심은 적분
<span class="math display">\[I := \int_{0}^{2\pi} |\cos\theta|\, d\theta
\label{eq:alpha_I_def}\]</span>
의 계산이다. <span class="math inline">\(|\cos\theta|\)</span>의 부호 변화를 구간으로 분해하여 계산한다.</p>
<h4 data-number="7.3.3.1" id="부호-구간-분해"><span class="header-section-number">7.3.3.1</span> (1) 부호 구간 분해</h4>
<p><span class="math inline">\(\cos\theta\)</span>는 다음 구간에서 부호가 결정된다.
<span class="math display">\[\cos\theta \ge 0 \ \text{for}\ \theta\in\left[0,\frac{\pi}{2}\right]\cup\left[\frac{3\pi}{2},2\pi\right],
\qquad
\cos\theta \le 0 \ \text{for}\ \theta\in\left[\frac{\pi}{2},\frac{3\pi}{2}\right].
\label{eq:alpha_cos_sign_intervals}\]</span>
따라서 절댓값은
<span class="math display">\[|\cos\theta|=
\begin{cases}
\cos\theta, &amp; \theta\in\left[0,\frac{\pi}{2}\right]\cup\left[\frac{3\pi}{2},2\pi\right],\\
-\cos\theta, &amp; \theta\in\left[\frac{\pi}{2},\frac{3\pi}{2}\right].
\end{cases}
\label{eq:alpha_abs_cos_piecewise}\]</span></p>
<h4 data-number="7.3.3.2" id="적분의-구간-합"><span class="header-section-number">7.3.3.2</span> (2) 적분의 구간 합</h4>
<p>정의 <a data-reference="eq:alpha_I_def" data-reference-type="eqref" href="#eq:alpha_I_def">[eq:alpha_I_def]</a>와 <a data-reference="eq:alpha_abs_cos_piecewise" data-reference-type="eqref" href="#eq:alpha_abs_cos_piecewise">[eq:alpha_abs_cos_piecewise]</a>로부터,
<span class="math display">\[\begin{aligned}
I
&amp;= \int_{0}^{\pi/2} \cos\theta\, d\theta
   + \int_{\pi/2}^{3\pi/2} (-\cos\theta)\, d\theta
   + \int_{3\pi/2}^{2\pi} \cos\theta\, d\theta.
\label{eq:alpha_I_split}\end{aligned}\]</span>
각 적분을 차례로 계산한다.</p>
<h4 data-number="7.3.3.3" id="첫-번째-구간-적분"><span class="header-section-number">7.3.3.3</span> (3) 첫 번째 구간 적분</h4>
<p><span class="math display">\[\int_{0}^{\pi/2} \cos\theta\, d\theta
= \left[\sin\theta\right]_{0}^{\pi/2}
= \sin\left(\frac{\pi}{2}\right)-\sin(0)
= 1-0
= 1.
\label{eq:alpha_I1}\]</span></p>
<h4 data-number="7.3.3.4" id="두-번째-구간-적분"><span class="header-section-number">7.3.3.4</span> (4) 두 번째 구간 적분</h4>
<p>두 번째 적분은 부호가 반전되어 있으므로,
<span class="math display">\[\begin{aligned}
\int_{\pi/2}^{3\pi/2} (-\cos\theta)\, d\theta
&amp;= -\left[\sin\theta\right]_{\pi/2}^{3\pi/2}
= -\left(\sin\left(\frac{3\pi}{2}\right)-\sin\left(\frac{\pi}{2}\right)\right) \notag\\
&amp;= -\left((-1)-1\right)
= -(-2)
= 2.
\label{eq:alpha_I2}\end{aligned}\]</span></p>
<h4 data-number="7.3.3.5" id="세-번째-구간-적분"><span class="header-section-number">7.3.3.5</span> (5) 세 번째 구간 적분</h4>
<p><span class="math display">\[\int_{3\pi/2}^{2\pi} \cos\theta\, d\theta
= \left[\sin\theta\right]_{3\pi/2}^{2\pi}
= \sin(2\pi)-\sin\left(\frac{3\pi}{2}\right)
= 0-(-1)
= 1.
\label{eq:alpha_I3}\]</span></p>
<h4 data-number="7.3.3.6" id="합산"><span class="header-section-number">7.3.3.6</span> (6) 합산</h4>
<p><a data-reference="eq:alpha_I_split" data-reference-type="eqref" href="#eq:alpha_I_split">[eq:alpha_I_split]</a>에 <a data-reference="eq:alpha_I1" data-reference-type="eqref" href="#eq:alpha_I1">[eq:alpha_I1]</a>, <a data-reference="eq:alpha_I2" data-reference-type="eqref" href="#eq:alpha_I2">[eq:alpha_I2]</a>, <a data-reference="eq:alpha_I3" data-reference-type="eqref" href="#eq:alpha_I3">[eq:alpha_I3]</a>를 대입하면,
<span class="math display">\[I = 1 + 2 + 1 = 4.
\label{eq:alpha_I_value}\]</span>
따라서 전주기 평균은
<span class="math display">\[\left\langle |\cos\theta| \right\rangle
= \frac{1}{2\pi}\int_{0}^{2\pi} |\cos\theta|\, d\theta
= \frac{1}{2\pi}\cdot 4
= \frac{2}{\pi}.
\label{eq:alpha_abs_cos_average}\]</span></p>
<h3 data-number="7.3.4" id="정류-상수-alpha의-고정과-변환식"><span class="header-section-number">7.3.4</span> 5.1.4 정류 상수 <span class="math inline">\(\alpha\)</span>의 고정과 변환식</h3>
<p>정의 <a data-reference="eq:alpha_rect_reduce" data-reference-type="eqref" href="#eq:alpha_rect_reduce">[eq:alpha_rect_reduce]</a>와 <a data-reference="eq:alpha_abs_cos_average" data-reference-type="eqref" href="#eq:alpha_abs_cos_average">[eq:alpha_abs_cos_average]</a>로부터,
<span class="math display">\[X_{\mathrm{rect}} = X_{0}\left\langle |\cos\theta| \right\rangle = X_{0}\cdot\frac{2}{\pi}.
\label{eq:alpha_rect_result}\]</span>
따라서 방향 성분 <span class="math inline">\(X_{\parallel}(\theta)=X_{0}\cos\theta\)</span>를 전주기 정류한 스칼라 유효량은
<span class="math display">\[X_{\mathrm{rect}} = \alpha\, X_{0},
\qquad
\alpha := \frac{2}{\pi}.
\label{eq:alpha_definition_from_rect}\]</span>
식 <a data-reference="eq:alpha_definition_from_rect" data-reference-type="eqref" href="#eq:alpha_definition_from_rect">[eq:alpha_definition_from_rect]</a>에서 <span class="math inline">\(\alpha\)</span>는 <strong>정류 규약(정준 측도 + 절댓값 + 전주기 평균)</strong>에 의해 유도된 상수이며, 본 장(정류 상수 유일 출처)에서만 유도된다. 이후 절에서는 <span class="math inline">\(\alpha\)</span>를 <a data-reference="eq:alpha_definition_from_rect" data-reference-type="eqref" href="#eq:alpha_definition_from_rect">[eq:alpha_definition_from_rect]</a>의 결과로서 <strong>참조</strong>만 수행한다.</p>
<h3 data-number="7.3.5" id="사용처-연결정류-연산이-필요한-모든-변환의-공통-계수"><span class="header-section-number">7.3.5</span> 5.1.5 사용처 연결(정류 연산이 필요한 모든 변환의 공통 계수)</h3>
<p>본 문서에서 <span class="math inline">\(\alpha\)</span>는 “부호가 존재하는 방향 성분”을 “부호가 없는 유효 스칼라”로 변환하는 공통 계수로 사용된다. 사용은 다음 표준 형태로 고정한다.</p>
<h4 data-number="7.3.5.1" id="d-5.1-6-표준-사용-형태"><span class="header-section-number">7.3.5.1</span> [D-5.1-6] 표준 사용 형태</h4>
<p>방향 성분이
<span class="math display">\[X_{\parallel}(\theta)=X_{0}\cos\theta
\label{eq:alpha_useform_dir}\]</span>
의 형태로 정의될 때, 정류된 스칼라는
<span class="math display">\[X_{\mathrm{rect}}=\left\langle |X_{\parallel}(\theta)| \right\rangle = \alpha X_{0}
\label{eq:alpha_useform_rect}\]</span>
로 정의된다. 여기서 <span class="math inline">\(X_{0}\)</span>는 크기 스케일이며, <span class="math inline">\(X_{\parallel}\)</span>의 전주기 평균(부호 포함 평균)과 혼동되지 않는다.
특히
<span class="math display">\[\left\langle X_{\parallel}(\theta) \right\rangle
= \left\langle X_{0}\cos\theta \right\rangle
= X_{0}\left\langle \cos\theta \right\rangle
= X_{0}\cdot 0
=0
\label{eq:alpha_mean_zero_note}\]</span>
이므로, 부호 포함 평균은 소거되고, 정류 평균만이 유효량을 제공한다. 이 구분은 이후 모든 “상쇄<span class="math inline">\(\rightarrow\)</span>생존” 계열 유도에서 반복 사용된다.</p>
<h4 data-number="7.3.5.2" id="d-5.1-7-대표-사용처절-번호-기준-연결"><span class="header-section-number">7.3.5.2</span> [D-5.1-7] 대표 사용처(절 번호 기준 연결)</h4>
<p><span class="math inline">\(\alpha\)</span>의 대표 사용처는 다음과 같이 절 번호로 연결된다(모두 동일한 정류 규약 <a data-reference="eq:alpha_average_operator" data-reference-type="eqref" href="#eq:alpha_average_operator">[eq:alpha_average_operator]</a>–<a data-reference="eq:alpha_definition_from_rect" data-reference-type="eqref" href="#eq:alpha_definition_from_rect">[eq:alpha_definition_from_rect]</a>의 참조로만 사용된다).</p>
<ol>
<li><p><strong>코어 길이 선택 비율</strong>: 6장(연속체 코어 모델)에서 코어 반경과 기준 길이의 비율을 정류 계수로 기록할 때, <span class="math inline">\(\alpha\)</span>는 길이 선택 비율 계수로 사용된다.</p></li>
<li><p><strong>사건율 정류</strong>: 9장(사건 정의와 정준 사건율)에서 방향성 사건율(부호 포함 또는 위상 포함)로부터 정류된 사건율(스칼라 빈도)을 정의할 때, <span class="math inline">\(\alpha\)</span>는 정류 계수로 사용된다.</p></li>
<li><p><strong>상쇄-생존 규약의 스칼라화</strong>: 8장(이산 셸 구조) 및 4장(의미층 사상)에서 상쇄 후 남는 유효 스칼라량을 정의할 때, <span class="math inline">\(\alpha\)</span>는 부호 성분의 정류 계수로 사용된다.</p></li>
</ol>
<p>위 사용처들은 <span class="math inline">\(\alpha\)</span>를 “정류 계수”로만 사용하며, <span class="math inline">\(\alpha\)</span> 자체를 재유도하거나 다른 평균 규약으로 대체하지 않는다. 다른 평균 규약이 필요하면, <span class="math inline">\(\alpha\)</span>가 아니라 <strong>새 기호</strong>로 별도의 정류 계수를 정의하고, 그 계수는 별도 레지스트리 항목과 Gate를 요구한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-23">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 정준 측도 <span class="math inline">\(d\mu(\theta)=d\theta/(2\pi)\)</span> 및 전주기 평균 연산자 <a data-reference="eq:alpha_average_operator" data-reference-type="eqref" href="#eq:alpha_average_operator">[eq:alpha_average_operator]</a>를 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: 정류 연산(절댓값 + 전주기 평균) 정의 <a data-reference="eq:alpha_rect_average_def" data-reference-type="eqref" href="#eq:alpha_rect_average_def">[eq:alpha_rect_average_def]</a>를 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(\alpha=\langle|\cos\theta|\rangle=2/\pi\)</span> 유도 결과 <a data-reference="eq:alpha_definition_from_rect" data-reference-type="eqref" href="#eq:alpha_definition_from_rect">[eq:alpha_definition_from_rect]</a>를 정류 상수 항목으로 고정(유일 출처).</p></li>
<li><p>Gate: 정류 상수 무결성(G-RECT)에서 <span class="math inline">\(\alpha\)</span> 재유도/재정의/평균 규약 교체는 즉시 <code>FAIL</code>.</p></li>
<li><p>Gate: 기호 오버로딩(G-SYM) 및 lock_id 혼합(G-LOCK)은 즉시 <code>FAIL</code>.</p></li>
</ul>
<h2 data-number="7.4" id="delta1pi2-유도-보편성-공리"><span class="header-section-number">7.4</span> 5.2 <span class="math inline">\(\delta=1/\pi^{2}\)</span> 유도 + 보편성 공리</h2>
<h3 data-number="7.4.1" id="정류-계수-delta의-역할부호-구속-사건의-생존-계수"><span class="header-section-number">7.4.1</span> 5.2.1 정류 계수 <span class="math inline">\(\delta\)</span>의 역할(부호-구속 사건의 생존 계수)</h3>
<p><span class="math inline">\(\delta\)</span>는 “부호를 가진 방향 성분”이 사건(event)으로 집계될 때, <em>부호 구속</em> 때문에 소거되는 몫을 정류하여 “생존하는 평균 비율”로 환원하는 계수로 고정한다.
<span class="math inline">\(\delta\)</span>는 무차원 상수이며, 값은 본 절에서 유도되어 <code>canon_lock</code>에 잠긴다. 본 절 밖에서는 <span class="math inline">\(\delta\)</span>의 재유도, 재정의, 치환-유도 혼합을 금지한다.</p>
<h3 data-number="7.4.2" id="필수-정의정류-연산자-측도-사건의-이중-구속-위상"><span class="header-section-number">7.4.2</span> 5.2.2 필수 정의(정류 연산자, 측도, 사건의 이중 구속 위상)</h3>
<p>본 절의 유도는 다음 정의를 필요로 한다.</p>
<h4 data-number="7.4.2.1" id="d-5.2-1-위상-변수의-전주기"><span class="header-section-number">7.4.2.1</span> [D-5.2-1] 위상 변수의 전주기</h4>
<p>사건 집계에서 사용되는 위상 변수는 전주기 각변수로 정의한다.
<span class="math display">\[\theta \in [0,2\pi),
\qquad
\varphi \in [0,2\pi).
\label{eq:delta_phase_domain}\]</span>
<span class="math inline">\(\theta\)</span>와 <span class="math inline">\(\varphi\)</span>는 서로 다른 “구속(constraint)”을 나타내는 위상으로 사용되며, 구속의 종류는 아래 [D-5.2-4]에서 고정한다.</p>
<h4 data-number="7.4.2.2" id="d-5.2-2-정준-측도균등-측도"><span class="header-section-number">7.4.2.2</span> [D-5.2-2] 정준 측도(균등 측도)</h4>
<p>전주기 평균은 정준 측도에 의해 정의한다.
<span class="math display">\[d\mu(\theta):=\frac{d\theta}{2\pi},
\qquad
d\mu(\varphi):=\frac{d\varphi}{2\pi},
\qquad
\int_{0}^{2\pi} d\mu(\theta)=\int_{0}^{2\pi} d\mu(\varphi)=1.
\label{eq:delta_uniform_measure}\]</span>
정의 <a data-reference="eq:delta_uniform_measure" data-reference-type="eqref" href="#eq:delta_uniform_measure">[eq:delta_uniform_measure]</a>는 정류 상수의 <strong>정준 규약</strong>으로 잠기며, 결과를 본 뒤 가중 측도(비균등 분포)를 끼워 넣는 행위는 금지된다.</p>
<h4 data-number="7.4.2.3" id="d-5.2-3-반파-정류half-wave-rectification-연산자"><span class="header-section-number">7.4.2.3</span> [D-5.2-3] 반파 정류(half-wave rectification) 연산자</h4>
<p>부호 구속 사건에서 “생존”은 방향 성분이 특정 부호를 만족하는 경우에만 집계되는 것으로 정의한다. 이를 위해 반파 정류 연산자를 다음으로 정의한다.
<span class="math display">\[_{+}:=\max(0,x).
\label{eq:delta_pospart_def}\]</span>
반파 정류는 절댓값 정류(<span class="math inline">\(|x|\)</span>)와 다르다. <span class="math inline">\(|x|\)</span>는 부호를 제거하지만, <span class="math inline">\([x]_+\)</span>는 “부호 선택”(한쪽 반주기만 생존)을 포함한다.</p>
<h4 data-number="7.4.2.4" id="d-5.2-4-사건의-이중-구속두-위상의-and-결합"><span class="header-section-number">7.4.2.4</span> [D-5.2-4] 사건의 이중 구속(두 위상의 AND 결합)</h4>
<p>사건의 생존은 두 독립 구속의 <em>동시 만족</em>으로 정의한다. 구속은 다음 두 위상으로 표현한다.</p>
<ol>
<li><p><strong>방향 구속 위상</strong> <span class="math inline">\(\theta\)</span>: 사건이 정해진 방향(예: 지정된 축 또는 지정된 경계-법선)으로 “전진” 성분을 가질 때만 생존하는 구속.</p></li>
<li><p><strong>내부 구속 위상</strong> <span class="math inline">\(\varphi\)</span>: 사건이 내부 구조(예: 상쇄-생존 규약, 또는 국소 갱신의 부호 선택 규약)에서 “전진” 성분을 가질 때만 생존하는 구속.</p></li>
</ol>
<p>두 구속의 결합은 AND 결합(곱)으로 정의한다. 즉, 사건 <span class="math inline">\(e\)</span>의 생존 가중치는 다음으로 정의한다.
<span class="math display">\[w(e)
:=
\bigl[\cos\theta(e)\bigr]_{+}\,\bigl[\cos\varphi(e)\bigr]_{+}.
\label{eq:delta_weight_def}\]</span>
정의 <a data-reference="eq:delta_weight_def" data-reference-type="eqref" href="#eq:delta_weight_def">[eq:delta_weight_def]</a>에서 <span class="math inline">\(w(e)\in[0,1]\)</span>이며, <span class="math inline">\(w(e)=0\)</span>이면 사건은 생존 집계에 기여하지 않는다.
정의 <a data-reference="eq:delta_weight_def" data-reference-type="eqref" href="#eq:delta_weight_def">[eq:delta_weight_def]</a>는 “사건 생존의 운영 정의”로서 <code>analysis_lock</code>의 의미층 사상 항목에 잠겨야 하며, 결과를 본 뒤 다른 형태(예: <span class="math inline">\(|\,\cdot\,|\)</span> 사용, 거듭제곱 사용, 문턱함수 추가 등)로 바꾸는 행위는 금지된다.</p>
<h3 data-number="7.4.3" id="차-정류-평균-langle-costheta_rangle-1pi"><span class="header-section-number">7.4.3</span> 5.2.3 1차 정류 평균: <span class="math inline">\(\langle [\cos\theta]_{+}\rangle = 1/\pi\)</span></h3>
<p>정의 <a data-reference="eq:delta_uniform_measure" data-reference-type="eqref" href="#eq:delta_uniform_measure">[eq:delta_uniform_measure]</a>와 <a data-reference="eq:delta_pospart_def" data-reference-type="eqref" href="#eq:delta_pospart_def">[eq:delta_pospart_def]</a>로부터,
<span class="math display">\[\left\langle [\cos\theta]_{+}\right\rangle
:=
\frac{1}{2\pi}\int_{0}^{2\pi} [\cos\theta]_{+}\, d\theta
\label{eq:delta_beta_def}\]</span>
를 계산한다. <span class="math inline">\([\cos\theta]_{+}\)</span>는 <span class="math inline">\(\cos\theta\)</span>의 양의 구간에서만 <span class="math inline">\(\cos\theta\)</span>와 같고, 음의 구간에서는 0이다.</p>
<h4 data-number="7.4.3.1" id="양의-구간-분해"><span class="header-section-number">7.4.3.1</span> (1) 양의 구간 분해</h4>
<p><span class="math inline">\(\cos\theta&gt;0\)</span>인 구간은
<span class="math display">\[\theta\in\left[0,\frac{\pi}{2}\right)\ \cup\ \left(\frac{3\pi}{2},2\pi\right].
\label{eq:delta_pos_intervals}\]</span>
따라서
<span class="math display">\[_{+}
=
\begin{cases}
\cos\theta, &amp; \theta\in\left[0,\frac{\pi}{2}\right]\cup\left[\frac{3\pi}{2},2\pi\right],\\[4pt]
0, &amp; \theta\in\left[\frac{\pi}{2},\frac{3\pi}{2}\right].
\end{cases}
\label{eq:delta_pospart_piecewise}\]</span></p>
<h4 data-number="7.4.3.2" id="적분-계산"><span class="header-section-number">7.4.3.2</span> (2) 적분 계산</h4>
<p><a data-reference="eq:delta_beta_def" data-reference-type="eqref" href="#eq:delta_beta_def">[eq:delta_beta_def]</a>와 <a data-reference="eq:delta_pospart_piecewise" data-reference-type="eqref" href="#eq:delta_pospart_piecewise">[eq:delta_pospart_piecewise]</a>로부터,
<span class="math display">\[\begin{aligned}
\int_{0}^{2\pi} [\cos\theta]_{+}\, d\theta
&amp;=
\int_{0}^{\pi/2}\cos\theta\, d\theta
+
\int_{\pi/2}^{3\pi/2}0\, d\theta
+
\int_{3\pi/2}^{2\pi}\cos\theta\, d\theta
\notag\\
&amp;=
\left[\sin\theta\right]_{0}^{\pi/2}
+
0
+
\left[\sin\theta\right]_{3\pi/2}^{2\pi}
\notag\\
&amp;=
\Bigl(\sin(\pi/2)-\sin(0)\Bigr)+\Bigl(\sin(2\pi)-\sin(3\pi/2)\Bigr)
\notag\\
&amp;=
(1-0)+(0-(-1))
=
2.
\label{eq:delta_pospart_integral_value}\end{aligned}\]</span>
따라서
<span class="math display">\[\left\langle [\cos\theta]_{+}\right\rangle
=
\frac{1}{2\pi}\cdot 2
=
\frac{1}{\pi}.
\label{eq:delta_beta_value}\]</span>
편의상
<span class="math display">\[\beta := \left\langle [\cos\theta]_{+}\right\rangle
\label{eq:delta_beta_symbol}\]</span>
를 정의하면, <a data-reference="eq:delta_beta_value" data-reference-type="eqref" href="#eq:delta_beta_value">[eq:delta_beta_value]</a>에 의해
<span class="math display">\[\beta=\frac{1}{\pi}
\label{eq:delta_beta_final}\]</span>
로 고정된다. 여기서 <span class="math inline">\(\beta\)</span>는 <strong>정류 상수로 예약하지 않는다</strong>. <span class="math inline">\(\beta\)</span>는 본 절 내부의 중간량이며, 최종 정류 상수는 아래에서 <span class="math inline">\(\delta\)</span>로 고정한다.</p>
<h3 data-number="7.4.4" id="차-정류-평균-deltalangle-costheta_cosvarphi_rangle-1pi2"><span class="header-section-number">7.4.4</span> 5.2.4 2차 정류 평균: <span class="math inline">\(\delta=\langle [\cos\theta]_{+}[\cos\varphi]_{+}\rangle = 1/\pi^{2}\)</span></h3>
<p>사건 <span class="math inline">\(e\)</span>의 생존 가중치가 <a data-reference="eq:delta_weight_def" data-reference-type="eqref" href="#eq:delta_weight_def">[eq:delta_weight_def]</a>로 정의되었을 때, 레짐 내 평균 생존 계수 <span class="math inline">\(\delta\)</span>를 다음으로 정의한다.
<span class="math display">\[\delta
:=
\left\langle [\cos\theta]_{+}[\cos\varphi]_{+}\right\rangle.
\label{eq:delta_def_double}\]</span>
여기서 평균은 <span class="math inline">\((\theta,\varphi)\)</span>의 전주기 정준 측도 위에서 취한다.</p>
<h4 data-number="7.4.4.1" id="a-5.2-u0-중간-전제-이중-위상의-분리-측도"><span class="header-section-number">7.4.4.1</span> [A-5.2-U0] (중간 전제) 이중 위상의 분리 측도</h4>
<p>본 절의 유도는 <span class="math inline">\((\theta,\varphi)\)</span>에 대한 정준 측도가 곱측도로 분리된다는 전제를 사용한다.
<span class="math display">\[d\mu(\theta,\varphi) := d\mu(\theta)\,d\mu(\varphi)
= \frac{d\theta}{2\pi}\frac{d\varphi}{2\pi}.
\label{eq:delta_product_measure}\]</span>
이 전제는 아래 5.2.5의 ’편향 원인 부재(기본 상태)’ 조건 아래에서 잠긴다. 전제가 성립하지 않으면 <span class="math inline">\(\delta\)</span>의 보편 값은 주장되지 않으며, 해당 경우는 반증 트리거로 처리된다(5.2.6).</p>
<h4 data-number="7.4.4.2" id="이중-적분으로부터-분리"><span class="header-section-number">7.4.4.2</span> (1) 이중 적분으로부터 분리</h4>
<p>정의 <a data-reference="eq:delta_def_double" data-reference-type="eqref" href="#eq:delta_def_double">[eq:delta_def_double]</a>와 <a data-reference="eq:delta_product_measure" data-reference-type="eqref" href="#eq:delta_product_measure">[eq:delta_product_measure]</a>로부터,
<span class="math display">\[\begin{aligned}
\delta
&amp;=
\int_{0}^{2\pi}\int_{0}^{2\pi}
[\cos\theta]_{+}[\cos\varphi]_{+}\,
\frac{d\theta}{2\pi}\frac{d\varphi}{2\pi}
\notag\\
&amp;=
\left(\frac{1}{2\pi}\int_{0}^{2\pi}[\cos\theta]_{+}\, d\theta\right)
\left(\frac{1}{2\pi}\int_{0}^{2\pi}[\cos\varphi]_{+}\, d\varphi\right).
\label{eq:delta_factorization}\end{aligned}\]</span>
각 괄호는 <a data-reference="eq:delta_beta_def" data-reference-type="eqref" href="#eq:delta_beta_def">[eq:delta_beta_def]</a>와 동일한 적분이며, <a data-reference="eq:delta_beta_value" data-reference-type="eqref" href="#eq:delta_beta_value">[eq:delta_beta_value]</a>에 의해 각각 <span class="math inline">\(1/\pi\)</span>이다. 따라서
<span class="math display">\[\delta
=
\left(\frac{1}{\pi}\right)\left(\frac{1}{\pi}\right)
=
\frac{1}{\pi^{2}}.
\label{eq:delta_final}\]</span></p>
<h3 data-number="7.4.5" id="d-최대-엔트로피-분포로서의-정류-상수"><span class="header-section-number">7.4.5</span> 5.2.5 [D] 최대 엔트로피 분포로서의 정류 상수</h3>
<p>본 절은 <span class="math inline">\(\delta=1/\pi^{2}\)</span>를 <em>공리로</em> 도입하지 않는다.
초기 조건과 구동 프로토콜에 특정 위상 <span class="math inline">\(\theta_0\)</span> 또는 <span class="math inline">\(\varphi_0\)</span>를 선호하게 만드는 물리적 정보(힘, 구속, 경계조건)가
<strong>사전 등록되어 있지 않다면</strong>, 정보 이론적 원리에 따라 위상 분포 <span class="math inline">\(P(\theta)\)</span>는 엔트로피
<span class="math display">\[H[P] = -\int_{0}^{2\pi} P(\theta)\,\ln P(\theta)\,d\theta\]</span>
를 최대화하는 형태여야 한다. 따라서 (정규화 <span class="math inline">\(\int P=1\)</span> 하에서)
<span class="math display">\[\text{maximize }H[P]\ \Longrightarrow\ P(\theta)=\frac{1}{2\pi}\quad(\text{Uniform})
\label{eq:phase_uniform_distribution}\]</span>
가 기본 상태(Default state)로 결정된다. 동일한 논리는 <span class="math inline">\(\varphi\)</span>에도 적용된다.</p>
<h4 data-number="7.4.5.1" id="조건게이트-편향-원인-부재"><span class="header-section-number">7.4.5.1</span> 조건(게이트): “편향 원인 부재”</h4>
<p>위 균등 분포 결론을 <strong>보편 상수</strong>로 사용할 자격은 “편향을 유발하는 원인이 없다”는 조건이 <code>PASS</code>일 때만 부여된다.
본 문서는 이를 다음 조건(및 5.2.6의 반증 트리거)로 Gate화한다.</p>
<ol>
<li><p><strong>[A-5.2-U1] 전주기 균등성(Null)</strong>: <span class="math inline">\(\theta,\varphi\)</span>의 분포는 <a data-reference="eq:delta_uniform_measure" data-reference-type="eqref" href="#eq:delta_uniform_measure">[eq:delta_uniform_measure]</a>의 균등분포를 기본 상태로 갖는다.</p></li>
<li><p><strong>[A-5.2-U2] 구속의 이중성</strong>: 생존 가중치는 <a data-reference="eq:delta_weight_def" data-reference-type="eqref" href="#eq:delta_weight_def">[eq:delta_weight_def]</a>의 반파 정류 곱으로 정의된다.</p></li>
<li><p><strong>[A-5.2-U3] 분리 측도(비상관)</strong>: 편향/구속 정보가 없을 때 결합 측도는 곱측도 <a data-reference="eq:delta_product_measure" data-reference-type="eqref" href="#eq:delta_product_measure">[eq:delta_product_measure]</a>로 취급된다.</p></li>
<li><p><strong>[A-5.2-U4] 레짐 고정</strong>: 만약 편향 원인(외부장, 경계조건, 구속)이 존재한다면, 그 정보는 사전 등록되어야 하며, 그 경우 <span class="math inline">\(\delta\)</span>의 보편 사용은 자동으로 정지되고 5.2.6 트리거 검사를 강제한다.</p></li>
</ol>
<p>따라서 <span class="math inline">\(\delta=1/\pi^2\)</span>은 “믿자”가 아니라, <strong>편향 원인의 부재</strong>가 낳은 기본 상태이며,
편향이 탐지되면(5.2.6) 즉시 보편 사용이 금지된다.</p>
<h3 data-number="7.4.6" id="반증-트리거깨지는-조건와-처리-규칙"><span class="header-section-number">7.4.6</span> 5.2.6 반증 트리거(깨지는 조건)와 처리 규칙</h3>
<p>본 절의 보편성 공리 [A-5.2-U]는 다음 트리거 중 하나라도 발생하면 깨진 것으로 판정한다. 트리거는 <code>gate_lock</code>에 문턱과 함께 사전 등록되어야 하며, 사후 변경은 금지된다.</p>
<h4 data-number="7.4.6.1" id="트리거-t1-균등성-붕괴편향-위상"><span class="header-section-number">7.4.6.1</span> 5.2.6.1 트리거 T1: 균등성 붕괴(편향 위상)</h4>
<p>사건 표본에서 다음 값이 문턱을 위반하면 균등성이 붕괴한 것으로 판정한다.
<span class="math display">\[m_{\theta}:=\left|\frac{1}{N}\sum_{e=1}^{N}\cos\theta(e)\right|,
\qquad
m_{\varphi}:=\left|\frac{1}{N}\sum_{e=1}^{N}\cos\varphi(e)\right|.
\label{eq:delta_bias_metrics}\]</span>
<code>gate_lock</code>에 잠긴 문턱 <span class="math inline">\(\varepsilon_{\mathrm{bias}}\)</span>에 대해,
<span class="math display">\[m_{\theta}&gt;\varepsilon_{\mathrm{bias}}
\ \ \text{또는}\ \
m_{\varphi}&gt;\varepsilon_{\mathrm{bias}}
\quad\Longrightarrow\quad
\texttt{FAIL-RECT-DELTA-BIAS}.
\label{eq:delta_trigger_bias}\]</span>
이 판정이 발생하면 [A-5.2-U1]이 붕괴한 것으로 기록되며, 해당 레짐에서 <span class="math inline">\(\delta\)</span> 보편 사용은 금지된다.</p>
<h4 data-number="7.4.6.2" id="트리거-t2-분리-측도-붕괴상관-위상"><span class="header-section-number">7.4.6.2</span> 5.2.6.2 트리거 T2: 분리 측도 붕괴(상관 위상)</h4>
<p>사건 표본에서 다음 상관 지표를 정의한다.
<span class="math display">\[u(e):=[\cos\theta(e)]_{+},
\qquad
v(e):=[\cos\varphi(e)]_{+},
\qquad
C_{uv}:=\left|\frac{1}{N}\sum_{e=1}^{N}u(e)v(e)-\left(\frac{1}{N}\sum_{e=1}^{N}u(e)\right)\left(\frac{1}{N}\sum_{e=1}^{N}v(e)\right)\right|.
\label{eq:delta_corr_metric}\]</span>
<code>gate_lock</code>에 잠긴 문턱 <span class="math inline">\(\varepsilon_{\mathrm{corr}}\)</span>에 대해,
<span class="math display">\[C_{uv}&gt;\varepsilon_{\mathrm{corr}}
\quad\Longrightarrow\quad
\texttt{FAIL-RECT-DELTA-CORR}.
\label{eq:delta_trigger_corr}\]</span>
이 판정이 발생하면 [A-5.2-U3]이 붕괴한 것으로 기록되며, 해당 레짐에서 <span class="math inline">\(\delta\)</span> 보편 사용은 금지된다.</p>
<h4 data-number="7.4.6.3" id="트리거-t3-수치적-보편성-붕괴hatdelta-불일치"><span class="header-section-number">7.4.6.3</span> 5.2.6.3 트리거 T3: 수치적 보편성 붕괴(<span class="math inline">\(\hat{\delta}\)</span> 불일치)</h4>
<p>사건 표본으로부터 <span class="math inline">\(\delta\)</span>의 경험 추정치를 다음으로 정의한다.
<span class="math display">\[\hat{\delta}
:=
\frac{1}{N}\sum_{e=1}^{N} w(e)
=
\frac{1}{N}\sum_{e=1}^{N} [\cos\theta(e)]_{+}[\cos\varphi(e)]_{+}.
\label{eq:delta_hat}\]</span>
<code>gate_lock</code>에 잠긴 문턱 <span class="math inline">\(\varepsilon_{\delta}\)</span>에 대해,
<span class="math display">\[\left|\hat{\delta}-\frac{1}{\pi^{2}}\right|&gt;\varepsilon_{\delta}
\quad\Longrightarrow\quad
\texttt{FAIL-RECT-DELTA-NUM}.
\label{eq:delta_trigger_num}\]</span>
이 판정이 발생하면, [A-5.2-U1]~[A-5.2-U3] 중 적어도 하나가 성립하지 않거나, 생존 정의 <a data-reference="eq:delta_weight_def" data-reference-type="eqref" href="#eq:delta_weight_def">[eq:delta_weight_def]</a>가 레짐에서 유지되지 않는 것으로 기록된다.</p>
<h4 data-number="7.4.6.4" id="트리거-t4-생존-정의-붕괴운영-절차-변경-또는-혼합"><span class="header-section-number">7.4.6.4</span> 5.2.6.4 트리거 T4: 생존 정의 붕괴(운영 절차 변경 또는 혼합)</h4>
<p>다음 중 하나라도 발생하면 생존 정의 <a data-reference="eq:delta_weight_def" data-reference-type="eqref" href="#eq:delta_weight_def">[eq:delta_weight_def]</a>가 붕괴한 것으로 판정한다.</p>
<ol>
<li><p><span class="math inline">\([x]_{+}\)</span> 대신 <span class="math inline">\(|x|\)</span> 또는 다른 비선형 함수(거듭제곱, 문턱 함수, 클리핑 등)가 혼합 사용됨.</p></li>
<li><p><span class="math inline">\(\theta,\varphi\)</span>의 정의(좌표계, 대표축, 사건 전/후 기준)가 lock_id 없이 변경됨.</p></li>
<li><p>동일 산출물에서 서로 다른 <code>analysis_lock_id</code>의 사상/닫힘이 혼합 사용됨.</p></li>
</ol>
<p>이 경우 즉시
<span class="math display">\[\texttt{FAIL-RECT-DELTA-DEF}
\label{eq:delta_trigger_def}\]</span>
로 판정하며, 해당 산출물 및 파생 산출물은 결론 자격을 상실한다.</p>
<h4 data-number="7.4.6.5" id="트리거-t5-레짐-밖-외삽스코프-위반"><span class="header-section-number">7.4.6.5</span> 5.2.6.5 트리거 T5: 레짐 밖 외삽(스코프 위반)</h4>
<p>레짐 좌표축에서 <code>DRV-ROT</code> 등 구동 축 또는 이방성 축이 켜진 레짐, 또는 <span class="math inline">\(R_{\mathrm{span}}=\texttt{SPAN-0}\)</span>과 같이 스패닝이 붕괴한 레짐에서 <span class="math inline">\(\delta\)</span>를 보편 상수로 <em>그대로</em> 사용하면 레짐 밖 외삽으로 판정한다. 이 경우
<span class="math display">\[\texttt{FAIL-REG-EXTRAP}
\label{eq:delta_trigger_extrap}\]</span>
로 처리하며, 한계 결론(CT-LIM)만 허용된다.</p>
<h3 data-number="7.4.7" id="사용처-연결정준-사건율-및-생존-상쇄-계열"><span class="header-section-number">7.4.7</span> 5.2.7 사용처 연결(정준 사건율 및 생존-상쇄 계열)</h3>
<p><span class="math inline">\(\delta\)</span>는 다음 계열의 유도에서 “생존 계수”로 사용된다.</p>
<ol>
<li><p><strong>정준 사건율</strong>: 사건 집계가 두 구속을 동시에 요구하는 경우, 원시 사건 카운트(구속 미적용 카운트)에 <span class="math inline">\(\delta\)</span>를 곱한 정류 사건율을 정의한다. 이때 <span class="math inline">\(\delta\)</span>의 사용은 [A-5.2-U]가 성립하는 레짐으로 제한된다.</p></li>
<li><p><strong>상쇄-생존 계열</strong>: 이산 셸 구조에서 “상쇄”가 부호 선택을 포함하는 경우, 생존 성분의 평균 기여는 반파 정류 평균을 통해 정류되며, 두 구속이 동시에 요구되면 <span class="math inline">\(\delta\)</span>가 나타난다.</p></li>
<li><p><strong>교차정합(RCROSS) 및 Gate</strong>: <span class="math inline">\(\delta\)</span>는 수치 일치의 정당화 근거가 아니라, 레짐 내에서 잠긴 정류 계수로서 교차정합 및 재현 Gate의 입력으로만 사용된다.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-24">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 반파 정류 연산자 <span class="math inline">\([x]_{+}\)</span>, 정준 측도 <span class="math inline">\(d\mu=d\theta/(2\pi)\)</span>, 생존 가중치 <span class="math inline">\(w=[\cos\theta]_{+}[\cos\varphi]_{+}\)</span>를 <code>analysis_lock</code>/<code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(\delta=\langle[\cos\theta]_{+}[\cos\varphi]_{+}\rangle=1/\pi^{2}\)</span> 유도 결과를 정류 상수 항목으로 <code>canon_lock</code>에 고정(유일 출처).</p></li>
<li><p>LOCK: 보편성 공리 [A-5.2-U]의 적용 범위(균등성/이중구속/분리측도/레짐 고정)를 <code>canon_lock</code>에 고정.</p></li>
<li><p>Gate: 트리거(T1–T5)의 문턱 <span class="math inline">\(\varepsilon_{\mathrm{bias}},\varepsilon_{\mathrm{corr}},\varepsilon_{\delta}\)</span> 및 FAIL 라벨을 <code>gate_lock</code>에 고정.</p></li>
<li><p>Gate: 트리거 발생 시 <code>FAIL-RECT-DELTA-*</code> 또는 <code>FAIL-REG-EXTRAP</code>로 판정하며, 해당 산출물의 결론 자격 박탈 및 의존성 전파를 고정.</p></li>
</ul>
<h2 data-number="7.5" id="delta가-들어가는-자리"><span class="header-section-number">7.5</span> 5.3 <span class="math inline">\(\delta\)</span>가 들어가는 자리</h2>
<h3 data-number="7.5.1" id="delta의-정의와-사용-전제요약-정의가-아닌-완결-정의"><span class="header-section-number">7.5.1</span> 5.3.1 <span class="math inline">\(\delta\)</span>의 정의와 사용 전제(요약 정의가 아닌 완결 정의)</h3>
<p><span class="math inline">\(\delta\)</span>는 “이중 구속(two-constraint) 사건”에서 생존하는 평균 비율을 나타내는 정류 계수로 정의한다. 본 절에서 <span class="math inline">\(\delta\)</span>는 다음 정의와 전제 위에서만 사용된다.</p>
<h4 data-number="7.5.1.1" id="d-5.3-1-두-위상-변수와-정준-측도"><span class="header-section-number">7.5.1.1</span> [D-5.3-1] 두 위상 변수와 정준 측도</h4>
<p>두 위상 변수를 다음으로 정의한다.
<span class="math display">\[\theta \in [0,2\pi),\qquad \varphi \in [0,2\pi).
\label{eq:S05_delta_phase}\]</span>
정준 측도는 전주기 균등 측도로 잠근다.
<span class="math display">\[d\mu(\theta)=\frac{d\theta}{2\pi},\qquad d\mu(\varphi)=\frac{d\varphi}{2\pi}.
\label{eq:S05_delta_measure}\]</span>
균등 측도는 정류 규약의 일부이며, 결과를 본 뒤 가중을 끼워 넣어 바꾸지 않는다.</p>
<h4 data-number="7.5.1.2" id="d-5.3-2-반파-정류-연산자와-생존-가중치"><span class="header-section-number">7.5.1.2</span> [D-5.3-2] 반파 정류 연산자와 생존 가중치</h4>
<p>반파 정류 연산자를 다음으로 정의한다.
<span class="math display">\[_{+}:=\max(0,x).
\label{eq:S05_pospart}\]</span>
사건 <span class="math inline">\(e\)</span>의 생존 가중치를 다음으로 정의한다.
<span class="math display">\[w(e):=[\cos\theta(e)]_{+}\,[\cos\varphi(e)]_{+}.
\label{eq:S05_weight}\]</span>
정의 <a data-reference="eq:S05_weight" data-reference-type="eqref" href="#eq:S05_weight">[eq:S05_weight]</a>는 “생존”의 운영 정의이며, 동일 버전 내부에서 <span class="math inline">\(|\,\cdot\,|\)</span> 또는 다른 비선형 함수로 교체될 수 없다.</p>
<h4 data-number="7.5.1.3" id="d-5.3-3-delta의-정의"><span class="header-section-number">7.5.1.3</span> [D-5.3-3] <span class="math inline">\(\delta\)</span>의 정의</h4>
<p><span class="math inline">\(\delta\)</span>는 생존 가중치의 평균으로 정의한다.
<span class="math display">\[\delta
:=
\left\langle w \right\rangle
=
\int_{0}^{2\pi}\!\!\int_{0}^{2\pi}
[\cos\theta]_{+}[\cos\varphi]_{+}\, d\mu(\theta)\,d\mu(\varphi).
\label{eq:S05_delta_def}\]</span>
또한 다음 보편성 전제(분리 측도)가 성립하는 레짐에서
<span class="math display">\[d\mu(\theta,\varphi)=d\mu(\theta)\,d\mu(\varphi)
\label{eq:S05_product_measure}\]</span>
가 잠기면,
<span class="math display">\[\delta=\frac{1}{\pi^{2}}
\label{eq:S05_delta_value}\]</span>
로 고정된다. 보편성 전제가 성립하지 않는 레짐에서는 <a data-reference="eq:S05_delta_value" data-reference-type="eqref" href="#eq:S05_delta_value">[eq:S05_delta_value]</a>의 사용이 금지되며, 그 경우 <span class="math inline">\(\delta\)</span>는 레짐-의존 추정량으로만 다룬다(해당 추정량과 문턱은 닫힘과 Gate로 잠금).</p>
<h3 data-number="7.5.2" id="사건율에서의-delta-정의-삽입-결과형"><span class="header-section-number">7.5.2</span> 5.3.2 사건율에서의 <span class="math inline">\(\delta\)</span> (정의-삽입-결과형)</h3>
<h4 data-number="7.5.2.1" id="정의-원시-사건-카운트와-원시-사건율"><span class="header-section-number">7.5.2.1</span> 5.3.2.1 정의: 원시 사건 카운트와 원시 사건율</h4>
<p>틱 구간 <span class="math inline">\([n_1,n_2)\)</span>를 선택하고, 해당 구간의 실현 시간 길이를 다음으로 정의한다.
<span class="math display">\[\Delta N := n_2-n_1,
\qquad
\Delta T := \Delta N\,\Delta t.
\label{eq:S05_time_window}\]</span>
여기서 <span class="math inline">\(\Delta t\)</span>는 <code>realization_lock</code>에 잠긴 실현 시간 틱이다.</p>
<p>틱 구간에서 “원시 사건”을 다음으로 정의한다.
<span class="math display">\[\mathcal{E}_{0}[n_1,n_2)
:=\{\, e\ |\ n_1\le n(e)&lt;n_2\,\}.
\label{eq:S05_event_set_raw}\]</span>
원시 사건 카운트와 원시 사건율을 다음으로 정의한다.
<span class="math display">\[N_{0}
:=|\mathcal{E}_{0}[n_1,n_2)|,
\qquad
\nu_{0}
:=\frac{N_{0}}{\Delta T}.
\label{eq:S05_raw_rate}\]</span>
<span class="math inline">\(\nu_{0}\)</span>는 “구속을 적용하기 전”의 사건율이다.</p>
<h4 data-number="7.5.2.2" id="삽입-이중-구속-생존-가중치의-집계"><span class="header-section-number">7.5.2.2</span> 5.3.2.2 삽입: 이중 구속 생존 가중치의 집계</h4>
<p>원시 사건 집합 <span class="math inline">\(\mathcal{E}_{0}[n_1,n_2)\)</span>에 대해, 생존 가중치 <a data-reference="eq:S05_weight" data-reference-type="eqref" href="#eq:S05_weight">[eq:S05_weight]</a>를 적용한 “정류 사건 카운트”를 다음으로 정의한다.
<span class="math display">\[N_{\delta}
:=
\sum_{e\in\mathcal{E}_{0}[n_1,n_2)} w(e)
=
\sum_{e\in\mathcal{E}_{0}[n_1,n_2)}
[\cos\theta(e)]_{+}[\cos\varphi(e)]_{+}.
\label{eq:S05_Ndelta}\]</span>
정의 <a data-reference="eq:S05_Ndelta" data-reference-type="eqref" href="#eq:S05_Ndelta">[eq:S05_Ndelta]</a>는 “사건의 생존”을 수치로 기록하는 최소 집계이며, <span class="math inline">\(\theta(e)\)</span>와 <span class="math inline">\(\varphi(e)\)</span>의 정의(좌표계/축/대표 규약)는 <code>analysis_lock</code>에 잠겨야 한다.</p>
<p>보편성 전제(균등 측도 및 분리 측도)가 잠긴 레짐에서는 다음 등식이 성립하는 것을 정류 규약으로 고정한다.
<span class="math display">\[N_{\delta}
\equiv
\delta\,N_{0}.
\label{eq:S05_Ndelta_equiv}\]</span>
여기서 <span class="math inline">\(\delta\)</span>는 <a data-reference="eq:S05_delta_value" data-reference-type="eqref" href="#eq:S05_delta_value">[eq:S05_delta_value]</a>로 고정될 수 있으며, 고정되었을 때 <span class="math inline">\(\delta\)</span>는 값 자체가 아니라 “정류 규약”의 레지스트리 항목으로 참조된다.</p>
<h4 data-number="7.5.2.3" id="결과형-정류-사건율"><span class="header-section-number">7.5.2.3</span> 5.3.2.3 결과형: 정류 사건율</h4>
<p>정류 사건율을 다음으로 정의한다.
<span class="math display">\[\nu
:=
\frac{N_{\delta}}{\Delta T}.
\label{eq:S05_rect_rate_def}\]</span>
보편성 전제가 성립하여 <a data-reference="eq:S05_Ndelta_equiv" data-reference-type="eqref" href="#eq:S05_Ndelta_equiv">[eq:S05_Ndelta_equiv]</a>가 허용되는 레짐에서는,
<span class="math display">\[\nu
=
\frac{\delta\,N_{0}}{\Delta T}
=
\delta\,\nu_{0}.
\label{eq:S05_rect_rate_result}\]</span>
따라서 사건율에서 <span class="math inline">\(\delta\)</span>의 역할은 “원시 사건율 <span class="math inline">\(\nu_{0}\)</span>의 생존 정류”이며, 삽입 위치는 <a data-reference="eq:S05_Ndelta_equiv" data-reference-type="eqref" href="#eq:S05_Ndelta_equiv">[eq:S05_Ndelta_equiv]</a> 또는 <a data-reference="eq:S05_rect_rate_result" data-reference-type="eqref" href="#eq:S05_rect_rate_result">[eq:S05_rect_rate_result]</a>로 잠긴다.</p>
<h3 data-number="7.5.3" id="유효속도에서의-delta-정의-삽입-결과형"><span class="header-section-number">7.5.3</span> 5.3.3 유효속도에서의 <span class="math inline">\(\delta\)</span> (정의-삽입-결과형)</h3>
<h4 data-number="7.5.3.1" id="정의-방향-구속-이동량과-원시-전진-속도"><span class="header-section-number">7.5.3.1</span> 5.3.3.1 정의: 방향-구속 이동량과 원시 전진 속도</h4>
<p>전파(또는 전달)의 방향을 단위벡터 <span class="math inline">\(\mathbf{n}_v\)</span>로 잠근다.
<span class="math display">\[\|\mathbf{n}_v\|=1,
\qquad
\mathbf{n}_v\ \text{는 }\texttt{analysis\_lock}\text{에 잠긴다}.
\label{eq:S05_nv_lock}\]</span>
틱 구간 <span class="math inline">\([n_1,n_2)\)</span>에서 사건 <span class="math inline">\(e\)</span>가 발생할 때, 전/후 배치에 대해 “전진 이동량”을 다음으로 정의한다.
<span class="math display">\[\Delta \tilde{x}_{\parallel}(e)
:=
\mathbf{n}_v\cdot\Bigl(\tilde{\mathbf{x}}_{\mathrm{tag}}^{\mathrm{post}}(e)-\tilde{\mathbf{x}}_{\mathrm{tag}}^{\mathrm{pre}}(e)\Bigr),
\label{eq:S05_dx_tilde}\]</span>
여기서 <span class="math inline">\(\tilde{\mathbf{x}}_{\mathrm{tag}}\)</span>는 사건에 대해 잠긴 대표 좌표(예: 코어 표지점, 셸 생존 표지점, 또는 셀 표지점)이며, 대표 좌표의 선택 규약은 <code>analysis_lock</code>에 잠긴다. <span class="math inline">\(\Delta \tilde{x}_{\parallel}(e)\)</span>는 내부 단위(무차원 또는 내부 길이 단위)에서의 전진 이동량이며, 실현 길이는 <span class="math inline">\(a\)</span>를 통해 <a data-reference="eq:S05_dx_real" data-reference-type="eqref" href="#eq:S05_dx_real">[eq:S05_dx_real]</a>로 변환된다.</p>
<p>원시 전진 이동량의 합을 다음으로 정의한다.
<span class="math display">\[\Delta \tilde{X}_{0}
:=
\sum_{e\in\mathcal{E}_{0}[n_1,n_2)} \Delta \tilde{x}_{\parallel}(e).
\label{eq:S05_sum_dx_raw}\]</span>
원시 내부 전진 속도를 다음으로 정의한다.
<span class="math display">\[\tilde{v}_{0}
:=
\frac{\Delta \tilde{X}_{0}}{\Delta N}.
\label{eq:S05_vtilde0}\]</span>
<span class="math inline">\(\tilde{v}_{0}\)</span>는 “사건이 모두 전진 기여를 동일하게 인정받는다”는 원시 정의이며, 이중 구속 생존이 반영되지 않은 상태이다.</p>
<h4 data-number="7.5.3.2" id="삽입-생존-가중치에-의한-전진-이동량-정류"><span class="header-section-number">7.5.3.2</span> 5.3.3.2 삽입: 생존 가중치에 의한 전진 이동량 정류</h4>
<p>전진 이동량에 생존 가중치를 삽입한 정류 이동량을 다음으로 정의한다.
<span class="math display">\[\Delta \tilde{X}_{\delta}
:=
\sum_{e\in\mathcal{E}_{0}[n_1,n_2)} w(e)\,\Delta \tilde{x}_{\parallel}(e).
\label{eq:S05_sum_dx_rect}\]</span>
이에 대응하는 정류 내부 전진 속도를 다음으로 정의한다.
<span class="math display">\[\tilde{v}
:=
\frac{\Delta \tilde{X}_{\delta}}{\Delta N}.
\label{eq:S05_vtilde_rect_def}\]</span>
보편성 전제가 성립하고, 또한 전진 이동량 <span class="math inline">\(\Delta \tilde{x}_{\parallel}(e)\)</span>가 생존 구속 위상들과 레짐 내에서 분리되어 평균적으로 독립인 경우(이 독립성은 <code>analysis_lock</code>에 레짐 조건으로 잠김), 다음 형태의 정류가 허용된다.
<span class="math display">\[\Delta \tilde{X}_{\delta}\equiv \delta\,\Delta \tilde{X}_{0}.
\label{eq:S05_dx_rect_equiv}\]</span>
이 등식은 “항상 성립”이 아니라 레짐 조건이 잠겼을 때만 성립하는 닫힘이며, 레짐 밖 사용은 금지된다.</p>
<h4 data-number="7.5.3.3" id="결과형-실현-유효속도"><span class="header-section-number">7.5.3.3</span> 5.3.3.3 결과형: 실현 유효속도</h4>
<p>실현 길이 <span class="math inline">\(x\)</span>와 내부 길이 <span class="math inline">\(\tilde{x}\)</span>의 실현 사상을 다음으로 사용한다.
<span class="math display">\[x := a\,\tilde{x}.
\label{eq:S05_dx_real}\]</span>
실현 시간은 <span class="math inline">\(t:=\Delta t\,\tilde{t}\)</span>이며, 틱 구간에서 <span class="math inline">\(\Delta T=\Delta N\,\Delta t\)</span>로 정의된다(<a data-reference="eq:S05_time_window" data-reference-type="eqref" href="#eq:S05_time_window">[eq:S05_time_window]</a>).</p>
<p>실현 유효속도를 다음으로 정의한다.
<span class="math display">\[v_{\mathrm{eff}}
:=
\frac{\Delta X_{\delta}}{\Delta T}
=
\frac{a\,\Delta \tilde{X}_{\delta}}{\Delta N\,\Delta t}
=
\frac{a}{\Delta t}\,\tilde{v}.
\label{eq:S05_veff_def}\]</span>
보편성 및 독립성 조건이 성립하여 <a data-reference="eq:S05_dx_rect_equiv" data-reference-type="eqref" href="#eq:S05_dx_rect_equiv">[eq:S05_dx_rect_equiv]</a>가 허용되면,
<span class="math display">\[v_{\mathrm{eff}}
=
\frac{a}{\Delta t}\,\delta\,\tilde{v}_{0}
=
\delta\,v_{0},
\qquad
v_{0}:=\frac{a}{\Delta t}\tilde{v}_{0}.
\label{eq:S05_veff_result}\]</span>
따라서 유효속도에서 <span class="math inline">\(\delta\)</span>의 역할은 “전진 기여의 생존 정류”이며, 삽입 위치는 전진 이동량 합 <a data-reference="eq:S05_sum_dx_rect" data-reference-type="eqref" href="#eq:S05_sum_dx_rect">[eq:S05_sum_dx_rect]</a> 또는 결과식 <a data-reference="eq:S05_veff_result" data-reference-type="eqref" href="#eq:S05_veff_result">[eq:S05_veff_result]</a>로 잠긴다.</p>
<h3 data-number="7.5.4" id="질량-유도에서의-delta-정의-삽입-결과형"><span class="header-section-number">7.5.4</span> 5.3.4 질량 유도에서의 <span class="math inline">\(\delta\)</span> (정의-삽입-결과형)</h3>
<h4 data-number="7.5.4.1" id="정의-질량-스케일의-운영-정의사건-기하-결합"><span class="header-section-number">7.5.4.1</span> 5.3.4.1 정의: 질량 스케일의 운영 정의(사건-기하 결합)</h4>
<p>본 문서에서 “질량”은 외부 정설의 정당화로 도입되지 않으며, 다음 운영 정의로만 도입된다.
실현된 단위 에너지 <span class="math inline">\(U_{\mathrm{lat}}\)</span>를 <code>realization_lock</code>에 잠긴 스케일로 둔다. <span class="math inline">\(U_{\mathrm{lat}}\)</span>의 수치 생성 규약은 본 절의 대상이 아니며, 본 절에서는 <span class="math inline">\(U_{\mathrm{lat}}\)</span>가 “에너지 차원”을 갖는 잠긴 단위라는 사실만 사용한다.</p>
<p>객체 <span class="math inline">\(\mathcal{O}\)</span>에 대해, “질량 스케일” <span class="math inline">\(m(\mathcal{O})\)</span>를 다음 형태로 정의한다.
<span class="math display">\[m(\mathcal{O})
:=
U_{\mathrm{lat}}\,
\Lambda(\mathcal{O}),
\label{eq:S05_mass_def}\]</span>
여기서 <span class="math inline">\(\Lambda(\mathcal{O})\)</span>는 무차원 “기하-사건 결합 계수”이며, 다음 곱으로 구성되는 것을 표준 형태로 잠근다.
<span class="math display">\[\Lambda(\mathcal{O})
:=
\Gamma(\mathcal{O})\,
\Xi(\mathcal{O}).
\label{eq:S05_lambda_factor}\]</span></p>
<ul>
<li><p><span class="math inline">\(\Gamma(\mathcal{O})\)</span>는 <strong>기하 계수</strong>이다. 코어/셸/셀 등 객체 정의와 길이 비율로부터 도출되며, 정의와 파생 규약은 <code>canon_lock</code>에 잠긴다.</p></li>
<li><p><span class="math inline">\(\Xi(\mathcal{O})\)</span>는 <strong>사건 계수</strong>이다. 사건 집계(틱 창, 사건 정의, 생존 규약)로부터 도출되며, 정의와 집계 규약은 <code>analysis_lock</code>에 잠긴다.</p></li>
</ul>
<p>질량 유도에서 <span class="math inline">\(\delta\)</span>가 들어가는 자리는 <span class="math inline">\(\Xi(\mathcal{O})\)</span> 내부로 고정한다.</p>
<h4 data-number="7.5.4.2" id="삽입-사건-계수-ximathcalo에-대한-delta-삽입"><span class="header-section-number">7.5.4.2</span> 5.3.4.2 삽입: 사건 계수 <span class="math inline">\(\Xi(\mathcal{O})\)</span>에 대한 <span class="math inline">\(\delta\)</span> 삽입</h4>
<p>객체 <span class="math inline">\(\mathcal{O}\)</span>에 대해, 원시 사건 계수를 다음으로 정의한다.
<span class="math display">\[\Xi_{0}(\mathcal{O})
:=
\frac{N_{0}(\mathcal{O})}{N_{\mathrm{ref}}},
\label{eq:S05_Xi0}\]</span>
여기서 <span class="math inline">\(N_{0}(\mathcal{O})\)</span>는 <a data-reference="eq:S05_event_set_raw" data-reference-type="eqref" href="#eq:S05_event_set_raw">[eq:S05_event_set_raw]</a>와 동일한 방식으로 정의된 “객체 <span class="math inline">\(\mathcal{O}\)</span>에 귀속된 원시 사건 카운트”이며, <span class="math inline">\(N_{\mathrm{ref}}\)</span>는 동일 시간 창에서 잠긴 기준 카운트(레퍼런스)이다. 기준 카운트의 선택은 사전 등록되어야 하며, 사후 변경은 금지된다.</p>
<p>정류 사건 계수는 다음으로 정의한다.
<span class="math display">\[\Xi(\mathcal{O})
:=
\frac{N_{\delta}(\mathcal{O})}{N_{\mathrm{ref}}},
\qquad
N_{\delta}(\mathcal{O})
:=
\sum_{e\in\mathcal{E}_{0}(\mathcal{O})} w(e).
\label{eq:S05_Xi_rect}\]</span>
보편성 전제가 성립하여 <span class="math inline">\(N_{\delta}(\mathcal{O})\equiv \delta N_{0}(\mathcal{O})\)</span>가 허용되는 레짐에서는,
<span class="math display">\[\Xi(\mathcal{O}) \equiv \delta\,\Xi_{0}(\mathcal{O}).
\label{eq:S05_Xi_delta_insert}\]</span>
이것이 질량 유도에서 <span class="math inline">\(\delta\)</span>의 <strong>삽입 위치</strong>로 잠긴다.</p>
<h4 data-number="7.5.4.3" id="결과형-질량-스케일의-delta-포함-형태"><span class="header-section-number">7.5.4.3</span> 5.3.4.3 결과형: 질량 스케일의 <span class="math inline">\(\delta\)</span> 포함 형태</h4>
<p>정의 <a data-reference="eq:S05_mass_def" data-reference-type="eqref" href="#eq:S05_mass_def">[eq:S05_mass_def]</a>–<a data-reference="eq:S05_lambda_factor" data-reference-type="eqref" href="#eq:S05_lambda_factor">[eq:S05_lambda_factor]</a>와 <a data-reference="eq:S05_Xi_delta_insert" data-reference-type="eqref" href="#eq:S05_Xi_delta_insert">[eq:S05_Xi_delta_insert]</a>로부터, 보편성 전제가 성립하는 레짐에서는
<span class="math display">\[m(\mathcal{O})
=
U_{\mathrm{lat}}\,
\Gamma(\mathcal{O})\,\Xi(\mathcal{O})
\equiv
U_{\mathrm{lat}}\,
\Gamma(\mathcal{O})\,\delta\,\Xi_{0}(\mathcal{O}).
\label{eq:S05_mass_result}\]</span>
따라서 질량 유도에서 <span class="math inline">\(\delta\)</span>는 “사건 계수의 생존 정류”로만 들어가며, 기하 계수 <span class="math inline">\(\Gamma(\mathcal{O})\)</span>를 조정하는 항으로 사용될 수 없다. <span class="math inline">\(\delta\)</span>를 기하 계수로 흡수하거나, <span class="math inline">\(\Gamma(\mathcal{O})\)</span>의 정의를 바꾸어 <span class="math inline">\(\delta\)</span>를 제거하는 행위는 금지된다.</p>
<h3 data-number="7.5.5" id="힘-유도에서의-delta-정의-삽입-결과형"><span class="header-section-number">7.5.5</span> 5.3.5 힘 유도에서의 <span class="math inline">\(\delta\)</span> (정의-삽입-결과형)</h3>
<h4 data-number="7.5.5.1" id="정의-단위-힘과-방향성-사건-플럭스"><span class="header-section-number">7.5.5.1</span> 5.3.5.1 정의: 단위 힘과 방향성 사건 플럭스</h4>
<p>단위 힘 <span class="math inline">\(F_{\mathrm{lat}}\)</span>을 다음 파생 정의로 고정한다.
<span class="math display">\[F_{\mathrm{lat}} := \frac{U_{\mathrm{lat}}}{a}.
\label{eq:S05_Flat}\]</span>
여기서 <span class="math inline">\(U_{\mathrm{lat}}\)</span>와 <span class="math inline">\(a\)</span>는 <code>realization_lock</code>에 잠긴 실현 스케일이다. 정의 <a data-reference="eq:S05_Flat" data-reference-type="eqref" href="#eq:S05_Flat">[eq:S05_Flat]</a>는 “단위 에너지/단위 길이”라는 내부 정의이며, 외부 정설을 근거로 하지 않는다.</p>
<p>방향성 사건 플럭스를 다음으로 정의한다. 방향을 단위벡터 <span class="math inline">\(\mathbf{n}_F\)</span>로 잠근다.
<span class="math display">\[\|\mathbf{n}_F\|=1,
\qquad
\mathbf{n}_F\ \text{는 }\texttt{analysis\_lock}\text{에 잠긴다}.
\label{eq:S05_nF}\]</span>
사건 <span class="math inline">\(e\)</span>마다 “방향 기여 부호” <span class="math inline">\(s_F(e)\in\{-1,0,+1\}\)</span>를 다음으로 정의한다.
<span class="math display">\[s_F(e)
:=
\mathrm{sgn}\!\left(\Delta \tilde{x}_{\parallel,F}(e)\right),
\qquad
\Delta \tilde{x}_{\parallel,F}(e)
:=
\mathbf{n}_F\cdot\Bigl(\tilde{\mathbf{x}}_{\mathrm{tag}}^{\mathrm{post}}(e)-\tilde{\mathbf{x}}_{\mathrm{tag}}^{\mathrm{pre}}(e)\Bigr),
\label{eq:S05_sF}\]</span>
여기서 <span class="math inline">\(\tilde{\mathbf{x}}_{\mathrm{tag}}\)</span>의 선택 규약은 잠겨야 한다. 방향성 원시 집계량을 다음으로 정의한다.
<span class="math display">\[S_{0}
:=
\sum_{e\in\mathcal{E}_{0}[n_1,n_2)} s_F(e).
\label{eq:S05_S0}\]</span>
<span class="math inline">\(S_0\)</span>는 방향성 사건의 순부호 합이며, 단위는 없다.</p>
<h4 data-number="7.5.5.2" id="삽입-생존-가중치의-힘-방향-집계-삽입"><span class="header-section-number">7.5.5.2</span> 5.3.5.2 삽입: 생존 가중치의 힘-방향 집계 삽입</h4>
<p>방향성 집계에 생존 가중치를 삽입한 정류 집계량을 다음으로 정의한다.
<span class="math display">\[S_{\delta}
:=
\sum_{e\in\mathcal{E}_{0}[n_1,n_2)} w(e)\, s_F(e).
\label{eq:S05_Sdelta}\]</span>
보편성 전제가 성립하고, 또한 방향 부호 <span class="math inline">\(s_F(e)\)</span>가 생존 구속 위상들과 레짐 내에서 분리되어 평균적으로 독립인 경우(이 독립성은 레짐 조건으로 잠김), 다음 형태의 정류가 허용된다.
<span class="math display">\[S_{\delta}\equiv \delta\,S_{0}.
\label{eq:S05_Sdelta_equiv}\]</span>
이 등식은 레짐 밖에서 자동 성립하지 않으며, 레짐 밖 사용은 외삽으로 금지된다.</p>
<h4 data-number="7.5.5.3" id="결과형-힘-스케일의-delta-포함-형태"><span class="header-section-number">7.5.5.3</span> 5.3.5.3 결과형: 힘 스케일의 <span class="math inline">\(\delta\)</span> 포함 형태</h4>
<p>힘 스케일을 다음으로 정의한다.
<span class="math display">\[F
:=
F_{\mathrm{lat}}\,
\frac{S_{\delta}}{\Delta N}.
\label{eq:S05_force_def}\]</span>
여기서 <span class="math inline">\(\Delta N\)</span>은 틱 길이이며(정의 <a data-reference="eq:S05_time_window" data-reference-type="eqref" href="#eq:S05_time_window">[eq:S05_time_window]</a>), <span class="math inline">\(S_{\delta}/\Delta N\)</span>은 “틱당 방향성 생존 집계”이다. 보편성 및 독립성 조건이 성립하여 <a data-reference="eq:S05_Sdelta_equiv" data-reference-type="eqref" href="#eq:S05_Sdelta_equiv">[eq:S05_Sdelta_equiv]</a>가 허용되면,
<span class="math display">\[F
\equiv
F_{\mathrm{lat}}\,
\delta\,
\frac{S_{0}}{\Delta N}
=
\delta\,F_{0},
\qquad
F_{0}:=F_{\mathrm{lat}}\frac{S_{0}}{\Delta N}.
\label{eq:S05_force_result}\]</span>
따라서 힘 유도에서 <span class="math inline">\(\delta\)</span>의 역할은 “방향성 사건 집계의 생존 정류”이며, 삽입 위치는 <a data-reference="eq:S05_Sdelta" data-reference-type="eqref" href="#eq:S05_Sdelta">[eq:S05_Sdelta]</a> 또는 결과식 <a data-reference="eq:S05_force_result" data-reference-type="eqref" href="#eq:S05_force_result">[eq:S05_force_result]</a>로 잠긴다.</p>
<h3 data-number="7.5.6" id="delta-삽입의-공통-금지-규칙역삽입흡수재정의-금지"><span class="header-section-number">7.5.6</span> 5.3.6 <span class="math inline">\(\delta\)</span> 삽입의 공통 금지 규칙(역삽입/흡수/재정의 금지)</h3>
<p>본 절에서 고정된 <span class="math inline">\(\delta\)</span>의 삽입은 다음 금지 규칙을 동반한다.</p>
<ol>
<li><p><strong>역삽입 금지</strong>: <span class="math inline">\(\delta\)</span>가 들어간 결과식에서 <span class="math inline">\(\delta\)</span>를 제거하기 위해 원시량(<span class="math inline">\(N_0,\nu_0,\tilde{v}_0,\Xi_0,S_0\)</span> 등)을 재정의하는 행위를 금지한다.</p></li>
<li><p><strong>흡수 금지</strong>: <span class="math inline">\(\delta\)</span>를 기하 계수 <span class="math inline">\(\Gamma(\mathcal{O})\)</span> 또는 단위 스케일(<span class="math inline">\(a,\Delta t,U_{\mathrm{lat}}\)</span>)의 정의로 흡수하여 표면적으로 <span class="math inline">\(\delta\)</span>를 없애는 행위를 금지한다.</p></li>
<li><p><strong>재정의 금지</strong>: <span class="math inline">\(\delta\)</span>를 사건 정의, 평균 규약, 문턱 규약의 교체로 재정의하는 행위를 금지한다. 재정의는 버전업으로만 존재하며, 버전업은 전면 재유도/전면 재판정을 요구한다.</p></li>
<li><p><strong>레짐 밖 외삽 금지</strong>: 보편성 전제가 성립하지 않는 레짐에서 <a data-reference="eq:S05_delta_value" data-reference-type="eqref" href="#eq:S05_delta_value">[eq:S05_delta_value]</a>를 사용하거나, <a data-reference="eq:S05_Ndelta_equiv" data-reference-type="eqref" href="#eq:S05_Ndelta_equiv">[eq:S05_Ndelta_equiv]</a>, <a data-reference="eq:S05_dx_rect_equiv" data-reference-type="eqref" href="#eq:S05_dx_rect_equiv">[eq:S05_dx_rect_equiv]</a>, <a data-reference="eq:S05_Sdelta_equiv" data-reference-type="eqref" href="#eq:S05_Sdelta_equiv">[eq:S05_Sdelta_equiv]</a>를 자동 적용하는 행위를 금지한다.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-25">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(\delta\)</span>의 정의 <a data-reference="eq:S05_delta_def" data-reference-type="eqref" href="#eq:S05_delta_def">[eq:S05_delta_def]</a> 및 보편 값 <a data-reference="eq:S05_delta_value" data-reference-type="eqref" href="#eq:S05_delta_value">[eq:S05_delta_value]</a>는 정류 상수 항목으로 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: 사건율/유효속도/질량/힘에서의 <span class="math inline">\(\delta\)</span> 삽입 위치(각각 <a data-reference="eq:S05_Ndelta_equiv" data-reference-type="eqref" href="#eq:S05_Ndelta_equiv">[eq:S05_Ndelta_equiv]</a>, <a data-reference="eq:S05_dx_rect_equiv" data-reference-type="eqref" href="#eq:S05_dx_rect_equiv">[eq:S05_dx_rect_equiv]</a>, <a data-reference="eq:S05_Xi_delta_insert" data-reference-type="eqref" href="#eq:S05_Xi_delta_insert">[eq:S05_Xi_delta_insert]</a>, <a data-reference="eq:S05_Sdelta_equiv" data-reference-type="eqref" href="#eq:S05_Sdelta_equiv">[eq:S05_Sdelta_equiv]</a>)를 <code>analysis_lock</code>의 PASS.rules 훅으로 고정.</p></li>
<li><p>Gate: 보편성 전제(균등성/분리측도/생존 정의 유지) 위반은 G-RECT 및 G-REG에서 <code>FAIL</code> 또는 <code>INCONCLUSIVE</code>로 판정.</p></li>
<li><p>Gate: 생존 정의 <a data-reference="eq:S05_weight" data-reference-type="eqref" href="#eq:S05_weight">[eq:S05_weight]</a>의 사후 교체, 레짐 밖 외삽, 기호 오버로딩은 G-NT 또는 G-SYM에서 <code>FAIL</code>로 판정.</p></li>
<li><p>Gate: 서로 다른 lock_id 조합에서 산출된 <span class="math inline">\(\delta\)</span> 포함 결과의 혼합 서술은 G-LOCK에서 <code>FAIL</code>로 판정.</p></li>
</ul>
<h1 data-number="8" id="연속체-코어-모델-r_p-유도"><span class="header-section-number">8</span> 6. 연속체 코어 모델: <span class="math inline">\(R_p\)</span> 유도</h1>
<h2 class="unnumbered" id="목적산출물의-고정">목적(산출물의 고정)</h2>
<p>본 장의 목적은 코어 반경 <span class="math inline">\(R_p\)</span>를 내부 정의만으로 결정하는 연속체(연속 근사) 코어 모델을 구성하고, 그 모델로부터 다음의 산출물을 도출하여 잠그는 데 있다.</p>
<ol>
<li><p>코어 반경의 <strong>정의식</strong> <span class="math inline">\(R_p:=\mathcal{R}[\text{코어 상태}]\)</span> (정의-레짐 포함).</p></li>
<li><p>코어 안정 조건의 <strong>정식화</strong> (정지 조건/평형 조건/스위치 조건 중 하나로 잠금).</p></li>
<li><p>길이 선택 비율의 <strong>무차원 결론</strong>:
<span class="math display">\[\frac{R_p}{L_q}=\alpha=\frac{2}{\pi},
  \label{eq:S06_goal_ratio}\]</span>
여기서 <span class="math inline">\(L_q\)</span>는 코어 선택 길이(내부 길이 스케일)이며, <span class="math inline">\(\alpha\)</span>는 5장에서 유일 출처로 고정된 정류 상수이다.</p></li>
<li><p>위 결론을 사용하는 후속 유도(사건율, 질량/힘 스케일)의 <strong>삽입 위치</strong>와 <strong>금지되는 소급</strong>의 명시.</p></li>
</ol>
<p>본 장은 <span class="math inline">\(R_p\)</span>를 외부 텍스트의 정당화로 도입하지 않는다. 본 장에서 허용되는 입력은 오직 <code>canon_lock</code>/<code>analysis_lock</code>에 잠긴 내부 정의와 내부 규약뿐이다. 외부 수치와의 비교가 필요한 경우, 그 비교는 <strong>검증(Gate) 항목</strong>으로만 취급되며, 유도의 근거로 사용되지 않는다.</p>
<h2 class="unnumbered" id="입력lock과-레짐적용-범위">입력(LOCK)과 레짐(적용 범위)</h2>
<p><span class="math inline">\(R_p\)</span> 유도는 다음 입력 항목들이 잠겨 있을 때에만 수행된다.</p>
<h3 class="unnumbered" id="기판stone-레짐과-vp-공리">기판(Stone) 레짐과 VP 공리</h3>
<p>본 장은 3.1에서 잠긴 VP 공리 세트(무한강성/비침투/충만/국소 규칙/인접성)를 전제로 한다. 특히 다음 두 조건을 레짐 조건으로 고정한다.</p>
<ol>
<li><p><strong>Stone 레짐</strong>: VP의 부피 불변과 비침투가 전역 제약으로 유지된다.</p></li>
<li><p><strong>충만 레짐</strong>: 빈 공간을 독립 자유도로 도입하지 않으며, 코어 경계의 “결손/목/간격”은 배치와 인접성의 파생 구조량으로만 등장한다.</p></li>
</ol>
<p>위 레짐 조건이 잠기지 않으면 본 장의 연속체 근사는 적용 범위를 상실하며, 결론은 <code>INCONCLUSIVE</code>로 판정된다.</p>
<h3 class="unnumbered" id="정준-셀anchor-cell과-길이-스케일">정준 셀(Anchor Cell)과 길이 스케일</h3>
<p>정준 셀은 <code>CELL-CUBE</code>로 잠기며, 셀 대표 길이 <span class="math inline">\(D_{\mathrm{anch}}\)</span>는 모서리 길이(<code>edge</code>)로 잠긴다. 반길이 스케일은 다음 파생 정의로 고정되어야 한다.
<span class="math display">\[r_0:=\frac{D_{\mathrm{anch}}}{2}.
\label{eq:S06_r0_lock}\]</span>
본 장의 연속체 좌표 <span class="math inline">\(R\)</span>은 정준 셀 내부에서의 방사형 거리로 사용되며, <span class="math inline">\(R\)</span>의 단위와 좌표계는 <code>analysis_lock</code>의 좌표 규약으로 잠긴다.</p>
<h3 class="unnumbered" id="정류-상수-alpha의-입력">정류 상수 <span class="math inline">\(\alpha\)</span>의 입력</h3>
<p>본 장은 5.1에서 유일 출처로 고정된 정류 상수
<span class="math display">\[\alpha=\frac{2}{\pi}
\label{eq:S06_alpha_lock}\]</span>
를 입력으로 사용한다. <span class="math inline">\(\alpha\)</span>는 본 장에서 재유도되지 않으며, 코어 길이 선택의 무차원 비율 결론 <a data-reference="eq:S06_goal_ratio" data-reference-type="eqref" href="#eq:S06_goal_ratio">[eq:S06_goal_ratio]</a>에만 삽입된다.</p>
<h3 class="unnumbered" id="코어-선택-길이-l_q의-지위">코어 선택 길이 <span class="math inline">\(L_q\)</span>의 지위</h3>
<p><span class="math inline">\(L_q\)</span>는 코어 모델에서 “선택 길이”로 정의되는 내부 길이 스케일이다. <span class="math inline">\(L_q\)</span>의 지위는 다음 중 하나로 잠겨야 한다.</p>
<ol>
<li><p><strong>CANON-INPUT</strong>: <span class="math inline">\(L_q\)</span>를 정준 입력으로 <code>canon_lock</code>에 잠금(의미/단위/스코프 포함).</p></li>
<li><p><strong>CANON-DERIVED</strong>: <span class="math inline">\(L_q\)</span>를 정준 파생량으로 정의하고, 그 파생 규칙(어떤 구조량에서 어떻게 도출되는지)을 <code>analysis_lock</code>에 잠금.</p></li>
</ol>
<p><span class="math inline">\(L_q\)</span>의 지위가 잠기지 않으면 <span class="math inline">\(R_p/L_q\)</span>의 무차원 결론 자체가 정의 불능이며, 본 장의 유도는 성립하지 않는다.</p>
<h2 class="unnumbered" id="연속체-코어-모델의-내부-정의기하-구조의-연속-근사">연속체 코어 모델의 내부 정의(기하-구조의 연속 근사)</h2>
<p>본 장에서 “연속체”는 외부 이론의 도입이 아니라, VP 배치의 이산 구조량을 방사형 변수 <span class="math inline">\(R\)</span>의 함수로 <em>집계하여</em> 표현하는 내부 절차를 의미한다. 연속 근사는 다음 규칙으로 고정한다.</p>
<h3 class="unnumbered" id="코어-영역과-코어-경계의-정의">코어 영역과 코어 경계의 정의</h3>
<p>코어는 도메인 중심 <span class="math inline">\(\mathbf{x}_c\)</span>를 기준으로 정의되는 영역이며, 코어 경계는 다음과 같은 <strong>스위치 조건</strong>으로 정의한다.</p>
<ol>
<li><p>반경 <span class="math inline">\(R\)</span>에 대해, 반경 <span class="math inline">\(R\)</span> 내부의 이산 구조 지표가 “강성/전달” 조건을 만족하는지 판정하는 지시변수 <span class="math inline">\(\chi_{\mathrm{core}}(R)\in\{0,1\}\)</span>를 정의한다.</p></li>
<li><p>코어 반경 <span class="math inline">\(R_p\)</span>는 <span class="math inline">\(\chi_{\mathrm{core}}(R)\)</span>의 전이점으로 정의한다. 전이점의 이산/연속 판정 규칙(최초 전이/문턱 전이/안정 전이)은 <code>analysis_lock</code>에 잠겨야 한다.</p></li>
</ol>
<p>따라서 <span class="math inline">\(R_p\)</span>는 “기하적 임의 길이”가 아니라, 이산 구조 지표의 전이에 의해 <em>운영 정의</em>된 길이이다.</p>
<h3 class="unnumbered" id="방사형-집계량의-표준-형식">방사형 집계량의 표준 형식</h3>
<p>반경 <span class="math inline">\(R\)</span>에 대한 집계량 <span class="math inline">\(S(R)\)</span>은 다음 표준 형식으로만 정의한다.
<span class="math display">\[S(R)
:=
\mathcal{A}\Bigl(\{\Omega_i\}_{i\in\mathcal{V}(R)},\ \mathcal{G}_c(R),\ \mathcal{P}(R)\Bigr),
\label{eq:S06_radial_aggregate}\]</span>
여기서</p>
<ul>
<li><p><span class="math inline">\(\mathcal{V}(R)\)</span>는 반경 <span class="math inline">\(R\)</span> 내부에 포함되는 VP의 부분집합(포함/배제 규약 잠금),</p></li>
<li><p><span class="math inline">\(\mathcal{G}_c(R)\)</span>는 반경 <span class="math inline">\(R\)</span> 내부의 접촉 그래프(경계 처리 규약 잠금),</p></li>
<li><p><span class="math inline">\(\mathcal{P}(R)\)</span>는 반경 <span class="math inline">\(R\)</span>에서의 프로토콜/구동/완화 상태(레짐/초기조건/로그 규약 잠금),</p></li>
<li><p><span class="math inline">\(\mathcal{A}\)</span>는 집계 알고리즘(평균/합/최소절단/백본 선택 등, 닫힘으로 잠금)</p></li>
</ul>
<p>이다. 본 장의 모든 연속체식은 <a data-reference="eq:S06_radial_aggregate" data-reference-type="eqref" href="#eq:S06_radial_aggregate">[eq:S06_radial_aggregate]</a>의 형식으로 환원되며, 환원 규칙이 잠기지 않으면 연속체식은 정의 불능이다.</p>
<h2 class="unnumbered" id="안정-조건의-내부-정의두-스케일-법칙의-교차로서의-선택-반경">안정 조건의 내부 정의(두 스케일 법칙의 교차로서의 선택 반경)</h2>
<p>본 장은 코어 반경 <span class="math inline">\(R_p\)</span>가 “두 종류의 방사형 스케일 법칙”의 교차로 선택된다는 내부 원리를 채택한다. 이 원리는 외부 정설의 정당화가 아니라, VP Stone 제약과 충만 제약 하에서 코어 경계가 갖는 <strong>집계 비용</strong>의 스케일 법칙을 <em>정의하고</em> 그 교차를 <em>선택 규칙</em>으로 잠그는 방식으로 구현된다.</p>
<h3 class="unnumbered" id="두-집계-비용-함수의-정의-자리">두 집계 비용 함수의 정의 자리</h3>
<p>반경 <span class="math inline">\(R\)</span>에 대해 다음 두 비용(또는 압력에 준하는 스칼라 집계량)을 정의한다.
<span class="math display">\[\Pi_{4}(R) := \frac{C_{4}}{R^{4}},
\qquad
\Pi_{5}(R) := \frac{C_{5}}{R^{5}},
\label{eq:S06_two_scalings}\]</span>
여기서 <span class="math inline">\(C_{4},C_{5}\)</span>는 내부 집계로부터 도출되는 상수(또는 잠긴 계수)이며, <span class="math inline">\(R^{-4}\)</span>, <span class="math inline">\(R^{-5}\)</span>의 지수는 본 장 내부에서 <em>도메인/경계/카운팅 규약</em>으로부터 유도되어 잠긴다.
본 절(개요문)에서는 <a data-reference="eq:S06_two_scalings" data-reference-type="eqref" href="#eq:S06_two_scalings">[eq:S06_two_scalings]</a>의 정의 자리와 역할만을 고정하며, <span class="math inline">\(C_{4},C_{5}\)</span>의 구체 유도 및 지수의 내부 유도는 본 장의 후속 절에서 완결한다.</p>
<h3 class="unnumbered" id="선택-반경코어-반경의-안정-조건">선택 반경(코어 반경)의 안정 조건</h3>
<p>코어 반경 <span class="math inline">\(R_p\)</span>의 선택(안정) 조건은 다음 중 하나로 잠겨야 한다(택일, 결과에 따라 교체 금지).</p>
<ol>
<li><p><strong>교차 조건</strong>: <span class="math inline">\(\Pi_{4}(R_p)=\Pi_{5}(R_p)\)</span>.</p></li>
<li><p><strong>정지 조건</strong>: 어떤 잠긴 에너지형 집계량 <span class="math inline">\(U(R)\)</span>에 대해 <span class="math inline">\(dU/dR|_{R=R_p}=0\)</span>이며, 이 조건이 <a data-reference="eq:S06_two_scalings" data-reference-type="eqref" href="#eq:S06_two_scalings">[eq:S06_two_scalings]</a>의 교차와 동치가 되도록 <span class="math inline">\(U\)</span>를 정의.</p></li>
<li><p><strong>스위치 조건</strong>: 구조 지시변수 <span class="math inline">\(\chi_{\mathrm{core}}(R)\)</span>의 전이점이 <a data-reference="eq:S06_two_scalings" data-reference-type="eqref" href="#eq:S06_two_scalings">[eq:S06_two_scalings]</a>의 교차점과 일치하도록 스위치 관측량을 정의.</p></li>
</ol>
<p>본 장의 정준 선택은 교차 조건으로 잠그며, 교차 조건을 채택한 경우
<span class="math display">\[\Pi_{4}(R_p)=\Pi_{5}(R_p)
\ \Longrightarrow\
R_p=\frac{C_{5}}{C_{4}}.
\label{eq:S06_Rp_Cratio}\]</span>
따라서 <span class="math inline">\(R_p\)</span>의 무차원 비율 결론 <a data-reference="eq:S06_goal_ratio" data-reference-type="eqref" href="#eq:S06_goal_ratio">[eq:S06_goal_ratio]</a>는 <span class="math inline">\(C_{5}/C_{4}\)</span>의 내부 유도에 의해 완결된다.</p>
<h2 data-number="8.1" id="본-장-결론의-형식외부-정당화-금지의-구현"><span class="header-section-number">8.1</span> 6.5 본 장 결론의 형식(외부 정당화 금지의 구현)</h2>
<p>본 장의 결론은 다음 형식으로만 허용된다.</p>
<ol>
<li><p><span class="math inline">\(R_p/L_q\)</span>와 같은 <strong>무차원 비율</strong>의 유도(정류 상수 <span class="math inline">\(\alpha\)</span>의 삽입 포함).</p></li>
<li><p><span class="math inline">\(R_p=\alpha L_q\)</span> 형태의 <strong>내부 길이 선택식</strong> (단, <span class="math inline">\(L_q\)</span>의 지위가 잠겨 있을 때만).</p></li>
<li><p>특정 수치의 제시는 <strong>실현(REALIZATION)</strong> 또는 <strong>검증(Gate)</strong> 항목이 잠겼을 때만 허용되며, 수치 일치를 근거로 정의/공리/정류 규약을 정당화하지 않는다.</p></li>
</ol>
<p>따라서 본 장은 <span class="math inline">\(R_p\)</span> 유도의 근거로 외부 정설(다른 이론의 방정식, 다른 이론의 상수 정의, 다른 이론의 정당화)을 사용하지 않는다. 외부 텍스트와의 대응은 별도의 “대응표/비사용 범위 선언” 절에서만 다루며, 본 장의 결론 자격에 영향을 주지 않는다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-26">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: Stone 레짐(VP 무한강성/충만/국소 규칙), 정준 셀(<code>CELL-CUBE</code>)과 <span class="math inline">\(D_{\mathrm{anch}}\)</span> 의미(<code>edge</code>), <span class="math inline">\(r_0=D_{\mathrm{anch}}/2\)</span>를 전제로 고정.</p></li>
<li><p>LOCK: 정류 상수 <span class="math inline">\(\alpha=2/\pi\)</span>는 5장의 유일 출처를 참조하는 입력으로만 사용함을 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(L_q\)</span>의 지위(CANON-INPUT 또는 CANON-DERIVED)와 <span class="math inline">\(R_p/L_q=\alpha\)</span> 형태의 산출물 형식을 본 장 산출물로 고정.</p></li>
<li><p>Gate: 레짐 위반(Stone/충만/셀 의미 불일치), 정류 규약 위반, lock_id 혼합은 <code>FAIL</code>로 판정됨(G-REG/G-RECT/G-LOCK/G-SYM).</p></li>
<li><p>Gate: 외부 정당화의 근거 끌어오기 또는 사후조정은 <code>FAIL</code>로 판정됨(G-NT).</p></li>
</ul>
<h2 data-number="8.2" id="l_q와-lambda_c-연결l_qlambda_c"><span class="header-section-number">8.2</span> 6.1 <span class="math inline">\(L_q\)</span>와 <span class="math inline">\(\lambda_C\)</span> 연결(<span class="math inline">\(L_q=\lambda_C\)</span>)</h2>
<h3 data-number="8.2.1" id="목적-1"><span class="header-section-number">8.2.1</span> 6.1.1 목적</h3>
<p>본 절은 연속체 코어 모델에서 등장하는 두 길이 기호 <span class="math inline">\(L_q\)</span>와 <span class="math inline">\(\lambda_C\)</span>를 각각 내부 정의로 고정한 뒤, 두 길이를 동일시하는 규칙
<span class="math display">\[L_q=\lambda_C
\label{eq:S06_Lq_eq_lC}\]</span>
을 <strong>정준 잠금(LOCK)</strong>으로 확정한다. 본 절의 산출물은 (i) <span class="math inline">\(L_q\)</span>의 정의, (ii) <span class="math inline">\(\lambda_C\)</span>의 정의, (iii) 동일시의 내부 근거(공리 기반), (iv) 동일시 이후의 치환 규칙이다.</p>
<h3 data-number="8.2.2" id="정의-l_q-코어-선택-길이"><span class="header-section-number">8.2.2</span> 6.1.2 정의: <span class="math inline">\(L_q\)</span> (코어 선택 길이)</h3>
<h4 data-number="8.2.2.1" id="d-6.1-1-무차원-방사형-좌표"><span class="header-section-number">8.2.2.1</span> [D-6.1-1] 무차원 방사형 좌표</h4>
<p>정준 셀 내부에서 코어 중심 <span class="math inline">\(\mathbf{x}_c\)</span>를 잠그고, 방사형 거리 <span class="math inline">\(R\)</span>을 다음으로 정의한다.
<span class="math display">\[R := \|\mathbf{x}-\mathbf{x}_c\|.
\label{eq:S06_R_def}\]</span>
<span class="math inline">\(R\)</span>의 좌표계 및 <span class="math inline">\(\mathbf{x}_c\)</span>의 선택 규약은 <code>analysis_lock</code>에 잠긴다.</p>
<p>코어 모델의 방사형 기술은 무차원 좌표 <span class="math inline">\(\xi\)</span>로 정규화하여 진행하며, 그 정규화 길이를 <span class="math inline">\(L_q\)</span>로 정의한다.
<span class="math display">\[\xi := \frac{R}{L_q}.
\label{eq:S06_xi_def}\]</span></p>
<h4 data-number="8.2.2.2" id="d-6.1-2-l_q의-의미선택-길이"><span class="header-section-number">8.2.2.2</span> [D-6.1-2] <span class="math inline">\(L_q\)</span>의 의미(선택 길이)</h4>
<p><span class="math inline">\(L_q\)</span>는 코어 모델에서 다음 두 조건을 동시에 만족하는 <strong>유일한</strong> 길이 스케일로 정의한다.</p>
<ol>
<li><p>(정규화 조건) 코어 모델의 모든 방사형 집계량이 <span class="math inline">\(R\)</span>이 아니라 <span class="math inline">\(\xi=R/L_q\)</span>의 함수로만 표현되도록 하는 정규화 기준 길이이다.</p></li>
<li><p>(전이 조건) 코어의 경계 전이(코어 지시변수 또는 코어 비용 함수의 전이)가 <span class="math inline">\(\xi=\xi_p\)</span>의 <strong>단일 값</strong>에서 일어나도록 하는 선택 길이이다.</p></li>
</ol>
<p>따라서 <span class="math inline">\(L_q\)</span>는 “임의 길이”가 아니라 “코어 전이를 단일 무차원 값으로 고정시키는 정규화 길이”로 정의된다. 이 정의는 연속체 코어 모델의 성립을 위한 내부 정의이며, 외부 텍스트의 정당화를 사용하지 않는다.</p>
<h3 data-number="8.2.3" id="정의-lambda_c-코어-위상-완결-길이"><span class="header-section-number">8.2.3</span> 6.1.3 정의: <span class="math inline">\(\lambda_C\)</span> (코어 위상 완결 길이)</h3>
<h4 data-number="8.2.3.1" id="d-6.1-3-코어-위상-변수"><span class="header-section-number">8.2.3.1</span> [D-6.1-3] 코어 위상 변수</h4>
<p>코어 내부 상태의 방사형 전개를 기술하는 위상 변수 <span class="math inline">\(\psi(R)\)</span>를 다음으로 정의한다.
<span class="math display">\[\psi:\ [0,\infty)\to\mathbb{R},
\qquad
\psi(0)=0,
\label{eq:S06_phasepsi_def}\]</span>
여기서 <span class="math inline">\(\psi\)</span>는 “코어 내부의 한 주기(phase cycle)”를 표기하기 위한 내부 변수이며, <span class="math inline">\(\psi\)</span>의 구체 생성 규약(어떤 집계량을 위상으로 쓰는가)은 <code>analysis_lock</code>에 잠긴다. 본 절은 <span class="math inline">\(\psi\)</span>가 연속체 코어 모델의 내부 변수로서 존재한다는 사실과, “주기 완결”이 <span class="math inline">\(2\pi\)</span>로 잠긴다는 사실만을 사용한다.</p>
<h4 data-number="8.2.3.2" id="d-6.1-4-lambda_c의-의미최초-주기-완결-반경"><span class="header-section-number">8.2.3.2</span> [D-6.1-4] <span class="math inline">\(\lambda_C\)</span>의 의미(최초 주기 완결 반경)</h4>
<p><span class="math inline">\(\lambda_C\)</span>는 다음 조건을 만족하는 <strong>최초</strong>의 양의 길이로 정의한다.
<span class="math display">\[\lambda_C := \inf\{\, R&gt;0\ |\ \psi(R)=2\pi \,\}.
\label{eq:S06_lambdaC_def}\]</span>
정의 <a data-reference="eq:S06_lambdaC_def" data-reference-type="eqref" href="#eq:S06_lambdaC_def">[eq:S06_lambdaC_def]</a>에서 <span class="math inline">\(2\pi\)</span>는 5장에서 잠긴 전주기 정준(정류 규약의 기준)이며, <span class="math inline">\(\lambda_C\)</span>는 그 전주기가 코어 방사형 전개에서 <strong>처음으로 완결되는</strong> 길이 스케일이다.
따라서 <span class="math inline">\(\lambda_C\)</span>는 “외부 상수”가 아니라 “코어 위상 완결을 기준으로 정의된 내부 길이”이다.</p>
<h3 data-number="8.2.4" id="동일시의-근거내부-공리-기반"><span class="header-section-number">8.2.4</span> 6.1.4 동일시의 근거(내부 공리 기반)</h3>
<p><span class="math inline">\(L_q=\lambda_C\)</span>의 동일시는 추가 가정이 아니라, 본 문서의 전역 규칙(No-Tuning, SSOT, 단일 전이 정의)을 만족시키기 위한 <strong>정준 선택(잠금)</strong>으로 고정한다. 동일시의 근거는 다음 네 항목으로 구성된다.</p>
<h4 data-number="8.2.4.1" id="g1-단일-전이-원칙-코어-경계는-하나여야-한다"><span class="header-section-number">8.2.4.1</span> (G1) 단일 전이 원칙: 코어 경계는 하나여야 한다</h4>
<p>코어 반경 <span class="math inline">\(R_p\)</span>는 “코어 내부<span class="math inline">\(\rightarrow\)</span>코어 외부”의 전이를 표시하는 <strong>단일</strong> 경계로 정의된다(코어 지시변수의 전이 또는 비용 함수의 전이로 정의).
만약 <span class="math inline">\(L_q\)</span>와 <span class="math inline">\(\lambda_C\)</span>가 서로 독립 길이로 존재하면, 코어 전이를 정규화하는 길이(<span class="math inline">\(L_q\)</span>)와 코어 위상 완결을 정의하는 길이(<span class="math inline">\(\lambda_C\)</span>)가 서로 다른 전이를 지시할 수 있다. 그러면 코어 경계의 정의가 <strong>이중화</strong>되어 <span class="math inline">\(R_p\)</span>가 단일 길이로 고정될 수 없고, 코어 경계는 절차에 따라 달라지는 모호한 객체가 된다.
따라서 코어 경계가 단일이어야 한다는 정의를 보존하기 위해, 두 길이는 동일한 경계를 지시하도록 동일시되어야 한다.</p>
<h4 data-number="8.2.4.2" id="g2-ssot-원칙-동일한-의미의-길이는-하나만-남는다"><span class="header-section-number">8.2.4.2</span> (G2) SSOT 원칙: 동일한 의미의 길이는 하나만 남는다</h4>
<p><span class="math inline">\(L_q\)</span>와 <span class="math inline">\(\lambda_C\)</span>는 각각 <a data-reference="eq:S06_xi_def" data-reference-type="eqref" href="#eq:S06_xi_def">[eq:S06_xi_def]</a>와 <a data-reference="eq:S06_lambdaC_def" data-reference-type="eqref" href="#eq:S06_lambdaC_def">[eq:S06_lambdaC_def]</a>에 의해 정의되지만, 두 정의가 지시하는 물리적 의미는 동일한 자리(코어 선택 길이)로 수렴해야 한다.
즉, 코어 모델에서 “방사형 스케일 선택”과 “위상 주기 완결”은 둘 다 코어 내부의 조직화가 끝나고 경계가 형성되는 지점을 지시한다. 동일한 자리를 지시하는 두 길이를 동시에 남겨두면, 동일 의미가 복수 기호로 분열되어 SSOT를 위반한다.
SSOT를 만족시키기 위해, 두 기호는 하나의 정준 항목으로 통합되어야 하며, 그 통합 규칙이 <a data-reference="eq:S06_Lq_eq_lC" data-reference-type="eqref" href="#eq:S06_Lq_eq_lC">[eq:S06_Lq_eq_lC]</a>이다.</p>
<h4 data-number="8.2.4.3" id="g3-no-tuning-원칙-l_qlambda_c를-자유도튜닝로-남기지-않는다"><span class="header-section-number">8.2.4.3</span> (G3) No-Tuning 원칙: <span class="math inline">\(L_q/\lambda_C\)</span>를 자유도(튜닝)로 남기지 않는다</h4>
<p><span class="math inline">\(L_q\)</span>와 <span class="math inline">\(\lambda_C\)</span>를 서로 독립 입력으로 두면, 무차원 비율
<span class="math display">\[\eta := \frac{L_q}{\lambda_C}
\label{eq:S06_eta_def}\]</span>
이 추가 자유도로 생긴다. 이 비율 <span class="math inline">\(\eta\)</span>는 코어 반경 비율 <span class="math inline">\(R_p/L_q\)</span>, <span class="math inline">\(R_p/\lambda_C\)</span> 및 후속 사건율/질량/힘 유도에 직접 개입할 수 있으며, 결과를 맞추기 위해 <span class="math inline">\(\eta\)</span>를 조정하는 경로가 열린다.
그러나 본 문서는 결과를 본 뒤 비율을 조정하는 자유도를 금지(No-Tuning)한다. 추가 자유도를 도입하지 않고 코어 선택을 닫기 위해, <span class="math inline">\(\eta\)</span>는 잠금으로 고정되어야 한다. 본 절은 그 고정을
<span class="math display">\[\eta := 1
\label{eq:S06_eta_one}\]</span>
으로 선언하며, 이는 곧 <a data-reference="eq:S06_Lq_eq_lC" data-reference-type="eqref" href="#eq:S06_Lq_eq_lC">[eq:S06_Lq_eq_lC]</a>와 동치이다.</p>
<h4 data-number="8.2.4.4" id="g4-정류-상수의-유일-출처와-양립-pi-외의-새-상수를-추가하지-않는다"><span class="header-section-number">8.2.4.4</span> (G4) 정류 상수의 유일 출처와 양립: <span class="math inline">\(\pi\)</span> 외의 새 상수를 추가하지 않는다</h4>
<p>5장에서 정류 상수 <span class="math inline">\(\alpha=2/\pi\)</span>, <span class="math inline">\(\delta=1/\pi^2\)</span>는 유일 출처로 잠겼다. 코어 길이 선택에서 <span class="math inline">\(L_q\)</span>와 <span class="math inline">\(\lambda_C\)</span>를 분리하려면 <a data-reference="eq:S06_eta_def" data-reference-type="eqref" href="#eq:S06_eta_def">[eq:S06_eta_def]</a>의 <span class="math inline">\(\eta\)</span>를 결정하는 <strong>추가 상수</strong> 또는 <strong>추가 규약</strong>이 필요하다.
본 문서는 정류 상수 체계를 제외한 새로운 보편 상수를 임의로 도입하지 않는다. 따라서 코어 선택 길이의 중복을 제거하는 유일한 정준 선택은 <span class="math inline">\(\eta=1\)</span>, 즉 <span class="math inline">\(L_q=\lambda_C\)</span>이다.</p>
<h3 data-number="8.2.5" id="동일시-이후의-재사용-규칙치환-규칙"><span class="header-section-number">8.2.5</span> 6.1.5 동일시 이후의 재사용 규칙(치환 규칙)</h3>
<p>동일시 <a data-reference="eq:S06_Lq_eq_lC" data-reference-type="eqref" href="#eq:S06_Lq_eq_lC">[eq:S06_Lq_eq_lC]</a>가 잠긴 이후, 본문 전역에서 다음 재사용 규칙을 고정한다.</p>
<ol>
<li><p><span class="math inline">\(L_q\)</span>와 <span class="math inline">\(\lambda_C\)</span>는 동일 항목의 두 표기이며, <code>canon_lock</code>에는 하나의 항목으로 기록한다(동일 <code>lock_id</code>에 단일 값/단일 의미).</p></li>
<li><p>수식 전개에서 <span class="math inline">\(L_q\)</span>가 등장하는 모든 자리에는 <span class="math inline">\(\lambda_C\)</span>를 치환할 수 있고, 반대로도 치환할 수 있다. 단, 치환은 “정의된 동일시”에 따른 표기 치환일 뿐, 새로운 유도나 새로운 근거가 아니다.</p></li>
<li><p>동일 버전 내부에서 <span class="math inline">\(L_q\)</span>와 <span class="math inline">\(\lambda_C\)</span>를 서로 다른 값으로 취급하거나, 서로 다른 객체 귀속/기하 의미로 분리하는 행위는 금지된다.</p></li>
<li><p><span class="math inline">\(L_q=\lambda_C\)</span>의 동일시를 해제하거나 다른 비율(<span class="math inline">\(\eta\neq 1\)</span>)로 변경하려면, <code>canon_lock</code>의 버전업과 전면 재유도/전면 재판정을 수행해야 한다.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-27">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(L_q\)</span> 정의(무차원 좌표 <span class="math inline">\(\xi=R/L_q\)</span>의 정규화 길이)와 <span class="math inline">\(\lambda_C\)</span> 정의(위상 완결 길이, <span class="math inline">\(\psi(\lambda_C)=2\pi\)</span>)를 <code>canon_lock</code>/<code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 동일시 규칙 <span class="math inline">\(L_q=\lambda_C\)</span> 및 <span class="math inline">\(\eta=L_q/\lambda_C=1\)</span>을 <code>canon_lock</code>에 고정(SSOT 및 No-Tuning 준수).</p></li>
<li><p>Gate: 동일 버전에서 <span class="math inline">\(L_q\neq\lambda_C\)</span> 사용, 또는 두 기호의 객체 귀속/기하 의미 혼용은 G-SYM/G-LOCK에서 즉시 <code>FAIL</code>.</p></li>
<li><p>Gate: 동일시 해제 또는 비율 변경은 버전업 후 전면 재유도/전면 재판정이 요구되며, 무단 변경은 G-NT에서 <code>FAIL</code>.</p></li>
</ul>
<h2 data-number="8.3" id="r4-vs-1r5-균형-rightarrow-r_pl_q2pi"><span class="header-section-number">8.3</span> 6.2 <span class="math inline">\(1/R^{4}\)</span> vs <span class="math inline">\(1/R^{5}\)</span> 균형 <span class="math inline">\(\rightarrow R_p/L_q=2/\pi\)</span></h2>
<h3 data-number="8.3.1" id="방사형-집계-기하와-표준-기호"><span class="header-section-number">8.3.1</span> 6.2.1 방사형 집계 기하와 표준 기호</h3>
<p>코어 중심을 <span class="math inline">\(\mathbf{x}_c\)</span>로 잠그고, 방사형 거리 <span class="math inline">\(R\)</span>을
<span class="math display">\[R:=\|\mathbf{x}-\mathbf{x}_c\|
\label{eq:S06_02_R}\]</span>
로 정의한다. <span class="math inline">\(R\)</span>은 정준 셀(<code>CELL-CUBE</code>) 내부에서의 <em>집계 좌표</em>이며, 셀 기하를 구로 대체하지 않는다.
반경 <span class="math inline">\(R\)</span>에서의 방사형 집계면(수준집합)을 다음으로 정의한다.
<span class="math display">\[\mathbb{S}_R := \{\mathbf{x}\ |\ \|\mathbf{x}-\mathbf{x}_c\|=R\},
\qquad
A(R):=\mathrm{Area}(\mathbb{S}_R)=4\pi R^2.
\label{eq:S06_02_sphere_area}\]</span>
여기서 <span class="math inline">\(A(R)\)</span>은 방사형 집계면의 면적이며, 정준 셀의 정의(큐브)와는 독립인 <em>집계면의 정의</em>이다.</p>
<p>코어 선택 길이 <span class="math inline">\(L_q\)</span>는 6.1에서 잠긴 길이 스케일이며, 본 절에서는 <span class="math inline">\(L_q\)</span>를 다음 두 역할로 사용한다.</p>
<ol>
<li><p>방사형 집계에서의 <strong>단위 길이</strong>: <span class="math inline">\(R\)</span>을 무차원화하는 기준 길이.</p></li>
<li><p>방사형 집계면 위의 <strong>단위 패치 길이</strong>: 집계면을 세분하는 최소 선형 스케일.</p></li>
</ol>
<p>단위 패치의 선형 크기를 <span class="math inline">\(L_q\)</span>로 두고, 단위 패치 면적을 다음으로 정의한다.
<span class="math display">\[A_0 := L_q^2.
\label{eq:S06_02_patch_area}\]</span>
<span class="math inline">\(A_0\)</span>는 방사형 집계면 위에서의 최소 집계 단위이며, 결과를 본 뒤 바뀌지 않는다.</p>
<h3 data-number="8.3.2" id="방향-정류-계수-alpha의-삽입-위치"><span class="header-section-number">8.3.2</span> 6.2.2 방향 정류 계수 <span class="math inline">\(\alpha\)</span>의 삽입 위치</h3>
<p>방사형 집계에서 “방향 성분”이 스칼라로 집계될 때, 방향 성분의 정류 계수 <span class="math inline">\(\alpha\)</span>를 5.1의 유일 출처로부터 입력으로 사용한다.
<span class="math display">\[\alpha=\left\langle |\cos\theta| \right\rangle=\frac{2}{\pi}.
\label{eq:S06_02_alpha}\]</span>
여기서 <span class="math inline">\(\theta\)</span>는 전주기 <span class="math inline">\([0,2\pi)\)</span>에서 균등 측도로 집계되는 각변수이며, 평균 규약은 5.1에서 잠겨 있다.
본 절에서 <span class="math inline">\(\alpha\)</span>는 “방사 성분의 유효 기여가 평균적으로 <span class="math inline">\(\alpha\)</span>만큼만 살아남는다”는 정류 계수로만 사용되며, <span class="math inline">\(\alpha\)</span> 자체는 본 절에서 재유도되지 않는다.</p>
<h3 data-number="8.3.3" id="r4-붕괴항-pi_4r의-정의와-전개"><span class="header-section-number">8.3.3</span> 6.2.3 <span class="math inline">\(1/R^{4}\)</span> 붕괴항 <span class="math inline">\(\Pi_{4}(R)\)</span>의 정의와 전개</h3>
<p>본 절은 코어 경계에서 요구되는 “붕괴항(압력형 구속지표)” <span class="math inline">\(\Pi_{4}(R)\)</span>를 <strong>기하학적 희석(2회)</strong>과 <strong>방향 정류 손실 보정</strong>으로 정의한다.</p>
<h4 data-number="8.3.3.1" id="기하학적-희석-1-면적-희석패치-수"><span class="header-section-number">8.3.3.1</span> 6.2.3.1 기하학적 희석 1: 면적 희석(패치 수)</h4>
<p>반경 <span class="math inline">\(R\)</span>의 집계면 <span class="math inline">\(\mathbb{S}_R\)</span> 위에서 단위 패치 면적 <span class="math inline">\(A_0\)</span>로 분할할 때, 패치 수를 다음으로 정의한다.
<span class="math display">\[N_A(R) := \frac{A(R)}{A_0}=\frac{4\pi R^2}{L_q^2}.
\label{eq:S06_02_NA}\]</span>
따라서 단일 패치가 전체 집계면에서 차지하는 면적 비율(면적 희석 계수)은
<span class="math display">\[f_A(R) := \frac{1}{N_A(R)}=\frac{A_0}{A(R)}=\frac{L_q^2}{4\pi R^2}.
\label{eq:S06_02_fA}\]</span>
이다. <span class="math inline">\(f_A(R)\)</span>는 방사형 집계면 위에서 “단위 패치가 받는 평균 몫”을 나타내는 순수 기하 계수로 고정한다.</p>
<h4 data-number="8.3.3.2" id="기하학적-희석-2-방향-희석고정-패치로의-도달-창"><span class="header-section-number">8.3.3.2</span> 6.2.3.2 기하학적 희석 2: 방향 희석(고정 패치로의 도달 창)</h4>
<p>단위 패치(선형 크기 <span class="math inline">\(L_q\)</span>)를 향해 방향이 맞춰지는 정도를 “고정 패치로의 도달 창”으로 정의한다.
반경 <span class="math inline">\(R\)</span>에서 선형 크기 <span class="math inline">\(L_q\)</span>의 패치를 단위구면 위에서 바라볼 때, 그 패치가 차지하는 대표 고도각 폭을
<span class="math display">\[\Delta\vartheta(R) := \frac{L_q}{R}
\label{eq:S06_02_dtheta}\]</span>
로 정의한다. 고정 패치로의 방향 창에 해당하는 대표 고체각을 다음으로 정의한다.
<span class="math display">\[\Delta\Omega(R) := \bigl(\Delta\vartheta(R)\bigr)^2 = \left(\frac{L_q}{R}\right)^2.
\label{eq:S06_02_dOmega}\]</span>
전주기 방향 공간에서의 정규화는 단위구면의 전체 고체각 <span class="math inline">\(4\pi\)</span>로 잠근다. 따라서 방향 희석 계수는
<span class="math display">\[f_\Omega(R) := \frac{\Delta\Omega(R)}{4\pi}
= \frac{1}{4\pi}\left(\frac{L_q}{R}\right)^2.
\label{eq:S06_02_fOmega}\]</span>
이다. <span class="math inline">\(f_\Omega(R)\)</span>는 “단위 패치가 요구하는 방향 창”의 기하 계수로 고정한다.</p>
<h4 data-number="8.3.3.3" id="방향-정류-손실-보정역계수-1alpha"><span class="header-section-number">8.3.3.3</span> 6.2.3.3 방향 정류 손실 보정(역계수 <span class="math inline">\(1/\alpha\)</span>)</h4>
<p>방향이 맞춰졌더라도, 방사 성분은 부호를 가진 투영이므로 평균적으로 상쇄가 발생한다. 방사 성분의 유효 기여는 <span class="math inline">\(\alpha\)</span>만큼만 살아남는다고 잠겼으므로(<a data-reference="eq:S06_02_alpha" data-reference-type="eqref" href="#eq:S06_02_alpha">[eq:S06_02_alpha]</a>), 동일한 “유효 기여”를 확보하기 위해서는 역계수 <span class="math inline">\(1/\alpha\)</span>의 보정이 필요하다.
이 보정은 “결과를 맞추는 보정”이 아니라, 정류 규약(5.1)의 직접 귀결로 고정된다.</p>
<h4 data-number="8.3.3.4" id="붕괴항-pi_4r의-정의"><span class="header-section-number">8.3.3.4</span> 6.2.3.4 붕괴항 <span class="math inline">\(\Pi_{4}(R)\)</span>의 정의</h4>
<p>코어 경계에서의 붕괴항(압력형 구속지표) <span class="math inline">\(\Pi_{4}(R)\)</span>를 다음으로 정의한다.
<span class="math display">\[\Pi_{4}(R)
:= \Pi_\star\,
\frac{1}{\alpha}\,
f_A(R)\,
f_\Omega(R),
\label{eq:S06_02_Pi4_def}\]</span>
여기서 <span class="math inline">\(\Pi_\star\)</span>는 레짐 내부에서 잠긴 “단위 구속 강도”(무차원 또는 내부 단위)이며, <span class="math inline">\(R\)</span>에 의존하지 않는 기준값이다. <span class="math inline">\(\Pi_\star\)</span>는 본 절에서 소거되는 공통 인자이며, 값의 크기는 본 절의 비율 결론에 영향을 주지 않는다.</p>
<p>이제 <a data-reference="eq:S06_02_fA" data-reference-type="eqref" href="#eq:S06_02_fA">[eq:S06_02_fA]</a>와 <a data-reference="eq:S06_02_fOmega" data-reference-type="eqref" href="#eq:S06_02_fOmega">[eq:S06_02_fOmega]</a>를 <a data-reference="eq:S06_02_Pi4_def" data-reference-type="eqref" href="#eq:S06_02_Pi4_def">[eq:S06_02_Pi4_def]</a>에 대입하여 완전 전개한다.
<span class="math display">\[\begin{aligned}
\Pi_{4}(R)
&amp;= \Pi_\star\,
\frac{1}{\alpha}\,
\left(\frac{L_q^2}{4\pi R^2}\right)
\left(\frac{1}{4\pi}\left(\frac{L_q}{R}\right)^2\right)
\notag\\
&amp;= \Pi_\star\,
\frac{1}{\alpha}\,
\left(\frac{L_q^2}{4\pi R^2}\right)
\left(\frac{L_q^2}{4\pi R^2}\right)
\notag\\
&amp;= \Pi_\star\,
\frac{1}{\alpha}\,
\frac{L_q^4}{(4\pi)^2 R^4}
\notag\\
&amp;= \Pi_\star\,
\frac{1}{\alpha}\,
\frac{L_q^4}{16\pi^2}\,
\frac{1}{R^4}.
\label{eq:S06_02_Pi4_final}\end{aligned}\]</span>
따라서 붕괴항은 <span class="math inline">\(1/R^4\)</span> 스케일로 고정되며, 그 계수는 <span class="math inline">\(\alpha\)</span>의 역계수를 포함한다.</p>
<h3 data-number="8.3.4" id="r5-강성항-pi_5r의-정의와-전개"><span class="header-section-number">8.3.4</span> 6.2.4 <span class="math inline">\(1/R^{5}\)</span> 강성항 <span class="math inline">\(\Pi_{5}(R)\)</span>의 정의와 전개</h3>
<p>본 절은 기판(Stone) 레짐의 “강성항(압력형 구속지표)” <span class="math inline">\(\Pi_{5}(R)\)</span>를 <strong>동일한 2회 기하 희석</strong>에 <strong>방사 연쇄 잠금 계수</strong>를 추가하여 정의한다.</p>
<h4 data-number="8.3.4.1" id="방사-연쇄-잠금-계수-eta_rr"><span class="header-section-number">8.3.4.1</span> 6.2.4.1 방사 연쇄 잠금 계수 <span class="math inline">\(\eta_R(R)\)</span></h4>
<p>반경 <span class="math inline">\(R\)</span>까지의 방사 방향으로 단위 길이 <span class="math inline">\(L_q\)</span>가 몇 번 적층되는지(방사층 수)를 다음으로 정의한다.
<span class="math display">\[N_R(R) := \frac{R}{L_q}.
\label{eq:S06_02_NR}\]</span>
국소 규칙(3.1) 하에서 방사 방향 전달은 단위 층의 연쇄로 표현되며, 연쇄의 평균 기여는 층 수에 반비례하는 정류 계수로 고정한다. 이를 “방사 연쇄 잠금 계수”로 정의한다.
<span class="math display">\[\eta_R(R) := \frac{1}{N_R(R)}=\frac{L_q}{R}.
\label{eq:S06_02_etaR}\]</span>
<span class="math inline">\(\eta_R(R)\)</span>는 방사층 수의 정의 <a data-reference="eq:S06_02_NR" data-reference-type="eqref" href="#eq:S06_02_NR">[eq:S06_02_NR]</a>에 의해 결정되는 기하 계수이며, 결과를 본 뒤 조정되지 않는다.</p>
<h4 data-number="8.3.4.2" id="강성항-pi_5r의-정의"><span class="header-section-number">8.3.4.2</span> 6.2.4.2 강성항 <span class="math inline">\(\Pi_{5}(R)\)</span>의 정의</h4>
<p>강성항 <span class="math inline">\(\Pi_{5}(R)\)</span>를 다음으로 정의한다.
<span class="math display">\[\Pi_{5}(R)
:= \Pi_\star\,
f_A(R)\,
f_\Omega(R)\,
\eta_R(R).
\label{eq:S06_02_Pi5_def}\]</span>
붕괴항과 달리 강성항에는 <span class="math inline">\(1/\alpha\)</span>가 삽입되지 않는다. 강성항은 “방향 투영의 정류 손실”이 아니라 “방사 연쇄 잠금”으로만 감쇠가 결정되기 때문이다.
이제 <a data-reference="eq:S06_02_fA" data-reference-type="eqref" href="#eq:S06_02_fA">[eq:S06_02_fA]</a>, <a data-reference="eq:S06_02_fOmega" data-reference-type="eqref" href="#eq:S06_02_fOmega">[eq:S06_02_fOmega]</a>, <a data-reference="eq:S06_02_etaR" data-reference-type="eqref" href="#eq:S06_02_etaR">[eq:S06_02_etaR]</a>를 <a data-reference="eq:S06_02_Pi5_def" data-reference-type="eqref" href="#eq:S06_02_Pi5_def">[eq:S06_02_Pi5_def]</a>에 대입하여 완전 전개한다.
<span class="math display">\[\begin{aligned}
\Pi_{5}(R)
&amp;= \Pi_\star\,
\left(\frac{L_q^2}{4\pi R^2}\right)
\left(\frac{1}{4\pi}\left(\frac{L_q}{R}\right)^2\right)
\left(\frac{L_q}{R}\right)
\notag\\
&amp;= \Pi_\star\,
\left(\frac{L_q^2}{4\pi R^2}\right)
\left(\frac{L_q^2}{4\pi R^2}\right)
\left(\frac{L_q}{R}\right)
\notag\\
&amp;= \Pi_\star\,
\frac{L_q^5}{(4\pi)^2 R^5}
\notag\\
&amp;= \Pi_\star\,
\frac{L_q^5}{16\pi^2}\,
\frac{1}{R^5}.
\label{eq:S06_02_Pi5_final}\end{aligned}\]</span>
따라서 강성항은 <span class="math inline">\(1/R^5\)</span> 스케일로 고정되며, 붕괴항과 동일한 <span class="math inline">\((4\pi)^{-2}\)</span> 기하 계수를 공유하고, 추가로 <span class="math inline">\(L_q/R\)</span>에 의해 한 차수 더 감쇠한다.</p>
<h3 data-number="8.3.5" id="균형-조건과-r_pl_q2pi의-완전-도출"><span class="header-section-number">8.3.5</span> 6.2.5 균형 조건과 <span class="math inline">\(R_p/L_q=2/\pi\)</span>의 완전 도출</h3>
<p>코어 반경 <span class="math inline">\(R_p\)</span>는 “붕괴항”과 “강성항”이 균형을 이루는 전이점으로 정의한다. 균형 조건을 다음으로 잠근다.
<span class="math display">\[\Pi_{4}(R_p)=\Pi_{5}(R_p).
\label{eq:S06_02_balance_condition}\]</span>
<a data-reference="eq:S06_02_Pi4_final" data-reference-type="eqref" href="#eq:S06_02_Pi4_final">[eq:S06_02_Pi4_final]</a>과 <a data-reference="eq:S06_02_Pi5_final" data-reference-type="eqref" href="#eq:S06_02_Pi5_final">[eq:S06_02_Pi5_final]</a>을 <a data-reference="eq:S06_02_balance_condition" data-reference-type="eqref" href="#eq:S06_02_balance_condition">[eq:S06_02_balance_condition]</a>에 대입하여 전개한다.
<span class="math display">\[\begin{aligned}
\Pi_\star\,
\frac{1}{\alpha}\,
\frac{L_q^4}{16\pi^2}\,
\frac{1}{R_p^4}
&amp;=
\Pi_\star\,
\frac{L_q^5}{16\pi^2}\,
\frac{1}{R_p^5}.
\label{eq:S06_02_balance_sub}\end{aligned}\]</span>
양변에 공통으로 존재하는 <span class="math inline">\(\Pi_\star\)</span>와 <span class="math inline">\(16\pi^2\)</span>를 소거한다.
<span class="math display">\[\frac{1}{\alpha}\,L_q^4\,\frac{1}{R_p^4}
=
L_q^5\,\frac{1}{R_p^5}.
\label{eq:S06_02_balance_cancel1}\]</span>
양변을 <span class="math inline">\(L_q^4/R_p^4\)</span>로 나누어 소거한다.
<span class="math display">\[\frac{1}{\alpha}
=
\frac{L_q}{R_p}.
\label{eq:S06_02_balance_cancel2}\]</span>
따라서 코어 반경의 무차원 비율은
<span class="math display">\[\frac{R_p}{L_q}=\alpha.
\label{eq:S06_02_Rp_over_Lq_alpha}\]</span>
여기서 <span class="math inline">\(\alpha\)</span>는 5.1에서 유일 출처로 고정된 <span class="math inline">\(\alpha=2/\pi\)</span>이므로,
<span class="math display">\[\frac{R_p}{L_q}=\frac{2}{\pi}.
\label{eq:S06_02_Rp_over_Lq_final}\]</span>
또한 6.1에서 <span class="math inline">\(L_q=\lambda_C\)</span>가 잠겼으므로, 동일 잠금 버전 내부에서 다음 치환이 허용된다.
<span class="math display">\[R_p=\frac{2}{\pi}\,L_q=\frac{2}{\pi}\,\lambda_C.
\label{eq:S06_02_Rp_lambdaC}\]</span>
식 <a data-reference="eq:S06_02_Rp_over_Lq_final" data-reference-type="eqref" href="#eq:S06_02_Rp_over_Lq_final">[eq:S06_02_Rp_over_Lq_final]</a>과 <a data-reference="eq:S06_02_Rp_lambdaC" data-reference-type="eqref" href="#eq:S06_02_Rp_lambdaC">[eq:S06_02_Rp_lambdaC]</a>가 본 절의 결론으로 고정된다.</p>
<h3 data-number="8.3.6" id="성립-조건레짐-조건과-위반-시-처리"><span class="header-section-number">8.3.6</span> 6.2.6 성립 조건(레짐 조건)과 위반 시 처리</h3>
<p>본 절의 결론 <a data-reference="eq:S06_02_Rp_over_Lq_final" data-reference-type="eqref" href="#eq:S06_02_Rp_over_Lq_final">[eq:S06_02_Rp_over_Lq_final]</a>이 성립하려면 다음 조건이 잠겨 있어야 한다.</p>
<ol>
<li><p>단위 패치 길이로 <span class="math inline">\(L_q\)</span>를 채택하는 집계 규약이 잠겨 있어야 한다(<span class="math inline">\(A_0=L_q^2\)</span>).</p></li>
<li><p>방향 정류 계수 <span class="math inline">\(\alpha\)</span>가 정준 규약(5.1)으로 잠겨 있어야 한다(<span class="math inline">\(\alpha=2/\pi\)</span>).</p></li>
<li><p>방사 연쇄 잠금 계수 <span class="math inline">\(\eta_R(L_q/R)\)</span>가 레짐 규약으로 잠겨 있어야 한다.</p></li>
</ol>
<p>위 조건 중 하나라도 잠기지 않거나, 동일 산출물에서 혼합 사용되면 <a data-reference="eq:S06_02_Pi4_def" data-reference-type="eqref" href="#eq:S06_02_Pi4_def">[eq:S06_02_Pi4_def]</a>–<a data-reference="eq:S06_02_Pi5_def" data-reference-type="eqref" href="#eq:S06_02_Pi5_def">[eq:S06_02_Pi5_def]</a>의 정의가 붕괴하므로, 해당 결론은 결론 자격을 상실한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-28">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 단위 패치 <span class="math inline">\(A_0=L_q^2\)</span>, 집계면 면적 <span class="math inline">\(A(R)=4\pi R^2\)</span>, 희석 계수 <span class="math inline">\(f_A,f_\Omega\)</span> 및 연쇄 계수 <span class="math inline">\(\eta_R=L_q/R\)</span> 정의를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 붕괴항 <span class="math inline">\(\Pi_4(R)\)</span>, 강성항 <span class="math inline">\(\Pi_5(R)\)</span>의 정의 <a data-reference="eq:S06_02_Pi4_def" data-reference-type="eqref" href="#eq:S06_02_Pi4_def">[eq:S06_02_Pi4_def]</a>, <a data-reference="eq:S06_02_Pi5_def" data-reference-type="eqref" href="#eq:S06_02_Pi5_def">[eq:S06_02_Pi5_def]</a> 및 균형 조건 <a data-reference="eq:S06_02_balance_condition" data-reference-type="eqref" href="#eq:S06_02_balance_condition">[eq:S06_02_balance_condition]</a>을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(\alpha=2/\pi\)</span>는 5.1의 유일 출처를 참조하여 <code>canon_lock</code>에 의해 입력으로만 사용.</p></li>
<li><p>Gate: 셀 의미/지름-반지름/스코프 충돌은 G-SYM에서 즉시 <code>FAIL</code>; 레짐 불일치는 G-REG에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
<li><p>Gate: <span class="math inline">\(\alpha\)</span> 재유도/정류 규약 교체는 G-RECT에서 <code>FAIL</code>; <span class="math inline">\(L_q\)</span>와 <span class="math inline">\(\lambda_C\)</span> 혼용 불일치는 G-LOCK에서 <code>FAIL</code>.</p></li>
</ul>
<h2 data-number="8.4" id="r_p-수치-대입-불변량-정리"><span class="header-section-number">8.4</span> 6.3 <span class="math inline">\(R_p\)</span> 수치 대입 + 불변량 정리</h2>
<h3 data-number="8.4.1" id="입력lock과-참조식본-절의-출발점"><span class="header-section-number">8.4.1</span> 6.3.1 입력(LOCK)과 참조식(본 절의 출발점)</h3>
<p>본 절에서 사용하는 입력(LOCK)과 참조식은 다음으로 고정한다.</p>
<ol>
<li><p>정류 상수:
<span class="math display">\[\alpha=\frac{2}{\pi}.
  \label{eq:S06_03_alpha}\]</span></p></li>
<li><p>길이 동일시:
<span class="math display">\[L_q=\lambda_C.
  \label{eq:S06_03_Lq_eq_lC}\]</span></p></li>
<li><p>코어 반경의 비율 결론(6.2에서 도출된 결론):
<span class="math display">\[\frac{R_p}{L_q}=\alpha.
  \label{eq:S06_03_Rp_over_Lq}\]</span></p></li>
</ol>
<p>위 세 식은 본 절에서 재유도하지 않는다. 본 절은 위 식들을 결합하여 (i) <span class="math inline">\(R_p\)</span>의 수치 산출, (ii) 기하 단면 <span class="math inline">\(\sigma_{\mathrm{geom}}\)</span>의 정의 및 수치 산출, (iii) <span class="math inline">\(4/\pi\)</span> 불변량을 정리한다.</p>
<h3 data-number="8.4.2" id="r_p-산출식의-완전-전개"><span class="header-section-number">8.4.2</span> 6.3.2 <span class="math inline">\(R_p\)</span> 산출식의 완전 전개</h3>
<p>식 <a data-reference="eq:S06_03_Rp_over_Lq" data-reference-type="eqref" href="#eq:S06_03_Rp_over_Lq">[eq:S06_03_Rp_over_Lq]</a>에서
<span class="math display">\[\frac{R_p}{L_q}=\alpha
\quad\Longrightarrow\quad
R_p=\alpha\,L_q.
\label{eq:S06_03_Rp_alpha_Lq}\]</span>
식 <a data-reference="eq:S06_03_Lq_eq_lC" data-reference-type="eqref" href="#eq:S06_03_Lq_eq_lC">[eq:S06_03_Lq_eq_lC]</a>를 <a data-reference="eq:S06_03_Rp_alpha_Lq" data-reference-type="eqref" href="#eq:S06_03_Rp_alpha_Lq">[eq:S06_03_Rp_alpha_Lq]</a>에 대입하면
<span class="math display">\[R_p=\alpha\,\lambda_C.
\label{eq:S06_03_Rp_alpha_lC}\]</span>
식 <a data-reference="eq:S06_03_alpha" data-reference-type="eqref" href="#eq:S06_03_alpha">[eq:S06_03_alpha]</a>를 <a data-reference="eq:S06_03_Rp_alpha_lC" data-reference-type="eqref" href="#eq:S06_03_Rp_alpha_lC">[eq:S06_03_Rp_alpha_lC]</a>에 대입하면
<span class="math display">\[R_p=\frac{2}{\pi}\,\lambda_C.
\label{eq:S06_03_Rp_final_form}\]</span>
따라서 본 절에서 <span class="math inline">\(R_p\)</span>의 수치 대입은 <span class="math inline">\(\lambda_C\)</span>의 잠금값을 입력으로 하여 <a data-reference="eq:S06_03_Rp_final_form" data-reference-type="eqref" href="#eq:S06_03_Rp_final_form">[eq:S06_03_Rp_final_form]</a>을 평가하는 절차로 고정된다.</p>
<h3 data-number="8.4.3" id="lambda_c-잠금값의-수치-대입-rightarrow-r_p0.8412mathrmfm"><span class="header-section-number">8.4.3</span> 6.3.3 <span class="math inline">\(\lambda_C\)</span> 잠금값의 수치 대입 <span class="math inline">\(\rightarrow R_p=0.8412\,\mathrm{fm}\)</span></h3>
<p><span class="math inline">\(\lambda_C\)</span>는 6.1에서 “코어 위상 완결 길이”로 정의된 길이이며, 본 절에서는 다음 값이 <code>canon_lock</code>에 의해 잠겨 있다고 둔다.
<span class="math display">\[\lambda_C
=
1.3213538700998668\ \mathrm{fm}.
\label{eq:S06_03_lC_value_lock}\]</span>
식 <a data-reference="eq:S06_03_Rp_final_form" data-reference-type="eqref" href="#eq:S06_03_Rp_final_form">[eq:S06_03_Rp_final_form]</a>에 <a data-reference="eq:S06_03_lC_value_lock" data-reference-type="eqref" href="#eq:S06_03_lC_value_lock">[eq:S06_03_lC_value_lock]</a>을 대입하여 <span class="math inline">\(R_p\)</span>를 계산한다.
<span class="math display">\[\begin{aligned}
R_p
&amp;=\frac{2}{\pi}\,\lambda_C
=\frac{2}{\pi}\times 1.3213538700998668\ \mathrm{fm}
\notag\\
&amp;=
0.8412\ \mathrm{fm}.
\label{eq:S06_03_Rp_value_fm}\end{aligned}\]</span>
단위 변환 규약으로 <span class="math inline">\(1\,\mathrm{fm}=10^{-15}\,\mathrm{m}\)</span>를 사용하면,
<span class="math display">\[R_p
=
0.8412\times 10^{-15}\ \mathrm{m}
=
8.412\times 10^{-16}\ \mathrm{m}.
\label{eq:S06_03_Rp_value_m}\]</span></p>
<h3 data-number="8.4.4" id="역산일관성-r_p0.8412mathrmfm로부터-lambda_c-재구성"><span class="header-section-number">8.4.4</span> 6.3.4 역산(일관성): <span class="math inline">\(R_p=0.8412\,\mathrm{fm}\)</span>로부터 <span class="math inline">\(\lambda_C\)</span> 재구성</h3>
<p>식 <a data-reference="eq:S06_03_Rp_final_form" data-reference-type="eqref" href="#eq:S06_03_Rp_final_form">[eq:S06_03_Rp_final_form]</a>은 다음과 동치이다.
<span class="math display">\[\lambda_C=\frac{\pi}{2}\,R_p.
\label{eq:S06_03_lC_from_Rp}\]</span>
식 <a data-reference="eq:S06_03_Rp_value_fm" data-reference-type="eqref" href="#eq:S06_03_Rp_value_fm">[eq:S06_03_Rp_value_fm]</a>을 <a data-reference="eq:S06_03_lC_from_Rp" data-reference-type="eqref" href="#eq:S06_03_lC_from_Rp">[eq:S06_03_lC_from_Rp]</a>에 대입하면,
<span class="math display">\[\begin{aligned}
\lambda_C
&amp;=\frac{\pi}{2}\times 0.8412\ \mathrm{fm}
\notag\\
&amp;=
1.3213538700998668\ \mathrm{fm},
\label{eq:S06_03_lC_backcalc}\end{aligned}\]</span>
이며, 이는 <a data-reference="eq:S06_03_lC_value_lock" data-reference-type="eqref" href="#eq:S06_03_lC_value_lock">[eq:S06_03_lC_value_lock]</a>과 동일하다. 따라서 <span class="math inline">\(R_p/L_q=\alpha\)</span> 및 <span class="math inline">\(L_q=\lambda_C\)</span> 잠금이 동일 버전에서 일관되게 성립함이 수치로 확인된다(확인은 정당화가 아니라 Gate 판정 입력으로만 사용된다).</p>
<h3 data-number="8.4.5" id="기하-단면-sigma_mathrmgeom의-정의와-수치"><span class="header-section-number">8.4.5</span> 6.3.5 기하 단면 <span class="math inline">\(\sigma_{\mathrm{geom}}\)</span>의 정의와 수치</h3>
<h4 data-number="8.4.5.1" id="d-6.3-1-기하-단면-정의"><span class="header-section-number">8.4.5.1</span> [D-6.3-1] 기하 단면 정의</h4>
<p>코어 반경 <span class="math inline">\(R_p\)</span>가 정의되면, 기하 단면(기하학적 단면적)을 다음으로 정의한다.
<span class="math display">\[\sigma_{\mathrm{geom}}
:=
\pi R_p^2.
\label{eq:S06_03_sigma_def}\]</span>
정의 <a data-reference="eq:S06_03_sigma_def" data-reference-type="eqref" href="#eq:S06_03_sigma_def">[eq:S06_03_sigma_def]</a>는 “단면”의 기하학적 정의이며, 다른 의미(효과 단면, 유효 단면 등)로 재해석되지 않는다. 유효 단면이 필요하면 별도 기호로 분리하여 정의해야 한다.</p>
<h4 data-number="8.4.5.2" id="수치-대입"><span class="header-section-number">8.4.5.2</span> 수치 대입</h4>
<p>식 <a data-reference="eq:S06_03_Rp_value_fm" data-reference-type="eqref" href="#eq:S06_03_Rp_value_fm">[eq:S06_03_Rp_value_fm]</a>을 <a data-reference="eq:S06_03_sigma_def" data-reference-type="eqref" href="#eq:S06_03_sigma_def">[eq:S06_03_sigma_def]</a>에 대입하면,
<span class="math display">\[\begin{aligned}
\sigma_{\mathrm{geom}}
&amp;=\pi\,(0.8412\ \mathrm{fm})^2
\notag\\
&amp;=\pi\times 0.70761744\ \mathrm{fm}^2
\notag\\
&amp;=2.223045751056016\ \mathrm{fm}^2.
\label{eq:S06_03_sigma_value_fm2}\end{aligned}\]</span>
단위 변환 규약으로 <span class="math inline">\((1\,\mathrm{fm})^2=10^{-30}\,\mathrm{m}^2\)</span>이므로,
<span class="math display">\[\sigma_{\mathrm{geom}}
=
2.223045751056016\times 10^{-30}\ \mathrm{m}^2.
\label{eq:S06_03_sigma_value_m2}\]</span></p>
<h3 data-number="8.4.6" id="pi-불변량-정리정의-전개-결론"><span class="header-section-number">8.4.6</span> 6.3.6 <span class="math inline">\(4/\pi\)</span> 불변량 정리(정의-전개-결론)</h3>
<p>본 절의 “불변량”은 <span class="math inline">\(R_p\)</span>와 <span class="math inline">\(L_q\)</span>의 비율 잠금이 유지되는 한, 레짐 내부에서 단위 선택과 무관하게 유지되는 <strong>무차원</strong> 또는 <strong>정규화된</strong> 조합을 의미한다.</p>
<h4 data-number="8.4.6.1" id="불변량-i-sigma_mathrmgeoml_q24pi"><span class="header-section-number">8.4.6.1</span> 6.3.6.1 불변량 I: <span class="math inline">\(\sigma_{\mathrm{geom}}/L_q^2=4/\pi\)</span></h4>
<p>먼저 6.2의 결론 <a data-reference="eq:S06_03_Rp_over_Lq" data-reference-type="eqref" href="#eq:S06_03_Rp_over_Lq">[eq:S06_03_Rp_over_Lq]</a>에서
<span class="math display">\[R_p=\alpha L_q
\label{eq:S06_03_Rp_alphaLq_repeat}\]</span>
이고, <span class="math inline">\(\alpha=2/\pi\)</span>이므로
<span class="math display">\[R_p=\frac{2}{\pi}L_q.
\label{eq:S06_03_Rp_2overpi_Lq}\]</span>
식 <a data-reference="eq:S06_03_sigma_def" data-reference-type="eqref" href="#eq:S06_03_sigma_def">[eq:S06_03_sigma_def]</a>에 <a data-reference="eq:S06_03_Rp_2overpi_Lq" data-reference-type="eqref" href="#eq:S06_03_Rp_2overpi_Lq">[eq:S06_03_Rp_2overpi_Lq]</a>를 대입하여 전개한다.
<span class="math display">\[\begin{aligned}
\sigma_{\mathrm{geom}}
&amp;=\pi R_p^2
=\pi\left(\frac{2}{\pi}L_q\right)^2
\notag\\
&amp;=\pi\left(\frac{4}{\pi^2}\right)L_q^2
\notag\\
&amp;=\frac{4}{\pi}\,L_q^2.
\label{eq:S06_03_sigma_in_Lq}\end{aligned}\]</span>
따라서 다음 불변량이 성립한다.
<span class="math display">\[\boxed{
\frac{\sigma_{\mathrm{geom}}}{L_q^2}
=
\frac{4}{\pi}
}
\qquad
(\text{불변량 I}).
\label{eq:S06_03_invariant_4overpi}\]</span>
또한 6.1의 잠금 <span class="math inline">\(L_q=\lambda_C\)</span>를 적용하면,
<span class="math display">\[\boxed{
\frac{\sigma_{\mathrm{geom}}}{\lambda_C^2}
=
\frac{4}{\pi}
}
\qquad
(\text{불변량 I, 동일 표현}).
\label{eq:S06_03_invariant_4overpi_lC}\]</span></p>
<h4 data-number="8.4.6.2" id="수치-확인불변량-i"><span class="header-section-number">8.4.6.2</span> 6.3.6.2 수치 확인(불변량 I)</h4>
<p>식 <a data-reference="eq:S06_03_lC_value_lock" data-reference-type="eqref" href="#eq:S06_03_lC_value_lock">[eq:S06_03_lC_value_lock]</a>에서 <span class="math inline">\(L_q=\lambda_C\)</span>이므로 <span class="math inline">\(L_q^2\)</span>는
<span class="math display">\[L_q^2
=
(1.3213538700998668\ \mathrm{fm})^2
=
1.7459760500278958\ \mathrm{fm}^2.
\label{eq:S06_03_Lq2_value}\]</span>
식 <a data-reference="eq:S06_03_sigma_value_fm2" data-reference-type="eqref" href="#eq:S06_03_sigma_value_fm2">[eq:S06_03_sigma_value_fm2]</a>와 <a data-reference="eq:S06_03_Lq2_value" data-reference-type="eqref" href="#eq:S06_03_Lq2_value">[eq:S06_03_Lq2_value]</a>로부터
<span class="math display">\[\begin{aligned}
\frac{\sigma_{\mathrm{geom}}}{L_q^2}
&amp;=
\frac{2.223045751056016}{1.7459760500278958}
\notag\\
&amp;=
1.2732395447351628,
\label{eq:S06_03_ratio_numeric}\end{aligned}\]</span>
이며,
<span class="math display">\[\frac{4}{\pi}=1.2732395447351628
\label{eq:S06_03_4overpi_numeric}\]</span>
이므로 <a data-reference="eq:S06_03_invariant_4overpi" data-reference-type="eqref" href="#eq:S06_03_invariant_4overpi">[eq:S06_03_invariant_4overpi]</a>와 일치한다. 이 확인은 불변량의 <strong>검증용 계산</strong>이며, 불변량의 근거(정당화)로 외부 텍스트를 사용하지 않는다.</p>
<h3 data-number="8.4.7" id="불변량의-사용처삽입-위치-고정"><span class="header-section-number">8.4.7</span> 6.3.7 불변량의 사용처(삽입 위치 고정)</h3>
<p>불변량 I는 다음 형태의 유도에서 <em>기하 정규화</em>로 사용될 수 있으며, 사용은 삽입 위치가 잠겨야 한다.</p>
<ol>
<li><p><span class="math inline">\(\sigma_{\mathrm{geom}}\)</span>가 등장하는 모든 식에서, <span class="math inline">\(\sigma_{\mathrm{geom}}\)</span>를 <span class="math inline">\(L_q^2\)</span>로 정규화할 때 <a data-reference="eq:S06_03_invariant_4overpi" data-reference-type="eqref" href="#eq:S06_03_invariant_4overpi">[eq:S06_03_invariant_4overpi]</a>를 사용하여 상수를 <span class="math inline">\(4/\pi\)</span>로 고정한다.</p></li>
<li><p><span class="math inline">\(\lambda_C\)</span> 표현을 사용하는 식에서는 <a data-reference="eq:S06_03_invariant_4overpi_lC" data-reference-type="eqref" href="#eq:S06_03_invariant_4overpi_lC">[eq:S06_03_invariant_4overpi_lC]</a>로 동일하게 고정한다.</p></li>
</ol>
<p>위 사용은 “상수 보정”이 아니라, 이미 잠긴 비율 <span class="math inline">\(R_p/L_q=\alpha\)</span>와 <span class="math inline">\(\alpha=2/\pi\)</span>의 기하 귀결로만 허용된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-29">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(R_p/L_q=\alpha\)</span>, <span class="math inline">\(L_q=\lambda_C\)</span>, <span class="math inline">\(\alpha=2/\pi\)</span> 및 <span class="math inline">\(\lambda_C\)</span> 수치 <a data-reference="eq:S06_03_lC_value_lock" data-reference-type="eqref" href="#eq:S06_03_lC_value_lock">[eq:S06_03_lC_value_lock]</a>를 동일 <code>canon_lock</code> 버전에서 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(\sigma_{\mathrm{geom}}:=\pi R_p^2\)</span> 정의와 불변량 <span class="math inline">\(\sigma_{\mathrm{geom}}/L_q^2=4/\pi\)</span>를 고정.</p></li>
<li><p>Gate: <span class="math inline">\(R_p,L_q,\lambda_C\)</span> 의미/단위 혼용 또는 lock_id 혼합은 G-SYM/G-LOCK에서 즉시 <code>FAIL</code>.</p></li>
<li><p>Gate: <span class="math inline">\(\alpha\)</span> 및 <span class="math inline">\(\delta\)</span> 재유도/재정의는 G-RECT에서 즉시 <code>FAIL</code>.</p></li>
<li><p>Gate: 수치 확인(비율 및 불변량)은 결론 정당화가 아니라 판정 입력으로만 기록되며, 판정 스택은 <code>gate_lock</code>에 사전 등록되어야 함.</p></li>
</ul>
<h2 data-number="8.5" id="연속체rightarrow이산827-안정-조건"><span class="header-section-number">8.5</span> 6.4 연속체<span class="math inline">\(\rightarrow\)</span>이산(82+7) 안정 조건</h2>
<h3 data-number="8.5.1" id="목적-2"><span class="header-section-number">8.5.1</span> 6.4.1 목적</h3>
<p>본 절은 6장(연속체 코어 모델)에서 도출된 코어 반경 <span class="math inline">\(R_p\)</span> 및 관련 불변량(예: <span class="math inline">\(R_p/L_q=2/\pi\)</span>, <span class="math inline">\(\sigma_{\mathrm{geom}}/L_q^2=4/\pi\)</span>)이, 8장(이산 코어 82 + 셸 7) 구조로 <em>내려갈 때</em> 요구되는 최소 안정 조건을 <strong>조건 목록</strong>으로 선언한다.
본 절은 이산 구조의 상세 좌표나 결합 규약을 유도하지 않는다. 본 절은 연속체 결과가 이산 구조에 부과하는 <strong>필수 조건</strong>만을 (i) 조건 식별자, (ii) 조건 내용, (iii) 위반 시 처리로 고정한다.</p>
<h3 data-number="8.5.2" id="전제연속체-쪽-잠금-결과"><span class="header-section-number">8.5.2</span> 6.4.2 전제(연속체 쪽 잠금 결과)</h3>
<p>본 절이 참조하는 연속체 쪽 잠금 결과는 다음과 같다.</p>
<ol>
<li><p>코어 반경 비율:
<span class="math display">\[\frac{R_p}{L_q}=\frac{2}{\pi}.
  \label{eq:S06_04_Rp_ratio}\]</span></p></li>
<li><p>길이 동일시:
<span class="math display">\[L_q=\lambda_C.
  \label{eq:S06_04_Lq_eq_lC}\]</span></p></li>
<li><p>기하 단면 불변량:
<span class="math display">\[\frac{\sigma_{\mathrm{geom}}}{L_q^2}=\frac{4}{\pi},
  \qquad
  \sigma_{\mathrm{geom}}:=\pi R_p^2.
  \label{eq:S06_04_invariant_sigma}\]</span></p></li>
</ol>
<p>이 결과들은 연속체 모델의 산출물로서 <code>canon_lock</code>에 귀속되며, 이산 구조가 이를 만족시키지 못하면 연속체<span class="math inline">\(\rightarrow\)</span>이산 연결은 성립하지 않는다.</p>
<h3 data-number="8.5.3" id="이산-구조827의-최소-안정-조건-목록"><span class="header-section-number">8.5.3</span> 6.4.3 이산 구조(82+7)의 최소 안정 조건 목록</h3>
<p>이산 구조는 “코어 82”와 “셸 7”의 결합으로 구성되며, 연속체 결과는 다음 조건들을 <strong>필수</strong>로 요구한다. 각 조건은 독립이며, 하나라도 위반되면 연속체<span class="math inline">\(\rightarrow\)</span>이산 연결은 <code>FAIL</code>로 판정된다.</p>
<h3 data-number="8.5.4" id="c-827-01-코어-경계-반경-정합반경-잠금-조건"><span class="header-section-number">8.5.4</span> [C-82/7-01] 코어 경계 반경 정합(반경 잠금 조건)</h3>
<p>이산 코어(82)의 좌표 집합 <span class="math inline">\(\{\mathbf{x}_i\}_{i=1}^{82}\)</span>와 중심 <span class="math inline">\(\mathbf{x}_c\)</span>가 정의되었을 때, 코어를 이루는 핵심 경계 층(경계 후보 집합 <span class="math inline">\(\mathcal{B}_{82}\subseteq\{1,\ldots,82\}\)</span>)의 반경 집계량이 <span class="math inline">\(R_p\)</span>와 정합되어야 한다. 정합은 다음 형태로 선언한다.
<span class="math display">\[R_{82}
:=
\mathrm{Agg}\Bigl(\{\|\mathbf{x}_i-\mathbf{x}_c\|\}_{i\in\mathcal{B}_{82}}\Bigr)
\equiv R_p,
\label{eq:S06_04_R82_match}\]</span>
여기서 집계 연산자 <span class="math inline">\(\mathrm{Agg}\)</span> (예: 중앙값, 평균, 최소-최대 밴드의 중심 등)는 <code>analysis_lock</code>에 잠겨야 한다. <span class="math inline">\(\mathrm{Agg}\)</span>가 잠기지 않으면 <span class="math inline">\(R_{82}\)</span>가 비유일이므로 조건은 정의 불능이며 <code>INCONCLUSIVE</code>이다.
정합 문턱(허용오차) <span class="math inline">\(\varepsilon_{R}\)</span>는 <code>gate_lock</code>에 사전 등록되어야 하며,
<span class="math display">\[|R_{82}-R_p|&gt;\varepsilon_{R}
\quad\Longrightarrow\quad
\texttt{FAIL-CORE82-RADIUS}.
\label{eq:S06_04_R82_fail}\]</span></p>
<h3 data-number="8.5.5" id="c-827-02-단면-불변량-정합기하-단면-조건"><span class="header-section-number">8.5.5</span> [C-82/7-02] 단면 불변량 정합(기하 단면 조건)</h3>
<p>이산 코어(82)에서 코어 경계 후보 집합 <span class="math inline">\(\mathcal{B}_{82}\)</span>를 통해 “이산 단면”을 정의할 수 있어야 하며, 그 정규화가 불변량 <a data-reference="eq:S06_04_invariant_sigma" data-reference-type="eqref" href="#eq:S06_04_invariant_sigma">[eq:S06_04_invariant_sigma]</a>와 정합되어야 한다. 이산 단면 <span class="math inline">\(\sigma_{82}\)</span>는 다음 형태로 정의한다.
<span class="math display">\[\sigma_{82}
:=
\mathrm{ProjArea}\Bigl(\{\mathbf{x}_i\}_{i\in\mathcal{B}_{82}};\ \mathbf{n}_\sigma\Bigr),
\label{eq:S06_04_sigma82_def}\]</span>
여기서 <span class="math inline">\(\mathbf{n}_\sigma\)</span>는 단면 투영축이며 <code>analysis_lock</code>에 잠긴다. 투영 면적 연산자 <span class="math inline">\(\mathrm{ProjArea}\)</span>의 정의(볼록껍질/격자 셀 카운트/픽셀화 등)는 <code>analysis_lock</code>에 잠겨야 한다.</p>
<p>정규화된 단면 비율을 다음으로 정의한다.
<span class="math display">\[I_{\sigma,82}:=\frac{\sigma_{82}}{L_q^2}.
\label{eq:S06_04_I_sigma82}\]</span>
연속체 불변량의 요구는 다음으로 선언된다.
<span class="math display">\[\left|I_{\sigma,82}-\frac{4}{\pi}\right|&gt;\varepsilon_{\sigma}
\quad\Longrightarrow\quad
\texttt{FAIL-CORE82-SIGMA}.
\label{eq:S06_04_sigma_fail}\]</span>
여기서 <span class="math inline">\(\varepsilon_{\sigma}\)</span>는 <code>gate_lock</code>에 잠긴 문턱이다.</p>
<h3 data-number="8.5.6" id="c-827-03-경계-전이의-단일성단일-코어-경계-조건"><span class="header-section-number">8.5.6</span> [C-82/7-03] 경계 전이의 단일성(단일 코어 경계 조건)</h3>
<p>연속체 모델은 코어 경계가 단일 전이점으로 정의된다고 잠겼다. 이산 구조에서도 코어 경계의 전이는 단일이어야 한다. 이를 위해 “코어 지시변수” <span class="math inline">\(\chi_{82}(r)\)</span>를 반경 <span class="math inline">\(r\)</span>에 대해 정의하고, 전이점이 하나뿐임을 요구한다.
<span class="math display">\[\chi_{82}(r)\in\{0,1\},
\qquad
r\mapsto \chi_{82}(r)\ \text{는 한 번만 0$\rightarrow$1 전이}.
\label{eq:S06_04_single_transition}\]</span>
전이 판정 규칙(어떤 구조량을 기반으로 <span class="math inline">\(\chi_{82}\)</span>를 정의하는가, 전이를 “한 번”으로 판정하는 문턱)은 <code>analysis_lock</code>에 잠겨야 한다.
전이가 두 번 이상 발생하거나, 전이가 없는 경우는 연속체<span class="math inline">\(\rightarrow\)</span>이산 연결 실패로 처리한다.
<span class="math display">\[\text{전이 횟수}\neq 1
\quad\Longrightarrow\quad
\texttt{FAIL-CORE82-TRANSITION}.
\label{eq:S06_04_transition_fail}\]</span></p>
<h3 data-number="8.5.7" id="c-827-04-셸7-부착의-국소성국소-규칙-보존-조건"><span class="header-section-number">8.5.7</span> [C-82/7-04] 셸(7) 부착의 국소성(국소 규칙 보존 조건)</h3>
<p>셸(7)은 코어 경계 부근에서 <em>국소적으로</em> 부착/상쇄/생존 구조를 형성해야 한다. 이는 3.1의 국소 규칙 공리와 양립해야 한다는 요구이다. 이를 다음 조건으로 선언한다.
<span class="math display">\[\forall k\in\{1,\ldots,7\},\ \exists i(k)\in\mathcal{B}_{82}\ \text{s.t.}\
\|\mathbf{s}_k-\mathbf{x}_{i(k)}\|\le \rho_{\mathrm{attach}}.
\label{eq:S06_04_shell_local_attach}\]</span>
여기서 <span class="math inline">\(\mathbf{s}_k\)</span>는 셸 벡터 또는 셸 표지점(정의는 8장에서 잠김)이며, <span class="math inline">\(\rho_{\mathrm{attach}}\)</span>는 부착 반경 문턱이다. <span class="math inline">\(\rho_{\mathrm{attach}}\)</span>는 길이 스케일 <span class="math inline">\(L_q\)</span>로 정규화하여 <code>analysis_lock</code>에 잠근다.
<span class="math display">\[\rho_{\mathrm{attach}} := \eta_{\mathrm{attach}}\,L_q,
\qquad
\eta_{\mathrm{attach}}&gt;0\ \text{는 잠김}.
\label{eq:S06_04_attach_radius_lock}\]</span>
조건 위반은 다음으로 처리한다.
<span class="math display">\[\exists k\ \text{s.t.}\ \min_{i\in\mathcal{B}_{82}}\|\mathbf{s}_k-\mathbf{x}_i\|&gt;\rho_{\mathrm{attach}}
\quad\Longrightarrow\quad
\texttt{FAIL-SHELL7-LOCAL}.
\label{eq:S06_04_shell_local_fail}\]</span></p>
<h3 data-number="8.5.8" id="c-827-05-상쇄-생존-규약의-비퇴화생존-벡터-존재-조건"><span class="header-section-number">8.5.8</span> [C-82/7-05] 상쇄-생존 규약의 비퇴화(생존 벡터 존재 조건)</h3>
<p>연속체 결과가 이산 구조로 내려갈 때, 셸(7)의 상쇄-생존 규약은 “비퇴화” 상태를 유지해야 한다. 이는 생존 벡터 <span class="math inline">\(\mathbf{V}\)</span>가 정의 가능하고(비유일/모호가 아님), 동시에 영벡터로 붕괴하지 않아야 한다는 조건이다.
<span class="math display">\[\mathbf{V}:=\sum_{k=1}^{7}\mathbf{s}_k,
\qquad
\|\mathbf{V}\|\ge V_{\min}.
\label{eq:S06_04_survival_nondeg}\]</span>
<span class="math inline">\(V_{\min}\)</span>은 내부 단위 또는 <span class="math inline">\(L_q\)</span>로 정규화된 문턱으로 <code>gate_lock</code>에 잠긴다.
<span class="math inline">\(\|\mathbf{V}\|&lt;V_{\min}\)</span>이면 “생존 부호/전하/방출 방향”의 정의가 붕괴하므로 연결 실패로 처리한다.
<span class="math display">\[\|\mathbf{V}\|&lt;V_{\min}
\quad\Longrightarrow\quad
\texttt{FAIL-SHELL7-DEGEN}.
\label{eq:S06_04_survival_fail}\]</span></p>
<h3 data-number="8.5.9" id="c-827-06-레짐-일치stone충만재밍의-전제-조건"><span class="header-section-number">8.5.9</span> [C-82/7-06] 레짐 일치(Stone/충만/재밍의 전제 조건)</h3>
<p>연속체 코어 모델은 Stone/충만 레짐을 전제로 한다. 이산 코어(82+7) 또한 동일 레짐에서 정의되어야 한다. 이를 다음 조건으로 선언한다.</p>
<ol>
<li><p>이산 배치가 비침투를 위반하지 않는다.</p></li>
<li><p>이산 배치가 충만 규약과 충돌하지 않는다(빈 공간을 독립 객체로 취급하지 않는다).</p></li>
<li><p>접촉 그래프 및 백본 판정이 잠긴 레짐 좌표축(4.3)과 일치한다.</p></li>
</ol>
<p>위 세 항목 중 하나라도 위반되면 레짐 불일치로 처리한다.
<span class="math display">\[\text{레짐 불일치}
\quad\Longrightarrow\quad
\texttt{FAIL-REG-MISMATCH}.
\label{eq:S06_04_regime_fail}\]</span></p>
<h3 data-number="8.5.10" id="c-827-07-스케일-정규화-일치길이-단위의-단일성"><span class="header-section-number">8.5.10</span> [C-82/7-07] 스케일 정규화 일치(길이 단위의 단일성)</h3>
<p>이산 구조의 모든 좌표와 길이 판단은 동일 길이 스케일 <span class="math inline">\(L_q\)</span> (또는 동일시된 <span class="math inline">\(\lambda_C\)</span>)로 정규화되어야 한다. 동일 산출물에서 다음 혼합은 금지된다.</p>
<ol>
<li><p><span class="math inline">\(L_q\)</span>와 <span class="math inline">\(\lambda_C\)</span>를 서로 다른 값으로 사용.</p></li>
<li><p><span class="math inline">\(R_p\)</span>를 별도 정의로 재도입하여 <span class="math inline">\(R_{82}\)</span> 정합을 회피.</p></li>
<li><p>셀 기하(큐브)와 시각화 구를 혼합하여 단면 또는 반경을 산출.</p></li>
</ol>
<p>혼합이 발견되면 즉시 lock_id 혼합 또는 의미 충돌로 <code>FAIL</code>이다.
<span class="math display">\[\text{정규화 혼합}
\quad\Longrightarrow\quad
\texttt{FAIL-LOCK-MIX}\ \text{또는}\ \texttt{FAIL-GEO-CONF}.
\label{eq:S06_04_norm_fail}\]</span></p>
<h3 data-number="8.5.11" id="c-827-08-정사면체-락킹의-존재4-점-강성-증명서"><span class="header-section-number">8.5.11</span> [C-82/7-08] 정사면체 락킹의 존재(4-점 강성 증명서)</h3>
<p>본 조건은 “코어(82)가 <em>완전 재밍 강성</em>을 갖는다”(즉, 언재밍 트리거 <a data-reference="eq:unjamming_trigger" data-reference-type="eqref" href="#eq:unjamming_trigger">[eq:unjamming_trigger]</a>에서 <span class="math inline">\(\Psi_{\rm yield}\)</span>에 대응하는 <span class="math inline">\(c^2\)</span> 강성을 논리적으로 주장할 수 있다)는 서술에 필요한 <strong>최소 구조 증명서</strong>를 잠근다.</p>
<p>3차원에서 4점은 최소한의 비공면(simplex)이며, 접촉 네트워크가 이 정사면체(사면체) 백본을 포함하지 않으면 전단 강성은 영 또는 레짐 밖으로 남을 수 있다. 따라서 코어 82의 접촉 그래프 <span class="math inline">\(\mathcal{G}_c=(\mathcal{V}_c,\mathcal{E}_c)\)</span>가 다음을 만족해야 한다.
<span class="math display">\[\exists\ (i_1,i_2,i_3,i_4)\subset \mathcal{B}_{82}
\ \text{s.t.}\
(i_a,i_b)\in \mathcal{E}_c\ \forall\ a&lt;b.
\label{eq:S06_04_tetra_lock_exist}\]</span>
즉, <span class="math inline">\(\mathcal{B}_{82}\)</span> 내부에 완전 그래프 <span class="math inline">\(K_4\)</span>에 해당하는 4-점 백본이 존재해야 한다. 이때의 4점 집합을 <span class="math inline">\(\mathcal{T}_4\)</span>로 표기한다.</p>
<p>또한 “강성의 온전함”을 주장하려면 이 정사면체가 퇴화(공면 또는 거의 공면)하지 않아야 한다. 좌표 기반으로는 정사면체 부피(혼합곱) 문턱으로 판정한다.
<span class="math display">\[V_{\mathrm{tet}}(i_1,i_2,i_3,i_4)
:=\frac{1}{6}\left|\det\left[\mathbf{x}_{i_2}-\mathbf{x}_{i_1},\ \mathbf{x}_{i_3}-\mathbf{x}_{i_1},\ \mathbf{x}_{i_4}-\mathbf{x}_{i_1}\right]\right|
\ge V_{\min}^{\mathrm{tet}}.
\label{eq:S06_04_tetra_volume}\]</span>
여기서 <span class="math inline">\(V_{\min}^{\mathrm{tet}}\)</span>는 <span class="math inline">\(L_q^3\)</span>으로 정규화된 문턱으로 <code>gate_lock</code>에 잠긴다.</p>
<p>위 조건이 성립하면, 코어(82)가 “사면체 락킹”을 포함하는 재밍 백본을 갖는다는 사실이 확보되며, 본 문서의 동적 강성 혼합(<span class="math inline">\(\xi\in[0,1]\)</span>) 서술에서 <em>재밍 레짐(<span class="math inline">\(\xi\approx 1\)</span>)</em>을 주장할 최소 근거가 된다. 반대로, 본 조건이 위반되면 “코어 강성=<span class="math inline">\(c^2\)</span>” 또는 “더 이상 수축 불가” 같은 문장은 결론 자격을 상실하며, 한계 결론(CT-LIM)만 허용된다.
<span class="math display">\[\neg\exists\ \mathcal{T}_4\ \ \text{또는}\ \ V_{\mathrm{tet}}&lt;V_{\min}^{\mathrm{tet}}
\quad\Longrightarrow\quad
\texttt{FAIL-CORE82-TETRA}.
\label{eq:S06_04_tetra_fail}\]</span></p>
<h3 data-number="8.5.12" id="조건-위반의-처리결론-자격과-한계-문장"><span class="header-section-number">8.5.12</span> 6.4.4 조건 위반의 처리(결론 자격과 한계 문장)</h3>
<p>조건 목록 [C-82/7-01]~[C-82/7-08] 중 하나라도 위반되면, 연속체<span class="math inline">\(\rightarrow\)</span>이산 연결은 결론 자격을 상실한다. 이때 허용되는 서술은 “한계 결론(CT-LIM)”뿐이며, 반드시 FAIL 라벨과 원인 조건 ID를 함께 기록해야 한다.
조건 위반을 “해석”으로 봉합하거나, 조건 정의(집계 연산자, 문턱값, 경계 후보 집합 등)를 결과를 본 뒤 변경하는 행위는 No-Tuning 위반이며 금지된다. 변경이 필요하면 버전업과 전면 재검증만 허용된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-30">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<pre><code>  \item LOCK: 연속체 산출물($R_p/L_q=2/\pi$, $L_q=\lambda_C$, $\sigma_{\mathrm{geom}}/L_q^2=4/\pi$)을 상위 입력으로 고정.
  \item LOCK: 이산 안정 조건 목록 [C-82/7-01]\textasciitilde[C-82/7-08]의 정의(집계 연산자, 투영축, 문턱, 정규화 규약)를 \texttt{analysis\_lock}/\texttt{gate\_lock}에 잠금.
  \item Gate: 조건 위반 시 즉시 \texttt{FAIL-CORE82-*}/\texttt{FAIL-SHELL7-*}/\texttt{FAIL-REG-*} 라벨을 부여하고 결론 자격을 박탈함.
  \item Gate: 조건 정의 미잠금(집계 규약/문턱/경계 후보 미정)은 \texttt{INCONCLUSIVE}; 결과를 근거로 조건을 사후 수정하면 G-NT에서 \texttt{FAIL}.
  \item Gate: 서로 다른 lock\_id 조합 혼합 또는 셀 기하 혼동은 G-LOCK/G-SYM에서 즉시 \texttt{FAIL}.
</code></pre>
<h1 data-number="9" id="섹터-정수화120와-빌드-타임"><span class="header-section-number">9</span> 7. 3-섹터 정수화(120)와 빌드 타임</h1>
<h2 class="unnumbered" id="섹터의-위상학적-필연성">3-섹터의 위상학적 필연성</h2>
<p>2차원 단면에서 중심점(Core)을 물리적으로 가두기(Enclosure) 위해서는 최소 3개의 벡터가 필요하다(2개는 선형, 4개는 과잉).
따라서 전하(<span class="math inline">\(\pm,0\)</span>)와 같은 상태를 구분하는 최소 기하학적 비용은 필연적으로 3-섹터 구조(120)로 귀결된다.</p>
<h4 data-number="9.0.0.1" id="정리-3이-최소이며-120circ가-강제됨"><span class="header-section-number">9.0.0.1</span> (정리) <span class="math inline">\(3\)</span>이 최소이며 <span class="math inline">\(120^\circ\)</span>가 강제됨</h4>
<p><strong>(i) 최소성.</strong> 2개의 벡터로는 (서로 반대인 경우를 제외하면) 중심점을 둘러싸는 <em>폐포</em>를 만들 수 없으며, 반대쌍인 경우에도 “선”만 남아 3개의 섹터(상태)를 만들 수 없다. 따라서 중심을 가두는 최소 위상 비용은 <span class="math inline">\(3\)</span>이다.<br/>
<strong>(ii) <span class="math inline">\(120^\circ\)</span> 강제.</strong> 방향축을 단위벡터 <span class="math inline">\(\{\mathbf{n}_1,\mathbf{n}_2,\mathbf{n}_3\}\)</span>로 두고 합-제로 닫힘을
<span class="math display">\[\mathbf{n}_1+\mathbf{n}_2+\mathbf{n}_3=\mathbf{0},\qquad \|\mathbf{n}_i\|=1
\label{eq:S07_00_nsum0_unit}\]</span>
로 고정하면, <span class="math inline">\(\mathbf{n}_3=-(\mathbf{n}_1+\mathbf{n}_2)\)</span>이므로
<span class="math display">\[\|\mathbf{n}_3\|^2=\|\mathbf{n}_1+\mathbf{n}_2\|^2=2+2\,\mathbf{n}_1\cdot\mathbf{n}_2.\]</span>
좌변이 <span class="math inline">\(1\)</span>이려면 <span class="math inline">\(\mathbf{n}_1\cdot\mathbf{n}_2=-\tfrac{1}{2}\)</span>이고, 따라서 두 축 사이 각은 <span class="math inline">\(120^\circ\)</span>이다. 순열 대칭으로 모든 쌍이 <span class="math inline">\(120^\circ\)</span>이므로 3-섹터(120) 구조는 <em>선택</em>이 아니라 “최소성 + 합-제로 닫힘”의 기하학적 귀결이다.</p>
<h2 class="unnumbered" id="장의-목적과-산출물">장의 목적과 산출물</h2>
<p>본 장은 (i) 120 3-섹터 좌표축을 정의하고, (ii) 연속(실수) 형태의 방향/위상 기여를 3개의 정수 섹터 카운트로 변환하는 <strong>정수화 규칙</strong>을 고정하며, (iii) 정수화된 카운트를 시간 틱과 결합하여 <strong>빌드 타임</strong>을 정의한다.
본 장의 산출물은 다음 네 가지로 고정한다.</p>
<ol>
<li><p>3-섹터 축 <span class="math inline">\(\{\mathbf{n}_1,\mathbf{n}_2,\mathbf{n}_3\}\)</span>의 정의(120 조건 포함).</p></li>
<li><p>정수화 결과 <span class="math inline">\((k_1,k_2,k_3)\in\mathbb{Z}_{\ge 0}^3\)</span>의 정의와 합 보존 규칙 <span class="math inline">\(k_1+k_2+k_3=N\)</span>.</p></li>
<li><p>잔차(불상쇄) 벡터 <span class="math inline">\(\mathbf{V}\)</span>의 정의와 비퇴화 조건(영벡터 붕괴 금지 조건 포함).</p></li>
<li><p>빌드 타임 <span class="math inline">\(T_{\mathrm{build}}\)</span> 및 보조 빌드 타임들의 정의(틱/사건율 기반).</p></li>
</ol>
<p>정수화 규칙은 이후 장에서 (a) 셸 상쇄-생존(6 상쇄 + 1 생존) 구조의 라벨, (b) 전하 부호 라벨, (c) 전자(생존) 라벨의 생성 규칙으로 직접 연결된다. 따라서 본 장에서 정수화 규칙이 잠기지 않으면 이후 전하/전자 라벨은 정의 불능이다.</p>
<h2 class="unnumbered" id="섹터120-축의-정의">3-섹터(120) 축의 정의</h2>
<h3 class="unnumbered" id="차원-섹터-평면과-단위축">2차원 섹터 평면과 단위축</h3>
<p>3-섹터 정수화는 특정 평면 <span class="math inline">\(\Pi\)</span> 위에서 수행된다. 평면의 선택(어떤 좌표계의 어떤 2차원 부분공간인가)은 <code>analysis_lock</code>에 잠긴다.
평면 <span class="math inline">\(\Pi\)</span> 위에 다음 세 개의 단위벡터를 정의한다.
<span class="math display">\[\mathbf{n}_1,\mathbf{n}_2,\mathbf{n}_3 \in \Pi,\qquad
\|\mathbf{n}_1\|=\|\mathbf{n}_2\|=\|\mathbf{n}_3\|=1.
\label{eq:S07_n_unit}\]</span></p>
<h3 class="unnumbered" id="조건내적-규약">120 조건(내적 규약)</h3>
<p>3-섹터 축은 서로 120 간격을 갖도록 다음 내적 규약으로 잠근다.
<span class="math display">\[\mathbf{n}_i\cdot \mathbf{n}_j=
\begin{cases}
1,&amp; i=j,\\
-\dfrac{1}{2},&amp; i\neq j.
\end{cases}
\label{eq:S07_120deg_inner}\]</span>
또한 세 축의 합이 0이 되도록(중심 상쇄) 다음을 잠근다.
<span class="math display">\[\mathbf{n}_1+\mathbf{n}_2+\mathbf{n}_3=\mathbf{0}.
\label{eq:S07_n_sum_zero}\]</span>
<a data-reference="eq:S07_120deg_inner" data-reference-type="eqref" href="#eq:S07_120deg_inner">[eq:S07_120deg_inner]</a>–<a data-reference="eq:S07_n_sum_zero" data-reference-type="eqref" href="#eq:S07_n_sum_zero">[eq:S07_n_sum_zero]</a>는 3-섹터 정수화의 기하학적 기반이며, 축 선택은 결과를 본 뒤 회전/치환될 수 없다. 축의 치환(순서 교체)은 허용될 수 있으나, 치환 규칙(예: <span class="math inline">\(\mathbf{n}_1\mapsto \mathbf{n}_2\)</span>)은 <code>analysis_lock</code>에 사전 등록되어야 한다.</p>
<h2 class="unnumbered" id="정수화-규칙-연속-기여-rightarrow-k_1k_2k_3">정수화 규칙: 연속 기여 <span class="math inline">\(\rightarrow\)</span> <span class="math inline">\((k_1,k_2,k_3)\)</span></h2>
<h3 class="unnumbered" id="입력-방향-기여-벡터와-총-카운트-n">입력: 방향 기여 벡터와 총 카운트 <span class="math inline">\(N\)</span></h3>
<p>정수화의 입력은 평면 <span class="math inline">\(\Pi\)</span> 위의 벡터 <span class="math inline">\(\mathbf{u}\)</span>와 총 카운트 <span class="math inline">\(N\)</span>이다.
<span class="math display">\[\mathbf{u}\in \Pi,\qquad
N\in \mathbb{Z}_{\ge 0}.
\label{eq:S07_inputs}\]</span>
<span class="math inline">\(\mathbf{u}\)</span>는 사건 집계, 셸 구조, 또는 코어-셸 결합에서 도출되는 “방향성 기여”를 대표하는 벡터로 정의되며, <span class="math inline">\(\mathbf{u}\)</span>의 생성 절차(어떤 표지점/어떤 전후 배치/어떤 집계 창을 쓰는가)는 <code>analysis_lock</code>에 잠긴다.
<span class="math inline">\(N\)</span>은 해당 단계에서 보존되는 총 정수 자원(총 섹터 카운트)이며, <span class="math inline">\(N\)</span>의 출처(예: 특정 구조에서의 총 개수, 특정 사건 집계창의 총량)는 <code>analysis_lock</code> 또는 <code>canon_lock</code>에 잠긴다.</p>
<h3 class="unnumbered" id="섹터-실수-점수-s_i의-정의비음수화">섹터 실수 점수 <span class="math inline">\(s_i\)</span>의 정의(비음수화)</h3>
<p>섹터 축에 대한 투영 점수를 다음으로 정의한다.
<span class="math display">\[p_i := \mathbf{u}\cdot \mathbf{n}_i\qquad (i=1,2,3).
\label{eq:S07_projection_pi}\]</span>
<span class="math inline">\(p_i\)</span>는 양/음 값을 가질 수 있으므로, 정수 카운트로 변환하기 위해 비음수 점수로 이동시킨다. 이동량을 다음으로 정의한다.
<span class="math display">\[p_{\min}:=\min\{p_1,p_2,p_3\},
\qquad
s_i:=p_i-p_{\min}\qquad (i=1,2,3).
\label{eq:S07_shift_si}\]</span>
따라서
<span class="math display">\[s_i\ge 0\quad (i=1,2,3),
\qquad
\text{그리고 적어도 하나의 } s_i \text{는 } 0.
\label{eq:S07_si_nonneg}\]</span>
만약 <span class="math inline">\(\mathbf{u}\)</span>가 세 축에 대해 완전 대칭이면 <span class="math inline">\(p_1=p_2=p_3\)</span>이고, 이때 <span class="math inline">\(s_1=s_2=s_3=0\)</span>이 되어 이후 정규화가 불능이므로 별도 처리 규칙이 필요하다. 이를 위해 퇴화 판정 지표를 잠근다.
<span class="math display">\[S:=s_1+s_2+s_3.
\label{eq:S07_S_sum}\]</span>
<span class="math inline">\(S=0\)</span>이면 정수화는 “완전 대칭 입력”으로 분류되며, 이 경우 정수화 결과는
<span class="math display">\[(k_1,k_2,k_3)=
\begin{cases}
\left(\dfrac{N}{3},\dfrac{N}{3},\dfrac{N}{3}\right),&amp; N\equiv 0\ (\mathrm{mod}\ 3),\\[6pt]
\left(\left\lfloor\dfrac{N}{3}\right\rfloor,\left\lfloor\dfrac{N}{3}\right\rfloor,\left\lceil\dfrac{N}{3}\right\rceil\right)\ \text{및 그 순열},&amp; N\not\equiv 0\ (\mathrm{mod}\ 3),
\end{cases}
\label{eq:S07_degenerate_rule}\]</span>
로 잠근다. 순열 선택 규칙은 <code>analysis_lock</code>에 사전 등록되어야 하며, 결과를 본 뒤 선택될 수 없다.</p>
<h3 class="unnumbered" id="정규화-분율-f_i의-정의">정규화 분율 <span class="math inline">\(f_i\)</span>의 정의</h3>
<p><span class="math inline">\(S&gt;0\)</span>인 경우, 섹터 분율을 다음으로 정의한다.
<span class="math display">\[f_i := \frac{s_i}{S}\qquad (i=1,2,3),
\label{eq:S07_fi_def}\]</span>
따라서
<span class="math display">\[f_i\ge 0,\qquad f_1+f_2+f_3=1.
\label{eq:S07_fi_simplex}\]</span></p>
<h3 class="unnumbered" id="정수화합-보존-규칙">정수화(합 보존) 규칙</h3>
<p>정수화의 목표는 다음을 동시에 만족하는 정수 삼중항 <span class="math inline">\((k_1,k_2,k_3)\)</span>를 선택하는 것이다.
<span class="math display">\[k_i\in\mathbb{Z}_{\ge 0},\qquad
k_1+k_2+k_3=N.
\label{eq:S07_sum_constraint}\]</span>
정수화는 “분율 <span class="math inline">\(f_i\)</span>에 가장 가까운 정수 할당”으로 정의하며, 다음 절차로 잠근다.</p>
<h4 data-number="9.0.0.2" id="바닥-할당"><span class="header-section-number">9.0.0.2</span> (1) 바닥 할당</h4>
<p><span class="math display">\[\tilde{k}_i := \left\lfloor N f_i \right\rfloor,\qquad
r_i := N f_i - \tilde{k}_i \in [0,1),
\label{eq:S07_floor_and_residual}\]</span>
여기서 <span class="math inline">\(r_i\)</span>는 잔여(소수부)이다.</p>
<h4 data-number="9.0.0.3" id="부족량-계산"><span class="header-section-number">9.0.0.3</span> (2) 부족량 계산</h4>
<p><span class="math display">\[\Delta := N - (\tilde{k}_1+\tilde{k}_2+\tilde{k}_3).
\label{eq:S07_deficit_Delta}\]</span>
정의상 <span class="math inline">\(\Delta\in\{0,1,2\}\)</span>이다.</p>
<h4 data-number="9.0.0.4" id="잔여-큰-순서로-보정"><span class="header-section-number">9.0.0.4</span> (3) 잔여 큰 순서로 보정</h4>
<p><span class="math inline">\(r_i\)</span>가 큰 순서대로 <span class="math inline">\(\Delta\)</span>개의 인덱스를 선택하여 그 인덱스의 <span class="math inline">\(\tilde{k}_i\)</span>에 1을 더한다. 이를 정식화하면, <span class="math inline">\(\Delta\)</span>개의 인덱스 집합 <span class="math inline">\(\mathcal{I}_\Delta\subset\{1,2,3\}\)</span>를
<span class="math display">\[\mathcal{I}_\Delta := \operatorname{TopK}\bigl(\{r_1,r_2,r_3\};\Delta\bigr)
\label{eq:S07_topk_def}\]</span>
로 정의하고, 최종 정수화 결과를
<span class="math display">\[k_i :=
\tilde{k}_i + \mathbf{1}_{\{i\in\mathcal{I}_\Delta\}}
\qquad (i=1,2,3)
\label{eq:S07_final_ki}\]</span>
로 정의한다. 여기서 <span class="math inline">\(\mathbf{1}_{\{\cdot\}}\)</span>는 지시함수이다.</p>
<h4 data-number="9.0.0.5" id="동률-처리타이브레이크"><span class="header-section-number">9.0.0.5</span> (4) 동률 처리(타이브레이크)</h4>
<p><span class="math inline">\(\operatorname{TopK}\)</span>에서 잔여값 동률이 발생할 수 있으므로, 타이브레이크 규칙을 사전 등록하여 잠근다. 타이브레이크는 다음 중 하나로만 허용된다(택일 잠금).</p>
<ol>
<li><p><strong>TB-LEX</strong>: 인덱스 순서(1<span class="math inline">\(\rightarrow\)</span>2<span class="math inline">\(\rightarrow\)</span>3) 우선.</p></li>
<li><p><strong>TB-AXIS</strong>: 사전 등록된 우선 축(예: <span class="math inline">\(\mathbf{n}_1\)</span> 우선) 우선.</p></li>
<li><p><strong>TB-HASH</strong>: 사건/구조 식별자로부터 계산된 해시 기반 결정(동일 입력이면 동일 출력).</p></li>
</ol>
<p>타이브레이크 규칙이 잠기지 않으면 정수화 결과가 비유일이므로 <code>INCONCLUSIVE</code>이다.</p>
<h3 class="unnumbered" id="정수화-산출물의-1차-불변량">정수화 산출물의 1차 불변량</h3>
<p>정수화 결과는 다음 불변량을 가진다.</p>
<ol>
<li><p>합 보존: <span class="math inline">\(k_1+k_2+k_3=N\)</span>.</p></li>
<li><p>비음수성: <span class="math inline">\(k_i\ge 0\)</span>.</p></li>
<li><p>분율 근사: <span class="math inline">\(\left|k_i/N - f_i\right|\)</span>가 최소가 되도록 구성됨(타이브레이크는 사전 등록된 규칙에 따름).</p></li>
</ol>
<p>위 불변량은 이후 전하/전자 라벨의 정수 기반으로 사용되며, 불변량이 깨지면 라벨은 정의 불능이다.</p>
<h2 class="unnumbered" id="잔차불상쇄-벡터와-전하전자-라벨의-연결">잔차(불상쇄) 벡터와 전하/전자 라벨의 연결</h2>
<h3 class="unnumbered" id="잔차-벡터-mathbfv의-정의">잔차 벡터 <span class="math inline">\(\mathbf{V}\)</span>의 정의</h3>
<p>정수화 결과 <span class="math inline">\((k_1,k_2,k_3)\)</span>로부터 섹터 잔차(불상쇄) 벡터를 다음으로 정의한다.
<span class="math display">\[\mathbf{V}
:=
k_1\mathbf{n}_1+k_2\mathbf{n}_2+k_3\mathbf{n}_3.
\label{eq:S07_V_def}\]</span>
<a data-reference="eq:S07_n_sum_zero" data-reference-type="eqref" href="#eq:S07_n_sum_zero">[eq:S07_n_sum_zero]</a>에 의해 <span class="math inline">\(k_1=k_2=k_3\)</span>이면 <span class="math inline">\(\mathbf{V}=\mathbf{0}\)</span>이다. 따라서 <span class="math inline">\(\mathbf{V}\)</span>는 “완전 상쇄”에서 벗어난 정도와 방향을 나타내는 정수 기반 잔차 벡터로 고정한다.</p>
<h3 class="unnumbered" id="비퇴화-조건라벨-정의-가능-조건">비퇴화 조건(라벨 정의 가능 조건)</h3>
<p>전하/전자 라벨은 <span class="math inline">\(\mathbf{V}\)</span>가 비영(비퇴화)일 때 정의 가능하도록 잠근다. 이를 위해 문턱을 다음으로 정의한다.
<span class="math display">\[\|\mathbf{V}\|\ge V_{\min},
\label{eq:S07_Vmin}\]</span>
여기서 <span class="math inline">\(V_{\min}\)</span>은 <code>gate_lock</code>에 사전 등록된 문턱이며, <span class="math inline">\(V_{\min}\)</span>의 변경은 버전업으로만 허용된다.
만약 <span class="math inline">\(\|\mathbf{V}\|&lt;V_{\min}\)</span>이면 라벨은 중립(또는 정의 불능)으로 처리되며, 해당 경우의 처리 규칙(CT-LIM 또는 CT-DEF로의 귀속)은 PASS.rules로 잠겨야 한다.</p>
<h3 class="unnumbered" id="전하전자-라벨로의-연결-선언">전하/전자 라벨로의 연결 선언</h3>
<p>정수화 규칙은 이후 장에서 다음 형태로 라벨에 연결된다.</p>
<ol>
<li><p><strong>전하 부호 라벨</strong>: 사전 등록된 전하 축 <span class="math inline">\(\mathbf{n}_Q\)</span>에 대해
<span class="math display">\[q := \mathrm{sgn}(\mathbf{V}\cdot\mathbf{n}_Q)
  \label{eq:S07_charge_label_decl}\]</span>
형태로 부호 라벨을 정의한다. <span class="math inline">\(\mathbf{n}_Q\)</span>의 선택은 <code>analysis_lock</code>에 잠겨야 하며, 결과를 본 뒤 선택될 수 없다.</p></li>
<li><p><strong>전자(생존) 라벨</strong>: 셸(7) 상쇄-생존 규약에서 “생존”을 나타내는 잔차 방향이 <span class="math inline">\(\mathbf{V}\)</span>로부터 정의되며, 전자 라벨은 생존 잔차의 존재 및 방향 부호로 귀속된다. 생존 규약의 상세는 이산 구조 장에서 잠기며, 본 장은 정수화가 라벨의 정수 기반임을 선언한다.</p></li>
</ol>
<p>따라서 본 장의 정수화 규칙은 “전하/전자 라벨의 상위 규약”이며, 라벨의 정의는 정수화 규칙을 우회하여 별도로 도입될 수 없다.</p>
<h2 data-number="9.1" id="빌드-타임build-time의-정의"><span class="header-section-number">9.1</span> 7.5 빌드 타임(Build Time)의 정의</h2>
<h3 data-number="9.1.1" id="틱-기반-빌드-타임"><span class="header-section-number">9.1.1</span> 7.5.1 틱 기반 빌드 타임</h3>
<p>실현 시간 틱 <span class="math inline">\(\Delta t\)</span>가 <code>realization_lock</code>에 잠겨 있을 때, 총 카운트 <span class="math inline">\(N\)</span>에 해당하는 빌드 타임을 다음으로 정의한다.
<span class="math display">\[T_{\mathrm{build}} := N\,\Delta t.
\label{eq:S07_Tbuild_tick}\]</span>
정의 <a data-reference="eq:S07_Tbuild_tick" data-reference-type="eqref" href="#eq:S07_Tbuild_tick">[eq:S07_Tbuild_tick]</a>은 “한 틱당 1 카운트”를 채택하는 빌드 타임 정의이며, 다른 집계(예: 한 틱당 다중 카운트 또는 희소 카운트)를 채택하려면 별도의 닫힘으로 정의해야 한다.</p>
<h3 data-number="9.1.2" id="사건율-기반-빌드-타임"><span class="header-section-number">9.1.2</span> 7.5.2 사건율 기반 빌드 타임</h3>
<p>정류 사건율 <span class="math inline">\(\nu\)</span>가 정의되어 있고(사건 정의 및 <span class="math inline">\(\delta\)</span> 삽입이 잠겨 있음), 동일 레짐에서 <span class="math inline">\(N\)</span>개의 카운트를 누적하는 평균 시간이 빌드 타임으로 사용될 경우, 다음 정의를 잠근다.
<span class="math display">\[T_{\mathrm{build}} := \frac{N}{\nu}.
\label{eq:S07_Tbuild_rate}\]</span>
<a data-reference="eq:S07_Tbuild_rate" data-reference-type="eqref" href="#eq:S07_Tbuild_rate">[eq:S07_Tbuild_rate]</a>의 사용은 레짐에 의존한다. <span class="math inline">\(\nu\)</span>가 정의 불능이거나 Gate에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>이면 <a data-reference="eq:S07_Tbuild_rate" data-reference-type="eqref" href="#eq:S07_Tbuild_rate">[eq:S07_Tbuild_rate]</a>는 사용할 수 없으며, <a data-reference="eq:S07_Tbuild_tick" data-reference-type="eqref" href="#eq:S07_Tbuild_tick">[eq:S07_Tbuild_tick]</a>만 허용된다.</p>
<h3 data-number="9.1.3" id="섹터-분해-기반-보조-빌드-타임"><span class="header-section-number">9.1.3</span> 7.5.3 3-섹터 분해 기반 보조 빌드 타임</h3>
<p>정수화 결과 <span class="math inline">\((k_1,k_2,k_3)\)</span>가 잠겨 있을 때, 섹터별 빌드 타임을 다음으로 정의한다.
<span class="math display">\[T_i := k_i\,\Delta t
\qquad (i=1,2,3),
\label{eq:S07_Ti_def}\]</span>
따라서
<span class="math display">\[T_1+T_2+T_3 = (k_1+k_2+k_3)\Delta t = N\Delta t = T_{\mathrm{build}}.
\label{eq:S07_Tsum}\]</span>
<span class="math inline">\(T_i\)</span>는 “섹터별 누적 시간”이며, 이후 장에서 섹터 비대칭의 시간적 표현(예: 특정 섹터의 우세가 전하/전자 라벨에 미치는 방식)으로 사용될 수 있다. 이때도 <span class="math inline">\(T_i\)</span>의 정의는 <a data-reference="eq:S07_Ti_def" data-reference-type="eqref" href="#eq:S07_Ti_def">[eq:S07_Ti_def]</a>로 고정되며, 결과를 본 뒤 다른 방식으로 재정의될 수 없다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-31">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 3-섹터 축 <span class="math inline">\(\{\mathbf{n}_1,\mathbf{n}_2,\mathbf{n}_3\}\)</span>의 120 규약(<a data-reference="eq:S07_120deg_inner" data-reference-type="eqref" href="#eq:S07_120deg_inner">[eq:S07_120deg_inner]</a>, <a data-reference="eq:S07_n_sum_zero" data-reference-type="eqref" href="#eq:S07_n_sum_zero">[eq:S07_n_sum_zero]</a>)과 축/순서/타이브레이크 규칙을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 정수화 규칙(<a data-reference="eq:S07_shift_si" data-reference-type="eqref" href="#eq:S07_shift_si">[eq:S07_shift_si]</a>–<a data-reference="eq:S07_final_ki" data-reference-type="eqref" href="#eq:S07_final_ki">[eq:S07_final_ki]</a>)과 합 보존 <span class="math inline">\(k_1+k_2+k_3=N\)</span>을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 잔차 벡터 <span class="math inline">\(\mathbf{V}\)</span> 정의(<a data-reference="eq:S07_V_def" data-reference-type="eqref" href="#eq:S07_V_def">[eq:S07_V_def]</a>) 및 라벨 연결 선언(<a data-reference="eq:S07_charge_label_decl" data-reference-type="eqref" href="#eq:S07_charge_label_decl">[eq:S07_charge_label_decl]</a>)의 입력 축 <span class="math inline">\(\mathbf{n}_Q\)</span>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 합 보존/비음수성/타이브레이크 미잠금은 G-STR/G-LOCK에서 <code>FAIL</code> 또는 <code>INCONCLUSIVE</code>; 사후 선택은 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 비퇴화 조건(<a data-reference="eq:S07_Vmin" data-reference-type="eqref" href="#eq:S07_Vmin">[eq:S07_Vmin]</a>)의 문턱 <span class="math inline">\(V_{\min}\)</span> 및 라벨 처리 규칙은 <code>gate_lock</code>과 PASS.rules에 사전 등록되어야 함.</p></li>
</ul>
<h2 data-number="9.2" id="최소분산-정수화n3mr-89-82"><span class="header-section-number">9.2</span> 7.1 최소분산 정수화(<span class="math inline">\(N=3m+r\)</span>): 89, 82</h2>
<h3 data-number="9.2.1" id="정수화-문제의-정의"><span class="header-section-number">9.2.1</span> 7.1.1 정수화 문제의 정의</h3>
<p>3-섹터 정수화의 목표는 총 정수 자원 <span class="math inline">\(N\in\mathbb{Z}_{\ge 0}\)</span>을 세 섹터 정수 카운트
<span class="math display">\[(k_1,k_2,k_3)\in\mathbb{Z}_{\ge 0}^3
\label{eq:S07_01_k_domain}\]</span>
로 배분하되,
<span class="math display">\[k_1+k_2+k_3=N
\label{eq:S07_01_sumN}\]</span>
을 만족시키면서 “편향(비대칭)”을 최소화하는 것이다.</p>
<p>본 절은 편향을 “분산”으로 정의하고, 분산이 최소가 되는 정수화 규칙을 <strong>최소분산 정수화</strong>로 고정한다.
평균을
<span class="math display">\[\mu := \frac{N}{3}
\label{eq:S07_01_mu}\]</span>
로 두고, 분산(3-섹터 분산)을 다음으로 정의한다.
<span class="math display">\[\mathrm{Var}(k_1,k_2,k_3)
:=
\frac{1}{3}\sum_{i=1}^{3}(k_i-\mu)^2.
\label{eq:S07_01_variance}\]</span>
동일 합 조건 <a data-reference="eq:S07_01_sumN" data-reference-type="eqref" href="#eq:S07_01_sumN">[eq:S07_01_sumN]</a> 하에서 <a data-reference="eq:S07_01_variance" data-reference-type="eqref" href="#eq:S07_01_variance">[eq:S07_01_variance]</a>의 최소화는 다음 2차 모멘트의 최소화와 동치이다.
<span class="math display">\[S_2(k_1,k_2,k_3):=\sum_{i=1}^{3}k_i^2.
\label{eq:S07_01_S2}\]</span>
실제로 <a data-reference="eq:S07_01_sumN" data-reference-type="eqref" href="#eq:S07_01_sumN">[eq:S07_01_sumN]</a>을 사용하면
<span class="math display">\[\begin{aligned}
\mathrm{Var}
&amp;=\frac{1}{3}\sum_{i=1}^{3}(k_i^2-2\mu k_i+\mu^2)
=\frac{1}{3}\sum_{i=1}^{3}k_i^2-\frac{2\mu}{3}\sum_{i=1}^{3}k_i+\mu^2 \notag\\
&amp;=\frac{1}{3}S_2-\frac{2\mu}{3}N+\mu^2
=\frac{1}{3}S_2-\frac{2}{3}\left(\frac{N}{3}\right)N+\left(\frac{N}{3}\right)^2
=\frac{1}{3}S_2-\frac{N^2}{9}.
\label{eq:S07_01_var_S2_relation}\end{aligned}\]</span>
따라서 <span class="math inline">\(N\)</span>이 고정되면 <span class="math inline">\(\mathrm{Var}\)</span>의 최소화는 <span class="math inline">\(S_2\)</span>의 최소화와 완전히 동치이다.</p>
<h3 data-number="9.2.2" id="최소분산-정수화-정리균등화-원리"><span class="header-section-number">9.2.2</span> 7.1.2 최소분산 정수화 정리(균등화 원리)</h3>
<h4 data-number="9.2.2.1" id="균등화-보조정리"><span class="header-section-number">9.2.2.1</span> 7.1.2.1 균등화 보조정리</h4>
<p>정수 삼중항 <span class="math inline">\((k_1,k_2,k_3)\)</span>가 <a data-reference="eq:S07_01_sumN" data-reference-type="eqref" href="#eq:S07_01_sumN">[eq:S07_01_sumN]</a>을 만족한다고 하자. 만약 어떤 쌍 <span class="math inline">\((k_a,k_b)\)</span>가
<span class="math display">\[k_a \ge k_b + 2
\label{eq:S07_01_gap_ge2}\]</span>
를 만족하면, 다음 “균등화 이동”을 정의한다.
<span class="math display">\[k_a' := k_a-1,\qquad k_b' := k_b+1,
\qquad k_c' := k_c\ (c\neq a,b).
\label{eq:S07_01_balance_move}\]</span>
그러면 합은 보존된다.
<span class="math display">\[k_1'+k_2'+k_3' = (k_1+k_2+k_3) = N.
\label{eq:S07_01_sum_preserve}\]</span>
또한 2차 모멘트는 엄밀히 감소한다.
<span class="math display">\[\begin{aligned}
S_2(k_1,k_2,k_3)-S_2(k_1',k_2',k_3')
&amp;= (k_a^2+k_b^2)-\bigl((k_a-1)^2+(k_b+1)^2\bigr)\notag\\
&amp;= k_a^2+k_b^2-\bigl(k_a^2-2k_a+1+k_b^2+2k_b+1\bigr)\notag\\
&amp;= 2(k_a-k_b)-2.
\label{eq:S07_01_S2_decrease}\end{aligned}\]</span>
가정 <a data-reference="eq:S07_01_gap_ge2" data-reference-type="eqref" href="#eq:S07_01_gap_ge2">[eq:S07_01_gap_ge2]</a>에 의해 <span class="math inline">\(k_a-k_b\ge 2\)</span>이므로,
<span class="math display">\[2(k_a-k_b)-2 \ge 2 &gt; 0,
\label{eq:S07_01_S2_strict}\]</span>
따라서 <span class="math inline">\(S_2\)</span>는 반드시 감소한다. 즉, 어떤 해에든 <a data-reference="eq:S07_01_gap_ge2" data-reference-type="eqref" href="#eq:S07_01_gap_ge2">[eq:S07_01_gap_ge2]</a> 형태의 큰 격차가 존재하면, 그 해는 최소분산 해가 될 수 없다.</p>
<h4 data-number="9.2.2.2" id="최소분산-해의-필요충분-조건"><span class="header-section-number">9.2.2.2</span> 7.1.2.2 최소분산 해의 필요충분 조건</h4>
<p>위 보조정리에 의해, <span class="math inline">\(S_2\)</span>를 최소로 만드는 해는 모든 쌍에 대해 격차가 1을 넘지 않아야 한다.
<span class="math display">\[|k_i-k_j|\le 1\qquad (i,j\in\{1,2,3\}).
\label{eq:S07_01_gap_le1}\]</span>
반대로, <a data-reference="eq:S07_01_gap_le1" data-reference-type="eqref" href="#eq:S07_01_gap_le1">[eq:S07_01_gap_le1]</a>을 만족하는 해는 더 이상 <a data-reference="eq:S07_01_balance_move" data-reference-type="eqref" href="#eq:S07_01_balance_move">[eq:S07_01_balance_move]</a>로 <span class="math inline">\(S_2\)</span>를 감소시킬 수 없으므로, 이 조건은 최소분산 해의 필요조건이자 충분조건이다(정수 집합에서의 국소 최소는 전역 최소가 된다).</p>
<h3 data-number="9.2.3" id="n3mr-분해와-최소분산-해의-닫힌형"><span class="header-section-number">9.2.3</span> 7.1.3 <span class="math inline">\(N=3m+r\)</span> 분해와 최소분산 해의 닫힌형</h3>
<h4 data-number="9.2.3.1" id="몫과-나머지의-정의"><span class="header-section-number">9.2.3.1</span> 7.1.3.1 몫과 나머지의 정의</h4>
<p><span class="math inline">\(N\)</span>을 3으로 나눈 몫과 나머지를 다음으로 정의한다.
<span class="math display">\[N = 3m + r,
\qquad
m:=\left\lfloor\frac{N}{3}\right\rfloor,
\qquad
r:=N-3m\in\{0,1,2\}.
\label{eq:S07_01_division}\]</span></p>
<h4 data-number="9.2.3.2" id="최소분산-해의-형태순열까지-유일"><span class="header-section-number">9.2.3.2</span> 7.1.3.2 최소분산 해의 형태(순열까지 유일)</h4>
<p>조건 <a data-reference="eq:S07_01_gap_le1" data-reference-type="eqref" href="#eq:S07_01_gap_le1">[eq:S07_01_gap_le1]</a>과 합 조건 <a data-reference="eq:S07_01_sumN" data-reference-type="eqref" href="#eq:S07_01_sumN">[eq:S07_01_sumN]</a>을 동시에 만족하는 정수 삼중항은 다음 형태로만 존재한다(순열까지 유일).</p>
<ol>
<li><p><span class="math inline">\(r=0\)</span>:
<span class="math display">\[(k_1,k_2,k_3)=(m,m,m).
  \label{eq:S07_01_case_r0}\]</span></p></li>
<li><p><span class="math inline">\(r=1\)</span>:
<span class="math display">\[(k_1,k_2,k_3)\ \text{는}\ (m,m,m+1)\ \text{의 순열}.
  \label{eq:S07_01_case_r1}\]</span></p></li>
<li><p><span class="math inline">\(r=2\)</span>:
<span class="math display">\[(k_1,k_2,k_3)\ \text{는}\ (m,m+1,m+1)\ \text{의 순열}.
  \label{eq:S07_01_case_r2}\]</span></p></li>
</ol>
<p>위 세 경우는 <a data-reference="eq:S07_01_gap_le1" data-reference-type="eqref" href="#eq:S07_01_gap_le1">[eq:S07_01_gap_le1]</a>을 만족하는 모든 해를 완전히 분류한다.</p>
<h4 data-number="9.2.3.3" id="최소-2차-모멘트의-닫힌형"><span class="header-section-number">9.2.3.3</span> 7.1.3.3 최소 2차 모멘트의 닫힌형</h4>
<p>최소분산 해에서의 2차 모멘트 최소값은 다음으로 고정된다.
<span class="math display">\[S_{2,\min}(N)=3m^2+2mr+r,
\qquad (N=3m+r,\ r\in\{0,1,2\}).
\label{eq:S07_01_S2min}\]</span>
실제로 <span class="math inline">\(r=0\)</span>이면 <span class="math inline">\(S_2=3m^2\)</span>, <span class="math inline">\(r=1\)</span>이면 <span class="math inline">\(S_2=2m^2+(m+1)^2=3m^2+2m+1\)</span>, <span class="math inline">\(r=2\)</span>이면 <span class="math inline">\(S_2=m^2+2(m+1)^2=3m^2+4m+2\)</span>로 일치한다.</p>
<h3 data-number="9.2.4" id="섹터-우선순위타이브레이크-규칙"><span class="header-section-number">9.2.4</span> 7.1.4 섹터 우선순위(타이브레이크) 규칙</h3>
<p><span class="math inline">\(r\neq 0\)</span>인 경우, 어떤 섹터가 <span class="math inline">\(m+1\)</span>을 받는지(즉, 어떤 순열을 채택하는지)가 남는다. 이 선택은 결과를 보고 바뀔 수 없으므로, 다음 “우선순위 순열”을 사전 등록하여 잠근다.
<span class="math display">\[\pi_{\mathrm{sec}}=(i_1,i_2,i_3)
\quad\text{는}\ \{1,2,3\}\ \text{의 순열이며,}\ \texttt{analysis\_lock}\ \text{에 잠김}.
\label{eq:S07_01_priority_perm}\]</span>
<span class="math inline">\(\pi_{\mathrm{sec}}\)</span>가 주어졌을 때, 최소분산 정수화 결과를 다음으로 정의한다.
<span class="math display">\[k_{i_j}:=
\begin{cases}
m+1,&amp; 1\le j\le r,\\
m,&amp; r&lt;j\le 3.
\end{cases}
\label{eq:S07_01_priority_assign}\]</span>
즉, 우선순위 순열의 앞에서부터 <span class="math inline">\(r\)</span>개 섹터가 <span class="math inline">\(m+1\)</span>을 받고, 나머지는 <span class="math inline">\(m\)</span>을 받는다. <span class="math inline">\(\pi_{\mathrm{sec}}\)</span>가 잠기지 않으면 <span class="math inline">\(r\neq 0\)</span>에서 결과가 비유일이므로 <code>INCONCLUSIVE</code>이다.</p>
<h3 data-number="9.2.5" id="예시-n89와-n82"><span class="header-section-number">9.2.5</span> 7.1.5 예시: <span class="math inline">\(N=89\)</span>와 <span class="math inline">\(N=82\)</span></h3>
<h4 data-number="9.2.5.1" id="n89"><span class="header-section-number">9.2.5.1</span> 7.1.5.1 <span class="math inline">\(N=89\)</span></h4>
<p><a data-reference="eq:S07_01_division" data-reference-type="eqref" href="#eq:S07_01_division">[eq:S07_01_division]</a>에 의해
<span class="math display">\[89=3\cdot 29 + 2,
\qquad
m=29,\quad r=2.
\label{eq:S07_01_89_div}\]</span>
따라서 최소분산 해는 <a data-reference="eq:S07_01_case_r2" data-reference-type="eqref" href="#eq:S07_01_case_r2">[eq:S07_01_case_r2]</a>에 의해
<span class="math display">\[(k_1,k_2,k_3)\ \text{는}\ (29,30,30)\ \text{의 순열}.
\label{eq:S07_01_89_triplet}\]</span>
우선순위 순열이 예컨대 <span class="math inline">\(\pi_{\mathrm{sec}}=(1,2,3)\)</span>로 잠겼다면 <a data-reference="eq:S07_01_priority_assign" data-reference-type="eqref" href="#eq:S07_01_priority_assign">[eq:S07_01_priority_assign]</a>에 의해
<span class="math display">\[(k_1,k_2,k_3)=(30,30,29)
\label{eq:S07_01_89_example_order}\]</span>
로 고정된다.</p>
<h4 data-number="9.2.5.2" id="n82"><span class="header-section-number">9.2.5.2</span> 7.1.5.2 <span class="math inline">\(N=82\)</span></h4>
<p><a data-reference="eq:S07_01_division" data-reference-type="eqref" href="#eq:S07_01_division">[eq:S07_01_division]</a>에 의해
<span class="math display">\[82=3\cdot 27 + 1,
\qquad
m=27,\quad r=1.
\label{eq:S07_01_82_div}\]</span>
따라서 최소분산 해는 <a data-reference="eq:S07_01_case_r1" data-reference-type="eqref" href="#eq:S07_01_case_r1">[eq:S07_01_case_r1]</a>에 의해
<span class="math display">\[(k_1,k_2,k_3)\ \text{는}\ (27,27,28)\ \text{의 순열}.
\label{eq:S07_01_82_triplet}\]</span>
우선순위 순열이 예컨대 <span class="math inline">\(\pi_{\mathrm{sec}}=(1,2,3)\)</span>로 잠겼다면
<span class="math display">\[(k_1,k_2,k_3)=(28,27,27)
\label{eq:S07_01_82_example_order}\]</span>
로 고정된다.</p>
<h3 data-number="9.2.6" id="내부-정당화최소-편향-원리와-이후-라벨로의-연결"><span class="header-section-number">9.2.6</span> 7.1.6 내부 정당화(최소 편향 원리)와 이후 라벨로의 연결</h3>
<h4 data-number="9.2.6.1" id="최소-편향-원리내부-규칙"><span class="header-section-number">9.2.6.1</span> 7.1.6.1 최소 편향 원리(내부 규칙)</h4>
<p>3-섹터는 120 대칭 구조로 잠겨 있으며(7장 개요 및 7.0에서 고정), 세 섹터는 <strong>동등한 지위</strong>를 갖는다. 따라서 정수화는 다음 내부 규칙을 만족해야 한다.</p>
<ol>
<li><p><strong>대칭 보존</strong>: 입력이 섹터를 구별하지 않는 경우, 출력도 가능한 한 섹터를 구별하지 않는다.</p></li>
<li><p><strong>편향 최소화</strong>: 출력의 섹터 불균형(분산 또는 격차)을 최소화한다.</p></li>
<li><p><strong>필연적 잔차만 허용</strong>: <span class="math inline">\(N\ (\mathrm{mod}\ 3)\)</span>로 인해 피할 수 없는 불균형만 남기고, 그 이상의 불균형은 허용하지 않는다.</p></li>
</ol>
<p><a data-reference="eq:S07_01_gap_le1" data-reference-type="eqref" href="#eq:S07_01_gap_le1">[eq:S07_01_gap_le1]</a>을 만족하는 분배는 위 세 규칙을 동시에 만족하는 유일한 형태이며, 특히 최대 격차
<span class="math display">\[\Delta_{\max}:=\max_i k_i-\min_i k_i
\label{eq:S07_01_DeltaMax}\]</span>
에 대해
<span class="math display">\[\Delta_{\max}=
\begin{cases}
0,&amp; r=0,\\
1,&amp; r=1,2,
\end{cases}
\label{eq:S07_01_DeltaMax_min}\]</span>
로 최소가 된다. <a data-reference="eq:S07_01_gap_ge2" data-reference-type="eqref" href="#eq:S07_01_gap_ge2">[eq:S07_01_gap_ge2]</a> 형태의 해는 <span class="math inline">\(\Delta_{\max}\ge 2\)</span>이므로 내부 규칙을 위반한다.</p>
<h4 data-number="9.2.6.2" id="잔차-벡터의-최소-크기전하전자-라벨의-최소-잔차-기반"><span class="header-section-number">9.2.6.2</span> 7.1.6.2 잔차 벡터의 최소 크기(전하/전자 라벨의 최소 잔차 기반)</h4>
<p>7장의 3-섹터 축이
<span class="math display">\[\mathbf{n}_1+\mathbf{n}_2+\mathbf{n}_3=\mathbf{0}
\label{eq:S07_01_nsum0}\]</span>
로 잠겨 있을 때, 정수화 결과로부터 잔차 벡터를
<span class="math display">\[\mathbf{V}:=k_1\mathbf{n}_1+k_2\mathbf{n}_2+k_3\mathbf{n}_3
\label{eq:S07_01_V}\]</span>
로 정의하면,</p>
<ol>
<li><p><span class="math inline">\(r=0\)</span> (완전 균등)에서는 <span class="math inline">\((k_1,k_2,k_3)=(m,m,m)\)</span>이므로 <span class="math inline">\(\mathbf{V}=m(\mathbf{n}_1+\mathbf{n}_2+\mathbf{n}_3)=\mathbf{0}\)</span>.</p></li>
<li><p><span class="math inline">\(r=1\)</span>에서는 <span class="math inline">\((m,m,m+1)\)</span> 형태이므로 <span class="math inline">\(\mathbf{V}\)</span>는 “추가 1”이 배정된 축 방향(예: <span class="math inline">\(\mathbf{n}_{i_1}\)</span>)으로 남는다.</p></li>
<li><p><span class="math inline">\(r=2\)</span>에서는 <span class="math inline">\((m,m+1,m+1)\)</span> 형태이므로 <span class="math inline">\(\mathbf{V}\)</span>는 “빠진 1”의 축 방향의 반대(예: <span class="math inline">\(-(\mathbf{n}_{i_3})\)</span>)로 남는다.</p></li>
</ol>
<p>즉, 최소분산 정수화는 <span class="math inline">\(N\ (\mathrm{mod}\ 3)\)</span>로 인해 필연적으로 발생하는 <strong>최소 크기의 잔차 방향성</strong>만을 남기며, 이 잔차 방향성이 이후 장에서 전하 부호 및 전자(생존) 라벨의 입력으로 사용된다. 추가적인 큰 잔차(격차 <span class="math inline">\(\ge 2\)</span>)는 내부 규칙 위반으로 금지된다.</p>
<h3 data-number="9.2.7" id="부피-정수화반경-정수배-r_pn_rr_u"><span class="header-section-number">9.2.7</span> 7.1.7 부피 정수화(반경 정수배): <span class="math inline">\(R_p=n_r\,r_u\)</span></h3>
<p>본 절은 3-섹터 정수화와 <em>별개의</em> “부피(반경) 정수화” 규칙을 <strong>보조 닫힘</strong>으로 추가한다. 목적은 코어(82)의 총 카운트가 단지 “섹터 분해의 산물”이 아니라, <strong>반경 스케일의 정수배 선택</strong>과도 양립하도록 하는 것이다.</p>
<h4 data-number="9.2.7.1" id="d-7.1-7.1-서브-양자-유닛sq-unit-반경-r_u"><span class="header-section-number">9.2.7.1</span> [D-7.1-7.1] 서브-양자 유닛(SQ unit) 반경 <span class="math inline">\(r_u\)</span></h4>
<p>82+7 구조에서의 “유닛”(코어 82, 셸 7)은 VP 자체가 아니라, 다수의 VP를 포함하는 <em>상위 블록</em>(Sub-quantum unit, SQ)으로 해석된다(객체 귀속은 <code>canon_lock</code>에 잠김). 이 SQ 유닛의 유효 반경을 <span class="math inline">\(r_u\)</span>로 표기한다.</p>
<h4 data-number="9.2.7.2" id="d-7.1-7.2-반경-정수배-규칙"><span class="header-section-number">9.2.7.2</span> [D-7.1-7.2] 반경 정수배 규칙</h4>
<p>코어 반경 <span class="math inline">\(R_p\)</span>와 SQ 유닛 반경 <span class="math inline">\(r_u\)</span> 사이에 다음 정수배 관계를 <strong>정수화 규칙</strong>으로 선언한다.
<span class="math display">\[R_p = n_r\, r_u,
\qquad n_r\in\mathbb{Z}_{&gt;0}.
\label{eq:S07_01_radial_integerization}\]</span>
여기서 <span class="math inline">\(n_r\)</span>는 “반경 정수화 지수”이며, 값은 결과를 본 뒤 선택될 수 없다(사후 선택은 G-NT에서 <code>FAIL</code>).</p>
<h4 data-number="9.2.7.3" id="d-7.1-7.3-이상-슬롯-수부피비-n_r3"><span class="header-section-number">9.2.7.3</span> [D-7.1-7.3] 이상 슬롯 수(부피비) <span class="math inline">\(n_r^3\)</span></h4>
<p><a data-reference="eq:S07_01_radial_integerization" data-reference-type="eqref" href="#eq:S07_01_radial_integerization">[eq:S07_01_radial_integerization]</a>을 채택하면, 동일 스케일의 구형 유닛이 코어 구 내부에서 가질 수 있는 <em>수학적 최대 슬롯</em>은 부피비로
<span class="math display">\[\frac{V_{\mathrm{core}}}{v_u}=\left(\frac{R_p}{r_u}\right)^3 = n_r^3
\label{eq:S07_01_slot_count}\]</span>
로 주어진다(여기서 <span class="math inline">\(V_{\mathrm{core}}\propto R_p^3\)</span>, <span class="math inline">\(v_u\propto r_u^3\)</span>). 이 값은 “충만”을 가정한 <em>수학적 상한</em>이며, 실제 배치는 회전/배척/결손(Void) 때문에 더 작을 수 있다.</p>
<h3 data-number="9.2.8" id="패킹-정류-계수-phi_mathrmpack와-125rightarrow-82-폐회로"><span class="header-section-number">9.2.8</span> 7.1.8 패킹-정류 계수 <span class="math inline">\(\phi_{\mathrm{pack}}\)</span>와 <span class="math inline">\(125\rightarrow 82\)</span> 폐회로</h3>
<p>본 절은 “수학적 슬롯 수” <span class="math inline">\(n_r^3\)</span>가 <em>그대로 실현되지 않는다</em>는 사실을 <strong>운영계수</strong>로 기록한다. 이를 위해 “패킹-정류 계수” <span class="math inline">\(\phi_{\mathrm{pack}}\in(0,1]\)</span>를 다음처럼 정의한다.
<span class="math display">\[N_{\mathrm{core}}\ :=\ \phi_{\mathrm{pack}}\,n_r^3,
\qquad
\phi_{\mathrm{pack}}:=\frac{N_{\mathrm{core}}}{n_r^3}.
\label{eq:S07_01_pack_rect_def}\]</span>
여기서 <span class="math inline">\(N_{\mathrm{core}}\)</span>는 코어 유닛 카운트(본 문서에서는 <span class="math inline">\(82\)</span>로 잠김)이며, <span class="math inline">\(\phi_{\mathrm{pack}}\)</span>는 <em>사후 조정용 자유도</em>가 아니라, <span class="math inline">\(N_{\mathrm{core}}\)</span>와 <span class="math inline">\(n_r\)</span>가 잠겼을 때 <strong>자동으로 산출되는 파생량</strong>이다.</p>
<h4 data-number="9.2.8.1" id="n_r5의-선택과-125rightarrow-82"><span class="header-section-number">9.2.8.1</span> 7.1.8.1 <span class="math inline">\(n_r=5\)</span>의 선택과 <span class="math inline">\(125\rightarrow 82\)</span></h4>
<p>본 문서의 코어(82) 레짐에서 반경 정수화 지수는 다음처럼 <code>LOCK</code>으로 고정된다.
<span class="math display">\[n_r \equiv 5.
\label{eq:S07_01_nr_lock5}\]</span>
이 선택은 결과(<span class="math inline">\(82\)</span>)를 보고 조정될 수 없으며, 변경은 버전업으로만 허용된다. 이제 <a data-reference="eq:S07_01_slot_count" data-reference-type="eqref" href="#eq:S07_01_slot_count">[eq:S07_01_slot_count]</a>에 <a data-reference="eq:S07_01_nr_lock5" data-reference-type="eqref" href="#eq:S07_01_nr_lock5">[eq:S07_01_nr_lock5]</a>를 대입하면 이상 슬롯 수는
<span class="math display">\[n_r^3 = 5^3 = 125.
\label{eq:S07_01_125_slots}\]</span>
코어 카운트가 <span class="math inline">\(N_{\mathrm{core}}=82\)</span>로 잠겨 있을 때 <a data-reference="eq:S07_01_pack_rect_def" data-reference-type="eqref" href="#eq:S07_01_pack_rect_def">[eq:S07_01_pack_rect_def]</a>는 즉시
<span class="math display">\[\phi_{\mathrm{pack}}=\frac{82}{125}\approx 0.66
\label{eq:S07_01_phi_pack_value}\]</span>
를 준다. 즉, “125의 수학적 슬롯” 중 약 34%는 <em>결손(Void)</em>으로 남는다. 본 문서의 언재밍/유입(Flux) 서술에서는 이 결손을 <em>채널 및 탄성 여지</em>로 해석할 수 있으나, 해석의 자격은 별도의 Gate(레짐/로그/재현성)를 통과해야 한다.</p>
<h4 data-number="9.2.8.2" id="강한-주장82의-필연성의-자격"><span class="header-section-number">9.2.8.2</span> 7.1.8.2 강한 주장(82의 필연성)의 자격</h4>
<p>“<span class="math inline">\(82\)</span>가 반경 정수화만으로 <em>필연</em>”이라고 주장하려면, <span class="math inline">\(\phi_{\mathrm{pack}}\)</span>을 외부에서 독립적으로 측정(또는 시뮬레이션으로 봉인)하여 <span class="math inline">\(n_r^3\phi_{\mathrm{pack}}\)</span>이 정수 <span class="math inline">\(82\)</span>로 수렴함을 보여야 한다. 반대로, 본 문서처럼 <span class="math inline">\(82\)</span>를 구조 정수(3-섹터 최소분산 및 82+7 구조)로 잠그는 경우, <a data-reference="eq:S07_01_phi_pack_value" data-reference-type="eqref" href="#eq:S07_01_phi_pack_value">[eq:S07_01_phi_pack_value]</a>는 <strong>예측이라기보다 역산된 일관성 지표</strong>로 취급된다.</p>
<h4 data-number="9.2.8.3" id="gate해석-가능성-판정"><span class="header-section-number">9.2.8.3</span> 7.1.8.3 Gate(해석 가능성 판정)</h4>
<p><span class="math inline">\(\phi_{\mathrm{pack}}\)</span>의 <em>물리적 해석</em>(예: “재밍 패킹 효율”로의 해석)은 다음 조건을 동시에 만족할 때에만 허용된다.</p>
<ol>
<li><p><span class="math inline">\(n_r\)</span>가 <code>analysis_lock</code>/<code>canon_lock</code>에 사전 등록되어 있고, 결과를 본 뒤 바뀌지 않는다.</p></li>
<li><p><span class="math inline">\(N_{\mathrm{core}}\)</span>의 객체 귀속(무엇을 1 유닛으로 세는가)과 포함/배제 규약이 <code>canon_lock</code>에 잠겨 있다.</p></li>
<li><p><span class="math inline">\(\phi_{\mathrm{pack}}\)</span>을 다른 계수(<span class="math inline">\(\delta,\alpha,\phi_{\mathrm{jam}}\)</span> 등)로 <em>흡수하거나 재정의</em>하지 않는다(기호 오버로딩은 G-SYM에서 <code>FAIL</code>).</p></li>
</ol>
<p>위 조건이 하나라도 깨지면, <span class="math inline">\(\phi_{\mathrm{pack}}\)</span>은 수치로 보고될 수는 있으나(CT-LIM), 그 해석을 결론 근거로 사용하는 것은 금지된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-32">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 최소분산 목표(분산 <a data-reference="eq:S07_01_variance" data-reference-type="eqref" href="#eq:S07_01_variance">[eq:S07_01_variance]</a> 또는 <span class="math inline">\(S_2\)</span> <a data-reference="eq:S07_01_S2" data-reference-type="eqref" href="#eq:S07_01_S2">[eq:S07_01_S2]</a> 최소)와 해의 형태 <a data-reference="eq:S07_01_case_r0" data-reference-type="eqref" href="#eq:S07_01_case_r0">[eq:S07_01_case_r0]</a>–<a data-reference="eq:S07_01_case_r2" data-reference-type="eqref" href="#eq:S07_01_case_r2">[eq:S07_01_case_r2]</a>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 타이브레이크 우선순위 순열 <span class="math inline">\(\pi_{\mathrm{sec}}\)</span> 및 배정 규칙 <a data-reference="eq:S07_01_priority_assign" data-reference-type="eqref" href="#eq:S07_01_priority_assign">[eq:S07_01_priority_assign]</a>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: (보조 닫힘 사용 시) 반경 정수화 규칙 <a data-reference="eq:S07_01_radial_integerization" data-reference-type="eqref" href="#eq:S07_01_radial_integerization">[eq:S07_01_radial_integerization]</a>의 적용 대상(코어 반경 <span class="math inline">\(R_p\)</span>, 유닛 반경 <span class="math inline">\(r_u\)</span>)과 정수 지수 <span class="math inline">\(n_r\)</span>의 값을 <code>canon_lock</code>/<code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: (보조 닫힘 사용 시) 패킹-정류 계수 정의 <a data-reference="eq:S07_01_pack_rect_def" data-reference-type="eqref" href="#eq:S07_01_pack_rect_def">[eq:S07_01_pack_rect_def]</a> 및 슬롯 수 식 <a data-reference="eq:S07_01_slot_count" data-reference-type="eqref" href="#eq:S07_01_slot_count">[eq:S07_01_slot_count]</a>의 사용 규약을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 합 보존 <a data-reference="eq:S07_01_sumN" data-reference-type="eqref" href="#eq:S07_01_sumN">[eq:S07_01_sumN]</a>, 비음수성 <a data-reference="eq:S07_01_k_domain" data-reference-type="eqref" href="#eq:S07_01_k_domain">[eq:S07_01_k_domain]</a>, 격차 조건 <a data-reference="eq:S07_01_gap_le1" data-reference-type="eqref" href="#eq:S07_01_gap_le1">[eq:S07_01_gap_le1]</a> 위반은 G-STR에서 <code>FAIL</code>.</p></li>
<li><p>Gate: <span class="math inline">\(\pi_{\mathrm{sec}}\)</span> 미잠금 또는 순열 혼합은 G-LOCK에서 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
<li><p>Gate: 결과를 본 뒤 섹터 배정(순열)을 바꾸는 행위는 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: <span class="math inline">\(n_r\)</span>의 사후 선택, <span class="math inline">\(N_{\mathrm{core}}\)</span>의 카운트 귀속 변경, 또는 <span class="math inline">\(\phi_{\mathrm{pack}}\)</span>의 흡수/재정의(기호 오버로딩)는 G-NT/G-LOCK/G-SYM에서 <code>FAIL</code>.</p></li>
</ul>
<h2 data-number="9.3" id="빌드시간-t_pt_n-정의"><span class="header-section-number">9.3</span> 7.2 빌드시간 <span class="math inline">\(T_p,T_n\)</span> 정의</h2>
<h3 data-number="9.3.1" id="정준-사건율-nu_pmathrmcan의-정의시간-카운트-연결"><span class="header-section-number">9.3.1</span> 7.2.1 정준 사건율 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>의 정의(시간-카운트 연결)</h3>
<p>시간 변수 <span class="math inline">\(t\)</span>를 실현 시간(단위: s)으로 둔다. 사건(event)은 <code>canon_lock</code>에 잠긴 운영 정의에 따라 카운트되며, 사건 카운트는 무차원 정수로 기록된다. 시간 구간 <span class="math inline">\([t_1,t_2)\)</span>에서의 원시 사건 집합과 원시 사건 카운트를 다음으로 정의한다.
<span class="math display">\[\mathcal{E}_0[t_1,t_2)
:=\{\,e\mid t_1\le t(e)&lt;t_2\,\},
\qquad
N_0(t_1,t_2):=\bigl|\mathcal{E}_0[t_1,t_2)\bigr|.
\label{eq:S07_02_eventset}\]</span>
정준 사건율(정준 turnover 사건율) <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>는 다음 극한으로 정의한다.
<span class="math display">\[\nu_{p,\mathrm{can}}
:=
\lim_{T\to\infty}\frac{N_0(t,t+T)}{T}.
\label{eq:S07_02_nu_can_def}\]</span>
정의 <a data-reference="eq:S07_02_nu_can_def" data-reference-type="eqref" href="#eq:S07_02_nu_can_def">[eq:S07_02_nu_can_def]</a>는 “단위 시간당 사건 수”의 정의이며, <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>의 단위는 <span class="math inline">\([\mathrm{s}^{-1}]\)</span>로 잠긴다. 동일 레짐에서 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>가 상수로 취급될 때, 평균적으로 다음 관계가 성립하도록 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>를 사용한다.
<span class="math display">\[N_0(t_1,t_2)\equiv \nu_{p,\mathrm{can}}\,(t_2-t_1).
\label{eq:S07_02_N_equals_nuT}\]</span>
식 <a data-reference="eq:S07_02_N_equals_nuT" data-reference-type="eqref" href="#eq:S07_02_N_equals_nuT">[eq:S07_02_N_equals_nuT]</a>는 정준 사건율의 사용 규약이며, 레짐이 잠기지 않거나 Gate에서 <code>INCONCLUSIVE</code>인 경우에는 사용될 수 없다.</p>
<h3 data-number="9.3.2" id="구조-카운트-n_pn_n의-정의827-및-82"><span class="header-section-number">9.3.2</span> 7.2.2 구조 카운트 <span class="math inline">\(N_p,N_n\)</span>의 정의(82+7 및 82)</h3>
<p>빌드시간은 “정해진 구조 카운트 <span class="math inline">\(N\)</span>을 누적하는 데 필요한 시간”으로 정의된다. 본 절은 두 개의 구조 카운트를 다음과 같이 잠근다.</p>
<ol>
<li><p><span class="math inline">\(p\)</span>-구조 총 카운트:
<span class="math display">\[N_p:=82+7=89.
  \label{eq:S07_02_Np_def}\]</span></p></li>
<li><p><span class="math inline">\(n\)</span>-구조 총 카운트:
<span class="math display">\[N_n:=82.
  \label{eq:S07_02_Nn_def}\]</span></p></li>
</ol>
<p>여기서 <span class="math inline">\(82\)</span>와 <span class="math inline">\(7\)</span>은 이산 구조(코어 82, 셸 7)의 정의로부터 주어지는 정수이며, 그 객체 귀속과 포함/배제 규약은 <code>canon_lock</code>에 잠겨야 한다. <span class="math inline">\(N_p,N_n\)</span>을 결과를 본 뒤 바꾸는 행위는 금지되며, 변경은 버전업으로만 허용된다.</p>
<h3 data-number="9.3.3" id="최소분산-3-섹터-정수화와-섹터-카운트-k_1k_2k_3"><span class="header-section-number">9.3.3</span> 7.2.3 최소분산 3-섹터 정수화와 섹터 카운트 <span class="math inline">\((k_1,k_2,k_3)\)</span></h3>
<p>3-섹터 정수화는 총 카운트 <span class="math inline">\(N\)</span>을 세 섹터 정수로 분해하되 편향(분산)을 최소화하는 규칙이다. <span class="math inline">\(N\)</span>을 다음과 같이 나눈다.
<span class="math display">\[N=3m+r,
\qquad
m:=\left\lfloor\frac{N}{3}\right\rfloor,
\qquad
r\in\{0,1,2\}.
\label{eq:S07_02_div}\]</span>
최소분산 조건은
<span class="math display">\[|k_i-k_j|\le 1\qquad (i,j\in\{1,2,3\}),
\qquad
k_1+k_2+k_3=N
\label{eq:S07_02_minvar}\]</span>
을 만족하는 정수 삼중항을 채택하는 것으로 고정한다. 이 조건을 만족하는 해는 순열까지 다음 형태로 완전 분류된다.
<span class="math display">\[(k_1,k_2,k_3)=
\begin{cases}
(m,m,m),&amp; r=0,\\
(m,m,m+1)\ \text{의 순열},&amp; r=1,\\
(m,m+1,m+1)\ \text{의 순열},&amp; r=2.
\end{cases}
\label{eq:S07_02_triplets}\]</span>
순열 선택(어느 섹터가 <span class="math inline">\(m+1\)</span>을 받는지)은 결과를 본 뒤 결정될 수 없으므로, 섹터 우선순위 순열 <span class="math inline">\(\pi_{\mathrm{sec}}\)</span>를 <code>analysis_lock</code>에 사전 등록하여 잠근다. <span class="math inline">\(\pi_{\mathrm{sec}}\)</span>에 의해 <span class="math inline">\(r\)</span>개 섹터에 <span class="math inline">\(m+1\)</span>을 부여하고 나머지에 <span class="math inline">\(m\)</span>을 부여한다.</p>
<h4 data-number="9.3.3.1" id="n_p89의-섹터-분해"><span class="header-section-number">9.3.3.1</span> <span class="math inline">\(N_p=89\)</span>의 섹터 분해</h4>
<p><a data-reference="eq:S07_02_Np_def" data-reference-type="eqref" href="#eq:S07_02_Np_def">[eq:S07_02_Np_def]</a>로부터
<span class="math display">\[89=3\cdot 29+2
\quad\Longrightarrow\quad
m_p=29,\ r_p=2.
\label{eq:S07_02_89}\]</span>
따라서 최소분산 섹터 카운트는
<span class="math display">\[(k_{p,1},k_{p,2},k_{p,3})
\ \text{는}\
(29,30,30)\ \text{의 순열}.
\label{eq:S07_02_kp}\]</span></p>
<h4 data-number="9.3.3.2" id="n_n82의-섹터-분해"><span class="header-section-number">9.3.3.2</span> <span class="math inline">\(N_n=82\)</span>의 섹터 분해</h4>
<p><a data-reference="eq:S07_02_Nn_def" data-reference-type="eqref" href="#eq:S07_02_Nn_def">[eq:S07_02_Nn_def]</a>로부터
<span class="math display">\[82=3\cdot 27+1
\quad\Longrightarrow\quad
m_n=27,\ r_n=1.
\label{eq:S07_02_82}\]</span>
따라서 최소분산 섹터 카운트는
<span class="math display">\[(k_{n,1},k_{n,2},k_{n,3})
\ \text{는}\
(27,27,28)\ \text{의 순열}.
\label{eq:S07_02_kn}\]</span></p>
<h3 data-number="9.3.4" id="빌드시간의-정의정준-사건율-기반"><span class="header-section-number">9.3.4</span> 7.2.4 빌드시간의 정의(정준 사건율 기반)</h3>
<h4 data-number="9.3.4.1" id="d-7.2-1-빌드시간-함수"><span class="header-section-number">9.3.4.1</span> [D-7.2-1] 빌드시간 함수</h4>
<p>정준 사건율 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>가 잠긴 레짐에서, 총 카운트 <span class="math inline">\(N\)</span>을 누적하는 데 필요한 평균 시간을 빌드시간으로 정의한다.
<span class="math display">\[T_{\mathrm{build}}(N)
:=\frac{N}{\nu_{p,\mathrm{can}}}.
\label{eq:S07_02_Tbuild_def}\]</span>
정의 <a data-reference="eq:S07_02_Tbuild_def" data-reference-type="eqref" href="#eq:S07_02_Tbuild_def">[eq:S07_02_Tbuild_def]</a>는 시간-카운트의 기본 연결이며, 추가 가정이 아니다. 이는 <a data-reference="eq:S07_02_N_equals_nuT" data-reference-type="eqref" href="#eq:S07_02_N_equals_nuT">[eq:S07_02_N_equals_nuT]</a>를 <span class="math inline">\(T=t_2-t_1\)</span>로 두고 <span class="math inline">\(N=\nu T\)</span>를 <span class="math inline">\(T=N/\nu\)</span>로 푸는 것과 동치이다.</p>
<h4 data-number="9.3.4.2" id="p-구조-빌드시간-t_p"><span class="header-section-number">9.3.4.2</span> <span class="math inline">\(p\)</span>-구조 빌드시간 <span class="math inline">\(T_p\)</span></h4>
<p><a data-reference="eq:S07_02_Tbuild_def" data-reference-type="eqref" href="#eq:S07_02_Tbuild_def">[eq:S07_02_Tbuild_def]</a>와 <a data-reference="eq:S07_02_Np_def" data-reference-type="eqref" href="#eq:S07_02_Np_def">[eq:S07_02_Np_def]</a>로부터
<span class="math display">\[T_p
:=T_{\mathrm{build}}(N_p)
=\frac{N_p}{\nu_{p,\mathrm{can}}}
=\frac{89}{\nu_{p,\mathrm{can}}}.
\label{eq:S07_02_Tp_def}\]</span></p>
<h4 data-number="9.3.4.3" id="n-구조-빌드시간-t_n"><span class="header-section-number">9.3.4.3</span> <span class="math inline">\(n\)</span>-구조 빌드시간 <span class="math inline">\(T_n\)</span></h4>
<p><a data-reference="eq:S07_02_Tbuild_def" data-reference-type="eqref" href="#eq:S07_02_Tbuild_def">[eq:S07_02_Tbuild_def]</a>와 <a data-reference="eq:S07_02_Nn_def" data-reference-type="eqref" href="#eq:S07_02_Nn_def">[eq:S07_02_Nn_def]</a>로부터
<span class="math display">\[T_n
:=T_{\mathrm{build}}(N_n)
=\frac{N_n}{\nu_{p,\mathrm{can}}}
=\frac{82}{\nu_{p,\mathrm{can}}}.
\label{eq:S07_02_Tn_def}\]</span></p>
<h3 data-number="9.3.5" id="시간-구조-불변량정준-사건율이-소거되는-결론"><span class="header-section-number">9.3.5</span> 7.2.5 시간-구조 불변량(정준 사건율이 소거되는 결론)</h3>
<p>정의 <a data-reference="eq:S07_02_Tp_def" data-reference-type="eqref" href="#eq:S07_02_Tp_def">[eq:S07_02_Tp_def]</a>–<a data-reference="eq:S07_02_Tn_def" data-reference-type="eqref" href="#eq:S07_02_Tn_def">[eq:S07_02_Tn_def]</a>로부터 다음 불변량들이 즉시 도출된다.</p>
<h4 data-number="9.3.5.1" id="비율-불변량"><span class="header-section-number">9.3.5.1</span> 7.2.5.1 비율 불변량</h4>
<p><span class="math display">\[\frac{T_p}{T_n}
=
\frac{89/\nu_{p,\mathrm{can}}}{82/\nu_{p,\mathrm{can}}}
=
\frac{89}{82}.
\label{eq:S07_02_ratio_invariant}\]</span>
따라서 <span class="math inline">\(T_p/T_n\)</span>은 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>의 값과 무관한 구조 비율 불변량이다.</p>
<h4 data-number="9.3.5.2" id="차이-불변량카운트-차이-7의-시간화"><span class="header-section-number">9.3.5.2</span> 7.2.5.2 차이 불변량(카운트 차이 7의 시간화)</h4>
<p><span class="math display">\[T_p-T_n
=
\frac{89}{\nu_{p,\mathrm{can}}}-\frac{82}{\nu_{p,\mathrm{can}}}
=
\frac{7}{\nu_{p,\mathrm{can}}}.
\label{eq:S07_02_diff_invariant}\]</span>
즉, <span class="math inline">\(p\)</span>-구조와 <span class="math inline">\(n\)</span>-구조의 빌드시간 차이는 “추가 카운트 7”을 정준 사건율로 시간화한 값으로 고정된다.</p>
<h4 data-number="9.3.5.3" id="카운트-시간-폐회로무차원-결합"><span class="header-section-number">9.3.5.3</span> 7.2.5.3 카운트-시간 폐회로(무차원 결합)</h4>
<p><span class="math display">\[\nu_{p,\mathrm{can}}\,T_p = 89,
\qquad
\nu_{p,\mathrm{can}}\,T_n = 82.
\label{eq:S07_02_closed_loop}\]</span>
식 <a data-reference="eq:S07_02_closed_loop" data-reference-type="eqref" href="#eq:S07_02_closed_loop">[eq:S07_02_closed_loop]</a>은 “정준 사건율<span class="math inline">\(\times\)</span>빌드시간”이 구조 카운트로 되돌아오는 무차원 폐회로이며, 동일 잠금 버전에서만 의미를 가진다.</p>
<h3 data-number="9.3.6" id="섹터별-빌드시간-분해3-섹터-시간-구조-연결"><span class="header-section-number">9.3.6</span> 7.2.6 섹터별 빌드시간 분해(3-섹터 시간-구조 연결)</h3>
<p>3-섹터 정수화 결과 <a data-reference="eq:S07_02_kp" data-reference-type="eqref" href="#eq:S07_02_kp">[eq:S07_02_kp]</a>, <a data-reference="eq:S07_02_kn" data-reference-type="eqref" href="#eq:S07_02_kn">[eq:S07_02_kn]</a>에 대해, 섹터별 빌드시간을 다음으로 정의한다.
<span class="math display">\[T_{p,i}:=\frac{k_{p,i}}{\nu_{p,\mathrm{can}}}
\quad (i=1,2,3),
\qquad
T_{n,i}:=\frac{k_{n,i}}{\nu_{p,\mathrm{can}}}
\quad (i=1,2,3).
\label{eq:S07_02_sector_times}\]</span>
합 보존 <a data-reference="eq:S07_02_minvar" data-reference-type="eqref" href="#eq:S07_02_minvar">[eq:S07_02_minvar]</a>에 의해
<span class="math display">\[T_{p,1}+T_{p,2}+T_{p,3}
=
\frac{k_{p,1}+k_{p,2}+k_{p,3}}{\nu_{p,\mathrm{can}}}
=
\frac{N_p}{\nu_{p,\mathrm{can}}}
=
T_p,
\label{eq:S07_02_sector_sum_p}\]</span>
<span class="math display">\[T_{n,1}+T_{n,2}+T_{n,3}
=
\frac{k_{n,1}+k_{n,2}+k_{n,3}}{\nu_{p,\mathrm{can}}}
=
\frac{N_n}{\nu_{p,\mathrm{can}}}
=
T_n.
\label{eq:S07_02_sector_sum_n}\]</span>
따라서 빌드시간은 3-섹터 구조 카운트의 시간화로 완전히 분해된다.</p>
<h3 data-number="9.3.7" id="레짐-조건과-실패-처리정의-불능-및-위반"><span class="header-section-number">9.3.7</span> 7.2.7 레짐 조건과 실패 처리(정의 불능 및 위반)</h3>
<p>본 절의 정의들이 결론 자격을 가지려면 다음 조건이 잠겨야 한다.</p>
<ol>
<li><p><span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>가 동일 레짐에서 상수로 취급될 수 있어야 하며, 그 정의(<a data-reference="eq:S07_02_nu_can_def" data-reference-type="eqref" href="#eq:S07_02_nu_can_def">[eq:S07_02_nu_can_def]</a>)에 필요한 사건 로그가 완결되어야 한다.</p></li>
<li><p>구조 카운트 <span class="math inline">\(N_p,N_n\)</span>의 객체 귀속과 포함/배제 규약이 잠겨 있어야 한다.</p></li>
<li><p>3-섹터 정수화에서 순열 선택 규칙(우선순위 <span class="math inline">\(\pi_{\mathrm{sec}}\)</span>)이 잠겨 있어야 하며, 최소분산 조건 <a data-reference="eq:S07_02_minvar" data-reference-type="eqref" href="#eq:S07_02_minvar">[eq:S07_02_minvar]</a>이 위반되지 않아야 한다.</p></li>
</ol>
<p>위 조건이 충족되지 않으면 <span class="math inline">\(T_p,T_n\)</span>은 정의 불능(<code>INCONCLUSIVE</code>) 또는 레짐/구조 위반(<code>FAIL</code>)로 판정되며, 해당 산출물은 결론 자격을 갖지 못한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-33">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 구조 카운트 <span class="math inline">\(N_p=89\)</span>, <span class="math inline">\(N_n=82\)</span>의 객체 귀속 및 포함/배제 규약을 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: 정준 사건율 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span> 정의 및 빌드시간 정의 <span class="math inline">\(T_{\mathrm{build}}(N)=N/\nu_{p,\mathrm{can}}\)</span>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 3-섹터 최소분산 정수화(<span class="math inline">\(N=3m+r\)</span>, <a data-reference="eq:S07_02_triplets" data-reference-type="eqref" href="#eq:S07_02_triplets">[eq:S07_02_triplets]</a>) 및 우선순위 순열 <span class="math inline">\(\pi_{\mathrm{sec}}\)</span>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 최소분산 조건 <span class="math inline">\(|k_i-k_j|\le 1\)</span> 및 합 보존 <span class="math inline">\(k_1+k_2+k_3=N\)</span> 위반은 G-STR에서 <code>FAIL</code>.</p></li>
<li><p>Gate: <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>의 레짐 불일치/로그 불완결은 G-REG 또는 G-REP에서 <code>INCONCLUSIVE</code>; 사후 변경은 G-NT에서 <code>FAIL</code>.</p></li>
</ul>
<h2 data-number="9.4" id="phi-chi-정의관측분석-넘김-기준"><span class="header-section-number">9.4</span> 7.3 <span class="math inline">\(\Phi\)</span>, <span class="math inline">\(\chi\)</span> 정의(관측·분석 넘김 기준)</h2>
<h3 data-number="9.4.1" id="목적-3"><span class="header-section-number">9.4.1</span> 7.3.1 목적</h3>
<p>본 절은 (i) 관측 가능한 집계량 <span class="math inline">\(\Phi\)</span>, <span class="math inline">\(\chi\)</span>를 내부 정의로 고정하고, (ii) <span class="math inline">\(\Phi\)</span>, <span class="math inline">\(\chi\)</span>의 측정가능성(로그 기반 산출 가능 조건)을 명시하며, (iii) <span class="math inline">\(\Phi\)</span>, <span class="math inline">\(\chi\)</span>를 분석 파트(닫힘/게이트/추정기 스택)로 넘기는 Gate를 정의한다.
본 절의 <span class="math inline">\(\Phi\)</span>, <span class="math inline">\(\chi\)</span>는 외부 텍스트의 정당화 없이, 사건 로그와 3-섹터 정수화 및 정류 규약만으로 정의된다.</p>
<h3 data-number="9.4.2" id="관측-입력이벤트-로그-최소-스키마"><span class="header-section-number">9.4.2</span> 7.3.2 관측 입력(이벤트 로그) 최소 스키마</h3>
<p><span class="math inline">\(\Phi\)</span>, <span class="math inline">\(\chi\)</span>는 사건(event) 집계량이므로, 사건 로그가 다음 필드를 <em>필수</em>로 포함해야 한다. 필드 누락은 정의 불능이며 즉시 <code>INCONCLUSIVE</code> 또는 <code>FAIL</code>이다.</p>
<ol>
<li><p>사건 집합: <span class="math inline">\(\mathcal{E}\)</span>.</p></li>
<li><p>사건 인덱스: <span class="math inline">\(e\in\mathcal{E}\)</span>.</p></li>
<li><p>사건 시간(틱): <span class="math inline">\(n(e)\in\mathbb{Z}\)</span>.</p></li>
<li><p>시간 창 정의를 위한 틱 경계: <span class="math inline">\(n_1&lt;n_2\)</span>.</p></li>
<li><p>사건 전/후 상태 식별자: <span class="math inline">\(\mathrm{pre}(e)\)</span>, <span class="math inline">\(\mathrm{post}(e)\)</span>.</p></li>
<li><p>사건에 관여한 VP 부분집합: <span class="math inline">\(\mathcal{V}(e)\subseteq\mathcal{V}\)</span>.</p></li>
<li><p>3-섹터 정수화 입력: 총 카운트 <span class="math inline">\(N(e)\)</span> 또는 섹터 삼중항 <span class="math inline">\((k_1(e),k_2(e),k_3(e))\)</span> 중 하나.</p></li>
<li><p>(정류 생존을 사용하는 경우) 두 위상 값: <span class="math inline">\(\theta(e)\in[0,2\pi)\)</span>, <span class="math inline">\(\varphi(e)\in[0,2\pi)\)</span>.</p></li>
</ol>
<p>본 절에서 사용하는 실현 시간 틱 <span class="math inline">\(\Delta t\)</span>는 <code>realization_lock</code>에 잠겨 있어야 하며,
<span class="math display">\[\Delta T := (n_2-n_1)\Delta t
\label{eq:S07_03_DeltaT}\]</span>
로 시간 창 길이를 정의한다.</p>
<h3 data-number="9.4.3" id="phi의-정의생존-정류-기반-로그-비율"><span class="header-section-number">9.4.3</span> 7.3.3 <span class="math inline">\(\Phi\)</span>의 정의(생존 정류 기반 로그-비율)</h3>
<h4 data-number="9.4.3.1" id="시간-창과-원시-사건-집합"><span class="header-section-number">9.4.3.1</span> 7.3.3.1 시간 창과 원시 사건 집합</h4>
<p>틱 구간 <span class="math inline">\([n_1,n_2)\)</span>에서의 원시 사건 집합을 다음으로 정의한다.
<span class="math display">\[\mathcal{E}_0[n_1,n_2)
:=\{\,e\in\mathcal{E}\mid n_1\le n(e)&lt;n_2\,\}.
\label{eq:S07_03_E0}\]</span>
원시 사건 수를 다음으로 정의한다.
<span class="math display">\[N_0 := \bigl|\mathcal{E}_0[n_1,n_2)\bigr|.
\label{eq:S07_03_N0}\]</span>
<span class="math inline">\(N_0=0\)</span>이면 <span class="math inline">\(\Phi\)</span>는 정의 불능이다.</p>
<h4 data-number="9.4.3.2" id="생존-가중치와-정류-사건-수"><span class="header-section-number">9.4.3.2</span> 7.3.3.2 생존 가중치와 정류 사건 수</h4>
<p>반파 정류 연산자를 다음으로 정의한다.
<span class="math display">\[_+ := \max(0,x).
\label{eq:S07_03_pospart}\]</span>
사건 <span class="math inline">\(e\)</span>의 생존 가중치를 다음으로 정의한다.
<span class="math display">\[w(e) := [\cos\theta(e)]_+\,[\cos\varphi(e)]_+.
\label{eq:S07_03_w}\]</span>
정류 사건 수를 다음으로 정의한다.
<span class="math display">\[N_\delta
:=\sum_{e\in\mathcal{E}_0[n_1,n_2)} w(e).
\label{eq:S07_03_Ndelta}\]</span>
정의상 <span class="math inline">\(0\le N_\delta\le N_0\)</span>이다.</p>
<h4 data-number="9.4.3.3" id="생존-비율과-안정화를-위한-varepsilon_phi"><span class="header-section-number">9.4.3.3</span> 7.3.3.3 생존 비율과 안정화를 위한 <span class="math inline">\(\varepsilon_\Phi\)</span></h4>
<p>생존 비율을 다음으로 정의한다.
<span class="math display">\[\rho := \frac{N_\delta}{N_0}.
\label{eq:S07_03_rho}\]</span>
<span class="math inline">\(\rho=0\)</span> 또는 <span class="math inline">\(\rho=1\)</span>에서 로그-비율이 발산하므로, 안정화 상수 <span class="math inline">\(\varepsilon_\Phi\)</span>를 다음 조건으로 잠근다.
<span class="math display">\[\varepsilon_\Phi&gt;0,
\qquad
\varepsilon_\Phi\ \text{는}\ \texttt{analysis\_lock}\ \text{에 사전 등록}.
\label{eq:S07_03_epsphi_lock}\]</span>
안정화된 생존 비율을 다음으로 정의한다.
<span class="math display">\[\tilde{\rho}
:=\frac{N_\delta+\varepsilon_\Phi}{N_0+2\varepsilon_\Phi}.
\label{eq:S07_03_rhotilde}\]</span>
그러면 <span class="math inline">\(0&lt;\tilde{\rho}&lt;1\)</span>이 성립한다.</p>
<h4 data-number="9.4.3.4" id="phi의-정의로그-비율"><span class="header-section-number">9.4.3.4</span> 7.3.3.4 <span class="math inline">\(\Phi\)</span>의 정의(로그-비율)</h4>
<p><span class="math inline">\(\Phi\)</span>를 다음으로 정의한다.
<span class="math display">\[\Phi
:=\log\left(\frac{\tilde{\rho}}{1-\tilde{\rho}}\right).
\label{eq:S07_03_Phi_def}\]</span>
<span class="math inline">\(\Phi\)</span>의 타입은 스칼라, 차원은 무차원(<span class="math inline">\([1]\)</span>)으로 잠긴다. <span class="math inline">\(\Phi\)</span>는 “생존이 우세한가/상쇄가 우세한가”를 로그-비율로 집계한 관측량이며, 외부 정당화 없이 사건 로그로부터 계산되는 값으로만 존재한다.</p>
<h3 data-number="9.4.4" id="chi의-정의방향-코히런스-chi_mathrmdir와-내부-안정성-chi_mathrmint"><span class="header-section-number">9.4.4</span> 7.3.4 <span class="math inline">\(\chi\)</span>의 정의(방향 코히런스 <span class="math inline">\(\chi_{\mathrm{dir}}\)</span>와 내부 안정성 <span class="math inline">\(\chi_{\mathrm{int}}\)</span>)</h3>
<h4 data-number="9.4.4.1" id="섹터-잔차-벡터정수-기반"><span class="header-section-number">9.4.4.1</span> 7.3.4.1 3-섹터 잔차 벡터(정수 기반)</h4>
<p>시간 창 <span class="math inline">\([n_1,n_2)\)</span>에서 3-섹터 정수화 결과를 얻는 방식은 다음 두 방식 중 하나로 잠긴다.</p>
<ol>
<li><p>사건별 정수화: 각 사건 <span class="math inline">\(e\)</span>가 <span class="math inline">\((k_1(e),k_2(e),k_3(e))\)</span>를 제공한다.</p></li>
<li><p>창 집계 정수화: 창 전체의 총 카운트 <span class="math inline">\(N\)</span>을 먼저 정의하고, 최소분산 정수화로 <span class="math inline">\((k_1,k_2,k_3)\)</span>를 산출한다.</p></li>
</ol>
<p>창 집계 정수화를 사용하는 경우, 총 카운트를 다음으로 정의한다.
<span class="math display">\[N := \sum_{e\in\mathcal{E}_0[n_1,n_2)} N(e),
\label{eq:S07_03_N_total}\]</span>
그리고 7.1의 최소분산 규칙에 의해 <span class="math inline">\((k_1,k_2,k_3)\)</span>를 산출한다.
3-섹터 축 <span class="math inline">\(\{\mathbf{n}_1,\mathbf{n}_2,\mathbf{n}_3\}\)</span>는 120 조건으로 잠겨 있다.
<span class="math display">\[\mathbf{n}_i\cdot\mathbf{n}_j=
\begin{cases}
1,&amp; i=j,\\
-\dfrac{1}{2},&amp; i\neq j,
\end{cases}
\qquad
\mathbf{n}_1+\mathbf{n}_2+\mathbf{n}_3=\mathbf{0}.
\label{eq:S07_03_sector_axes}\]</span>
창 집계 잔차 벡터를 다음으로 정의한다.
<span class="math display">\[\mathbf{V}
:=k_1\mathbf{n}_1+k_2\mathbf{n}_2+k_3\mathbf{n}_3.
\label{eq:S07_03_V_window}\]</span>
사건별 정수화를 사용하는 경우에는 사건별 잔차 벡터
<span class="math display">\[\mathbf{V}(e)
:=k_1(e)\mathbf{n}_1+k_2(e)\mathbf{n}_2+k_3(e)\mathbf{n}_3
\label{eq:S07_03_V_event}\]</span>
를 정의하고, 아래 집계를 사건별로 수행한다.</p>
<h4 data-number="9.4.4.2" id="방향-코히런스-chi_mathrmdir"><span class="header-section-number">9.4.4.2</span> 7.3.4.2 방향 코히런스 <span class="math inline">\(\chi_{\mathrm{dir}}\)</span></h4>
<p>코히런스 축(방향 기준) <span class="math inline">\(\mathbf{n}_\chi\)</span>를 다음으로 잠근다.
<span class="math display">\[\mathbf{n}_\chi\in \Pi,\qquad \|\mathbf{n}_\chi\|=1,
\qquad
\mathbf{n}_\chi\ \text{는}\ \texttt{analysis\_lock}\ \text{에 사전 등록}.
\label{eq:S07_03_nchi_lock}\]</span>
사건별 집계를 사용하는 경우, 유효 사건 집합을 다음으로 정의한다.
<span class="math display">\[\mathcal{E}_{\mathrm{eff}}
:=\{\,e\in\mathcal{E}_0[n_1,n_2)\mid \|\mathbf{V}(e)\|&gt;0\,\},
\qquad
N_{\mathrm{eff}}:=|\mathcal{E}_{\mathrm{eff}}|.
\label{eq:S07_03_Eeff}\]</span>
단위 잔차 방향을 다음으로 정의한다.
<span class="math display">\[\widehat{\mathbf{V}}(e):=\frac{\mathbf{V}(e)}{\|\mathbf{V}(e)\|}\qquad (e\in\mathcal{E}_{\mathrm{eff}}).
\label{eq:S07_03_Vhat}\]</span>
방향 코히런스 <span class="math inline">\(\chi_{\mathrm{dir}}\)</span>를 다음으로 정의한다.
<span class="math display">\[\chi_{\mathrm{dir}}
:=
\left|
\frac{1}{N_{\mathrm{eff}}}\sum_{e\in\mathcal{E}_{\mathrm{eff}}}\widehat{\mathbf{V}}(e)\cdot \mathbf{n}_\chi
\right|.
\label{eq:S07_03_chidir_def}\]</span>
정의상 <span class="math inline">\(0\le \chi_{\mathrm{dir}}\le 1\)</span>이다. <span class="math inline">\(N_{\mathrm{eff}}=0\)</span>이면 <span class="math inline">\(\chi_{\mathrm{dir}}\)</span>는 정의 불능이다.</p>
<p>창 집계 잔차 벡터만 사용하는 경우에는 단일 방향 투영으로 정의한다.
<span class="math display">\[\chi_{\mathrm{dir}}
:=
\left|\frac{\mathbf{V}}{\|\mathbf{V}\|}\cdot \mathbf{n}_\chi\right|
\qquad (\|\mathbf{V}\|&gt;0).
\label{eq:S07_03_chidir_window}\]</span></p>
<h4 data-number="9.4.4.3" id="내부-안정성-chi_mathrmint-다중-창-일치도"><span class="header-section-number">9.4.4.3</span> 7.3.4.3 내부 안정성 <span class="math inline">\(\chi_{\mathrm{int}}\)</span> (다중 창 일치도)</h4>
<p><span class="math inline">\(\Phi\)</span>의 창 길이 의존성을 사용하여 내부 안정성을 정의한다. 다중 창 길이 집합을 다음으로 잠근다.
<span class="math display">\[\mathcal{W}:=\{\Delta N_1,\Delta N_2,\ldots,\Delta N_M\},
\qquad
\Delta N_m\in\mathbb{Z}_{&gt;0},
\qquad
\mathcal{W}\ \text{는}\ \texttt{analysis\_lock}\ \text{에 사전 등록}.
\label{eq:S07_03_Wset}\]</span>
각 창 길이 <span class="math inline">\(\Delta N_m\)</span>에 대해 동일한 프로토콜(동일 사건 정의, 동일 생존 가중치, 동일 <span class="math inline">\(\varepsilon_\Phi\)</span>)로 <span class="math inline">\(\Phi_m\)</span>을 계산한다.
<span class="math display">\[\Phi_m := \Phi(\Delta N_m).
\label{eq:S07_03_Phim}\]</span>
평균과 분산을 다음으로 정의한다.
<span class="math display">\[\overline{\Phi}
:=\frac{1}{M}\sum_{m=1}^{M}\Phi_m,
\qquad
\sigma_\Phi^2
:=\frac{1}{M}\sum_{m=1}^{M}(\Phi_m-\overline{\Phi})^2,
\qquad
\sigma_\Phi:=\sqrt{\sigma_\Phi^2}.
\label{eq:S07_03_sigmaPhi}\]</span>
내부 안정성 스케일 <span class="math inline">\(\varepsilon_{\chi}&gt;0\)</span>를 다음으로 잠근다.
<span class="math display">\[\varepsilon_{\chi}&gt;0,
\qquad
\varepsilon_{\chi}\ \text{는}\ \texttt{analysis\_lock}\ \text{에 사전 등록}.
\label{eq:S07_03_epschi_lock}\]</span>
<span class="math inline">\(\chi_{\mathrm{int}}\)</span>를 다음으로 정의한다.
<span class="math display">\[\chi_{\mathrm{int}}
:=
\frac{1}{1+\sigma_\Phi/\varepsilon_{\chi}}.
\label{eq:S07_03_chiint_def}\]</span>
정의상 <span class="math inline">\(0&lt;\chi_{\mathrm{int}}\le 1\)</span>이며, <span class="math inline">\(\sigma_\Phi=0\)</span>이면 <span class="math inline">\(\chi_{\mathrm{int}}=1\)</span>이다. <span class="math inline">\(M=0\)</span> 또는 <span class="math inline">\(\Phi_m\)</span>이 정의 불능이면 <span class="math inline">\(\chi_{\mathrm{int}}\)</span>는 정의 불능이다.</p>
<h4 data-number="9.4.4.4" id="결합-코히런스-chi"><span class="header-section-number">9.4.4.4</span> 7.3.4.4 결합 코히런스 <span class="math inline">\(\chi\)</span></h4>
<p>결합 코히런스 <span class="math inline">\(\chi\)</span>를 다음 곱으로 정의한다.
<span class="math display">\[\chi := \chi_{\mathrm{dir}}\chi_{\mathrm{int}}.
\label{eq:S07_03_chi_def}\]</span>
따라서 <span class="math inline">\(0\le \chi\le 1\)</span>이다. <span class="math inline">\(\chi\)</span>는 관측량이면서 동시에 “분석 입력으로 승격 가능한가”를 판단하는 핵심 입력으로 사용된다.</p>
<h3 data-number="9.4.5" id="측정가능성-조건정의-불능-방지"><span class="header-section-number">9.4.5</span> 7.3.5 측정가능성 조건(정의 불능 방지)</h3>
<p><span class="math inline">\(\Phi\)</span>, <span class="math inline">\(\chi\)</span>의 측정가능성은 다음 조건을 만족할 때에만 성립한다.</p>
<ol>
<li><p><strong>로그 완결성</strong>: 7.3.2의 필드가 모두 존재하며, 각 필드의 스키마가 <code>protocol_lock</code>에 의해 잠겨 있다.</p></li>
<li><p><strong>표본 크기</strong>: <span class="math inline">\(N_0\ge N_{\min}\)</span> 및 <span class="math inline">\(N_{\mathrm{eff}}\ge N_{\min,\mathrm{eff}}\)</span>를 만족한다.</p></li>
<li><p><strong>정류 정의 유지</strong>: <span class="math inline">\(w(e)\)</span>의 정의 <a data-reference="eq:S07_03_w" data-reference-type="eqref" href="#eq:S07_03_w">[eq:S07_03_w]</a>가 동일 버전에서 유지된다.</p></li>
<li><p><strong>정수화 규칙 유지</strong>: 3-섹터 축 <a data-reference="eq:S07_03_sector_axes" data-reference-type="eqref" href="#eq:S07_03_sector_axes">[eq:S07_03_sector_axes]</a> 및 최소분산 정수화 규칙(7.1)이 동일 버전에서 유지된다.</p></li>
<li><p><strong>다중 창 집합 고정</strong>: <span class="math inline">\(\mathcal{W}\)</span>가 잠겨 있으며, 동일 규약으로 <span class="math inline">\(\Phi_m\)</span>이 계산된다.</p></li>
</ol>
<p><span class="math inline">\(N_{\min}\)</span>, <span class="math inline">\(N_{\min,\mathrm{eff}}\)</span>는 <code>gate_lock</code>에 사전 등록된 문턱이며, 결과를 본 뒤 이동될 수 없다.</p>
<h3 data-number="9.4.6" id="분석-파트로-넘기는-gate정의-판정-등록-규약"><span class="header-section-number">9.4.6</span> 7.3.6 분석 파트로 넘기는 Gate(정의, 판정, 등록 규약)</h3>
<h4 data-number="9.4.6.1" id="gate-분류와-표준-출력"><span class="header-section-number">9.4.6.1</span> 7.3.6.1 Gate 분류와 표준 출력</h4>
<p><span class="math inline">\(\Phi\)</span>, <span class="math inline">\(\chi\)</span>의 넘김 Gate는 다음 세 Gate로 구성되며, 출력은 <code>PASS</code>/<code>FAIL</code>/<code>INCONCLUSIVE</code>로만 기록된다.</p>
<ol>
<li><p><strong>G-OBS-PHI</strong>: <span class="math inline">\(\Phi\)</span>의 정의 가능성과 안정성을 판정.</p></li>
<li><p><strong>G-OBS-CHI</strong>: <span class="math inline">\(\chi\)</span>의 정의 가능성과 코히런스 문턱 통과를 판정.</p></li>
<li><p><strong>G-HANDOFF</strong>: G-OBS-PHI 및 G-OBS-CHI의 동시 <code>PASS</code>를 전제로 분석 입력(OBS-REF)으로 등록하는 Gate.</p></li>
</ol>
<h4 data-number="9.4.6.2" id="g-obs-phi-판정식"><span class="header-section-number">9.4.6.2</span> 7.3.6.2 G-OBS-PHI 판정식</h4>
<p>다음 조건을 모두 만족하면 G-OBS-PHI=<code>PASS</code>로 판정한다.</p>
<ol>
<li><p><span class="math inline">\(N_0\ge N_{\min}\)</span>.</p></li>
<li><p><span class="math inline">\(\Phi\)</span>가 <a data-reference="eq:S07_03_Phi_def" data-reference-type="eqref" href="#eq:S07_03_Phi_def">[eq:S07_03_Phi_def]</a>로 계산 가능(즉, <span class="math inline">\(\varepsilon_\Phi\)</span> 잠금 및 <span class="math inline">\(N_0&gt;0\)</span>).</p></li>
<li><p>다중 창 집합 <span class="math inline">\(\mathcal{W}\)</span>가 잠김(<a data-reference="eq:S07_03_Wset" data-reference-type="eqref" href="#eq:S07_03_Wset">[eq:S07_03_Wset]</a>)이며, 모든 <span class="math inline">\(\Phi_m\)</span>이 정의 가능.</p></li>
</ol>
<p>위 조건 중 하나라도 스키마 누락 또는 잠금 누락이면 <code>INCONCLUSIVE</code>로 판정한다.
정의 충돌(예: <span class="math inline">\(\Phi\)</span> 기호의 의미 충돌, <span class="math inline">\(\varepsilon_\Phi\)</span>의 사후 변경, <span class="math inline">\(w(e)\)</span>의 교체)이 탐지되면 <code>FAIL</code>로 판정한다.</p>
<h4 data-number="9.4.6.3" id="g-obs-chi-판정식"><span class="header-section-number">9.4.6.3</span> 7.3.6.3 G-OBS-CHI 판정식</h4>
<p>다음 조건을 모두 만족하면 G-OBS-CHI=<code>PASS</code>로 판정한다.</p>
<ol>
<li><p><span class="math inline">\(N_{\mathrm{eff}}\ge N_{\min,\mathrm{eff}}\)</span>.</p></li>
<li><p><span class="math inline">\(\chi_{\mathrm{dir}}\)</span>가 <a data-reference="eq:S07_03_chidir_def" data-reference-type="eqref" href="#eq:S07_03_chidir_def">[eq:S07_03_chidir_def]</a> 또는 <a data-reference="eq:S07_03_chidir_window" data-reference-type="eqref" href="#eq:S07_03_chidir_window">[eq:S07_03_chidir_window]</a>로 정의 가능(즉, <span class="math inline">\(\mathbf{n}_\chi\)</span> 잠금 및 <span class="math inline">\(\|\mathbf{V}\|&gt;0\)</span> 조건 만족).</p></li>
<li><p><span class="math inline">\(\chi_{\mathrm{int}}\)</span>가 <a data-reference="eq:S07_03_chiint_def" data-reference-type="eqref" href="#eq:S07_03_chiint_def">[eq:S07_03_chiint_def]</a>로 정의 가능(즉, <span class="math inline">\(\mathcal{W}\)</span>, <span class="math inline">\(\varepsilon_{\chi}\)</span> 잠금 및 <span class="math inline">\(\Phi_m\)</span> 정의 가능).</p></li>
<li><p>문턱 통과:
<span class="math display">\[\chi_{\mathrm{dir}}\ge \chi_{\mathrm{dir,min}},
  \qquad
  \chi_{\mathrm{int}}\ge \chi_{\mathrm{int,min}},
  \qquad
  \chi\ge \chi_{\min},
  \label{eq:S07_03_chi_thresholds}\]</span>
여기서 <span class="math inline">\(\chi_{\mathrm{dir,min}},\chi_{\mathrm{int,min}},\chi_{\min}\)</span>은 <code>gate_lock</code>에 사전 등록된 문턱이다.</p></li>
</ol>
<p>문턱이 미잠금이거나, <span class="math inline">\(\mathbf{n}_\chi\)</span>가 미잠금이거나, 정수화 규칙이 혼합되면 <code>INCONCLUSIVE</code> 또는 <code>FAIL</code>로 판정한다. 결과를 본 뒤 문턱을 이동하면 No-Tuning 위반으로 <code>FAIL</code>이다.</p>
<h4 data-number="9.4.6.4" id="g-handoff분석-입력-등록-규칙"><span class="header-section-number">9.4.6.4</span> 7.3.6.4 G-HANDOFF(분석 입력 등록) 규칙</h4>
<p>G-HANDOFF는 다음 판정으로 정의한다.
<span class="math display">\[\texttt{G-HANDOFF}=\texttt{PASS}
\quad\Longleftrightarrow\quad
(\texttt{G-OBS-PHI}=\texttt{PASS})\ \wedge\ (\texttt{G-OBS-CHI}=\texttt{PASS}).
\label{eq:S07_03_handoff_rule}\]</span>
<code>G-HANDOFF</code>=<code>PASS</code>인 경우, <span class="math inline">\(\Phi\)</span>, <span class="math inline">\(\chi_{\mathrm{dir}}\)</span>, <span class="math inline">\(\chi_{\mathrm{int}}\)</span>, <span class="math inline">\(\chi\)</span>는 분석 입력(OBS-REF)으로 등록된다. 등록은 다음 레코드 형식으로 잠근다.</p>
<pre><code>obs_ref_records:
  - quantity_id: Q-PHI-001
    value: (Phi)
    window: [n1,n2)
    lock_refs: {canon_lock_id, realization_lock_id, analysis_lock_id}
    gate_refs: {G-OBS-PHI: PASS, G-OBS-CHI: PASS, G-HANDOFF: PASS}
  - quantity_id: Q-CHI-DIR-001
    value: (chi_dir)
    window: [n1,n2)
    lock_refs: { ... }
    gate_refs: { ... }
  - quantity_id: Q-CHI-INT-001
    value: (chi_int)
    window: [n1,n2)
    lock_refs: { ... }
    gate_refs: { ... }
  - quantity_id: Q-CHI-001
    value: (chi)
    window: [n1,n2)
    lock_refs: { ... }
    gate_refs: { ... }</code></pre>
<p>위 레코드는 <code>analysis_lock</code> 또는 <code>registry_snapshot</code>에 포함되어 봉인되어야 하며, 봉인되지 않은 값은 분석 입력으로 사용할 수 없다.</p>
<h4 data-number="9.4.6.5" id="failinconclusive-시-허용-범위"><span class="header-section-number">9.4.6.5</span> 7.3.6.5 <code>FAIL</code>/<code>INCONCLUSIVE</code> 시 허용 범위</h4>
<p><code>G-HANDOFF</code><span class="math inline">\(\neq\)</span><code>PASS</code>인 경우, <span class="math inline">\(\Phi\)</span>, <span class="math inline">\(\chi\)</span>는 결론 근거로 사용할 수 없으며, 다음만 허용된다.</p>
<ol>
<li><p>한계 결론(CT-LIM)로서 “정의 불능/조건 위반”의 라벨과 함께 기록.</p></li>
<li><p>원인 라벨(로그 누락, 잠금 누락, 레짐 위반, 문턱 미통과, No-Tuning 위반)을 Gate 보고서에 남김.</p></li>
</ol>
<p><code>FAIL</code>/<code>INCONCLUSIVE</code>를 해석으로 무력화하는 문장은 금지된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-34">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(\Phi\)</span> 정의(<a data-reference="eq:S07_03_Phi_def" data-reference-type="eqref" href="#eq:S07_03_Phi_def">[eq:S07_03_Phi_def]</a>)에 필요한 <span class="math inline">\(\varepsilon_\Phi\)</span>, 생존 가중치 <span class="math inline">\(w(e)\)</span>, 시간 창 규약을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(\chi_{\mathrm{dir}},\chi_{\mathrm{int}},\chi\)</span> 정의(<a data-reference="eq:S07_03_chidir_def" data-reference-type="eqref" href="#eq:S07_03_chidir_def">[eq:S07_03_chidir_def]</a>, <a data-reference="eq:S07_03_chiint_def" data-reference-type="eqref" href="#eq:S07_03_chiint_def">[eq:S07_03_chiint_def]</a>, <a data-reference="eq:S07_03_chi_def" data-reference-type="eqref" href="#eq:S07_03_chi_def">[eq:S07_03_chi_def]</a>)에 필요한 <span class="math inline">\(\mathbf{n}_\chi\)</span>, <span class="math inline">\(\mathcal{W}\)</span>, <span class="math inline">\(\varepsilon_{\chi}\)</span>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: G-OBS-PHI/G-OBS-CHI/G-HANDOFF 판정식과 문턱(<span class="math inline">\(N_{\min}\)</span>, <span class="math inline">\(N_{\min,\mathrm{eff}}\)</span>, <span class="math inline">\(\chi_{\mathrm{dir,min}}\)</span>, <span class="math inline">\(\chi_{\mathrm{int,min}}\)</span>, <span class="math inline">\(\chi_{\min}\)</span>)을 <code>gate_lock</code>에 고정.</p></li>
<li><p>Gate: 스키마 누락/잠금 누락은 <code>INCONCLUSIVE</code>, 정의 충돌/사후 변경은 <code>FAIL</code>(G-SYM/G-LOCK/G-NT 연동).</p></li>
<li><p>Gate: <code>G-HANDOFF</code>=<code>PASS</code>인 경우에만 OBS-REF 등록을 허용하며, 봉인 없는 값은 분석 입력으로 사용 불가.</p></li>
</ul>
<h2 data-number="9.5" id="섹터부호pmrightarrow전자반전자-라벨"><span class="header-section-number">9.5</span> 7.4 섹터/부호(<span class="math inline">\(\pm\)</span>)<span class="math inline">\(\rightarrow\)</span>전자·반전자 라벨</h2>
<h3 data-number="9.5.1" id="목적-4"><span class="header-section-number">9.5.1</span> 7.4.1 목적</h3>
<p>본 절은 3-섹터 정수화 결과와 잔차(불상쇄) 벡터의 부호를 사용하여 “전자 라벨”과 “반전자 라벨”을 <strong>정의</strong>로 고정한다.
본 절은 라벨의 의미를 해석하거나 정당화하지 않는다. 본 절의 산출물은 (i) 라벨의 정의식, (ii) 라벨이 정의 가능한 조건, (iii) 라벨이 정의 불능일 때의 처리 규칙이다.</p>
<h3 data-number="9.5.2" id="입력lock-3-섹터-축-정수화-잔차-벡터"><span class="header-section-number">9.5.2</span> 7.4.2 입력(LOCK): 3-섹터 축, 정수화, 잔차 벡터</h3>
<h4 data-number="9.5.2.1" id="섹터-축의-잠금"><span class="header-section-number">9.5.2.1</span> 7.4.2.1 3-섹터 축의 잠금</h4>
<p>3-섹터 축 <span class="math inline">\(\{\mathbf{n}_1,\mathbf{n}_2,\mathbf{n}_3\}\)</span>는 120 조건으로 잠긴다.
<span class="math display">\[\mathbf{n}_i\cdot\mathbf{n}_j=
\begin{cases}
1,&amp; i=j,\\
-\dfrac{1}{2},&amp; i\neq j,
\end{cases}
\qquad
\mathbf{n}_1+\mathbf{n}_2+\mathbf{n}_3=\mathbf{0}.
\label{eq:S07_04_axes}\]</span>
축의 선택과 순서는 <code>analysis_lock</code>에 잠겨야 하며, 결과를 본 뒤 교체될 수 없다.</p>
<h4 data-number="9.5.2.2" id="섹터-정수화-결과"><span class="header-section-number">9.5.2.2</span> 7.4.2.2 섹터 정수화 결과</h4>
<p>총 카운트 <span class="math inline">\(N\)</span>에 대한 섹터 정수화 결과를
<span class="math display">\[(k_1,k_2,k_3)\in\mathbb{Z}_{\ge 0}^3,
\qquad
k_1+k_2+k_3=N
\label{eq:S07_04_k}\]</span>
로 둔다. <span class="math inline">\((k_1,k_2,k_3)\)</span>의 산출 규칙(최소분산 규칙 및 타이브레이크)은 <code>analysis_lock</code>에 잠겨야 한다.</p>
<h4 data-number="9.5.2.3" id="잔차-벡터의-정의"><span class="header-section-number">9.5.2.3</span> 7.4.2.3 잔차 벡터의 정의</h4>
<p>잔차(불상쇄) 벡터를 다음으로 정의한다.
<span class="math display">\[\mathbf{V}:=k_1\mathbf{n}_1+k_2\mathbf{n}_2+k_3\mathbf{n}_3.
\label{eq:S07_04_V}\]</span>
<span class="math inline">\(\mathbf{V}\)</span>는 정수화 결과와 축 잠금이 주어지면 유일하게 결정된다.</p>
<h3 data-number="9.5.3" id="라벨-기준축전하축-mathbfn_q의-잠금"><span class="header-section-number">9.5.3</span> 7.4.3 라벨 기준축(전하축) <span class="math inline">\(\mathbf{n}_Q\)</span>의 잠금</h3>
<p>전자/반전자 라벨은 <span class="math inline">\(\mathbf{V}\)</span>의 부호를 하나의 기준축에 대해 판정하여 정의한다. 기준축(라벨 축)을 <span class="math inline">\(\mathbf{n}_Q\)</span>로 두고 다음 조건으로 잠근다.
<span class="math display">\[\mathbf{n}_Q\in\Pi,\qquad \|\mathbf{n}_Q\|=1,
\qquad
\mathbf{n}_Q\ \text{는}\ \texttt{analysis\_lock}\ \text{에 사전 등록}.
\label{eq:S07_04_nQ_lock}\]</span>
<span class="math inline">\(\Pi\)</span>는 3-섹터 축이 놓인 섹터 평면이다. <span class="math inline">\(\mathbf{n}_Q\)</span>는 결과를 본 뒤 선택될 수 없으며, <span class="math inline">\(\mathbf{n}_Q\)</span>의 변경은 버전업으로만 허용된다.</p>
<h3 data-number="9.5.4" id="부호-판정-함수와-라벨-정의"><span class="header-section-number">9.5.4</span> 7.4.4 부호 판정 함수와 라벨 정의</h3>
<h4 data-number="9.5.4.1" id="부호-판정-함수"><span class="header-section-number">9.5.4.1</span> 7.4.4.1 부호 판정 함수</h4>
<p>부호 판정 함수를 다음으로 정의한다.
<span class="math display">\[s_Q(\mathbf{V})
:=
\mathrm{sgn}\!\left(\mathbf{V}\cdot\mathbf{n}_Q\right),
\qquad
\mathrm{sgn}(x)=
\begin{cases}
+1,&amp; x&gt;0,\\
0,&amp; x=0,\\
-1,&amp; x&lt;0.
\end{cases}
\label{eq:S07_04_sign}\]</span>
<span class="math inline">\(s_Q(\mathbf{V})\)</span>는 <span class="math inline">\(\{+1,0,-1\}\)</span> 중 하나이며, <span class="math inline">\(0\)</span>은 경계(중립) 또는 판정 불능을 나타내는 예약 값이다.</p>
<h4 data-number="9.5.4.2" id="비퇴화판정-가능-문턱"><span class="header-section-number">9.5.4.2</span> 7.4.4.2 비퇴화(판정 가능) 문턱</h4>
<p>부호 판정의 안정성을 위해 비퇴화 문턱 <span class="math inline">\(V_{\min}&gt;0\)</span>를 다음으로 잠근다.
<span class="math display">\[V_{\min}&gt;0,
\qquad
V_{\min}\ \text{는}\ \texttt{gate\_lock}\ \text{에 사전 등록}.
\label{eq:S07_04_Vmin}\]</span>
비퇴화 조건을 다음으로 정의한다.
<span class="math display">\[\|\mathbf{V}\|\ge V_{\min}.
\label{eq:S07_04_nondeg}\]</span>
<a data-reference="eq:S07_04_nondeg" data-reference-type="eqref" href="#eq:S07_04_nondeg">[eq:S07_04_nondeg]</a>가 성립하지 않으면 라벨은 정의 불능(또는 중립 처리)로 분류된다.</p>
<h4 data-number="9.5.4.3" id="전자반전자-라벨의-정의정의만"><span class="header-section-number">9.5.4.3</span> 7.4.4.3 전자/반전자 라벨의 정의(정의만)</h4>
<p>전자 라벨과 반전자 라벨을 다음으로 정의한다.
<span class="math display">\[\mathcal{L}_{e}(\mathbf{V})
:=
\begin{cases}
\texttt{ELECTRON}, &amp; \|\mathbf{V}\|\ge V_{\min}\ \wedge\ s_Q(\mathbf{V})=+1,\\
\texttt{UNDEFINED}, &amp; \text{otherwise},
\end{cases}
\label{eq:S07_04_label_e}\]</span>
<span class="math display">\[\mathcal{L}_{\bar e}(\mathbf{V})
:=
\begin{cases}
\texttt{POSITRON}, &amp; \|\mathbf{V}\|\ge V_{\min}\ \wedge\ s_Q(\mathbf{V})=-1,\\
\texttt{UNDEFINED}, &amp; \text{otherwise}.
\end{cases}
\label{eq:S07_04_label_ebar}\]</span>
또한 하나의 단일 라벨 함수로 결합하여 다음으로 정의한다.
<span class="math display">\[\mathcal{L}(\mathbf{V})
:=
\begin{cases}
\texttt{ELECTRON}, &amp; \|\mathbf{V}\|\ge V_{\min}\ \wedge\ s_Q(\mathbf{V})=+1,\\
\texttt{POSITRON}, &amp; \|\mathbf{V}\|\ge V_{\min}\ \wedge\ s_Q(\mathbf{V})=-1,\\
\texttt{NEUTRAL}, &amp; \|\mathbf{V}\|&lt;V_{\min}\ \vee\ s_Q(\mathbf{V})=0.
\end{cases}
\label{eq:S07_04_label_combined}\]</span>
정의 <a data-reference="eq:S07_04_label_combined" data-reference-type="eqref" href="#eq:S07_04_label_combined">[eq:S07_04_label_combined]</a>에서 <code>NEUTRAL</code>은 “라벨 중립/정의 불능”의 예약 출력이며, 이 출력이 결론 문장으로 허용되는지(예: 한계 결론 CT-LIM로만 허용)는 PASS.rules에 의해 잠긴다.</p>
<h3 data-number="9.5.5" id="섹터-비대칭과-부호의-연결정의적-연결"><span class="header-section-number">9.5.5</span> 7.4.5 섹터 비대칭과 부호의 연결(정의적 연결)</h3>
<p>3-섹터 축이 <a data-reference="eq:S07_04_axes" data-reference-type="eqref" href="#eq:S07_04_axes">[eq:S07_04_axes]</a>로 잠겨 있을 때, 최소분산 정수화 결과는 <span class="math inline">\(N\ (\mathrm{mod}\ 3)\)</span>에 의해 잔차 방향을 갖는다. 본 절은 그 사실을 <strong>정의적 연결</strong>로만 기록한다.</p>
<ol>
<li><p><span class="math inline">\(N\equiv 0\ (\mathrm{mod}\ 3)\)</span>이고 최소분산 정수화가 <span class="math inline">\((m,m,m)\)</span>이면 <span class="math inline">\(\mathbf{V}=\mathbf{0}\)</span>이므로 <a data-reference="eq:S07_04_label_combined" data-reference-type="eqref" href="#eq:S07_04_label_combined">[eq:S07_04_label_combined]</a>에 의해 <code>NEUTRAL</code>이다(비퇴화 문턱을 만족하지 못함).</p></li>
<li><p><span class="math inline">\(N\equiv 1\ (\mathrm{mod}\ 3)\)</span>이고 최소분산 정수화가 <span class="math inline">\((m,m,m+1)\)</span>의 순열이면, <span class="math inline">\(\mathbf{V}\)</span>는 “<span class="math inline">\(+1\)</span>을 받은 섹터 축” 방향으로 남는다.</p></li>
<li><p><span class="math inline">\(N\equiv 2\ (\mathrm{mod}\ 3)\)</span>이고 최소분산 정수화가 <span class="math inline">\((m,m+1,m+1)\)</span>의 순열이면, <span class="math inline">\(\mathbf{V}\)</span>는 “<span class="math inline">\(m\)</span>을 받은 섹터 축”의 반대 방향으로 남는다.</p></li>
</ol>
<p>위 항목은 라벨의 해석이 아니라, <span class="math inline">\(\mathbf{V}\)</span>의 정의 <a data-reference="eq:S07_04_V" data-reference-type="eqref" href="#eq:S07_04_V">[eq:S07_04_V]</a>와 축 합 <a data-reference="eq:S07_04_axes" data-reference-type="eqref" href="#eq:S07_04_axes">[eq:S07_04_axes]</a>로부터의 구조적 사실을 기록한 것이다. 라벨의 결정은 오직 <span class="math inline">\(\mathbf{V}\cdot\mathbf{n}_Q\)</span>의 부호로만 이루어진다.</p>
<h3 data-number="9.5.6" id="라벨-금지-규칙해석-금지-재정의-금지"><span class="header-section-number">9.5.6</span> 7.4.6 라벨 금지 규칙(해석 금지, 재정의 금지)</h3>
<p>본 절에서 정의된 라벨에 대해 다음 금지 규칙을 고정한다.</p>
<ol>
<li><p><strong>해석 금지</strong>: <code>ELECTRON</code>/<code>POSITRON</code>/<code>NEUTRAL</code> 출력의 물리적 의미를 본 절에서 서술하지 않는다. 본 절은 라벨 정의만을 제공한다.</p></li>
<li><p><strong>사후 축 선택 금지</strong>: <span class="math inline">\(\mathbf{n}_Q\)</span>는 결과를 본 뒤 선택될 수 없으며, 축 선택은 <code>analysis_lock</code>에 사전 등록되어야 한다.</p></li>
<li><p><strong>문턱 사후 이동 금지</strong>: <span class="math inline">\(V_{\min}\)</span>의 사후 이동은 금지되며, 변경은 버전업으로만 허용된다.</p></li>
<li><p><strong>정수화 규칙 우회 금지</strong>: <span class="math inline">\((k_1,k_2,k_3)\)</span> 또는 <span class="math inline">\(\mathbf{V}\)</span>를 우회하여 라벨을 직접 부여하는 행위는 금지된다.</p></li>
<li><p><strong>혼합 금지</strong>: 서로 다른 lock_id 조합(축/정수화/문턱)의 결과를 혼합하여 하나의 라벨 결론으로 서술하는 행위는 금지된다.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-35">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 3-섹터 축(120 규약)과 정수화 규칙(최소분산+타이브레이크)을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 라벨 축 <span class="math inline">\(\mathbf{n}_Q\)</span>를 <code>analysis_lock</code>에 사전 등록하여 고정.</p></li>
<li><p>LOCK: 라벨 정의 함수 <span class="math inline">\(\mathcal{L}(\mathbf{V})\)</span>(<a data-reference="eq:S07_04_label_combined" data-reference-type="eqref" href="#eq:S07_04_label_combined">[eq:S07_04_label_combined]</a>)를 <code>analysis_lock</code>의 의미층 사상 항목으로 고정.</p></li>
<li><p>Gate: 비퇴화 문턱 <span class="math inline">\(V_{\min}\)</span> 및 라벨 판정의 PASS.rules 연결(예: <code>NEUTRAL</code> 처리) 을 <code>gate_lock</code>에 고정.</p></li>
<li><p>Gate: 축/문턱/정수화 규칙의 사후 변경 또는 혼합은 G-NT/G-LOCK에서 <code>FAIL</code>; 기호 의미 충돌은 G-SYM에서 <code>FAIL</code>.</p></li>
</ul>
<h1 data-number="10" id="이산-양성자-구조827"><span class="header-section-number">10</span> 8. 이산 양성자 구조(82+7)</h1>
<h2 class="unnumbered" id="장의-목적정의의-고정과-산출물">장의 목적(정의의 고정과 산출물)</h2>
<p>본 장은 양성자 구조를 <strong>이산 좌표 집합</strong>과 <strong>접촉 그래프</strong>로 정의하고, 그 구조가 연속체 코어 결과(6장) 및 정류/정수화 규약(5–7장)과 양립하는지 검증하는 프레임을 고정한다.
본 장의 산출물은 다음 세 묶음으로 고정한다.</p>
<ol>
<li><p><strong>좌표 산출물</strong>: 코어 82 좌표 집합 <span class="math inline">\(\mathcal{X}_{82}\)</span>, 셸 7 좌표(또는 벡터) 집합 <span class="math inline">\(\mathcal{S}_{7}\)</span>, 중심 <span class="math inline">\(\mathbf{x}_c\)</span> 및 좌표계 잠금.</p></li>
<li><p><strong>그래프 산출물</strong>: 노드 집합(82 또는 89), 간선 집합(접촉/인접성), 접촉 차수/경로/백본 등 구조 지표의 정의.</p></li>
<li><p><strong>검증 산출물</strong>: 구조 불변량, 반경/단면 정합, 상쇄-생존 규약, 레짐/잠금 무결성, 재현 패키지 및 Gate 판정 로그.</p></li>
</ol>
<p>본 장에서 “82+7”은 <em>정의로 잠긴 정수 구조</em>이며, 결과를 본 뒤 정수를 바꾸는 행위는 금지된다. 정수의 변경은 버전업으로만 허용된다.</p>
<h2 class="unnumbered" id="좌표-체계의-선언좌표단위기준점-잠금">좌표 체계의 선언(좌표/단위/기준점 잠금)</h2>
<h3 class="unnumbered" id="좌표계와-단위">좌표계와 단위</h3>
<p>이산 좌표는 3차원 유클리드 좌표 <span class="math inline">\(\mathbb{R}^3\)</span> 위에서 정의한다. 좌표의 단위는 <strong>내부 길이 단위</strong>로 고정하며, 정규화 길이 <span class="math inline">\(L_q\)</span>를 기준으로 무차원 좌표계를 사용할 수 있다. 무차원 좌표계는 다음 변환으로 정의한다.
<span class="math display">\[\tilde{\mathbf{x}} := \frac{\mathbf{x}}{L_q},
\qquad
\tilde{\mathbf{s}} := \frac{\mathbf{s}}{L_q}.
\label{eq:S08_x_tilde}\]</span>
여기서 <span class="math inline">\(L_q\)</span>는 6.1에서 잠긴 선택 길이이며, <span class="math inline">\(L_q=\lambda_C\)</span> 동일시가 잠긴 동일 버전에서만 <a data-reference="eq:S08_x_tilde" data-reference-type="eqref" href="#eq:S08_x_tilde">[eq:S08_x_tilde]</a>가 사용된다.</p>
<h3 class="unnumbered" id="중심-mathbfx_c의-잠금">중심 <span class="math inline">\(\mathbf{x}_c\)</span>의 잠금</h3>
<p>코어 구조의 중심 <span class="math inline">\(\mathbf{x}_c\)</span>를 다음으로 잠근다.
<span class="math display">\[\mathbf{x}_c\in\mathbb{R}^3,
\qquad
\mathbf{x}_c\ \text{는}\ \texttt{analysis\_lock}\ \text{에 사전 등록된 선택 규약으로 결정}.
\label{eq:S08_center_lock}\]</span>
<span class="math inline">\(\mathbf{x}_c\)</span>는 결과를 본 뒤 이동될 수 없다. 중심의 재선택은 버전업으로만 허용된다.</p>
<h3 class="unnumbered" id="코어-82-좌표-집합-mathcalx_82의-정의">코어 82 좌표 집합 <span class="math inline">\(\mathcal{X}_{82}\)</span>의 정의</h3>
<p>코어 82는 82개의 좌표 점(또는 대표점) 집합으로 정의한다.
<span class="math display">\[\mathcal{X}_{82}:=\{\mathbf{x}_i\}_{i=1}^{82},
\qquad
\mathbf{x}_i\in\mathbb{R}^3.
\label{eq:S08_X82_def}\]</span>
각 좌표의 의미(대표점이 무엇을 나타내는지: VP 대표점/접촉 중심/격자 노드 등)는 <code>canon_lock</code>의 객체 정의로 잠긴다. 좌표 집합 <span class="math inline">\(\mathcal{X}_{82}\)</span>는 단일 출처(SSOT)로 보관되며, 본문 다른 절에서 다른 좌표 집합으로 재정의하지 않는다.</p>
<h3 class="unnumbered" id="셸-7-집합-mathcals_7의-정의">셸 7 집합 <span class="math inline">\(\mathcal{S}_{7}\)</span>의 정의</h3>
<p>셸 7은 7개의 좌표(또는 벡터) 집합으로 정의한다.
<span class="math display">\[\mathcal{S}_{7}:=\{\mathbf{s}_k\}_{k=1}^{7},
\qquad
\mathbf{s}_k\in\mathbb{R}^3.
\label{eq:S08_S7_def}\]</span>
<span class="math inline">\(\mathbf{s}_k\)</span>의 의미(셸 좌표인지, 셸 방향 벡터인지, 사건 표지점인지)는 <code>canon_lock</code>의 객체 정의로 잠긴다. 셸의 상쇄-생존 규약은 이후 절에서 별도 정의로 잠기며, 본 개요에서는 “셸 7이 코어 경계 근방에서 부착된다”는 요구만을 검증 프레임에 포함한다(6.4 조건과 연결).</p>
<h2 class="unnumbered" id="그래프접촉인접성의-선언노드간선가중치-잠금">그래프(접촉/인접성)의 선언(노드/간선/가중치 잠금)</h2>
<h3 class="unnumbered" id="노드-집합">노드 집합</h3>
<p>본 장에서 사용할 노드 집합은 레짐과 목적에 따라 다음 둘 중 하나로 잠근다.
<span class="math display">\[\mathcal{V}_{82}:=\{1,2,\ldots,82\},
\qquad
\mathcal{V}_{89}:=\{1,2,\ldots,82,\,82+1,\ldots,82+7\}.
\label{eq:S08_nodes}\]</span>
<span class="math inline">\(\mathcal{V}_{82}\)</span>는 코어 내부 구조 검증에 사용되고, <span class="math inline">\(\mathcal{V}_{89}\)</span>는 코어-셸 결합 및 상쇄-생존 규약 검증에 사용된다. 동일 산출물에서 두 노드 집합을 혼합하지 않는다.</p>
<h3 class="unnumbered" id="접촉-판정-함수와-간선-집합">접촉 판정 함수와 간선 집합</h3>
<p>노드 <span class="math inline">\(i,j\)</span>에 대한 접촉 판정 함수 <span class="math inline">\(C(i,j)\)</span>를 다음으로 정의한다.
<span class="math display">\[C(i,j)\in\{0,1\},
\qquad
C(i,j)=1\ \Longleftrightarrow\ \text{사전 등록된 접촉 규약을 만족}.
\label{eq:S08_contact_pred}\]</span>
접촉 규약(거리 기반/표면 기반/완화 후 유지 접촉 기반 등)은 <code>analysis_lock</code>에 잠긴다.
간선 집합을 다음으로 정의한다.
<span class="math display">\[\mathcal{E}_c := \{(i,j)\mid i\neq j,\ C(i,j)=1\}.
\label{eq:S08_edges}\]</span>
따라서 접촉 그래프는
<span class="math display">\[\mathcal{G}_c := (\mathcal{V},\mathcal{E}_c)
\label{eq:S08_graph}\]</span>
로 정의한다. <span class="math inline">\(\mathcal{V}\)</span>는 <a data-reference="eq:S08_nodes" data-reference-type="eqref" href="#eq:S08_nodes">[eq:S08_nodes]</a>에서 선택된 노드 집합이다.</p>
<h3 class="unnumbered" id="인접-행렬과-차수">인접 행렬과 차수</h3>
<p>인접 행렬을 다음으로 정의한다.
<span class="math display">\[A_{ij}:=
\begin{cases}
1,&amp; (i,j)\in\mathcal{E}_c,\\
0,&amp; \text{otherwise}.
\end{cases}
\label{eq:S08_adj_matrix}\]</span>
각 노드의 접촉 차수(차수)를 다음으로 정의한다.
<span class="math display">\[z_i := \sum_{j\in\mathcal{V}} A_{ij}.
\label{eq:S08_degree}\]</span>
접촉 차수는 결손/목/경로 등의 파생 지표의 입력이며, 접촉 규약이 잠기지 않으면 <span class="math inline">\(A_{ij}\)</span>와 <span class="math inline">\(z_i\)</span>는 정의 불능이다.</p>
<h3 class="unnumbered" id="가중치선택적와-가중-그래프">가중치(선택적)와 가중 그래프</h3>
<p>가중 그래프를 사용할 경우 가중치 함수 <span class="math inline">\(W(i,j)\ge 0\)</span>를 다음으로 정의한다.
<span class="math display">\[W:\mathcal{E}_c\to\mathbb{R}_{\ge 0},
\qquad
(i,j)\mapsto W(i,j).
\label{eq:S08_weight}\]</span>
가중치의 정의(거리/각도/목 두께/경로 저항 등)는 <code>analysis_lock</code>에 잠긴다. 가중치를 사용하는 결론은 가중치 미사용 결론과 혼합될 수 없다.</p>
<h2 class="unnumbered" id="검증-프레임구조-불변량-gate-스택의-선언">검증 프레임(구조 불변량 + Gate 스택)의 선언</h2>
<h3 class="unnumbered" id="구조-불변량의-범주">구조 불변량의 범주</h3>
<p>본 장의 검증은 다음 네 범주의 구조 불변량을 대상으로 한다.</p>
<ol>
<li><p><strong>기하 정합 불변량</strong>: 코어 반경 정합(<span class="math inline">\(R_{82}\equiv R_p\)</span>), 단면 불변량(<span class="math inline">\(\sigma_{82}/L_q^2\equiv 4/\pi\)</span>) 등(6.4의 조건 목록과 연결).</p></li>
<li><p><strong>그래프 불변량</strong>: 연결성, 병목 지표, 최소 절단/대체 경로 민감도, 차수 분포의 레짐 일치 등.</p></li>
<li><p><strong>상쇄-생존 불변량</strong>: 셸 7의 상쇄 구성(6 상쇄 + 1 생존) 및 생존 벡터 비퇴화(<span class="math inline">\(\|\mathbf{V}\|\ge V_{\min}\)</span>) 등.</p></li>
<li><p><strong>정수/섹터 불변량</strong>: 3-섹터 정수화의 합 보존 및 최소분산 조건, 잔차 방향 라벨의 정의 가능 조건 등(7장과 연결).</p></li>
</ol>
<h3 class="unnumbered" id="gate-스택의-표준-구성">Gate 스택의 표준 구성</h3>
<p>본 장의 결론은 다음 Gate 스택의 <code>PASS</code>를 필요조건으로 갖는다.</p>
<ol>
<li><p><strong>G-SYM</strong>: 좌표/단위/지름-반지름/셀 기하 의미 충돌 없음.</p></li>
<li><p><strong>G-LOCK</strong>: 좌표 집합/접촉 규약/가중치 정의/문턱값이 동일 lock_id에 귀속됨.</p></li>
<li><p><strong>G-REG</strong>: 레짐 좌표축(차원/구동/스패닝/병목/초기조건/관측축)이 일치함.</p></li>
<li><p><strong>G-STR</strong>: 코어 82 및 셸 7의 구조 불변량(정수, 대칭, 상쇄 규약)이 유지됨.</p></li>
<li><p><strong>G-NUM</strong>: 수치 절차(접촉 판정, 투영 면적, 집계 연산)의 안정성과 반복 일치.</p></li>
<li><p><strong>G-REP</strong>: 동일 패키지로 재실행 시 동일 결과/동일 판정이 재현됨.</p></li>
<li><p><strong>G-NT</strong>: 좌표/규약/문턱/선택 규칙의 사후 변경 또는 선택 편향이 탐지되지 않음.</p></li>
</ol>
<p>Gate 스택의 세부 문턱값과 보고 형식은 <code>gate_lock</code> 및 <code>protocol_lock</code>에 사전 등록되어야 하며, 결과를 본 뒤 수정될 수 없다.</p>
<h3 class="unnumbered" id="패키지-봉인좌표그래프판정-로그">패키지 봉인(좌표/그래프/판정 로그)</h3>
<p>본 장의 좌표 산출물 <span class="math inline">\(\mathcal{X}_{82},\mathcal{S}_{7}\)</span>, 그래프 산출물 <span class="math inline">\(\mathcal{G}_c\)</span> 및 판정 로그는 동일 릴리즈에서 <code>manifest</code>와 <code>checksums</code>에 포함되어 봉인되어야 한다. 봉인되지 않은 산출물은 결론 자격을 부여하지 않는다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-36">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(\mathcal{X}_{82}\)</span>, <span class="math inline">\(\mathcal{S}_{7}\)</span>, <span class="math inline">\(\mathbf{x}_c\)</span> 및 좌표 정규화(<span class="math inline">\(L_q\)</span> 기준) 규약을 <code>canon_lock</code>/<code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 접촉 판정 <span class="math inline">\(C(i,j)\)</span>, 그래프 <span class="math inline">\(\mathcal{G}_c\)</span>, 차수 <span class="math inline">\(z_i\)</span>, (선택) 가중치 <span class="math inline">\(W(i,j)\)</span> 정의를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 구조 검증은 G-SYM/G-LOCK/G-REG/G-STR/G-NUM/G-REP/G-NT 스택 <code>PASS</code>를 필요조건으로 연결.</p></li>
<li><p>Gate: 좌표/규약/문턱의 사후 변경 또는 선택 편향은 G-NT에서 즉시 <code>FAIL</code>.</p></li>
<li><p>Gate: 봉인(manifest/checksums/registry_snapshot) 없는 좌표/그래프/로그는 G-REP에서 <code>FAIL</code> 또는 <code>INCONCLUSIVE</code>.</p></li>
</ul>
<h2 data-number="10.1" id="코어-좌표계층d2-접촉-그래프"><span class="header-section-number">10.1</span> 8.1 82-코어 좌표/계층(d2) + 접촉 그래프</h2>
<h3 data-number="10.1.1" id="산출물좌표-파일-계층-라벨-그래프"><span class="header-section-number">10.1.1</span> 8.1.1 산출물(좌표 파일 + 계층 라벨 + 그래프)</h3>
<p>본 절의 산출물은 다음 세 묶음으로 고정한다.</p>
<ol>
<li><p><strong>좌표 집합</strong>:
<span class="math display">\[\mathcal{X}_{82}:=\{\mathbf{x}_i\}_{i=1}^{82},\qquad \mathbf{x}_i\in\mathbb{R}^3,
  \label{eq:S08_01_X82}\]</span>
및 중심 <span class="math inline">\(\mathbf{x}_c\)</span>.</p></li>
<li><p><strong>계층(거리) 라벨</strong>:
접촉 그래프 위의 최단거리 계층 함수
<span class="math display">\[d:\{1,\ldots,82\}\to\mathbb{Z}_{\ge 0},
  \qquad
  d(i):=\mathrm{dist}_{\mathcal{G}_c}(i,\mathcal{R}_0),
  \label{eq:S08_01_layer_d}\]</span>
및 <span class="math inline">\(d=2\)</span> 계층 집합
<span class="math display">\[\mathcal{L}_2:=\{\,i\mid d(i)=2\,\}.
  \label{eq:S08_01_L2}\]</span></p></li>
<li><p><strong>접촉 그래프</strong>:
<span class="math display">\[\mathcal{G}_c:=(\mathcal{V}_{82},\mathcal{E}_c),
  \qquad
  \mathcal{V}_{82}:=\{1,2,\ldots,82\}.
  \label{eq:S08_01_Gc}\]</span></p></li>
</ol>
<p>좌표, 계층, 그래프는 동일 <code>analysis_lock</code> 버전에 귀속되며, 동일 산출물에서 서로 다른 규약을 혼합하지 않는다.</p>
<h3 data-number="10.1.2" id="입력lock-길이반경절차-파라미터"><span class="header-section-number">10.1.2</span> 8.1.2 입력(LOCK): 길이/반경/절차 파라미터</h3>
<p>본 절의 구성 절차는 다음 입력들이 잠겨 있을 때에만 정의가 성립한다.</p>
<ol>
<li><p>코어 노드 수:
<span class="math display">\[N_{\mathrm{core}}:=82.
  \label{eq:S08_01_Ncore}\]</span></p></li>
<li><p>정규화 길이:
<span class="math display">\[L_q\ \text{(잠김)},\qquad \tilde{\mathbf{x}}:=\mathbf{x}/L_q.
  \label{eq:S08_01_Lq_norm}\]</span></p></li>
<li><p>코어 반경:
<span class="math display">\[R_p\ \text{(잠김)}.
  \label{eq:S08_01_Rp_lock}\]</span></p></li>
<li><p>최소 분리 길이(비침투/중복 방지):
<span class="math display">\[d_{\min}&gt;0\ \text{(잠김)}.
  \label{eq:S08_01_dmin}\]</span></p></li>
<li><p>접촉 판정 길이:
<span class="math display">\[d_c:=\gamma_c\,d_{\min},
  \qquad
  \gamma_c&gt;1\ \text{(잠김)}.
  \label{eq:S08_01_dc}\]</span></p></li>
<li><p>후보점 생성 격자 스텝과 경계:
<span class="math display">\[h_{\mathrm{grid}}&gt;0\ \text{(잠김)},\qquad
  B\in\mathbb{Z}_{&gt;0}\ \text{(잠김)}.
  \label{eq:S08_01_grid_params}\]</span></p></li>
<li><p>안정화(완화) 허용오차 및 반복 횟수:
<span class="math display">\[\varepsilon_{\mathrm{pos}}&gt;0\ \text{(잠김)},\qquad
  K_{\max}\in\mathbb{Z}_{&gt;0}\ \text{(잠김)}.
  \label{eq:S08_01_relax_params}\]</span></p></li>
<li><p>계층 루트 집합 크기:
<span class="math display">\[N_0\in\{1,2,\ldots,82\}\ \text{(잠김)}.
  \label{eq:S08_01_N0}\]</span></p></li>
<li><p>타이브레이크(결정 규칙):
동일 점수 동률 시 선택 순서를 결정하는 규칙 <code>TB</code>를 잠근다(예: 사전식(lex) 정렬, 인덱스 우선 등).</p></li>
</ol>
<p>위 항목 중 하나라도 미잠금이면 본 절의 산출물은 정의 불능이며 <code>INCONCLUSIVE</code>로 판정한다.</p>
<h3 data-number="10.1.3" id="후보점-집합-mathcalc-생성완전-결정-절차"><span class="header-section-number">10.1.3</span> 8.1.3 후보점 집합 <span class="math inline">\(\mathcal{C}\)</span> 생성(완전 결정 절차)</h3>
<p>후보점은 정수 격자 인덱스의 집합을 실공간으로 사상하여 생성한다.</p>
<h4 data-number="10.1.3.1" id="정수-인덱스-집합"><span class="header-section-number">10.1.3.1</span> 8.1.3.1 정수 인덱스 집합</h4>
<p>정수 인덱스 집합을 다음으로 정의한다.
<span class="math display">\[\mathcal{I}:=\{(u,v,w)\in\mathbb{Z}^3\mid -B\le u,v,w\le B\}.
\label{eq:S08_01_Iset}\]</span></p>
<h4 data-number="10.1.3.2" id="격자-사상과-후보점"><span class="header-section-number">10.1.3.2</span> 8.1.3.2 격자 사상과 후보점</h4>
<p>사상을 다음으로 정의한다.
<span class="math display">\[\mathbf{y}(u,v,w):=h_{\mathrm{grid}}\,(u,v,w).
\label{eq:S08_01_grid_map}\]</span>
후보점 집합 <span class="math inline">\(\mathcal{C}\)</span>를 다음 필터로 정의한다.
<span class="math display">\[\mathcal{C}
:=
\left\{
\mathbf{y}(u,v,w)\ \middle|\ (u,v,w)\in\mathcal{I},\
0&lt;\|\mathbf{y}(u,v,w)\|\le R_p
\right\}.
\label{eq:S08_01_candidates}\]</span>
<span class="math inline">\(\|\mathbf{y}\|=0\)</span> (중심점)은 본 절에서 기본적으로 제외한다. 중심점을 포함해야 하는 버전은 <code>analysis_lock</code>의 <code>include_center</code> 플래그로만 허용되며, 플래그가 <code>false</code>이면 중심은 항상 제외된다.</p>
<h4 data-number="10.1.3.3" id="후보점-정렬결정-순서"><span class="header-section-number">10.1.3.3</span> 8.1.3.3 후보점 정렬(결정 순서)</h4>
<p>후보점의 결정 순서를 다음 키로 정렬하여 고정한다.
<span class="math display">\[\mathrm{key}(\mathbf{y}) := \Bigl(\|\mathbf{y}\|,\ y_x,\ y_y,\ y_z\Bigr),
\label{eq:S08_01_candidate_key}\]</span>
여기서 <span class="math inline">\(y_x,y_y,y_z\)</span>는 <span class="math inline">\(\mathbf{y}\)</span>의 성분이다. 정렬은 (1) 반경 오름차순, (2) 사전식 성분 오름차순으로 고정한다.</p>
<h3 data-number="10.1.4" id="점-선택-규칙결정적-poisson-간격-샘플링"><span class="header-section-number">10.1.4</span> 8.1.4 82점 선택 규칙(결정적 Poisson-간격 샘플링)</h3>
<p>좌표 집합 <span class="math inline">\(\mathcal{X}_{82}\)</span>는 후보점 <span class="math inline">\(\mathcal{C}\)</span>에서 82점을 선택하여 구성한다. 선택 규칙은 “최소 분리 길이”와 “최대 분산 억제(균등 분포)”를 동시에 만족하도록 고정한다.</p>
<h4 data-number="10.1.4.1" id="최소-분리-조건"><span class="header-section-number">10.1.4.1</span> 8.1.4.1 최소 분리 조건</h4>
<p>선택된 점들 <span class="math inline">\(\mathbf{x}_i\)</span>는 다음을 만족해야 한다.
<span class="math display">\[\|\mathbf{x}_i-\mathbf{x}_j\|\ge d_{\min}
\qquad
(1\le i&lt;j\le 82).
\label{eq:S08_01_separation}\]</span></p>
<h4 data-number="10.1.4.2" id="점수-함수최소거리-최대화"><span class="header-section-number">10.1.4.2</span> 8.1.4.2 점수 함수(최소거리 최대화)</h4>
<p>부분 집합 <span class="math inline">\(\mathcal{S}\subset\mathcal{C}\)</span>가 주어졌을 때, 후보점 <span class="math inline">\(\mathbf{y}\in\mathcal{C}\setminus\mathcal{S}\)</span>의 점수를 다음으로 정의한다.
<span class="math display">\[\mathrm{score}(\mathbf{y};\mathcal{S})
:=
\min_{\mathbf{z}\in\mathcal{S}}\|\mathbf{y}-\mathbf{z}\|.
\label{eq:S08_01_score}\]</span>
점수는 “이미 선택된 점들로부터의 최소거리”이며, 점수가 큰 후보는 더 균등한 분포를 형성하는 방향으로 선택된다.</p>
<h4 data-number="10.1.4.3" id="선택-알고리즘완전-절차"><span class="header-section-number">10.1.4.3</span> 8.1.4.3 선택 알고리즘(완전 절차)</h4>
<p>선택은 다음 결정 절차로 고정한다.</p>
<pre><code>ALG-CORE82-SELECT (inputs: C, d_min, N_core=82, TB)

S := empty set
1) 초기 선택:
   - C를 key(y)로 정렬
   - 첫 원소 y0를 S에 추가 (가장 작은 반경, 동률이면 사전식)
2) 반복 선택 (|S| &lt; 82):
   - 후보들 중 separation 조건을 위반하지 않는 집합 C_ok를 만든다:
       C_ok := { y in C \ S | for all z in S: ||y-z|| &gt;= d_min }
   - 만약 C_ok가 비어 있으면: FAIL-CORE82-NOTENOUGH
   - 각 y in C_ok에 대해 score(y;S)를 계산한다.
   - score가 최대인 y*를 선택한다.
   - 동률이면 TB(타이브레이크)로 하나를 선택한다.
   - y*를 S에 추가한다.
3) 출력:
   - S의 원소를 {x_i}_{i=1..82}로 인덱싱하여 X82를 구성한다.</code></pre>
<p>위 알고리즘은 난수 없이 결정적으로 동작한다. 알고리즘이 82개를 채우지 못하면 본 절의 구성은 실패이며, 이후 단계(계층/그래프)로 진행하지 않는다.</p>
<h3 data-number="10.1.5" id="스케일-정합경계-반경-r_p로의-정규화"><span class="header-section-number">10.1.5</span> 8.1.5 스케일 정합(경계 반경 <span class="math inline">\(R_p\)</span>로의 정규화)</h3>
<p>선택된 좌표 집합 <span class="math inline">\(\mathcal{X}_{82}\)</span>는 반경 정합을 위해 단일 스케일 팩터로 정규화한다.</p>
<h4 data-number="10.1.5.1" id="경계-후보-집합과-집계-반경"><span class="header-section-number">10.1.5.1</span> 8.1.5.1 경계 후보 집합과 집계 반경</h4>
<p>각 점의 반경을 <span class="math inline">\(r_i:=\|\mathbf{x}_i-\mathbf{x}_c\|\)</span>로 정의한다. 중심은 기본적으로
<span class="math display">\[\mathbf{x}_c:=\mathbf{0}
\label{eq:S08_01_center_zero}\]</span>
로 잠그며, 다른 중심 선택은 버전업으로만 허용한다.</p>
<p>경계 후보 집합을 다음으로 정의한다. <span class="math inline">\(K_b\)</span>는 잠긴 정수이다.
<span class="math display">\[K_b\in\{1,\ldots,82\}\ \text{(잠김)},\qquad
\mathcal{B}_{82}:=\text{반경 $r_i$가 큰 순서로 상위 $K_b$개의 인덱스 집합}.
\label{eq:S08_01_boundary_set}\]</span>
집계 반경을 다음으로 정의한다.
<span class="math display">\[R_{82}:=\mathrm{Agg}\bigl(\{r_i\}_{i\in\mathcal{B}_{82}}\bigr),
\label{eq:S08_01_R82_agg}\]</span>
여기서 <span class="math inline">\(\mathrm{Agg}\)</span>는 <code>analysis_lock</code>에 잠긴 집계 연산자(예: 중앙값, 평균)이다.</p>
<h4 data-number="10.1.5.2" id="스케일-팩터와-좌표-재정의"><span class="header-section-number">10.1.5.2</span> 8.1.5.2 스케일 팩터와 좌표 재정의</h4>
<p>스케일 팩터를 다음으로 정의한다.
<span class="math display">\[s:=\frac{R_p}{R_{82}}.
\label{eq:S08_01_scale_factor}\]</span>
좌표를 다음으로 재정의한다.
<span class="math display">\[\mathbf{x}_i \leftarrow s\,\mathbf{x}_i
\qquad (i=1,\ldots,82).
\label{eq:S08_01_rescale}\]</span>
재스케일 후에는 <span class="math inline">\(R_{82}\equiv R_p\)</span>가 정의에 의해 성립한다(정의적 정합). 단, 이 정합은 <span class="math inline">\(\mathrm{Agg}\)</span>와 <span class="math inline">\(\mathcal{B}_{82}\)</span>가 잠겨 있을 때만 의미를 가진다.</p>
<h3 data-number="10.1.6" id="안정화완화-절차-최소-분리와-경계-제한의-동시-만족"><span class="header-section-number">10.1.6</span> 8.1.6 안정화(완화) 절차: 최소 분리와 경계 제한의 동시 만족</h3>
<p>재스케일 후에도 <a data-reference="eq:S08_01_separation" data-reference-type="eqref" href="#eq:S08_01_separation">[eq:S08_01_separation]</a> 및 <span class="math inline">\(\|\mathbf{x}_i\|\le R_p\)</span>를 강제하기 위해, 다음 결정적 완화 절차를 수행한다.</p>
<h4 data-number="10.1.6.1" id="위반량-정의"><span class="header-section-number">10.1.6.1</span> 8.1.6.1 위반량 정의</h4>
<p>쌍 위반량을 다음으로 정의한다.
<span class="math display">\[\Delta_{ij}:=\max\!\bigl(0,\ d_{\min}-\|\mathbf{x}_i-\mathbf{x}_j\|\bigr),
\qquad (i&lt;j).
\label{eq:S08_01_pair_violation}\]</span>
경계 위반량을 다음으로 정의한다.
<span class="math display">\[\Delta_i^{(R)}:=\max\!\bigl(0,\ \|\mathbf{x}_i\|-R_p\bigr).
\label{eq:S08_01_rad_violation}\]</span>
전체 위반량을 다음으로 정의한다.
<span class="math display">\[\Delta_{\max}
:=
\max\left(
\max_{i&lt;j}\Delta_{ij},
\max_i \Delta_i^{(R)}
\right).
\label{eq:S08_01_Dmax}\]</span></p>
<h4 data-number="10.1.6.2" id="결정적-투영-분리-완화-알고리즘"><span class="header-section-number">10.1.6.2</span> 8.1.6.2 결정적 투영-분리 완화 알고리즘</h4>
<pre><code>ALG-CORE82-RELAX (inputs: X82, d_min, R_p, eps_pos, K_max)

for iter = 1..K_max:
  # (A) 쌍 분리 투영
  for i = 1..82:
    for j = i+1..82:
      d = ||x_i - x_j||
      if d &lt; d_min:
        u = (x_i - x_j) / max(d, tiny)   # tiny&gt;0은 고정된 수치 보호 상수
        shift = 0.5 * (d_min - d)
        x_i := x_i + shift * u
        x_j := x_j - shift * u

  # (B) 반경 경계 투영
  for i = 1..82:
    r = ||x_i||
    if r &gt; R_p:
      x_i := (R_p / r) * x_i

  # (C) 종료 판정
  compute D_max
  if D_max &lt;= eps_pos:
    break

if D_max &gt; eps_pos:
  FAIL-CORE82-NOCONVERGE</code></pre>
<p>위 알고리즘은 업데이트 순서가 인덱스 순서로 고정되어 있으며, <code>tiny</code>는 고정된 수치 보호 상수로 잠긴다. 종료 후에는 다음이 보장되어야 한다.
<span class="math display">\[\|\mathbf{x}_i-\mathbf{x}_j\|\ge d_{\min}-\varepsilon_{\mathrm{pos}},
\qquad
\|\mathbf{x}_i\|\le R_p,
\label{eq:S08_01_relax_guarantee}\]</span>
그렇지 않으면 <code>FAIL</code>이다.</p>
<h3 data-number="10.1.7" id="접촉-그래프-구성거리-기반-판정의-단일-규약"><span class="header-section-number">10.1.7</span> 8.1.7 접촉 그래프 구성(거리 기반 판정의 단일 규약)</h3>
<p>접촉 판정은 좌표로부터 결정되는 단일 규약으로 고정한다.</p>
<h4 data-number="10.1.7.1" id="접촉-판정-함수"><span class="header-section-number">10.1.7.1</span> 8.1.7.1 접촉 판정 함수</h4>
<p>접촉 판정 함수 <span class="math inline">\(C(i,j)\)</span>를 다음으로 정의한다.
<span class="math display">\[C(i,j):=
\begin{cases}
1,&amp; \|\mathbf{x}_i-\mathbf{x}_j\|\le d_c,\\
0,&amp; \text{otherwise},
\end{cases}
\qquad (i\neq j).
\label{eq:S08_01_contact_pred}\]</span>
여기서 <span class="math inline">\(d_c\)</span>는 <a data-reference="eq:S08_01_dc" data-reference-type="eqref" href="#eq:S08_01_dc">[eq:S08_01_dc]</a>로 잠긴 접촉 판정 길이이며, 결과를 본 뒤 조정될 수 없다.</p>
<h4 data-number="10.1.7.2" id="간선-집합과-인접-행렬"><span class="header-section-number">10.1.7.2</span> 8.1.7.2 간선 집합과 인접 행렬</h4>
<p>간선 집합을 다음으로 정의한다.
<span class="math display">\[\mathcal{E}_c:=\{(i,j)\mid 1\le i&lt;j\le 82,\ C(i,j)=1\}.
\label{eq:S08_01_edges}\]</span>
인접 행렬을 다음으로 정의한다.
<span class="math display">\[A_{ij}:=
\begin{cases}
1,&amp; (i,j)\in\mathcal{E}_c\ \text{또는}\ (j,i)\in\mathcal{E}_c,\\
0,&amp; \text{otherwise},
\end{cases}
\qquad
A_{ii}:=0.
\label{eq:S08_01_adj}\]</span>
차수를 다음으로 정의한다.
<span class="math display">\[z_i:=\sum_{j=1}^{82}A_{ij}.
\label{eq:S08_01_degree}\]</span></p>
<h4 data-number="10.1.7.3" id="연결성-조건최소-요구"><span class="header-section-number">10.1.7.3</span> 8.1.7.3 연결성 조건(최소 요구)</h4>
<p>그래프가 단일 코어로 기능하려면 연결 그래프여야 한다. 연결성 지시변수를 다음으로 정의한다.
<span class="math display">\[\chi_{\mathrm{conn}}:=
\begin{cases}
1,&amp; \mathcal{G}_c\ \text{가 연결 그래프},\\
0,&amp; \text{otherwise}.
\end{cases}
\label{eq:S08_01_conn}\]</span>
<span class="math inline">\(\chi_{\mathrm{conn}}=0\)</span>이면 <code>FAIL-CORE82-DISCONNECTED</code>이다.</p>
<h3 data-number="10.1.8" id="계층d2-구성-루트-집합-mathcalr_0와-bfs-거리"><span class="header-section-number">10.1.8</span> 8.1.8 계층(d2) 구성: 루트 집합 <span class="math inline">\(\mathcal{R}_0\)</span>와 BFS 거리</h3>
<p>계층은 접촉 그래프 위의 최단거리로 정의한다.</p>
<h4 data-number="10.1.8.1" id="루트-집합-mathcalr_0의-결정"><span class="header-section-number">10.1.8.1</span> 8.1.8.1 루트 집합 <span class="math inline">\(\mathcal{R}_0\)</span>의 결정</h4>
<p>루트 집합의 크기 <span class="math inline">\(N_0\)</span>는 <a data-reference="eq:S08_01_N0" data-reference-type="eqref" href="#eq:S08_01_N0">[eq:S08_01_N0]</a>로 잠겨 있다. 루트 집합은 “가장 작은 반경” 기준으로 결정한다.
<span class="math display">\[r_i:=\|\mathbf{x}_i\|,
\qquad
\mathcal{R}_0:=\text{반경 $r_i$가 작은 순서로 상위 $N_0$개의 인덱스 집합}.
\label{eq:S08_01_rootset}\]</span>
동률은 사전 등록된 타이브레이크(<code>TB</code>)로 결정한다.</p>
<h4 data-number="10.1.8.2" id="계층-함수-di"><span class="header-section-number">10.1.8.2</span> 8.1.8.2 계층 함수 <span class="math inline">\(d(i)\)</span></h4>
<p>접촉 그래프 <span class="math inline">\(\mathcal{G}_c\)</span> 위에서 루트 집합까지의 최단거리(간선 수)를 다음으로 정의한다.
<span class="math display">\[d(i):=\min_{r\in\mathcal{R}_0}\mathrm{dist}_{\mathcal{G}_c}(i,r),
\qquad
d(r)=0\ (r\in\mathcal{R}_0).
\label{eq:S08_01_di_def}\]</span>
계층 집합을
<span class="math display">\[\mathcal{L}_\ell:=\{\,i\mid d(i)=\ell\,\},
\qquad \ell=0,1,2,\ldots
\label{eq:S08_01_Lell}\]</span>
로 정의한다. 이때 본 절의 “d2”는 <span class="math inline">\(\mathcal{L}_2\)</span>로 고정한다(<a data-reference="eq:S08_01_L2" data-reference-type="eqref" href="#eq:S08_01_L2">[eq:S08_01_L2]</a>).</p>
<h4 data-number="10.1.8.3" id="계층-완결성-조건"><span class="header-section-number">10.1.8.3</span> 8.1.8.3 계층 완결성 조건</h4>
<p>모든 노드가 루트로부터 도달 가능해야 하므로,
<span class="math display">\[\max_{1\le i\le 82} d(i) &lt; \infty
\label{eq:S08_01_layer_finite}\]</span>
가 요구된다. 이는 <a data-reference="eq:S08_01_conn" data-reference-type="eqref" href="#eq:S08_01_conn">[eq:S08_01_conn]</a>의 연결성과 동치이며, 위반 시 <code>FAIL-CORE82-DISCONNECTED</code>이다.</p>
<h3 data-number="10.1.9" id="저장-형식좌표계층그래프의-단일-출처"><span class="header-section-number">10.1.9</span> 8.1.9 저장 형식(좌표/계층/그래프의 단일 출처)</h3>
<p>본 절의 산출물은 다음 파일들로 저장되며, 동일 릴리즈의 <code>manifest</code>와 <code>checksums</code>에 포함되어 봉인되어야 한다.</p>
<ol>
<li><p><code>X82.csv</code>: <span class="math inline">\((i,x_i,y_i,z_i,r_i)\)</span>.</p></li>
<li><p><code>G82.edgelist</code>: <span class="math inline">\((i,j)\)</span> 간선 목록.</p></li>
<li><p><code>layers82.csv</code>: <span class="math inline">\((i,d(i))\)</span> 및 <span class="math inline">\(\ell\)</span>별 노드 수 <span class="math inline">\(|\mathcal{L}_\ell|\)</span>.</p></li>
<li><p><code>params82.yaml</code>: <span class="math inline">\(R_p,L_q,d_{\min},\gamma_c,h_{\mathrm{grid}},B,\varepsilon_{\mathrm{pos}},K_{\max},N_0,K_b,\mathrm{Agg},\texttt{TB}\)</span>.</p></li>
</ol>
<p>봉인되지 않은 산출물은 결론 자격을 갖지 못한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-37">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(N_{\mathrm{core}}=82\)</span>, <span class="math inline">\(R_p\)</span>, <span class="math inline">\(L_q\)</span>, <span class="math inline">\(d_{\min}\)</span>, <span class="math inline">\(\gamma_c\)</span>, <span class="math inline">\(h_{\mathrm{grid}}\)</span>, <span class="math inline">\(B\)</span>, <span class="math inline">\(\varepsilon_{\mathrm{pos}}\)</span>, <span class="math inline">\(K_{\max}\)</span>, <span class="math inline">\(N_0\)</span>, <span class="math inline">\(K_b\)</span>, <span class="math inline">\(\mathrm{Agg}\)</span>, <code>TB</code>를 <code>analysis_lock</code>/<code>canon_lock</code>에 고정.</p></li>
<li><p>Gate: 점 선택 실패(<code>FAIL-CORE82-NOTENOUGH</code>), 완화 실패(<code>FAIL-CORE82-NOCONVERGE</code>), 비연결(<code>FAIL-CORE82-DISCONNECTED</code>)은 즉시 <code>FAIL</code>.</p></li>
<li><p>Gate: 의미/단위/셀 기하 충돌은 G-SYM에서 <code>FAIL</code>; lock_id 혼합은 G-LOCK에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 좌표/그래프/계층 파일이 <code>manifest+checksums</code>로 봉인되지 않으면 G-REP에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
<li><p>Gate: 파라미터 사후 변경 또는 타이브레이크 사후 선택은 G-NT에서 <code>FAIL</code>.</p></li>
</ul>
<h2 data-number="10.2" id="셸-기본-구조"><span class="header-section-number">10.2</span> 8.2 7-셸 기본 구조</h2>
<h2 class="unnumbered" id="셸-카운트7의-기하학적-최소성-잔여-일치">셸 카운트(7)의 기하학적 최소성 + 잔여 일치</h2>
<p>본 절에서 <span class="math inline">\(N_{\mathrm{shell}}=7\)</span>은 <em>임의 선택</em>이 아니라, (i) 3차원 상쇄(취소) 규약과 (ii) 하나의 생존 벡터(라벨 입력)를 <strong>동시에</strong> 만족시키는 최소 정수로서 고정된다. 이 최소성은 8.2.1의 "2 페어 + 4 쿼드 + 1 생존" 정의를 선행 정당화한다.</p>
<h4 data-number="10.2.0.1" id="i-상쇄-원소의-기하학적-최소성"><span class="header-section-number">10.2.0.1</span> (I) 상쇄 원소의 기하학적 최소성</h4>
<p>셸은 “가능한 한 많이 상쇄”되면서도(안정) “완전히 0이 되지 않아야” 한다(라벨). 3차원에서 편향을 줄이는 상쇄는 다음 두 종류가 자연스럽다.</p>
<ol>
<li><p><strong>페어(pair) 상쇄(2-원소):</strong> <span class="math inline">\((\mathbf{s},-\mathbf{s})\)</span>는 어떤 좌표계에서도 완전 상쇄한다.</p></li>
<li><p><strong>쿼드(quad) 상쇄(4-원소):</strong> 세 벡터의 합-제로 상쇄는 항상 한 평면에 놓이므로 3차원 등방 상쇄를 강제하지 못한다. 반면 정사면체 방향의 네 단위벡터 <span class="math inline">\(\{\mathbf{q}_i\}_{i=1}^4\)</span>는
<span class="math display">\[\mathbf{q}_1+\mathbf{q}_2+\mathbf{q}_3+\mathbf{q}_4=\mathbf{0},
  \qquad
  \mathbf{q}_i\cdot\mathbf{q}_j=-\frac{1}{3}\ (i\neq j)
  \label{eq:S08_02_tetra_cancel}\]</span>
을 만족하는 대표적(등방) 상쇄 원소를 제공한다.</p></li>
</ol>
<p>따라서 “페어 1개”와 “쿼드 1개”를 <strong>동시에</strong> 포함해 상쇄를 최대화하려면 최소 <span class="math inline">\(2+4=6\)</span>개의 셸 벡터가 필요하다.</p>
<h4 data-number="10.2.0.2" id="ii-생존-벡터-1개"><span class="header-section-number">10.2.0.2</span> (II) 생존 벡터 1개</h4>
<p>전하/전자 라벨을 담기 위해, 상쇄되지 않는 생존 벡터가 최소 1개 필요하다(8.2.1의 정의). 따라서
<span class="math display">\[\boxed{N_{\mathrm{shell}}=2+4+1=7.}
\label{eq:S08_02_shell7_minimal}\]</span></p>
<h4 data-number="10.2.0.3" id="iii-잔여residual-일치산술-체크"><span class="header-section-number">10.2.0.3</span> (III) 잔여(Residual) 일치(산술 체크)</h4>
<p>한편, 총 구조 카운트 <span class="math inline">\(N_{\mathrm{str}}\)</span>와 코어 카운트 <span class="math inline">\(N_{\mathrm{core}}\)</span>가 <em>독립적으로</em> 잠기면, 셸 카운트는 산술적으로도
<span class="math display">\[N_{\mathrm{shell}}=N_{\mathrm{str}}-N_{\mathrm{core}}
\label{eq:S08_02_shell_residual}\]</span>
로 강제된다. 본 버전에서는 <span class="math inline">\(N_{\mathrm{str}}=89\)</span> (7.2의 구조 카운트)와 <span class="math inline">\(N_{\mathrm{core}}=82\)</span> (8.1의 코어 구성)이 잠겨 있으므로 잔여는 <span class="math inline">\(7\)</span>이며, 이는 <a data-reference="eq:S08_02_shell7_minimal" data-reference-type="eqref" href="#eq:S08_02_shell7_minimal">[eq:S08_02_shell7_minimal]</a>의 최소성 결과와 일치한다.</p>
<h3 data-number="10.2.1" id="목적-5"><span class="header-section-number">10.2.1</span> 8.2.1 목적</h3>
<p>본 절은 셸 7의 내부 구조를 “2 페어 + 4 쿼드 + 1 생존”의 조합 구조로 <strong>정의</strong>로 고정한다. 본 절은 해석을 수행하지 않으며, (i) 셸 벡터(또는 좌표) 집합, (ii) 파티셔닝(분할) 규칙, (iii) 상쇄 판정 규칙, (iv) 생존 항의 정의를 고정한다.
본 절의 정의가 잠기지 않으면, 이후 절의 전하/전자 라벨 및 사건율/질량 유도에서 사용하는 “생존 벡터”가 정의 불능이다.</p>
<h3 data-number="10.2.2" id="입력lock-셸-7-벡터-집합과-좌표계"><span class="header-section-number">10.2.2</span> 8.2.2 입력(LOCK): 셸 7 벡터 집합과 좌표계</h3>
<p>셸 7을 다음 집합으로 정의한다.
<span class="math display">\[\mathcal{S}_7:=\{\mathbf{s}_k\}_{k=1}^{7},
\qquad
\mathbf{s}_k\in\mathbb{R}^3.
\label{eq:S08_02_S7}\]</span>
<span class="math inline">\(\mathbf{s}_k\)</span>의 의미는 다음 둘 중 하나로 잠겨야 한다(택일 잠금).</p>
<ol>
<li><p><strong>좌표 모드(<code>SHELL-POINT</code>)</strong>: <span class="math inline">\(\mathbf{s}_k\)</span>는 코어 중심 <span class="math inline">\(\mathbf{x}_c\)</span>를 기준으로 한 셸의 대표점(좌표)이다.</p></li>
<li><p><strong>벡터 모드(<code>SHELL-VEC</code>)</strong>: <span class="math inline">\(\mathbf{s}_k\)</span>는 셸의 방향/기여를 나타내는 벡터이다.</p></li>
</ol>
<p>어느 모드를 채택하든, 좌표계(기준축, 단위, 정규화)는 <code>analysis_lock</code>에 잠겨야 하며, 결과를 본 뒤 교체될 수 없다.</p>
<h3 data-number="10.2.3" id="상쇄-판정의-표준-정의상쇄-연산자"><span class="header-section-number">10.2.3</span> 8.2.3 상쇄 판정의 표준 정의(상쇄 연산자)</h3>
<p>셸 구조의 “상쇄”는 두 벡터의 합이 충분히 작아지는 것을 뜻하며, 상쇄 판정은 문턱 기반으로 정의된다.</p>
<h4 data-number="10.2.3.1" id="상쇄-문턱"><span class="header-section-number">10.2.3.1</span> 8.2.3.1 상쇄 문턱</h4>
<p>상쇄 문턱 <span class="math inline">\(s_{\min}&gt;0\)</span>를 다음으로 잠근다.
<span class="math display">\[s_{\min}&gt;0,
\qquad
s_{\min}\ \text{는}\ \texttt{gate\_lock}\ \text{에 사전 등록}.
\label{eq:S08_02_smin}\]</span></p>
<h4 data-number="10.2.3.2" id="페어-상쇄-판정"><span class="header-section-number">10.2.3.2</span> 8.2.3.2 페어 상쇄 판정</h4>
<p>서로 다른 두 인덱스 <span class="math inline">\(a\neq b\)</span>에 대해 페어 상쇄 판정 함수를 다음으로 정의한다.
<span class="math display">\[\mathrm{CancelPair}(a,b)
:=
\begin{cases}
1,&amp; \|\mathbf{s}_a+\mathbf{s}_b\|\le s_{\min},\\
0,&amp; \text{otherwise}.
\end{cases}
\label{eq:S08_02_cancel_pair}\]</span>
이 정의는 <strong>상쇄의 운영 정의</strong>이며, 결과를 본 뒤 바뀌지 않는다.</p>
<h4 data-number="10.2.3.3" id="쿼드-상쇄-판정"><span class="header-section-number">10.2.3.3</span> 8.2.3.3 쿼드 상쇄 판정</h4>
<p>서로 다른 네 인덱스 <span class="math inline">\((a,b,c,d)\)</span>에 대해 쿼드 상쇄 판정 함수를 다음으로 정의한다.
<span class="math display">\[\mathrm{CancelQuad}(a,b,c,d)
:=
\begin{cases}
1,&amp; \|\mathbf{s}_a+\mathbf{s}_b+\mathbf{s}_c+\mathbf{s}_d\|\le s_{\min},\\
0,&amp; \text{otherwise}.
\end{cases}
\label{eq:S08_02_cancel_quad}\]</span>
쿼드 상쇄 판정은 “네 항의 합이 상쇄 문턱 이내”임을 의미한다.</p>
<h3 data-number="10.2.4" id="페어-4-쿼드-1-생존의-구조적-정의"><span class="header-section-number">10.2.4</span> 8.2.4 2 페어 + 4 쿼드 + 1 생존의 구조적 정의</h3>
<p>본 절의 핵심은 <span class="math inline">\(\{1,\ldots,7\}\)</span>의 인덱스를 다음 세 부분으로 <strong>분할(partition)</strong>하는 규칙을 정의하는 것이다.
<span class="math display">\[\{1,2,\ldots,7\}
=
P_1 \,\dot\cup\, P_2 \,\dot\cup\, Q \,\dot\cup\, \{u\}.
\label{eq:S08_02_partition}\]</span>
여기서
<span class="math display">\[|P_1|=2,\quad |P_2|=2,\quad |Q|=4,\quad u\in\{1,\ldots,7\},
\label{eq:S08_02_sizes}\]</span>
이며 <span class="math inline">\(\dot\cup\)</span>는 서로소 합(겹침 없음)을 의미한다. <span class="math inline">\(P_1,P_2\)</span>는 두 개의 페어, <span class="math inline">\(Q\)</span>는 하나의 쿼드, <span class="math inline">\(\{u\}\)</span>는 생존 인덱스이다.</p>
<h4 data-number="10.2.4.1" id="페어의-정의"><span class="header-section-number">10.2.4.1</span> 8.2.4.1 “2 페어”의 정의</h4>
<p>두 페어는 다음 조건을 만족하는 인덱스 쌍으로 정의한다.
<span class="math display">\[P_1=\{a_1,b_1\},\qquad P_2=\{a_2,b_2\},
\qquad
\mathrm{CancelPair}(a_1,b_1)=1,\quad \mathrm{CancelPair}(a_2,b_2)=1.
\label{eq:S08_02_two_pairs}\]</span>
즉, 두 페어는 각각 상쇄 문턱 <span class="math inline">\(s_{\min}\)</span> 이내로 상쇄되어야 한다.</p>
<h4 data-number="10.2.4.2" id="쿼드의-정의"><span class="header-section-number">10.2.4.2</span> 8.2.4.2 “4 쿼드”의 정의</h4>
<p>쿼드는 남은 네 인덱스의 집합 <span class="math inline">\(Q\)</span>로 정의하며 다음 조건을 만족해야 한다.
<span class="math display">\[Q=\{c_1,c_2,c_3,c_4\},
\qquad
\mathrm{CancelQuad}(c_1,c_2,c_3,c_4)=1.
\label{eq:S08_02_quad}\]</span>
즉, 쿼드는 네 항의 합이 상쇄 문턱 <span class="math inline">\(s_{\min}\)</span> 이내로 상쇄되어야 한다.</p>
<h4 data-number="10.2.4.3" id="생존의-정의"><span class="header-section-number">10.2.4.3</span> 8.2.4.3 “1 생존”의 정의</h4>
<p>생존 인덱스 <span class="math inline">\(u\)</span>는 페어와 쿼드에 포함되지 않은 유일한 인덱스로 정의한다.
<span class="math display">\[u\notin P_1\cup P_2\cup Q,
\qquad
\{u\}=\{1,\ldots,7\}\setminus(P_1\cup P_2\cup Q).
\label{eq:S08_02_survivor_index}\]</span>
생존 벡터(또는 생존 좌표)는 다음으로 정의한다.
<span class="math display">\[\mathbf{V}_{\mathrm{surv}} := \mathbf{s}_u.
\label{eq:S08_02_Vsurv_simple}\]</span>
단, 실제 운영 절차에서 페어와 쿼드의 잔차가 0이 아닌 경우(문턱 이내이지만 완전 0이 아닌 경우)가 존재하므로, 생존 벡터의 표준 정의를 다음으로 확장하여 잠근다.
<span class="math display">\[\mathbf{V}_{\mathrm{surv}}
:=
\mathbf{s}_u
+
(\mathbf{s}_{a_1}+\mathbf{s}_{b_1})
+
(\mathbf{s}_{a_2}+\mathbf{s}_{b_2})
+
(\mathbf{s}_{c_1}+\mathbf{s}_{c_2}+\mathbf{s}_{c_3}+\mathbf{s}_{c_4}).
\label{eq:S08_02_Vsurv_full}\]</span>
정의 <a data-reference="eq:S08_02_Vsurv_full" data-reference-type="eqref" href="#eq:S08_02_Vsurv_full">[eq:S08_02_Vsurv_full]</a>은 “상쇄 잔차까지 포함한 생존 잔차”의 정의이며, 이후 절에서 전하/전자 라벨의 입력으로 사용된다. <a data-reference="eq:S08_02_Vsurv_simple" data-reference-type="eqref" href="#eq:S08_02_Vsurv_simple">[eq:S08_02_Vsurv_simple]</a>은 이상적 완전 상쇄(잔차 0)에서의 특수형이다.</p>
<h3 data-number="10.2.5" id="분할의-선택-규칙비유일성-제거를-위한-닫힘"><span class="header-section-number">10.2.5</span> 8.2.5 분할의 선택 규칙(비유일성 제거를 위한 닫힘)</h3>
<p>조건 <a data-reference="eq:S08_02_two_pairs" data-reference-type="eqref" href="#eq:S08_02_two_pairs">[eq:S08_02_two_pairs]</a>와 <a data-reference="eq:S08_02_quad" data-reference-type="eqref" href="#eq:S08_02_quad">[eq:S08_02_quad]</a>는 다중 해를 가질 수 있다. 따라서 분할 <span class="math inline">\((P_1,P_2,Q,u)\)</span>의 선택은 닫힘(closure)로 잠겨야 한다. 본 절은 선택 규칙의 <strong>자리</strong>만 고정하고, 구체 선택 규칙은 <code>analysis_lock</code>의 <code>CL-G-SHELL7-PARTITION</code>로 잠긴다고 선언한다.</p>
<h4 data-number="10.2.5.1" id="유효-분할-집합"><span class="header-section-number">10.2.5.1</span> 8.2.5.1 유효 분할 집합</h4>
<p>유효 분할의 집합을 다음으로 정의한다.
<span class="math display">\[\mathcal{P}_{\mathrm{valid}}
:=
\left\{
(P_1,P_2,Q,u)\ \middle|\
\eqref{eq:S08_02_partition},\ \eqref{eq:S08_02_sizes},\ \eqref{eq:S08_02_two_pairs},\ \eqref{eq:S08_02_quad}\ \text{를 만족}
\right\}.
\label{eq:S08_02_Pvalid}\]</span>
<span class="math inline">\(\mathcal{P}_{\mathrm{valid}}=\varnothing\)</span>이면 본 절의 구조 정의가 적용 불가이며, 셸 7 구조는 해당 레짐에서 성립하지 않는다.</p>
<h4 data-number="10.2.5.2" id="선택-함수닫힘으로-잠금"><span class="header-section-number">10.2.5.2</span> 8.2.5.2 선택 함수(닫힘으로 잠금)</h4>
<p>선택 함수 <span class="math inline">\(\mathrm{Select}(\cdot)\)</span>를 다음으로 정의한다.
<span class="math display">\[(P_1^\ast,P_2^\ast,Q^\ast,u^\ast)
:=
\mathrm{Select}\bigl(\mathcal{P}_{\mathrm{valid}}\bigr).
\label{eq:S08_02_select}\]</span>
<span class="math inline">\(\mathrm{Select}\)</span>는 다음 요소들을 포함하여 <code>analysis_lock</code>에 잠겨야 한다.</p>
<ol>
<li><p>최적화 목표(예: <span class="math inline">\(\|\mathbf{V}_{\mathrm{surv}}\|\)</span> 최대/최소, 잔차 합 최소, 특정 축 투영 최대 등 중 택일).</p></li>
<li><p>동률 처리(타이브레이크).</p></li>
<li><p>실패모드(유효 분할 없음, 다중 해 무해결, 수치 불안정 등).</p></li>
<li><p>요구 Gate 스택(G-SYM, G-LOCK, G-REG, G-STR, 필요 시 G-NUM, G-NT).</p></li>
</ol>
<p>결과를 본 뒤 <span class="math inline">\(\mathrm{Select}\)</span>를 변경하는 행위는 No-Tuning 위반이다.</p>
<h3 data-number="10.2.6" id="구조-요구의-요약정의적-결론"><span class="header-section-number">10.2.6</span> 8.2.6 구조 요구의 요약(정의적 결론)</h3>
<p>본 절에서 “7-셸 기본 구조”는 다음 단일 문장으로 정의된다.</p>
<blockquote>
<p>셸 7은 인덱스 집합 <span class="math inline">\(\{1,\ldots,7\}\)</span>에 대해, 두 개의 상쇄 페어 <span class="math inline">\((P_1,P_2)\)</span>와 하나의 상쇄 쿼드 <span class="math inline">\(Q\)</span> 및 하나의 생존 인덱스 <span class="math inline">\(u\)</span>로 분할되며, 페어 및 쿼드는 상쇄 문턱 <span class="math inline">\(s_{\min}\)</span> 이내로 상쇄되고, 생존 벡터는 <a data-reference="eq:S08_02_Vsurv_full" data-reference-type="eqref" href="#eq:S08_02_Vsurv_full">[eq:S08_02_Vsurv_full]</a>로 정의된다.</p>
</blockquote>
<p>위 문장은 해석이 아니라 정의이며, 이후 절에서는 재서술하지 않고 참조한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-38">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 셸 집합 <span class="math inline">\(\mathcal{S}_7=\{\mathbf{s}_k\}\)</span>의 의미(좌표 모드/벡터 모드), 좌표계, 단위/정규화 규약을 <code>canon_lock</code>/<code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 상쇄 문턱 <span class="math inline">\(s_{\min}\)</span> 및 상쇄 판정 함수 <a data-reference="eq:S08_02_cancel_pair" data-reference-type="eqref" href="#eq:S08_02_cancel_pair">[eq:S08_02_cancel_pair]</a>, <a data-reference="eq:S08_02_cancel_quad" data-reference-type="eqref" href="#eq:S08_02_cancel_quad">[eq:S08_02_cancel_quad]</a>를 <code>gate_lock</code>/<code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 분할 구조(2 페어 + 4 쿼드 + 1 생존) 정의 <a data-reference="eq:S08_02_partition" data-reference-type="eqref" href="#eq:S08_02_partition">[eq:S08_02_partition]</a>–<a data-reference="eq:S08_02_Vsurv_full" data-reference-type="eqref" href="#eq:S08_02_Vsurv_full">[eq:S08_02_Vsurv_full]</a>을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 유효 분할 집합 공집합(<span class="math inline">\(\mathcal{P}_{\mathrm{valid}}=\varnothing\)</span>)은 <code>FAIL-SHELL7-NOPART</code>; 사후 선택/문턱 이동은 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 기호/의미/단위 충돌은 G-SYM에서 <code>FAIL</code>; lock_id 혼합은 G-LOCK에서 <code>FAIL</code>.</p></li>
</ul>
<h2 data-number="10.3" id="상쇄1-생존-검증-프레임"><span class="header-section-number">10.3</span> 8.3 “6 상쇄+1 생존” 검증 프레임</h2>
<h3 data-number="10.3.1" id="검증-대상의-정의"><span class="header-section-number">10.3.1</span> 8.3.1 검증 대상의 정의</h3>
<p>본 절에서 “6 상쇄+1 생존”은 8.2에서 정의된 셸 7 분할 구조가 <strong>실제 데이터(또는 실제 산출 좌표/벡터)</strong>에 대해 성립하는지 판정하는 검증 문제이다.
검증의 대상은 다음 세 가지이다.</p>
<ol>
<li><p><strong>존재성(existence)</strong>: 상쇄 문턱 <span class="math inline">\(s_{\min}\)</span> 하에서 유효 분할 <span class="math inline">\((P_1,P_2,Q,u)\)</span>가 존재하는가.</p></li>
<li><p><strong>정합성(consistency)</strong>: 선택된 분할이 상쇄 조건(두 페어, 한 쿼드)을 만족하는가.</p></li>
<li><p><strong>비퇴화(nondegeneracy)</strong>: 생존 벡터(상쇄 잔차 포함)가 비퇴화 문턱을 만족하여 라벨/사건/후속 유도의 입력으로 사용 가능한가.</p></li>
</ol>
<p>검증은 <code>PASS</code>/<code>FAIL</code>/<code>INCONCLUSIVE</code>로만 판정되며, 해석으로 판정을 무력화하지 않는다.</p>
<h3 data-number="10.3.2" id="입력lock과-선행-정의"><span class="header-section-number">10.3.2</span> 8.3.2 입력(LOCK)과 선행 정의</h3>
<h4 data-number="10.3.2.1" id="셸-벡터-집합"><span class="header-section-number">10.3.2.1</span> 8.3.2.1 셸 벡터 집합</h4>
<p>셸 7은 다음 집합으로 입력된다.
<span class="math display">\[\mathcal{S}_7:=\{\mathbf{s}_k\}_{k=1}^{7},
\qquad
\mathbf{s}_k\in\mathbb{R}^3.
\label{eq:S08_03_S7}\]</span>
<span class="math inline">\(\mathbf{s}_k\)</span>의 의미(좌표 모드/벡터 모드), 좌표계, 정규화 규약은 <code>analysis_lock</code>에 잠겨 있어야 한다.</p>
<h4 data-number="10.3.2.2" id="상쇄-문턱과-비퇴화-문턱"><span class="header-section-number">10.3.2.2</span> 8.3.2.2 상쇄 문턱과 비퇴화 문턱</h4>
<p>상쇄 문턱 <span class="math inline">\(s_{\min}\)</span>과 비퇴화 문턱 <span class="math inline">\(V_{\min}\)</span>을 다음으로 입력한다.
<span class="math display">\[s_{\min}&gt;0,\qquad V_{\min}&gt;0,
\label{eq:S08_03_thresholds}\]</span>
<span class="math inline">\(s_{\min},V_{\min}\)</span>은 <code>gate_lock</code>에 사전 등록되어야 하며, 결과를 본 뒤 이동될 수 없다.</p>
<h4 data-number="10.3.2.3" id="상쇄-판정-함수8.2의-정의-참조"><span class="header-section-number">10.3.2.3</span> 8.3.2.3 상쇄 판정 함수(8.2의 정의 참조)</h4>
<p>페어 상쇄와 쿼드 상쇄 판정은 다음으로 정의된다.
<span class="math display">\[\mathrm{CancelPair}(a,b)=1 \Longleftrightarrow \|\mathbf{s}_a+\mathbf{s}_b\|\le s_{\min},
\label{eq:S08_03_CancelPair}\]</span>
<span class="math display">\[\mathrm{CancelQuad}(a,b,c,d)=1 \Longleftrightarrow \|\mathbf{s}_a+\mathbf{s}_b+\mathbf{s}_c+\mathbf{s}_d\|\le s_{\min}.
\label{eq:S08_03_CancelQuad}\]</span>
이 판정 함수의 정의는 동일 버전 내부에서 변경되지 않는다.</p>
<h4 data-number="10.3.2.4" id="분할-선택-닫힘선택-규칙의-잠금"><span class="header-section-number">10.3.2.4</span> 8.3.2.4 분할 선택 닫힘(선택 규칙의 잠금)</h4>
<p>유효 분할 집합과 선택 함수는 다음으로 정의된다.
<span class="math display">\[\mathcal{P}_{\mathrm{valid}}
:=
\left\{
(P_1,P_2,Q,u)\ \middle|\
\{1,\ldots,7\}=P_1\dot\cup P_2\dot\cup Q\dot\cup\{u\},\
|P_1|=|P_2|=2,\ |Q|=4,
\ \mathrm{CancelPair}(P_1)=\mathrm{CancelPair}(P_2)=\mathrm{CancelQuad}(Q)=1
\right\},
\label{eq:S08_03_Pvalid}\]</span>
<span class="math display">\[(P_1^\ast,P_2^\ast,Q^\ast,u^\ast)
:=
\mathrm{Select}\bigl(\mathcal{P}_{\mathrm{valid}}\bigr).
\label{eq:S08_03_Select}\]</span>
<span class="math inline">\(\mathrm{Select}\)</span>의 구체 규칙(목표함수/타이브레이크/실패모드/Gate 스택)은 <code>analysis_lock</code>에 잠겨 있어야 한다. 미잠금이면 <code>INCONCLUSIVE</code>이다.</p>
<h4 data-number="10.3.2.5" id="생존-벡터상쇄-잔차-포함-정의"><span class="header-section-number">10.3.2.5</span> 8.3.2.5 생존 벡터(상쇄 잔차 포함) 정의</h4>
<p>선택된 분할에 대해 생존 벡터를 다음으로 정의한다.
<span class="math display">\[\mathbf{V}_{\mathrm{surv}}
:=
\mathbf{s}_{u^\ast}
+
\sum_{k\in P_1^\ast}\mathbf{s}_{k}
+
\sum_{k\in P_2^\ast}\mathbf{s}_{k}
+
\sum_{k\in Q^\ast}\mathbf{s}_{k}.
\label{eq:S08_03_Vsurv}\]</span>
<a data-reference="eq:S08_03_Vsurv" data-reference-type="eqref" href="#eq:S08_03_Vsurv">[eq:S08_03_Vsurv]</a>는 “6 상쇄 잔차 + 1 생존”의 표준 잔차 정의이며, 이후 전하/전자 라벨의 입력으로 사용된다.</p>
<h3 data-number="10.3.3" id="검증-항목체크리스트-정의"><span class="header-section-number">10.3.3</span> 8.3.3 검증 항목(체크리스트) 정의</h3>
<p>본 절의 검증 항목은 다음 6개로 고정한다. 각 항목은 <code>PASS</code>/<code>FAIL</code>/<code>INCONCLUSIVE</code>의 원인 라벨을 생성한다.</p>
<h3 data-number="10.3.4" id="v1-입력-잠금-완결성"><span class="header-section-number">10.3.4</span> (V1) 입력 잠금 완결성</h3>
<p>다음 항목이 모두 잠겨 있어야 한다.</p>
<ol>
<li><p><span class="math inline">\(\mathcal{S}_7\)</span>의 의미(좌표/벡터 모드), 좌표계, 단위/정규화 규약.</p></li>
<li><p><span class="math inline">\(s_{\min}\)</span>, <span class="math inline">\(V_{\min}\)</span>의 문턱값.</p></li>
<li><p><span class="math inline">\(\mathrm{Select}\)</span> 닫힘의 목표함수/타이브레이크/실패모드/요구 Gate.</p></li>
</ol>
<p>하나라도 누락이면 <code>INCONCLUSIVE</code>이며, 사후 변경 흔적이 탐지되면 <code>FAIL</code>이다.</p>
<h3 data-number="10.3.5" id="v2-유효-분할-존재성"><span class="header-section-number">10.3.5</span> (V2) 유효 분할 존재성</h3>
<p><span class="math inline">\(\mathcal{P}_{\mathrm{valid}}\)</span>가 공집합이 아니어야 한다.
<span class="math display">\[\mathcal{P}_{\mathrm{valid}}=\varnothing
\quad\Longrightarrow\quad
\texttt{FAIL-SHELL7-NOPART}.
\label{eq:S08_03_fail_nopart}\]</span></p>
<h3 data-number="10.3.6" id="v3-선택된-분할의-상쇄-정합성두-페어-한-쿼드"><span class="header-section-number">10.3.6</span> (V3) 선택된 분할의 상쇄 정합성(두 페어 + 한 쿼드)</h3>
<p>선택 결과 <span class="math inline">\((P_1^\ast,P_2^\ast,Q^\ast,u^\ast)\)</span>에 대해 다음을 요구한다.
<span class="math display">\[\mathrm{CancelPair}(P_1^\ast)=1,\quad
\mathrm{CancelPair}(P_2^\ast)=1,\quad
\mathrm{CancelQuad}(Q^\ast)=1.
\label{eq:S08_03_cancel_consistency}\]</span>
위 조건 중 하나라도 위반하면 <code>FAIL-SHELL7-CANCEL</code>이다.</p>
<h3 data-number="10.3.7" id="v4-상쇄-잔차의-정량-기록정합성-지표"><span class="header-section-number">10.3.7</span> (V4) 상쇄 잔차의 정량 기록(정합성 지표)</h3>
<p>상쇄 잔차(노름)를 다음으로 정의한다.
<span class="math display">\[r_{P_1}:=\left\|\sum_{k\in P_1^\ast}\mathbf{s}_k\right\|,
\qquad
r_{P_2}:=\left\|\sum_{k\in P_2^\ast}\mathbf{s}_k\right\|,
\qquad
r_{Q}:=\left\|\sum_{k\in Q^\ast}\mathbf{s}_k\right\|.
\label{eq:S08_03_residuals}\]</span>
정의상 <a data-reference="eq:S08_03_cancel_consistency" data-reference-type="eqref" href="#eq:S08_03_cancel_consistency">[eq:S08_03_cancel_consistency]</a>가 성립하면 <span class="math inline">\(r_{P_1},r_{P_2},r_Q\le s_{\min}\)</span>이어야 한다.
이 항목은 “추가 판정”이 아니라 “로그에 반드시 남겨야 하는 지표”이다. 지표가 누락되면 <code>INCONCLUSIVE</code>이다.</p>
<h3 data-number="10.3.8" id="v5-생존-비퇴화라벨사건-입력-가능-조건"><span class="header-section-number">10.3.8</span> (V5) 생존 비퇴화(라벨/사건 입력 가능 조건)</h3>
<p>생존 벡터의 비퇴화 조건을 다음으로 정의한다.
<span class="math display">\[\|\mathbf{V}_{\mathrm{surv}}\|\ge V_{\min}.
\label{eq:S08_03_surv_nondeg}\]</span>
<a data-reference="eq:S08_03_surv_nondeg" data-reference-type="eqref" href="#eq:S08_03_surv_nondeg">[eq:S08_03_surv_nondeg]</a>가 위반되면 <code>FAIL-SHELL7-DEGEN</code>이다.
이 항목이 <code>FAIL</code>이면, 이후 전하/전자 라벨(7.4) 및 사건율/질량 유도에서 이 창의 셸 데이터를 입력으로 사용할 수 없다(한계 결론만 허용).</p>
<h3 data-number="10.3.9" id="v6-로버스트성정의된-재실행-스택에서의-일관성"><span class="header-section-number">10.3.9</span> (V6) 로버스트성(정의된 재실행 스택에서의 일관성)</h3>
<p>본 항목은 동일 <code>analysis_lock</code>에 사전 등록된 “재실행 세트”에 대해 <strong>판정 일관성</strong>을 요구한다. 재실행 세트는 다음과 같이 잠겨야 한다.
<span class="math display">\[\mathcal{R}_{\mathrm{replay}}:=\{r_1,r_2,\ldots,r_M\},
\qquad
M\in\mathbb{Z}_{&gt;0},
\label{eq:S08_03_replayset}\]</span>
각 <span class="math inline">\(r_m\)</span>은 동일한 입력 로그에서 (i) 다른 시간 창, 또는 (ii) 다른 하위 샘플(사전 등록된 선택 규칙), 또는 (iii) 동일 데이터의 재계산(동일 코드/환경)을 의미한다. 재실행 세트의 구성 규칙이 잠기지 않으면 <code>INCONCLUSIVE</code>이다.</p>
<p>각 재실행에서 산출된 생존 벡터를 <span class="math inline">\(\mathbf{V}_{\mathrm{surv}}^{(m)}\)</span>로 두고, 방향 일관성 지표를 다음으로 정의한다.
<span class="math display">\[c_{mn}
:=\frac{\mathbf{V}_{\mathrm{surv}}^{(m)}\cdot \mathbf{V}_{\mathrm{surv}}^{(n)}}{\|\mathbf{V}_{\mathrm{surv}}^{(m)}\|\,\|\mathbf{V}_{\mathrm{surv}}^{(n)}\|}
\qquad (m\neq n).
\label{eq:S08_03_coscons}\]</span>
문턱 <span class="math inline">\(c_{\min}\)</span>을 <code>gate_lock</code>에 잠근다(<span class="math inline">\(-1\le c_{\min}\le 1\)</span>). 로버스트성 조건을 다음으로 정의한다.
<span class="math display">\[\min_{m\neq n} c_{mn} \ge c_{\min}.
\label{eq:S08_03_robust_rule}\]</span>
<a data-reference="eq:S08_03_robust_rule" data-reference-type="eqref" href="#eq:S08_03_robust_rule">[eq:S08_03_robust_rule]</a> 위반은 <code>FAIL-SHELL7-ROBUST</code>로 처리한다.
본 항목은 “재실행 세트”가 잠긴 경우에만 적용되며, 잠기지 않은 경우에는 로버스트성 검증은 수행 불가(<code>INCONCLUSIVE</code>)이다.</p>
<h3 data-number="10.3.10" id="로그필수-기록-규격"><span class="header-section-number">10.3.10</span> 8.3.4 로그(필수 기록) 규격</h3>
<p>본 절의 판정은 다음 로그가 완결되어 있을 때만 결론 자격을 부여할 수 있다. 로그 형식(JSON/YAML/CSV 등)은 <code>protocol_lock</code>에 잠기되, 필드 의미는 다음으로 고정한다.</p>
<h4 data-number="10.3.10.1" id="입력-로그"><span class="header-section-number">10.3.10.1</span> 8.3.4.1 입력 로그</h4>
<ol>
<li><p><code>shell_id</code>: 셸 데이터 식별자.</p></li>
<li><p><code>s_k</code>: <span class="math inline">\(k=1..7\)</span>에 대한 <span class="math inline">\(\mathbf{s}_k\)</span>의 좌표/성분.</p></li>
<li><p><code>mode</code>: <code>SHELL-POINT</code> 또는 <code>SHELL-VEC</code>.</p></li>
<li><p><code>locks</code>: <code>canon_lock_id</code>, <code>realization_lock_id</code>, <code>analysis_lock_id</code>.</p></li>
<li><p><code>thresholds</code>: <span class="math inline">\(s_{\min}\)</span>, <span class="math inline">\(V_{\min}\)</span>, (선택) <span class="math inline">\(c_{\min}\)</span>.</p></li>
</ol>
<h4 data-number="10.3.10.2" id="분할상쇄-로그"><span class="header-section-number">10.3.10.2</span> 8.3.4.2 분할/상쇄 로그</h4>
<ol>
<li><p><code>P1</code>, <code>P2</code>, <code>Q</code>, <code>u</code>: 선택된 분할 <span class="math inline">\((P_1^\ast,P_2^\ast,Q^\ast,u^\ast)\)</span>.</p></li>
<li><p><code>residuals</code>: <span class="math inline">\((r_{P_1},r_{P_2},r_Q)\)</span>.</p></li>
<li><p><code>CancelPair(P1)</code>, <code>CancelPair(P2)</code>, <code>CancelQuad(Q)</code>: 상쇄 판정값(0/1).</p></li>
<li><p><code>V_surv</code>: <span class="math inline">\(\mathbf{V}_{\mathrm{surv}}\)</span> 성분 및 노름 <span class="math inline">\(\|\mathbf{V}_{\mathrm{surv}}\|\)</span>.</p></li>
</ol>
<h4 data-number="10.3.10.3" id="로버스트성-로그해당-시"><span class="header-section-number">10.3.10.3</span> 8.3.4.3 로버스트성 로그(해당 시)</h4>
<ol>
<li><p><code>replay_set</code>: 재실행 세트 식별자 및 구성 규칙.</p></li>
<li><p><code>V_surv[m]</code>: 각 재실행 <span class="math inline">\(m\)</span>의 <span class="math inline">\(\mathbf{V}_{\mathrm{surv}}^{(m)}\)</span>.</p></li>
<li><p><code>c_min_pair</code>: <span class="math inline">\(\min_{m\neq n}c_{mn}\)</span>.</p></li>
<li><p><code>pass_robust</code>: <code>true/false</code>.</p></li>
</ol>
<h3 data-number="10.3.11" id="판정-gate스택-정의"><span class="header-section-number">10.3.11</span> 8.3.5 판정 Gate(스택) 정의</h3>
<p>본 절의 Gate는 다음 스택으로 고정한다. 각 Gate는 <code>PASS</code>/<code>FAIL</code>/<code>INCONCLUSIVE</code> 중 하나를 출력한다.</p>
<h4 data-number="10.3.11.1" id="g-shell7-lock-입력-잠금-gate"><span class="header-section-number">10.3.11.1</span> 8.3.5.1 G-SHELL7-LOCK (입력 잠금 Gate)</h4>
<ul>
<li><p><code>PASS</code>: 8.3.2의 입력(LOCK) 항목이 모두 잠김.</p></li>
<li><p><code>INCONCLUSIVE</code>: 잠금 누락 또는 스키마 누락.</p></li>
<li><p><code>FAIL</code>: 사후 변경 흔적(문턱 이동, 선택 규칙 변경, lock_id 혼합) 탐지.</p></li>
</ul>
<h4 data-number="10.3.11.2" id="g-shell7-part-분할-존재성-gate"><span class="header-section-number">10.3.11.2</span> 8.3.5.2 G-SHELL7-PART (분할 존재성 Gate)</h4>
<ul>
<li><p><code>PASS</code>: <span class="math inline">\(\mathcal{P}_{\mathrm{valid}}\neq\varnothing\)</span>.</p></li>
<li><p><code>FAIL</code>: <code>FAIL-SHELL7-NOPART</code>.</p></li>
</ul>
<h4 data-number="10.3.11.3" id="g-shell7-cancel-상쇄-정합성-gate"><span class="header-section-number">10.3.11.3</span> 8.3.5.3 G-SHELL7-CANCEL (상쇄 정합성 Gate)</h4>
<ul>
<li><p><code>PASS</code>: <a data-reference="eq:S08_03_cancel_consistency" data-reference-type="eqref" href="#eq:S08_03_cancel_consistency">[eq:S08_03_cancel_consistency]</a> 만족.</p></li>
<li><p><code>FAIL</code>: <code>FAIL-SHELL7-CANCEL</code>.</p></li>
</ul>
<h4 data-number="10.3.11.4" id="g-shell7-surv-생존-비퇴화-gate"><span class="header-section-number">10.3.11.4</span> 8.3.5.4 G-SHELL7-SURV (생존 비퇴화 Gate)</h4>
<ul>
<li><p><code>PASS</code>: <a data-reference="eq:S08_03_surv_nondeg" data-reference-type="eqref" href="#eq:S08_03_surv_nondeg">[eq:S08_03_surv_nondeg]</a> 만족.</p></li>
<li><p><code>FAIL</code>: <code>FAIL-SHELL7-DEGEN</code>.</p></li>
</ul>
<h4 data-number="10.3.11.5" id="g-shell7-robust-로버스트성-gate-선택"><span class="header-section-number">10.3.11.5</span> 8.3.5.5 G-SHELL7-ROBUST (로버스트성 Gate; 선택)</h4>
<ul>
<li><p><code>PASS</code>: 재실행 세트가 잠겨 있고 <a data-reference="eq:S08_03_robust_rule" data-reference-type="eqref" href="#eq:S08_03_robust_rule">[eq:S08_03_robust_rule]</a> 만족.</p></li>
<li><p><code>INCONCLUSIVE</code>: 재실행 세트 또는 <span class="math inline">\(c_{\min}\)</span> 미잠금.</p></li>
<li><p><code>FAIL</code>: <code>FAIL-SHELL7-ROBUST</code>.</p></li>
</ul>
<h4 data-number="10.3.11.6" id="최종-gate-g-shell7-6c1s"><span class="header-section-number">10.3.11.6</span> 8.3.5.6 최종 Gate: G-SHELL7-6C1S</h4>
<p>최종 판정을 다음으로 정의한다.
<span class="math display">\[\texttt{G-SHELL7-6C1S}=\texttt{PASS}
\Longleftrightarrow
(\texttt{G-SHELL7-LOCK}=\texttt{PASS})
\wedge
(\texttt{G-SHELL7-PART}=\texttt{PASS})
\wedge
(\texttt{G-SHELL7-CANCEL}=\texttt{PASS})
\wedge
(\texttt{G-SHELL7-SURV}=\texttt{PASS})
\wedge
\bigl(\texttt{G-SHELL7-ROBUST}\in\{\texttt{PASS},\texttt{INCONCLUSIVE}\}\bigr),
\label{eq:S08_03_final_gate}\]</span>
즉, 로버스트성은 잠긴 경우에는 <code>PASS</code>를 요구하고, 잠기지 않은 경우에는 <code>INCONCLUSIVE</code>로 남길 수 있으나, 그 경우 “로버스트성 검증을 통과했다”는 문장은 금지된다(PASS.rules로 제한).</p>
<h3 data-number="10.3.12" id="허용되는-결론-문장표준-템플릿-연결"><span class="header-section-number">10.3.12</span> 8.3.6 허용되는 결론 문장(표준 템플릿 연결)</h3>
<p><code>G-SHELL7-6C1S</code>=<code>PASS</code>인 경우에만 다음 유형의 결론 문장이 허용된다.</p>
<ol>
<li><p>“본 셸 데이터는 <span class="math inline">\(s_{\min}\)</span> 기준에서 2 페어+1 쿼드 상쇄 및 비퇴화 생존을 만족한다.”</p></li>
<li><p>“생존 벡터 <span class="math inline">\(\mathbf{V}_{\mathrm{surv}}\)</span>가 정의되며 <span class="math inline">\(\|\mathbf{V}_{\mathrm{surv}}\|\ge V_{\min}\)</span>이다.”</p></li>
</ol>
<p><code>FAIL</code> 또는 <code>INCONCLUSIVE</code>인 경우, 허용되는 문장은 한계 결론(CT-LIM)뿐이며, 반드시 FAIL 라벨과 위반 항목(V1–V6)을 함께 기록해야 한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-39">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 상쇄 문턱 <span class="math inline">\(s_{\min}\)</span>, 비퇴화 문턱 <span class="math inline">\(V_{\min}\)</span>, (선택) 로버스트 문턱 <span class="math inline">\(c_{\min}\)</span> 및 재실행 세트 <span class="math inline">\(\mathcal{R}_{\mathrm{replay}}\)</span>를 <code>gate_lock</code>/<code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 분할 선택 닫힘 <span class="math inline">\(\mathrm{Select}(\mathcal{P}_{\mathrm{valid}})\)</span>와 생존 벡터 정의 <a data-reference="eq:S08_03_Vsurv" data-reference-type="eqref" href="#eq:S08_03_Vsurv">[eq:S08_03_Vsurv]</a>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: G-SHELL7-LOCK/PART/CANCEL/SURV/ROBUST 및 최종 Gate <a data-reference="eq:S08_03_final_gate" data-reference-type="eqref" href="#eq:S08_03_final_gate">[eq:S08_03_final_gate]</a>의 판정 규약을 <code>gate_lock</code>에 고정.</p></li>
<li><p>Gate: 사후 선택(문턱 이동, 선택 규칙 교체, lock_id 혼합)은 G-NT/G-LOCK에서 <code>FAIL</code>로 판정.</p></li>
<li><p>Gate: 입력/분할/잔차/생존 로그가 <code>manifest+checksums</code>로 봉인되지 않으면 결론 자격이 부여되지 않음(G-REP 연동).</p></li>
</ul>
<h2 data-number="10.4" id="전자-생성-메커니즘-전하-레이블-정의"><span class="header-section-number">10.4</span> 8.4 전자 생성 메커니즘 + 전하 레이블 정의</h2>
<h3 data-number="10.4.1" id="정의생존-벡터-rightarrow-방출-사건-rightarrow-라벨"><span class="header-section-number">10.4.1</span> 8.4.1 정의(생존 벡터 <span class="math inline">\(\rightarrow\)</span> 방출 사건 <span class="math inline">\(\rightarrow\)</span> 라벨)</h3>
<h4 data-number="10.4.1.1" id="코어셸-완결-상태와-완결-사건"><span class="header-section-number">10.4.1.1</span> 8.4.1.1 코어/셸 완결 상태와 완결 사건</h4>
<p>코어 82와 셸 7이 결합된 완결 상태를 다음 객체로 정의한다.
<span class="math display">\[\mathcal{P} := (\mathcal{X}_{82},\ \mathcal{S}_{7},\ \mathbf{x}_c,\ R_p),
\label{eq:S08_04_proton_state}\]</span>
여기서 <span class="math inline">\(\mathcal{X}_{82}\)</span>는 코어 82 좌표 집합, <span class="math inline">\(\mathcal{S}_{7}\)</span>은 셸 7 벡터(또는 좌표) 집합, <span class="math inline">\(\mathbf{x}_c\)</span>는 중심, <span class="math inline">\(R_p\)</span>는 코어 반경이다. 각 항목의 의미/단위/좌표계는 <code>canon_lock</code>/<code>analysis_lock</code>에 잠겨 있어야 한다.</p>
<p>완결 사건을 다음으로 정의한다.
<span class="math display">\[E_{\mathrm{build}}:\ \text{상태 }\mathcal{P}\text{가 생성되어 기록되는 사건}.
\label{eq:S08_04_Ebuild_def}\]</span>
완결 사건의 발생 시각 <span class="math inline">\(t_{\mathrm{build}}\)</span>는 빌드타임 규약에 의해 정의된다. 정준 사건율 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>가 잠긴 레짐에서는
<span class="math display">\[T_p := \frac{N_p}{\nu_{p,\mathrm{can}}},
\qquad
N_p:=89,
\label{eq:S08_04_Tp_def}\]</span>
이고, 빌드 시작 시각 <span class="math inline">\(t_0\)</span>가 주어졌을 때
<span class="math display">\[t_{\mathrm{build}} := t_0 + T_p
\label{eq:S08_04_tbuild}\]</span>
로 완결 사건 시각을 정의한다. <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>이 정의 불능이면 <span class="math inline">\(t_{\mathrm{build}}\)</span>는 창(틱) 기반 정의로 대체되며, 대체 규약은 <code>analysis_lock</code>에 잠겨야 한다.</p>
<h4 data-number="10.4.1.2" id="생존-벡터-mathbfv_mathrmsurv"><span class="header-section-number">10.4.1.2</span> 8.4.1.2 생존 벡터 <span class="math inline">\(\mathbf{V}_{\mathrm{surv}}\)</span></h4>
<p>셸 7의 분할 구조(2 페어 + 1 쿼드 + 1 생존)와 상쇄 문턱 <span class="math inline">\(s_{\min}\)</span>이 주어진다. 유효 분할 선택은 닫힘으로 잠기며,
<span class="math display">\[(P_1^\ast,P_2^\ast,Q^\ast,u^\ast)
:=
\mathrm{Select}\bigl(\mathcal{P}_{\mathrm{valid}}\bigr)
\label{eq:S08_04_select_partition}\]</span>
로 정의한다. 이때 생존 벡터(상쇄 잔차 포함)를 다음으로 정의한다.
<span class="math display">\[\mathbf{V}_{\mathrm{surv}}
:=
\mathbf{s}_{u^\ast}
+
\sum_{k\in P_1^\ast}\mathbf{s}_{k}
+
\sum_{k\in P_2^\ast}\mathbf{s}_{k}
+
\sum_{k\in Q^\ast}\mathbf{s}_{k}.
\label{eq:S08_04_Vsurv}\]</span>
정의 <a data-reference="eq:S08_04_Vsurv" data-reference-type="eqref" href="#eq:S08_04_Vsurv">[eq:S08_04_Vsurv]</a>는 “6 상쇄+1 생존” 구조의 유일한 표준 생존 정의이며, 동일 버전 내부에서 다른 방식(예: 완전 상쇄 가정, 절댓값 합, 다른 가중 합)으로 교체될 수 없다.</p>
<h4 data-number="10.4.1.3" id="방출-방향단위-방향과-방출점"><span class="header-section-number">10.4.1.3</span> 8.4.1.3 방출 방향(단위 방향)과 방출점</h4>
<p>생존 방향(방출 방향)을 다음으로 정의한다.
<span class="math display">\[\widehat{\mathbf{n}}_{\mathrm{emit}}
:=
\frac{\mathbf{V}_{\mathrm{surv}}}{\|\mathbf{V}_{\mathrm{surv}}\|},
\qquad
\text{단, }\|\mathbf{V}_{\mathrm{surv}}\|&gt;0.
\label{eq:S08_04_nemit}\]</span>
<span class="math inline">\(\|\mathbf{V}_{\mathrm{surv}}\|=0\)</span>이면 방출 방향은 정의 불능이다.</p>
<p>방출 길이 <span class="math inline">\(\ell_{\mathrm{emit}}&gt;0\)</span>를 다음으로 잠근다.
<span class="math display">\[\ell_{\mathrm{emit}}&gt;0,
\qquad
\ell_{\mathrm{emit}}\ \text{는}\ \texttt{analysis\_lock}\ \text{에 사전 등록}.
\label{eq:S08_04_lemit_lock}\]</span>
방출점(방출 위치)을 다음으로 정의한다.
<span class="math display">\[\mathbf{x}_{\mathrm{emit}}
:=
\mathbf{x}_c + (R_p+\ell_{\mathrm{emit}})\,\widehat{\mathbf{n}}_{\mathrm{emit}}.
\label{eq:S08_04_xemit}\]</span>
정의 <a data-reference="eq:S08_04_xemit" data-reference-type="eqref" href="#eq:S08_04_xemit">[eq:S08_04_xemit]</a>은 “코어 경계(<span class="math inline">\(R_p\)</span>) 바깥으로 <span class="math inline">\(\ell_{\mathrm{emit}}\)</span>만큼 이동”이라는 기하학적 규약이며, 결과를 본 뒤 조정되지 않는다.</p>
<h4 data-number="10.4.1.4" id="전하-축-mathbfn_q와-전하-단위-q_0"><span class="header-section-number">10.4.1.4</span> 8.4.1.4 전하 축 <span class="math inline">\(\mathbf{n}_Q\)</span>와 전하 단위 <span class="math inline">\(q_0\)</span></h4>
<p>전하 라벨은 생존 벡터의 부호를 하나의 기준축에 대해 판정하여 정의한다. 전하 축을 다음으로 잠근다.
<span class="math display">\[\mathbf{n}_Q\in\mathbb{R}^3,
\qquad
\|\mathbf{n}_Q\|=1,
\qquad
\mathbf{n}_Q\ \text{는}\ \texttt{analysis\_lock}\ \text{에 사전 등록}.
\label{eq:S08_04_nQ_lock}\]</span>
전하 단위 <span class="math inline">\(q_0\)</span>를 다음으로 잠근다.
<span class="math display">\[q_0:=1,
\qquad
q_0\ \text{는 전하 차원 }[Q]\text{의 기본 단위로}\ \texttt{canon\_lock}\ \text{에 잠김}.
\label{eq:S08_04_q0_lock}\]</span></p>
<h4 data-number="10.4.1.5" id="전하-부호-함수와-라벨-함수"><span class="header-section-number">10.4.1.5</span> 8.4.1.5 전하 부호 함수와 라벨 함수</h4>
<p>전하 부호 함수를 다음으로 정의한다.
<span class="math display">\[q(\mathbf{V}_{\mathrm{surv}})
:=
\mathrm{sgn}\!\left(\mathbf{V}_{\mathrm{surv}}\cdot\mathbf{n}_Q\right),
\qquad
\mathrm{sgn}(x)=
\begin{cases}
+1,&amp; x&gt;0,\\
0,&amp; x=0,\\
-1,&amp; x&lt;0.
\end{cases}
\label{eq:S08_04_q_sign}\]</span>
전하 레이블을 다음으로 정의한다.
<span class="math display">\[Q_{\mathrm{label}}
:=
q_0\,q(\mathbf{V}_{\mathrm{surv}}).
\label{eq:S08_04_Qlabel}\]</span>
전자/반전자 라벨을 다음으로 정의한다.
<span class="math display">\[\mathcal{L}_{e}(\mathbf{V}_{\mathrm{surv}})
:=
\begin{cases}
\texttt{ELECTRON}, &amp; q(\mathbf{V}_{\mathrm{surv}})=+1,\\
\texttt{ANTI\_ELECTRON}, &amp; q(\mathbf{V}_{\mathrm{surv}})=-1,\\
\texttt{NEUTRAL}, &amp; q(\mathbf{V}_{\mathrm{surv}})=0.
\end{cases}
\label{eq:S08_04_e_label}\]</span>
정의 <a data-reference="eq:S08_04_e_label" data-reference-type="eqref" href="#eq:S08_04_e_label">[eq:S08_04_e_label]</a>은 라벨의 형식 정의이며, 라벨의 의미 해석은 포함하지 않는다.</p>
<h3 data-number="10.4.2" id="규칙방출-조건과-라벨-부여-규칙"><span class="header-section-number">10.4.2</span> 8.4.2 규칙(방출 조건과 라벨 부여 규칙)</h3>
<h4 data-number="10.4.2.1" id="방출-성립-조건필수-gate-전제"><span class="header-section-number">10.4.2.1</span> 8.4.2.1 방출 성립 조건(필수 Gate 전제)</h4>
<p>방출 사건은 다음 조건이 <em>모두</em> 성립할 때만 정의된다.</p>
<h4 data-number="10.4.2.2" id="r1-6-상쇄1-생존-검증-통과"><span class="header-section-number">10.4.2.2</span> (R1) “6 상쇄+1 생존” 검증 통과</h4>
<p>셸 검증 Gate가 <code>PASS</code>이어야 한다.
<span class="math display">\[\texttt{G-SHELL7-6C1S}=\texttt{PASS}.
\label{eq:S08_04_rule_gate_shell}\]</span>
<code>PASS</code>가 아닌 경우 방출은 정의되지 않으며, 라벨은 결론 입력으로 사용할 수 없다.</p>
<h4 data-number="10.4.2.3" id="r2-생존-비퇴화-조건"><span class="header-section-number">10.4.2.3</span> (R2) 생존 비퇴화 조건</h4>
<p>비퇴화 문턱 <span class="math inline">\(V_{\min}&gt;0\)</span>을 다음으로 잠근다.
<span class="math display">\[V_{\min}&gt;0,
\qquad
V_{\min}\ \text{는}\ \texttt{gate\_lock}\ \text{에 사전 등록}.
\label{eq:S08_04_Vmin_lock}\]</span>
방출 조건은 다음으로 정의한다.
<span class="math display">\[\|\mathbf{V}_{\mathrm{surv}}\|\ge V_{\min}.
\label{eq:S08_04_emit_condition_V}\]</span>
<a data-reference="eq:S08_04_emit_condition_V" data-reference-type="eqref" href="#eq:S08_04_emit_condition_V">[eq:S08_04_emit_condition_V]</a>가 성립하지 않으면 <span class="math inline">\(\widehat{\mathbf{n}}_{\mathrm{emit}}\)</span>가 불안정/정의 불능이므로 방출은 정의되지 않는다.</p>
<h4 data-number="10.4.2.4" id="r3-축문턱규약의-잠금-무결성"><span class="header-section-number">10.4.2.4</span> (R3) 축/문턱/규약의 잠금 무결성</h4>
<p>다음 항목이 모두 동일 <code>lock_id</code> 조합에 귀속되어야 한다.
<span class="math display">\[(\mathbf{n}_Q,\ q_0,\ s_{\min},\ V_{\min},\ \ell_{\mathrm{emit}},\ \mathrm{Select}\ \text{규칙})
\ \text{의 lock\_id가 일치}.
\label{eq:S08_04_lock_integrity}\]</span>
불일치 또는 혼합이 발견되면 방출/라벨은 즉시 <code>FAIL</code>이다.</p>
<h4 data-number="10.4.2.5" id="방출-사건의-정의발생-시각위치방향상태"><span class="header-section-number">10.4.2.5</span> 8.4.2.2 방출 사건의 정의(발생 시각/위치/방향/상태)</h4>
<p>방출 사건을 다음으로 정의한다.
<span class="math display">\[E_{\mathrm{emit}}:\
(t_{\mathrm{emit}},\ \mathbf{x}_{\mathrm{emit}},\ \widehat{\mathbf{n}}_{\mathrm{emit}},\ \mathbf{V}_{\mathrm{surv}})\ \text{를 기록하는 사건}.
\label{eq:S08_04_Eemit_def}\]</span>
방출 사건의 시각을 다음으로 잠근다.
<span class="math display">\[t_{\mathrm{emit}} := t_{\mathrm{build}}
\label{eq:S08_04_temit}\]</span>
즉, 방출은 코어-셸 완결 사건과 동일 시각에 기록되는 사건으로 정의한다. (완결 사건과 방출 사건의 상대 시각을 달리 두려면 별도 버전업이 필요하며, 동일 버전 내부에서 조정할 수 없다.)</p>
<p>방출 사건의 위치와 방향은 <a data-reference="eq:S08_04_nemit" data-reference-type="eqref" href="#eq:S08_04_nemit">[eq:S08_04_nemit]</a>, <a data-reference="eq:S08_04_xemit" data-reference-type="eqref" href="#eq:S08_04_xemit">[eq:S08_04_xemit]</a>로 고정한다. 방출 사건의 상태 라벨은 <a data-reference="eq:S08_04_Qlabel" data-reference-type="eqref" href="#eq:S08_04_Qlabel">[eq:S08_04_Qlabel]</a>, <a data-reference="eq:S08_04_e_label" data-reference-type="eqref" href="#eq:S08_04_e_label">[eq:S08_04_e_label]</a>로 고정한다.</p>
<h4 data-number="10.4.2.6" id="라벨-부여-규칙해석-금지-정의적-부여"><span class="header-section-number">10.4.2.6</span> 8.4.2.3 라벨 부여 규칙(해석 금지, 정의적 부여)</h4>
<p>방출이 성립하는 경우, 다음 규칙으로 라벨을 부여한다.</p>
<ol>
<li><p>전하 부호: <span class="math inline">\(q:=q(\mathbf{V}_{\mathrm{surv}})\)</span>.</p></li>
<li><p>전하 레이블: <span class="math inline">\(Q_{\mathrm{label}}:=q_0 q\)</span>.</p></li>
<li><p>전자/반전자 라벨: <span class="math inline">\(\mathcal{L}_{e}:=\mathcal{L}_{e}(\mathbf{V}_{\mathrm{surv}})\)</span>.</p></li>
</ol>
<p>위 라벨 부여는 해석이 아니라 정의이며, 다른 기준(예: 다른 축, 다른 문턱, 다른 결합 규칙)으로 바꾸는 것은 동일 버전 내부에서 금지된다.</p>
<h4 data-number="10.4.2.7" id="정의-불능-처리-규칙"><span class="header-section-number">10.4.2.7</span> 8.4.2.4 정의 불능 처리 규칙</h4>
<p>다음 경우 방출 및 라벨은 정의 불능으로 처리되며, 한계 결론(CT-LIM)만 허용된다.</p>
<ol>
<li><p><code>G-SHELL7-6C1S</code><span class="math inline">\(\neq\)</span><code>PASS</code>.</p></li>
<li><p><span class="math inline">\(\|\mathbf{V}_{\mathrm{surv}}\|&lt;V_{\min}\)</span>.</p></li>
<li><p><span class="math inline">\(\mathbf{V}_{\mathrm{surv}}\cdot\mathbf{n}_Q=0\)</span> (부호 0).</p></li>
<li><p>lock_id 불일치 또는 잠금 누락(문턱/축/선택 규칙 미등록).</p></li>
</ol>
<p>정의 불능을 해석으로 봉합하거나, 문턱/축/규약을 사후 변경하여 정의 가능하게 만드는 행위는 No-Tuning 위반이며 금지된다.</p>
<h3 data-number="10.4.3" id="결과형방출-레코드-전하-레이블-전자반전자-라벨"><span class="header-section-number">10.4.3</span> 8.4.3 결과형(방출 레코드, 전하 레이블, 전자/반전자 라벨)</h3>
<h4 data-number="10.4.3.1" id="결과형-방출-레코드봉인-대상"><span class="header-section-number">10.4.3.1</span> 8.4.3.1 결과형: 방출 레코드(봉인 대상)</h4>
<p>방출 사건이 성립하는 경우, 방출 레코드를 다음 필드로 기록하고 봉인한다. 레코드는 <code>protocol_lock</code>의 스키마를 따르되, 필드 의미는 아래로 고정한다.</p>
<pre><code>emit_records:
  - emit_id: (unique)
    t_emit: (t_build)
    x_emit: [x, y, z]
    n_emit: [nx, ny, nz]
    V_surv: [Vx, Vy, Vz]
    V_norm: ||V_surv||
    q_sign: -1 | 0 | +1
    Q_label: q0 * q_sign
    e_label: ELECTRON | ANTI_ELECTRON | NEUTRAL
    refs:
      core_state_id: (X82,S7,xc,Rp snapshot id)
      shell_partition: (P1*,P2*,Q*,u*)
    lock_refs:
      canon_lock_id: (...)
      realization_lock_id: (...)
      analysis_lock_id: (...)
    gate_refs:
      G-SHELL7-6C1S: PASS
      (optional) G-REG: PASS
      (optional) G-REP: PASS</code></pre>
<p>방출 레코드는 <code>manifest</code>와 <code>checksums</code>에 포함되어 봉인되어야 하며, 봉인되지 않은 레코드는 후속 유도의 입력으로 사용할 수 없다.</p>
<h4 data-number="10.4.3.2" id="결과형-전하-레이블"><span class="header-section-number">10.4.3.2</span> 8.4.3.2 결과형: 전하 레이블</h4>
<p>방출이 성립하는 경우 전하 레이블은 <a data-reference="eq:S08_04_Qlabel" data-reference-type="eqref" href="#eq:S08_04_Qlabel">[eq:S08_04_Qlabel]</a>로 고정된다.
<span class="math display">\[Q_{\mathrm{label}}=q_0\,\mathrm{sgn}(\mathbf{V}_{\mathrm{surv}}\cdot\mathbf{n}_Q).
\label{eq:S08_04_Qlabel_result}\]</span>
<span class="math inline">\(q_0=1\)</span>이 잠긴 경우, <span class="math inline">\(Q_{\mathrm{label}}\in\{-1,0,+1\}\)</span>로 고정된다.</p>
<h4 data-number="10.4.3.3" id="결과형-전자반전자-라벨"><span class="header-section-number">10.4.3.3</span> 8.4.3.3 결과형: 전자/반전자 라벨</h4>
<p>방출이 성립하는 경우 전자/반전자 라벨은 <a data-reference="eq:S08_04_e_label" data-reference-type="eqref" href="#eq:S08_04_e_label">[eq:S08_04_e_label]</a>로 고정된다.
<span class="math display">\[\mathcal{L}_{e}=
\begin{cases}
\texttt{ELECTRON}, &amp; \mathbf{V}_{\mathrm{surv}}\cdot\mathbf{n}_Q&gt;0,\\
\texttt{ANTI\_ELECTRON}, &amp; \mathbf{V}_{\mathrm{surv}}\cdot\mathbf{n}_Q&lt;0,\\
\texttt{NEUTRAL}, &amp; \mathbf{V}_{\mathrm{surv}}\cdot\mathbf{n}_Q=0.
\end{cases}
\label{eq:S08_04_label_result}\]</span>
<code>NEUTRAL</code> 출력이 결론 문장으로 허용되는지 여부는 PASS.rules에 의해 잠기며, 본 절은 허용/금지 판단을 수행하지 않는다(정의만 고정).</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-40">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(\mathbf{V}_{\mathrm{surv}}\)</span> 정의(<a data-reference="eq:S08_04_Vsurv" data-reference-type="eqref" href="#eq:S08_04_Vsurv">[eq:S08_04_Vsurv]</a>), 방출 길이 <span class="math inline">\(\ell_{\mathrm{emit}}\)</span>(<a data-reference="eq:S08_04_lemit_lock" data-reference-type="eqref" href="#eq:S08_04_lemit_lock">[eq:S08_04_lemit_lock]</a>), 전하 축 <span class="math inline">\(\mathbf{n}_Q\)</span>(<a data-reference="eq:S08_04_nQ_lock" data-reference-type="eqref" href="#eq:S08_04_nQ_lock">[eq:S08_04_nQ_lock]</a>), 전하 단위 <span class="math inline">\(q_0\)</span>(<a data-reference="eq:S08_04_q0_lock" data-reference-type="eqref" href="#eq:S08_04_q0_lock">[eq:S08_04_q0_lock]</a>)를 고정.</p></li>
<li><p>Gate: 셸 검증 <code>G-SHELL7-6C1S</code>=<code>PASS</code> 및 비퇴화 조건 <span class="math inline">\(\|\mathbf{V}_{\mathrm{surv}}\|\ge V_{\min}\)</span>(<a data-reference="eq:S08_04_emit_condition_V" data-reference-type="eqref" href="#eq:S08_04_emit_condition_V">[eq:S08_04_emit_condition_V]</a>)을 방출의 필요조건으로 연결.</p></li>
<li><p>Gate: 문턱(<span class="math inline">\(s_{\min},V_{\min}\)</span>) 및 라벨 축 <span class="math inline">\(\mathbf{n}_Q\)</span>의 사후 변경, 선택 규칙 교체는 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 기호/의미/단위 충돌은 G-SYM에서 <code>FAIL</code>, lock_id 혼합은 G-LOCK에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 방출 레코드가 <code>manifest+checksums</code>로 봉인되지 않으면 G-REP에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
</ul>
<h1 data-number="11" id="사건quantum-정의와-정준-사건율"><span class="header-section-number">11</span> 9. 사건(Quantum) 정의와 정준 사건율</h1>
<h2 class="unnumbered" id="장의-목적운영-정의의-고정">장의 목적(운영 정의의 고정)</h2>
<p>본 장은 “사건(Quantum event)”을 계산/로그 가능한 <strong>운영 정의</strong>로 고정하고, 사건의 발생을 시간(틱)과 결합하여 “정준 사건율”을 정의한다.
본 장의 산출물은 다음 네 묶음으로 고정한다.</p>
<ol>
<li><p><strong>상태(state)</strong>의 운영 정의: 무엇을 상태로 기록하는가(필수 필드).</p></li>
<li><p><strong>사건(event)</strong>의 운영 정의: 상태 변화의 어떤 형태를 사건으로 카운트하는가(트리거 규칙).</p></li>
<li><p><strong>소멸(annihilation)</strong>의 운영 정의: 특정 조건에서 사건이 종료/상쇄되는 규칙(라벨 규칙 포함).</p></li>
<li><p><strong>정준 사건율</strong>의 정의: 잠긴 사건 정의를 바탕으로 장시간 평균 사건율을 정의하고, 이후 장(빌드타임/질량/힘/실현)으로 넘기는 연결 위치를 고정한다.</p></li>
</ol>
<p>본 장의 정의는 외부 텍스트의 정당화 없이, 본 문서의 공리(무한강성/충만/국소 규칙), 레지스트리(LOCK/SSOT), 정류 상수(<span class="math inline">\(\alpha,\delta\)</span>), 정수화 규칙(3-섹터, 82+7 구조)만을 근거로 한다.</p>
<h2 class="unnumbered" id="상위-전제레짐잠금기호-규약">상위 전제(레짐/잠금/기호 규약)</h2>
<p>본 장의 정의는 다음 전제가 잠겨 있을 때에만 유효하다.</p>
<ol>
<li><p><strong>Stone/충만/국소 규칙 레짐</strong>: VP 공리 세트가 적용되는 레짐에서 사건은 국소 갱신의 합성으로만 발생한다.</p></li>
<li><p><strong>정준 셀과 좌표계</strong>: 정준 셀(<code>CELL-CUBE</code>)과 중심/경계/절단 규약이 잠겨 있어야 한다.</p></li>
<li><p><strong>정류 상수와 생존 규약</strong>: <span class="math inline">\(\alpha=2/\pi\)</span>, <span class="math inline">\(\delta=1/\pi^2\)</span>의 정의가 잠겨 있고, 생존 가중치 <span class="math inline">\(w(e)\)</span>의 운영 정의가 잠겨 있어야 한다(정류 사건율을 사용하는 경우).</p></li>
<li><p><strong>정수 구조 및 라벨</strong>: 3-섹터 정수화와 셸 7 상쇄-생존 규약이 잠겨 있어야 하며, 전하/전자 라벨이 필요한 경우 라벨 축/문턱이 잠겨 있어야 한다.</p></li>
</ol>
<p>위 전제가 잠기지 않으면 본 장의 사건/상태/소멸 정의는 정의 불능이며, 이후 장으로 넘길 수 없다.</p>
<h2 class="unnumbered" id="운영-정의의-지위정의로서의-고정">운영 정의의 지위(정의로서의 고정)</h2>
<p>본 장에서 “운영 정의”란 다음을 의미한다.</p>
<ol>
<li><p>정의는 <strong>기계적으로 판정 가능</strong>해야 한다: 로그 필드로부터 사건의 존재/비존재가 자동으로 판정되어야 한다.</p></li>
<li><p>정의는 <strong>단일 출처(SSOT)</strong>로 고정되어야 한다: 동일 사건을 다른 절에서 다른 규칙으로 카운트하지 않는다.</p></li>
<li><p>정의는 <strong>사후 변경 불가</strong>이다: 정의를 바꾸면 사건율, 빌드타임, 질량/힘 유도의 입력이 바뀌므로, 변경은 버전업으로만 허용된다.</p></li>
</ol>
<p>따라서 본 장의 모든 항목은 “설명”이 아니라 “정의/규칙”으로만 제시되며, 해석 문장은 포함하지 않는다.</p>
<h2 class="unnumbered" id="사건상태소멸의-연결-골격">사건/상태/소멸의 연결 골격</h2>
<p>본 장의 핵심 골격은 다음 순서로 고정한다.
<span class="math display">\[\text{상태 기록} \;\Longrightarrow\; \text{사건 트리거 판정} \;\Longrightarrow\; \text{사건 집계(카운트/가중)} \;\Longrightarrow\; \text{소멸 판정} \;\Longrightarrow\; \text{정준 사건율}.
\label{eq:S09_chain}\]</span>
여기서</p>
<ul>
<li><p>“상태 기록”은 <strong>필수 필드</strong>를 갖는 로그 레코드로 잠긴다.</p></li>
<li><p>“사건 트리거”는 상태의 전/후 비교로 판정되는 <strong>불연속 또는 임계 전이</strong>의 규칙으로 잠긴다.</p></li>
<li><p>“사건 집계”는 원시 카운트 <span class="math inline">\(N_0\)</span> 또는 생존 정류 카운트 <span class="math inline">\(N_\delta\)</span>로 잠긴다.</p></li>
<li><p>“소멸 판정”은 라벨 상쇄 또는 임계 조건 만족으로 사건이 종료되는 규칙으로 잠긴다.</p></li>
<li><p>“정준 사건율”은 장시간 평균(또는 레짐 내 평균)으로 정의되며, 빌드타임 <span class="math inline">\(T_p,T_n\)</span> 및 후속 유도의 시간 스케일로 사용된다.</p></li>
</ul>
<p>본 개요는 이 골격을 선언하며, 구체 정의는 9.1 이후 절에서 완결한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-41">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 상태/사건/소멸의 운영 정의를 <code>canon_lock</code>의 단일 출처로 고정(SSOT).</p></li>
<li><p>LOCK: 사건 집계 방식(원시 <span class="math inline">\(N_0\)</span> vs 정류 <span class="math inline">\(N_\delta\)</span>) 및 정준 사건율 정의의 입력(정류 규약, 창 규약)을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 로그 스키마 누락 또는 정의 충돌은 G-LOCK/G-SYM에서 <code>INCONCLUSIVE</code> 또는 <code>FAIL</code>.</p></li>
<li><p>Gate: 사후 정의 변경(사건 트리거/소멸 규칙/가중치 교체)은 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 본 장 산출물(사건 로그/판정 로그)이 <code>manifest+checksums</code>로 봉인되지 않으면 G-REP에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
</ul>
<h2 data-number="11.1" id="양자사건상태소멸-운영정의"><span class="header-section-number">11.1</span> 9.1 양자/사건/상태/소멸 운영정의</h2>
<h3 data-number="11.1.1" id="목적-6"><span class="header-section-number">11.1.1</span> 9.1.1 목적</h3>
<p>본 절은 <strong>양자(Quantum)</strong>, <strong>사건(Event)</strong>, <strong>상태(State)</strong>, <strong>소멸(Annihilation)</strong>을 모두 <strong>로그 가능한 운영정의</strong>로 고정한다.
본 절의 정의는 (i) 필수 로그 필드, (ii) 판정 가능한 트리거 함수, (iii) 사후조정 금지(No-Tuning), (iv) 단일 출처(SSOT) 규약을 포함하며, 해석 문장은 포함하지 않는다.</p>
<h3 data-number="11.1.2" id="공통-시간창-정의틱과-실현-시간"><span class="header-section-number">11.1.2</span> 9.1.2 공통 시간/창 정의(틱과 실현 시간)</h3>
<h4 data-number="11.1.2.1" id="d-9.1-1-틱-인덱스"><span class="header-section-number">11.1.2.1</span> [D-9.1-1] 틱 인덱스</h4>
<p>틱 인덱스를 <span class="math inline">\(n\in\mathbb{Z}\)</span>로 정의한다. 사건 로그에서 모든 레코드는 정수 틱 <span class="math inline">\(n\)</span>을 필수로 가진다.</p>
<h4 data-number="11.1.2.2" id="d-9.1-2-실현-시간"><span class="header-section-number">11.1.2.2</span> [D-9.1-2] 실현 시간</h4>
<p>실현 시간 틱 <span class="math inline">\(\Delta t\)</span>가 <code>realization_lock</code>에 잠겨 있을 때 실현 시간을
<span class="math display">\[t := n\,\Delta t
\label{eq:S09_01_time_real}\]</span>
로 정의한다.</p>
<h4 data-number="11.1.2.3" id="d-9.1-3-시간-창"><span class="header-section-number">11.1.2.3</span> [D-9.1-3] 시간 창</h4>
<p>두 틱 <span class="math inline">\(n_1&lt;n_2\)</span>에 대해 시간 창을 다음으로 정의한다.
<span class="math display">\[W[n_1,n_2) := \{\,n\in\mathbb{Z}\mid n_1\le n&lt;n_2\,\},
\qquad
\Delta N := n_2-n_1,
\qquad
\Delta T := \Delta N\,\Delta t.
\label{eq:S09_01_window}\]</span>
<span class="math inline">\(\Delta t\)</span>가 정의 불능이면 <span class="math inline">\(\Delta T\)</span>는 사용 불가이며, 모든 사건율은 틱 기반으로만 기록한다.</p>
<h3 data-number="11.1.3" id="상태state-운영정의-로그-레코드필수-필드"><span class="header-section-number">11.1.3</span> 9.1.3 상태(State) 운영정의: 로그 레코드(필수 필드)</h3>
<h4 data-number="11.1.3.1" id="d-9.1-4-상태-레코드"><span class="header-section-number">11.1.3.1</span> [D-9.1-4] 상태 레코드</h4>
<p>상태는 “한 틱에서 고정된 스냅샷”으로 정의하며, 상태 레코드를 <span class="math inline">\(S[n]\)</span>로 표기한다. <span class="math inline">\(S[n]\)</span>은 다음 필드를 <strong>반드시</strong> 포함해야 한다(누락 시 정의 불능).</p>
<ol>
<li><p><strong>state_id</strong>: 상태 고유 식별자(문자열).</p></li>
<li><p><strong>tick</strong>: <span class="math inline">\(n\)</span> (정수).</p></li>
<li><p><strong>regime_id</strong>: 레짐 식별자(4.3에서 잠김).</p></li>
<li><p><strong>lock_refs</strong>: <code>canon_lock_id</code>, <code>realization_lock_id</code>, <code>analysis_lock_id</code>.</p></li>
<li><p><strong>core_state_ref</strong>: 코어 상태 참조(예: <code>X82.csv</code> 스냅샷 키, 또는 해시).</p></li>
<li><p><strong>shell_state_ref</strong>: 셸 상태 참조(예: <code>S7</code> 스냅샷 키, 또는 해시).</p></li>
<li><p><strong>center_ref</strong>: 중심 <span class="math inline">\(\mathbf{x}_c\)</span> 참조(또는 값).</p></li>
<li><p><strong>geometry_ref</strong>: <span class="math inline">\(R_p\)</span>, <span class="math inline">\(L_q\)</span>, <span class="math inline">\(D_{\mathrm{anch}}\)</span> 등 사용된 길이 스케일의 참조(항목명+lock_id).</p></li>
<li><p><strong>graph_ref</strong>: 접촉 그래프 참조(예: <code>G82.edgelist</code> 해시 또는 스냅샷 키).</p></li>
</ol>
<h4 data-number="11.1.3.2" id="d-9.1-5-상태의-완결성-조건"><span class="header-section-number">11.1.3.2</span> [D-9.1-5] 상태의 완결성 조건</h4>
<p>상태 레코드 <span class="math inline">\(S[n]\)</span>은 다음 조건을 만족해야 “완결 상태”로 정의된다.
<span class="math display">\[\mathrm{Complete}(S[n])=1
\Longleftrightarrow
\text{9.1.3의 필수 필드가 모두 존재하고, lock\_refs가 스냅샷에 봉인됨}.
\label{eq:S09_01_complete_state}\]</span>
<span class="math inline">\(\mathrm{Complete}(S[n])=0\)</span>이면 해당 틱은 사건 판정의 입력으로 사용할 수 없다.</p>
<h3 data-number="11.1.4" id="사건event-운영정의-전이transition와-트리거"><span class="header-section-number">11.1.4</span> 9.1.4 사건(Event) 운영정의: 전이(transition)와 트리거</h3>
<h4 data-number="11.1.4.1" id="d-9.1-6-전이"><span class="header-section-number">11.1.4.1</span> [D-9.1-6] 전이</h4>
<p>두 연속 상태 <span class="math inline">\(S[n-1],S[n]\)</span>이 모두 완결일 때, 전이를
<span class="math display">\[\Delta S[n] := (S[n-1]\rightarrow S[n])
\label{eq:S09_01_transition}\]</span>
로 정의한다.</p>
<h4 data-number="11.1.4.2" id="d-9.1-7-사건-트리거-함수"><span class="header-section-number">11.1.4.2</span> [D-9.1-7] 사건 트리거 함수</h4>
<p>사건은 전이 <span class="math inline">\(\Delta S[n]\)</span>에 대해 다음 트리거 함수가 1을 반환할 때 발생하는 것으로 정의한다.
<span class="math display">\[\mathrm{Trig}(\Delta S[n])\in\{0,1\},
\qquad
\mathrm{Trig}(\Delta S[n])=1\ \Longleftrightarrow\ \Delta S[n]\ \text{가 사건으로 카운트됨}.
\label{eq:S09_01_trig_def}\]</span>
<span class="math inline">\(\mathrm{Trig}\)</span>의 구체 규칙은 <code>analysis_lock</code>에 잠겨야 하며, 결과를 본 뒤 교체될 수 없다.</p>
<h4 data-number="11.1.4.3" id="d-9.1-8-사건-레코드"><span class="header-section-number">11.1.4.3</span> [D-9.1-8] 사건 레코드</h4>
<p><span class="math inline">\(\mathrm{Trig}(\Delta S[n])=1\)</span>이면 사건 레코드 <span class="math inline">\(e[n]\)</span>을 생성한다. 사건 레코드의 필수 필드는 다음과 같다.</p>
<ol>
<li><p><strong>event_id</strong>: 사건 고유 식별자(문자열).</p></li>
<li><p><strong>tick</strong>: <span class="math inline">\(n\)</span>.</p></li>
<li><p><strong>pre_state_id</strong>: <span class="math inline">\(S[n-1].\mathrm{state\_id}\)</span>.</p></li>
<li><p><strong>post_state_id</strong>: <span class="math inline">\(S[n].\mathrm{state\_id}\)</span>.</p></li>
<li><p><strong>trigger_id</strong>: 어떤 트리거가 작동했는지(열거형).</p></li>
<li><p><strong>lock_refs</strong>: <code>canon_lock_id</code>, <code>realization_lock_id</code>, <code>analysis_lock_id</code>.</p></li>
<li><p><strong>regime_id</strong>: <span class="math inline">\(S[n].\mathrm{regime\_id}\)</span>.</p></li>
<li><p><strong>event_payload</strong>: 트리거별 필수 데이터(아래 9.1.4.1–9.1.4.3).</p></li>
</ol>
<h4 data-number="11.1.4.4" id="트리거-집합표준-트리거-id"><span class="header-section-number">11.1.4.4</span> 9.1.4.1 트리거 집합(표준 트리거 ID)</h4>
<p>본 문서에서 사건 트리거 ID는 다음 열거형으로 고정한다(추가 트리거는 버전업으로만 허용).</p>
<ol>
<li><p><strong>TRIG-GRAPH</strong>: 접촉 그래프 변화 트리거.</p></li>
<li><p><strong>TRIG-SHELL</strong>: 셸 분할/상쇄-생존 변화 트리거.</p></li>
<li><p><strong>TRIG-LABEL</strong>: 전하/전자 라벨 변화 트리거.</p></li>
<li><p><strong>TRIG-EMIT</strong>: 방출 레코드 생성 트리거.</p></li>
<li><p><strong>TRIG-ANN</strong>: 소멸 판정 트리거(9.1.6).</p></li>
</ol>
<p>각 트리거의 구체 판정식은 다음과 같이 “로그 비교”로만 구성되며, 판정 문턱은 <code>gate_lock</code>에 잠긴다.</p>
<h4 data-number="11.1.4.5" id="trig-graph접촉-그래프-변화-정의"><span class="header-section-number">11.1.4.5</span> 9.1.4.2 TRIG-GRAPH(접촉 그래프 변화) 정의</h4>
<p>접촉 그래프를 <span class="math inline">\(\mathcal{G}_c[n]\)</span>로 표기하고, 간선 집합을 <span class="math inline">\(\mathcal{E}_c[n]\)</span>로 둔다. 그래프 변화량을 다음으로 정의한다.
<span class="math display">\[\Delta E[n] := |\mathcal{E}_c[n]\ \triangle\ \mathcal{E}_c[n-1]|
\label{eq:S09_01_graph_delta}\]</span>
여기서 <span class="math inline">\(\triangle\)</span>는 대칭차이다. 문턱 <span class="math inline">\(E_{\min}\in\mathbb{Z}_{\ge 0}\)</span>를 <code>gate_lock</code>에 잠근다. TRIG-GRAPH는 다음으로 정의한다.
<span class="math display">\[\mathrm{Trig}_{\mathrm{GRAPH}}(\Delta S[n])=1
\Longleftrightarrow
\Delta E[n]\ge E_{\min}.
\label{eq:S09_01_trig_graph}\]</span>
TRIG-GRAPH가 발화한 사건의 <strong>event_payload</strong>는 <span class="math inline">\((\Delta E[n],E_{\min},\mathcal{E}_c[n-1],\mathcal{E}_c[n])\)</span>의 참조를 포함해야 한다.</p>
<h4 data-number="11.1.4.6" id="trig-label라벨-변화-정의"><span class="header-section-number">11.1.4.6</span> 9.1.4.3 TRIG-LABEL(라벨 변화) 정의</h4>
<p>전자/반전자/중립 라벨을 <span class="math inline">\(\mathcal{L}[n]\in\{\texttt{ELECTRON},\texttt{ANTI\_ELECTRON},\texttt{NEUTRAL}\}\)</span>로 표기한다(7.4 및 8.4의 정의 참조). TRIG-LABEL은 다음으로 정의한다.
<span class="math display">\[\mathrm{Trig}_{\mathrm{LABEL}}(\Delta S[n])=1
\Longleftrightarrow
\mathcal{L}[n]\neq \mathcal{L}[n-1].
\label{eq:S09_01_trig_label}\]</span>
TRIG-LABEL 사건의 <strong>event_payload</strong>는 <span class="math inline">\((\mathcal{L}[n-1],\mathcal{L}[n])\)</span> 및 라벨 계산에 사용된 <span class="math inline">\(\mathbf{V}_{\mathrm{surv}}\)</span> 참조(또는 해시)를 포함해야 한다.</p>
<h3 data-number="11.1.5" id="양자quantum-운영정의-사건의-최소-단위"><span class="header-section-number">11.1.5</span> 9.1.5 양자(Quantum) 운영정의: 사건의 최소 단위</h3>
<h4 data-number="11.1.5.1" id="d-9.1-9-양자quantum"><span class="header-section-number">11.1.5.1</span> [D-9.1-9] 양자(Quantum)</h4>
<p>본 문서에서 “양자”는 <strong>사건 레코드 <span class="math inline">\(e[n]\)</span> 하나</strong>를 의미하는 예약어로 정의한다.
<span class="math display">\[\text{Quantum } q[n]\ \equiv\ e[n]\quad (\mathrm{Trig}(\Delta S[n])=1\text{일 때}).
\label{eq:S09_01_quantum_def}\]</span>
따라서 양자는 로그 가능한 최소 단위이며, 양자에 대한 모든 논의는 <span class="math inline">\(e[n]\)</span>의 필수 필드로 환원되어야 한다.
양자의 “크기” 또는 “가중”이 필요한 경우, 생존 가중치 <span class="math inline">\(w(e)\)</span> 또는 사건 카운트 <span class="math inline">\(N_0\)</span> 등의 정의를 <code>analysis_lock</code>에 잠긴 방식으로만 참조할 수 있다. (양자에 임의의 크기 함수를 추가하는 행위는 금지된다.)</p>
<h3 data-number="11.1.6" id="소멸annihilation-운영정의-상쇄-사건의-규칙"><span class="header-section-number">11.1.6</span> 9.1.6 소멸(Annihilation) 운영정의: 상쇄 사건의 규칙</h3>
<p>소멸은 “반대 라벨의 동시 존재가 특정 창에서 상쇄되어 제거되는 사건”으로 <strong>정의</strong>한다.</p>
<h4 data-number="11.1.6.1" id="소멸-창시간공간-정의"><span class="header-section-number">11.1.6.1</span> 9.1.6.1 소멸 창(시간/공간) 정의</h4>
<p>소멸 판정에는 시간 창과 공간 창이 필요하므로, 다음 문턱을 잠근다.
<span class="math display">\[\Delta n_{\mathrm{ann}}\in\mathbb{Z}_{&gt;0}\ \text{(잠김)},
\qquad
\rho_{\mathrm{ann}}&gt;0\ \text{(잠김)}.
\label{eq:S09_01_ann_windows}\]</span>
시간 창은 틱 기반으로
<span class="math display">\[W_{\mathrm{ann}}[n] := W[n-\Delta n_{\mathrm{ann}}+1,\ n+1)
\label{eq:S09_01_ann_time_window}\]</span>
로 정의한다. 공간 창은 방출점(8.4) <span class="math inline">\(\mathbf{x}_{\mathrm{emit}}\)</span>의 거리로 정의한다.</p>
<h4 data-number="11.1.6.2" id="소멸-후보반대-라벨-쌍-정의"><span class="header-section-number">11.1.6.2</span> 9.1.6.2 소멸 후보(반대 라벨 쌍) 정의</h4>
<p>시간 창 <span class="math inline">\(W_{\mathrm{ann}}[n]\)</span> 안에서 방출 사건 레코드 집합을
<span class="math display">\[\mathcal{E}_{\mathrm{emit}}(W_{\mathrm{ann}}[n])
:=
\{\, e[m]\mid m\in W_{\mathrm{ann}}[n],\ \texttt{trigger\_id}=\texttt{TRIG-EMIT}\,\}
\label{eq:S09_01_emit_set}\]</span>
로 정의한다. 각 방출 사건은 (8.4의 정의에 의해) 방출점 <span class="math inline">\(\mathbf{x}_{\mathrm{emit}}(e)\)</span>, 라벨 <span class="math inline">\(\mathcal{L}(e)\)</span>, 생존 벡터 <span class="math inline">\(\mathbf{V}_{\mathrm{surv}}(e)\)</span>의 참조를 가진다.</p>
<p>서로 다른 두 방출 사건 <span class="math inline">\(e_a,e_b\)</span>가 다음을 만족하면 소멸 후보 쌍으로 정의한다.
<span class="math display">\[\mathcal{L}(e_a)=\texttt{ELECTRON},
\qquad
\mathcal{L}(e_b)=\texttt{ANTI\_ELECTRON}.
\label{eq:S09_01_opposite_labels}\]</span></p>
<h4 data-number="11.1.6.3" id="공간-근접-조건"><span class="header-section-number">11.1.6.3</span> 9.1.6.3 공간 근접 조건</h4>
<p>공간 근접 조건을 다음으로 정의한다.
<span class="math display">\[\|\mathbf{x}_{\mathrm{emit}}(e_a)-\mathbf{x}_{\mathrm{emit}}(e_b)\|\le \rho_{\mathrm{ann}}.
\label{eq:S09_01_ann_spatial}\]</span></p>
<h4 data-number="11.1.6.4" id="상쇄-조건생존-벡터-합의-붕괴"><span class="header-section-number">11.1.6.4</span> 9.1.6.4 상쇄 조건(생존 벡터 합의 붕괴)</h4>
<p>상쇄 문턱 <span class="math inline">\(V_{\mathrm{ann}}&gt;0\)</span>를 잠근다. 소멸 상쇄 조건을 다음으로 정의한다.
<span class="math display">\[\left\|\mathbf{V}_{\mathrm{surv}}(e_a)+\mathbf{V}_{\mathrm{surv}}(e_b)\right\|\le V_{\mathrm{ann}}.
\label{eq:S09_01_ann_cancel}\]</span></p>
<h4 data-number="11.1.6.5" id="소멸-사건-정의trig-ann"><span class="header-section-number">11.1.6.5</span> 9.1.6.5 소멸 사건 정의(TRIG-ANN)</h4>
<p>소멸 트리거를 다음으로 정의한다.
<span class="math display">\[\mathrm{Trig}_{\mathrm{ANN}}(\Delta S[n])=1
\Longleftrightarrow
\exists (e_a,e_b)\subset \mathcal{E}_{\mathrm{emit}}(W_{\mathrm{ann}}[n])\ \text{s.t.}\
\eqref{eq:S09_01_opposite_labels},\ \eqref{eq:S09_01_ann_spatial},\ \eqref{eq:S09_01_ann_cancel}\ \text{를 모두 만족}.
\label{eq:S09_01_trig_ann}\]</span>
TRIG-ANN이 발화한 사건의 <strong>event_payload</strong>는 <span class="math inline">\((e_a,e_b)\)</span>의 참조, 거리값, 벡터합 노름, 문턱 <span class="math inline">\((\rho_{\mathrm{ann}},V_{\mathrm{ann}},\Delta n_{\mathrm{ann}})\)</span>를 포함해야 한다.</p>
<h4 data-number="11.1.6.6" id="소멸의-상태-업데이트-규칙라벨-소거"><span class="header-section-number">11.1.6.6</span> 9.1.6.6 소멸의 상태 업데이트 규칙(라벨 소거)</h4>
<p>TRIG-ANN 사건이 발생하면 상태 업데이트 규칙을 다음으로 정의한다.
<span class="math display">\[\mathcal{L}[n]\leftarrow \texttt{NEUTRAL}
\quad\text{및}\quad
\text{대상 방출 레코드 }(e_a,e_b)\text{는 소멸 처리로 라벨링}.
\label{eq:S09_01_ann_state_update}\]</span>
이 규칙은 “소멸은 라벨 소거로 기록된다”는 운영 정의이며, 다른 의미(해석)를 부여하지 않는다.</p>
<h3 data-number="11.1.7" id="금지되는-애매문장정의-위반판정-무력화사후조정"><span class="header-section-number">11.1.7</span> 9.1.7 금지되는 애매문장(정의 위반/판정 무력화/사후조정)</h3>
<p>본 절의 운영정의 체계에서 다음 문장 유형은 금지된다. 금지의 기준은 “로그로 판정 불가” 또는 “사후조정 허용” 또는 “Gate 무력화”이다.</p>
<ol>
<li><p><strong>정의 누락형</strong>: “상태가 변했으니 사건이다.” (어떤 필드 변화가 사건 트리거인지 미정)</p></li>
<li><p><strong>문턱 미정형</strong>: “충분히 가까우면 소멸이다.” ( <span class="math inline">\(\rho_{\mathrm{ann}}\)</span> 또는 <span class="math inline">\(V_{\mathrm{ann}}\)</span> 미잠금 )</p></li>
<li><p><strong>레짐 무시형</strong>: “어떤 레짐에서도 동일 사건율이 성립한다.” (레짐 좌표축/허용 스택 미표기)</p></li>
<li><p><strong>Gate 무력화형</strong>: “Gate가 FAIL이어도 해석상 사건으로 본다.” (판정 무력화)</p></li>
<li><p><strong>사후조정형</strong>: “결과가 맞지 않으니 트리거 문턱을 조정한다.” (No-Tuning 위반)</p></li>
<li><p><strong>잠금 혼합형</strong>: “이번에는 다른 기준축으로 라벨을 다시 정하자.” (lock_id 혼합)</p></li>
<li><p><strong>불완결 로그 정당화형</strong>: “로그가 없지만 아마 발생했을 것이다.” (로그 기반 판정 위반)</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-42">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 상태 레코드 <span class="math inline">\(S[n]\)</span>의 필수 필드(SSOT)와 완결성 <span class="math inline">\(\mathrm{Complete}(S[n])\)</span> 규칙을 <code>canon_lock</code>/<code>protocol_lock</code>에 고정.</p></li>
<li><p>LOCK: 사건 트리거 <span class="math inline">\(\mathrm{Trig}\)</span> 및 표준 트리거 집합(TRIG-*)과 문턱 <span class="math inline">\((E_{\min},\Delta n_{\mathrm{ann}},\rho_{\mathrm{ann}},V_{\mathrm{ann}})\)</span>을 <code>analysis_lock</code>/<code>gate_lock</code>에 고정.</p></li>
<li><p>Gate: 로그 누락/잠금 누락은 G-LOCK에서 <code>INCONCLUSIVE</code>; 의미 충돌은 G-SYM에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 문턱/규칙/축의 사후 변경 또는 선택 편향은 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 사건/소멸 레코드가 <code>manifest+checksums</code>로 봉인되지 않으면 G-REP에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
</ul>
<h2 data-number="11.2" id="정준-사건율-법칙-nu_mathrmcanscdotdelta"><span class="header-section-number">11.2</span> 9.2 정준 사건율 법칙 <span class="math inline">\(\nu_{\mathrm{can}}=s\cdot\delta\)</span></h2>
<h3 data-number="11.2.1" id="분류정의공리정리-고정"><span class="header-section-number">11.2.1</span> 9.2.1 분류(정의/공리/정리) 고정</h3>
<p>본 절에서 사용되는 핵심 문장들의 지위를 다음과 같이 고정한다.</p>
<ol>
<li><p><strong>[D] 정의</strong>: <span class="math inline">\(s\)</span> (시도율), <span class="math inline">\(\delta\)</span> (생존 정류 계수), <span class="math inline">\(\nu_{\mathrm{can}}\)</span> (정준 사건율), 그리고 이들을 구성하는 카운트/가중치/시간창/한계 연산.</p></li>
<li><p><strong>[A] 공리</strong>: (i) 장시간 평균의 존재 및 정착(정준 정상성), (ii) <span class="math inline">\(\delta\)</span> 보편성 조건(균등 위상, 이중 구속, 분리 측도)과 그 적용 범위.</p></li>
<li><p><strong>[T] 정리</strong>: 위 정의와 공리로부터 <span class="math inline">\(\nu_{\mathrm{can}}=s\cdot\delta\)</span>를 도출하는 정리.</p></li>
</ol>
<p>따라서 본 절의 등식 <span class="math inline">\(\nu_{\mathrm{can}}=s\cdot\delta\)</span>는 <strong>정리 [T]</strong>로 고정되며, 그 정리가 성립하기 위한 조건은 <strong>공리 [A]</strong>로 고정된다. <span class="math inline">\(s,\delta,\nu_{\mathrm{can}}\)</span>의 기호 의미는 <strong>정의 [D]</strong>로만 고정된다.</p>
<h3 data-number="11.2.2" id="d-시도-사건-집합과-시도율-s"><span class="header-section-number">11.2.2</span> 9.2.2 [D] 시도 사건 집합과 시도율 <span class="math inline">\(s\)</span></h3>
<h4 data-number="11.2.2.1" id="시간창과-시도-사건-집합"><span class="header-section-number">11.2.2.1</span> 9.2.2.1 시간창과 시도 사건 집합</h4>
<p>실현 시간창을 <span class="math inline">\([t,t+T)\)</span>로 두고(<span class="math inline">\(T&gt;0\)</span>), 해당 창에서 발생한 “시도 사건”의 집합을 다음으로 정의한다.
<span class="math display">\[\mathcal{E}_0(t;T)
:=\{\, e\mid t\le t(e)&lt;t+T,\ \mathrm{Trig}_0(e)=1\,\}.
\label{eq:S09_02_E0}\]</span>
여기서 <span class="math inline">\(\mathrm{Trig}_0(e)\in\{0,1\}\)</span>는 “시도 사건 트리거”이며, 다음을 만족하도록 <code>analysis_lock</code>에 잠긴다.</p>
<ol>
<li><p><span class="math inline">\(\mathrm{Trig}_0(e)=1\)</span>이면 사건 레코드가 생성될 최소 조건을 만족한다(로그 완결성 포함).</p></li>
<li><p><span class="math inline">\(\mathrm{Trig}_0\)</span>는 생존 구속(아래의 <span class="math inline">\(w(e)\)</span>)을 적용하기 <em>이전</em>의 사건 카운트 규칙이다.</p></li>
</ol>
<p><span class="math inline">\(\mathrm{Trig}_0\)</span>의 정의가 잠기지 않으면 <a data-reference="eq:S09_02_E0" data-reference-type="eqref" href="#eq:S09_02_E0">[eq:S09_02_E0]</a>는 정의 불능이다.</p>
<p>시도 사건 수(원시 사건 수)를 다음으로 정의한다.
<span class="math display">\[N_0(t;T):=\bigl|\mathcal{E}_0(t;T)\bigr|.
\label{eq:S09_02_N0}\]</span></p>
<h4 data-number="11.2.2.2" id="시도율-s의-정의장시간-평균"><span class="header-section-number">11.2.2.2</span> 9.2.2.2 시도율 <span class="math inline">\(s\)</span>의 정의(장시간 평균)</h4>
<p>시도율 <span class="math inline">\(s\)</span>를 다음 장시간 평균으로 정의한다.
<span class="math display">\[s
:=
\lim_{T\to\infty}\frac{N_0(t;T)}{T}.
\label{eq:S09_02_s_def}\]</span>
정의 <a data-reference="eq:S09_02_s_def" data-reference-type="eqref" href="#eq:S09_02_s_def">[eq:S09_02_s_def]</a>에서 한계가 존재하고 <span class="math inline">\(t\)</span>에 무관하게 정착하는 조건은 공리 [A-9.2-S1]로 고정된다(9.2.5).
따라서 <span class="math inline">\(s\)</span>는 <strong>정의 [D]</strong>로서 “시도 사건 카운트의 시간 밀도”이며, 외부 근거로 정당화되지 않는다.</p>
<h3 data-number="11.2.3" id="d-생존-가중치와-정준-사건율-nu_mathrmcan"><span class="header-section-number">11.2.3</span> 9.2.3 [D] 생존 가중치와 정준 사건율 <span class="math inline">\(\nu_{\mathrm{can}}\)</span></h3>
<h4 data-number="11.2.3.1" id="이중-구속-위상과-반파-정류"><span class="header-section-number">11.2.3.1</span> 9.2.3.1 이중 구속 위상과 반파 정류</h4>
<p>각 시도 사건 <span class="math inline">\(e\in\mathcal{E}_0(t;T)\)</span>에 대해 두 위상 변수를 다음으로 정의한다.
<span class="math display">\[\theta(e)\in[0,2\pi),
\qquad
\varphi(e)\in[0,2\pi).
\label{eq:S09_02_theta_phi}\]</span>
<span class="math inline">\(\theta(e)\)</span>와 <span class="math inline">\(\varphi(e)\)</span>의 산출 규칙(어떤 로그 필드에서 어떻게 계산되는지)은 <code>analysis_lock</code>에 잠긴다.
반파 정류 연산자를 다음으로 정의한다.
<span class="math display">\[_+ := \max(0,x).
\label{eq:S09_02_pospart}\]</span></p>
<h4 data-number="11.2.3.2" id="생존-가중치-we의-정의"><span class="header-section-number">11.2.3.2</span> 9.2.3.2 생존 가중치 <span class="math inline">\(w(e)\)</span>의 정의</h4>
<p>시도 사건 <span class="math inline">\(e\)</span>의 생존 가중치를 다음으로 정의한다.
<span class="math display">\[w(e)
:=
[\cos\theta(e)]_{+}\,[\cos\varphi(e)]_{+}.
\label{eq:S09_02_w_def}\]</span>
정의 <a data-reference="eq:S09_02_w_def" data-reference-type="eqref" href="#eq:S09_02_w_def">[eq:S09_02_w_def]</a>는 생존 규약의 유일 출처이며, 동일 버전 내부에서 <span class="math inline">\(|\,\cdot\,|\)</span> 또는 다른 비선형 함수로 교체될 수 없다.</p>
<h4 data-number="11.2.3.3" id="정준-사건-수-n_mathrmcan의-정의"><span class="header-section-number">11.2.3.3</span> 9.2.3.3 정준 사건 수 <span class="math inline">\(N_{\mathrm{can}}\)</span>의 정의</h4>
<p>시간창 <span class="math inline">\([t,t+T)\)</span>에서의 정준 사건 수(정류 카운트)를 다음으로 정의한다.
<span class="math display">\[N_{\mathrm{can}}(t;T)
:=
\sum_{e\in\mathcal{E}_0(t;T)} w(e).
\label{eq:S09_02_Ncan_def}\]</span>
정의상 <span class="math inline">\(0\le N_{\mathrm{can}}(t;T)\le N_0(t;T)\)</span>가 성립한다.</p>
<h4 data-number="11.2.3.4" id="정준-사건율-nu_mathrmcan의-정의장시간-평균"><span class="header-section-number">11.2.3.4</span> 9.2.3.4 정준 사건율 <span class="math inline">\(\nu_{\mathrm{can}}\)</span>의 정의(장시간 평균)</h4>
<p>정준 사건율을 다음 장시간 평균으로 정의한다.
<span class="math display">\[\nu_{\mathrm{can}}
:=
\lim_{T\to\infty}\frac{N_{\mathrm{can}}(t;T)}{T}.
\label{eq:S09_02_nucan_def}\]</span>
정의 <a data-reference="eq:S09_02_nucan_def" data-reference-type="eqref" href="#eq:S09_02_nucan_def">[eq:S09_02_nucan_def]</a>에서 한계가 존재하고 <span class="math inline">\(t\)</span>에 무관하게 정착하는 조건은 공리 [A-9.2-S1]로 고정된다(9.2.5).</p>
<h3 data-number="11.2.4" id="d-delta의-정의와-고정값잠금-위치"><span class="header-section-number">11.2.4</span> 9.2.4 [D] <span class="math inline">\(\delta\)</span>의 정의와 고정값(잠금 위치)</h3>
<h4 data-number="11.2.4.1" id="delta의-정의시도-사건에-대한-평균-생존-계수"><span class="header-section-number">11.2.4.1</span> 9.2.4.1 <span class="math inline">\(\delta\)</span>의 정의(시도 사건에 대한 평균 생존 계수)</h4>
<p><span class="math inline">\(\delta\)</span>를 다음 평균 생존 계수로 정의한다.
<span class="math display">\[\delta
:=
\lim_{T\to\infty}
\frac{1}{N_0(t;T)}
\sum_{e\in\mathcal{E}_0(t;T)} w(e),
\qquad
(\text{단, }N_0(t;T)&gt;0).
\label{eq:S09_02_delta_def}\]</span>
정의 <a data-reference="eq:S09_02_delta_def" data-reference-type="eqref" href="#eq:S09_02_delta_def">[eq:S09_02_delta_def]</a>가 의미를 가지려면, 장시간에서 <span class="math inline">\(N_0(t;T)\to\infty\)</span>가 성립해야 하며, 그 조건은 공리 [A-9.2-S1]에 포함된다.</p>
<h4 data-number="11.2.4.2" id="delta의-값-잠금보편성-공리-적용-레짐"><span class="header-section-number">11.2.4.2</span> 9.2.4.2 <span class="math inline">\(\delta\)</span>의 값 잠금(보편성 공리 적용 레짐)</h4>
<p>보편성 공리 [A-5.2-U]가 적용되는 레짐에서 <span class="math inline">\(\delta\)</span>의 값은 다음으로 잠긴다.
<span class="math display">\[\delta=\frac{1}{\pi^2}.
\label{eq:S09_02_delta_value_lock}\]</span>
식 <a data-reference="eq:S09_02_delta_value_lock" data-reference-type="eqref" href="#eq:S09_02_delta_value_lock">[eq:S09_02_delta_value_lock]</a>은 5.2의 유일 출처에서 잠긴 항목이며, 본 절에서는 재유도하지 않는다. 본 절에서 허용되는 것은 <a data-reference="eq:S09_02_delta_value_lock" data-reference-type="eqref" href="#eq:S09_02_delta_value_lock">[eq:S09_02_delta_value_lock]</a>의 <strong>참조</strong>뿐이다.</p>
<h3 data-number="11.2.5" id="a-공리-정준-정상성-및-delta-보편성의-적용-조건"><span class="header-section-number">11.2.5</span> 9.2.5 [A] 공리: 정준 정상성 및 <span class="math inline">\(\delta\)</span> 보편성의 적용 조건</h3>
<h3 data-number="11.2.6" id="a-9.2-s1-정준-정상성-공리장시간-평균의-존재와-정착"><span class="header-section-number">11.2.6</span> [A-9.2-S1] 정준 정상성 공리(장시간 평균의 존재와 정착)</h3>
<p>다음 한계들이 존재하며, 시작 시각 <span class="math inline">\(t\)</span>에 무관하게 동일 값으로 정착한다고 공리로 고정한다.
<span class="math display">\[\lim_{T\to\infty}\frac{N_0(t;T)}{T}=s,
\qquad
\lim_{T\to\infty}\frac{N_{\mathrm{can}}(t;T)}{T}=\nu_{\mathrm{can}},
\qquad
\lim_{T\to\infty}\frac{1}{N_0(t;T)}\sum_{e\in\mathcal{E}_0(t;T)}w(e)=\delta.
\label{eq:S09_02_stationarity_axiom}\]</span>
공리 <a data-reference="eq:S09_02_stationarity_axiom" data-reference-type="eqref" href="#eq:S09_02_stationarity_axiom">[eq:S09_02_stationarity_axiom]</a>은 “정준 사건율”과 “시도율” 및 “생존 계수”가 레짐 내에서 상수로 취급될 수 있음을 뜻한다. 이 공리가 성립하지 않으면 <span class="math inline">\(\nu_{\mathrm{can}}=s\delta\)</span>는 정리의 전제가 붕괴한다.</p>
<h3 data-number="11.2.7" id="a-9.2-s2-delta-보편성-공리적용-레짐에서의-값-고정"><span class="header-section-number">11.2.7</span> [A-9.2-S2] <span class="math inline">\(\delta\)</span> 보편성 공리(적용 레짐에서의 값 고정)</h3>
<p>다음 조건이 잠긴 레짐에서만 <span class="math inline">\(\delta=\frac{1}{\pi^2}\)</span>를 사용한다.</p>
<ol>
<li><p>위상 균등성: <span class="math inline">\(\theta,\varphi\)</span>가 각각 <span class="math inline">\([0,2\pi)\)</span> 전주기에서 균등 측도를 따른다.</p></li>
<li><p>이중 구속: 생존 가중치가 <a data-reference="eq:S09_02_w_def" data-reference-type="eqref" href="#eq:S09_02_w_def">[eq:S09_02_w_def]</a>의 곱 형태로 고정된다.</p></li>
<li><p>분리 측도: <span class="math inline">\((\theta,\varphi)\)</span>의 결합 측도가 곱측도로 분리된다.</p></li>
</ol>
<p>이 공리는 5.2의 보편성 공리 [A-5.2-U]의 레짐 제한을 본 장에서 재표현한 것이며, 값 고정은 <code>canon_lock</code>에 귀속된다.</p>
<h3 data-number="11.2.8" id="t-정준-사건율-법칙-nu_mathrmcanscdotdelta"><span class="header-section-number">11.2.8</span> 9.2.6 [T] 정준 사건율 법칙 <span class="math inline">\(\nu_{\mathrm{can}}=s\cdot\delta\)</span></h3>
<p>공리 [A-9.2-S1]이 성립하는 레짐에서, 정의 <a data-reference="eq:S09_02_s_def" data-reference-type="eqref" href="#eq:S09_02_s_def">[eq:S09_02_s_def]</a>, <a data-reference="eq:S09_02_nucan_def" data-reference-type="eqref" href="#eq:S09_02_nucan_def">[eq:S09_02_nucan_def]</a>, <a data-reference="eq:S09_02_delta_def" data-reference-type="eqref" href="#eq:S09_02_delta_def">[eq:S09_02_delta_def]</a>로부터 다음 정리를 도출한다.</p>
<h3 data-number="11.2.9" id="t-9.2-1-정리정준-사건율-법칙"><span class="header-section-number">11.2.9</span> [T-9.2-1] 정리(정준 사건율 법칙)</h3>
<p>다음이 성립한다.
<span class="math display">\[\nu_{\mathrm{can}} = s\cdot \delta.
\label{eq:S09_02_theorem_goal}\]</span></p>
<h4 data-number="11.2.9.1" id="증명"><span class="header-section-number">11.2.9.1</span> 증명</h4>
<p>정준 사건 수의 정의 <a data-reference="eq:S09_02_Ncan_def" data-reference-type="eqref" href="#eq:S09_02_Ncan_def">[eq:S09_02_Ncan_def]</a>를 사용하면,
<span class="math display">\[\frac{N_{\mathrm{can}}(t;T)}{T}
=
\frac{1}{T}\sum_{e\in\mathcal{E}_0(t;T)} w(e).
\label{eq:S09_02_step1}\]</span>
우변에 <span class="math inline">\(N_0(t;T)\)</span>를 곱하고 나누어 다음과 같이 변형한다(단, <span class="math inline">\(N_0(t;T)&gt;0\)</span>인 <span class="math inline">\(T\)</span>에 대해).
<span class="math display">\[\begin{aligned}
\frac{N_{\mathrm{can}}(t;T)}{T}
&amp;=
\left(\frac{N_0(t;T)}{T}\right)
\left(\frac{1}{N_0(t;T)}\sum_{e\in\mathcal{E}_0(t;T)} w(e)\right).
\label{eq:S09_02_step2}\end{aligned}\]</span>
이제 <span class="math inline">\(T\to\infty\)</span> 한계를 취한다. 공리 [A-9.2-S1]에 의해
<span class="math display">\[\lim_{T\to\infty}\frac{N_0(t;T)}{T}=s,
\qquad
\lim_{T\to\infty}\frac{1}{N_0(t;T)}\sum_{e\in\mathcal{E}_0(t;T)} w(e)=\delta,
\label{eq:S09_02_step3}\]</span>
이므로 <a data-reference="eq:S09_02_step2" data-reference-type="eqref" href="#eq:S09_02_step2">[eq:S09_02_step2]</a>에서
<span class="math display">\[\lim_{T\to\infty}\frac{N_{\mathrm{can}}(t;T)}{T}
=
s\cdot\delta.
\label{eq:S09_02_step4}\]</span>
좌변은 정의 <a data-reference="eq:S09_02_nucan_def" data-reference-type="eqref" href="#eq:S09_02_nucan_def">[eq:S09_02_nucan_def]</a>에 의해 <span class="math inline">\(\nu_{\mathrm{can}}\)</span>이므로,
<span class="math display">\[\nu_{\mathrm{can}}=s\cdot\delta.
\label{eq:S09_02_step5}\]</span>
정리 <a data-reference="eq:S09_02_theorem_goal" data-reference-type="eqref" href="#eq:S09_02_theorem_goal">[eq:S09_02_theorem_goal]</a>가 성립한다. <span class="math inline">\(\square\)</span></p>
<h3 data-number="11.2.10" id="t-9.2-2-보편-레짐에서의-특수형"><span class="header-section-number">11.2.10</span> [T-9.2-2] 보편 레짐에서의 특수형</h3>
<p>공리 [A-9.2-S2]가 성립하여 <a data-reference="eq:S09_02_delta_value_lock" data-reference-type="eqref" href="#eq:S09_02_delta_value_lock">[eq:S09_02_delta_value_lock]</a>을 사용할 수 있는 레짐에서는 정리 <a data-reference="eq:S09_02_theorem_goal" data-reference-type="eqref" href="#eq:S09_02_theorem_goal">[eq:S09_02_theorem_goal]</a>가 다음 특수형으로 고정된다.
<span class="math display">\[\nu_{\mathrm{can}}
=
s\cdot\frac{1}{\pi^2}.
\label{eq:S09_02_nucan_special}\]</span>
식 <a data-reference="eq:S09_02_nucan_special" data-reference-type="eqref" href="#eq:S09_02_nucan_special">[eq:S09_02_nucan_special]</a>은 <strong>정리의 특수형</strong>이며, <span class="math inline">\(\delta\)</span> 값 고정이 허용되는 레짐에서만 사용된다.</p>
<h3 data-number="11.2.11" id="문장-자격pass.rules-연결을-위한-표준-결론-형식"><span class="header-section-number">11.2.11</span> 9.2.7 문장 자격(PASS.rules) 연결을 위한 표준 결론 형식</h3>
<p>정리 <a data-reference="eq:S09_02_theorem_goal" data-reference-type="eqref" href="#eq:S09_02_theorem_goal">[eq:S09_02_theorem_goal]</a> 또는 <a data-reference="eq:S09_02_nucan_special" data-reference-type="eqref" href="#eq:S09_02_nucan_special">[eq:S09_02_nucan_special]</a>을 결론 문장으로 사용할 때, 다음 요소가 함께 표기되어야 한다(표기 누락 시 결론 자격 없음).</p>
<ol>
<li><p>참조된 <span class="math inline">\(\mathrm{Trig}_0\)</span> 및 <span class="math inline">\(w(e)\)</span> 정의의 식별자(analysis_lock 참조).</p></li>
<li><p><span class="math inline">\(\delta\)</span> 값 고정의 레짐 조건(보편 레짐인지 여부) 및 <span class="math inline">\(\delta\)</span> 관련 Gate 판정.</p></li>
<li><p><span class="math inline">\(s,\delta,\nu_{\mathrm{can}}\)</span>의 계산에 사용된 시간창/로그 스냅샷의 봉인 참조(manifest/checksums/registry_snapshot).</p></li>
</ol>
<p>위 요소는 “서술 규칙”이 아니라 결론 문장의 자격을 구성하는 필수 필드이며, PASS.rules에 의해 강제된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-43">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(s\)</span> 정의 <a data-reference="eq:S09_02_s_def" data-reference-type="eqref" href="#eq:S09_02_s_def">[eq:S09_02_s_def]</a>, <span class="math inline">\(\nu_{\mathrm{can}}\)</span> 정의 <a data-reference="eq:S09_02_nucan_def" data-reference-type="eqref" href="#eq:S09_02_nucan_def">[eq:S09_02_nucan_def]</a>, <span class="math inline">\(\delta\)</span> 정의 <a data-reference="eq:S09_02_delta_def" data-reference-type="eqref" href="#eq:S09_02_delta_def">[eq:S09_02_delta_def]</a> 및 <span class="math inline">\(w(e)\)</span> 정의 <a data-reference="eq:S09_02_w_def" data-reference-type="eqref" href="#eq:S09_02_w_def">[eq:S09_02_w_def]</a>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 보편 레짐에서 <span class="math inline">\(\delta=1/\pi^2\)</span> 값 고정 <a data-reference="eq:S09_02_delta_value_lock" data-reference-type="eqref" href="#eq:S09_02_delta_value_lock">[eq:S09_02_delta_value_lock]</a>을 <code>canon_lock</code>에 귀속(유일 출처 참조).</p></li>
<li><p>Gate: <span class="math inline">\(\delta\)</span> 보편성 트리거(편향/상관/정의 붕괴)는 G-RECT에서 <code>FAIL</code>; 레짐 밖 사용은 G-REG에서 <code>FAIL-REG-EXTRAP</code>.</p></li>
<li><p>Gate: 장시간 평균 존재/로그 완결성 불충족은 G-REP 또는 G-LOCK에서 <code>INCONCLUSIVE</code>.</p></li>
<li><p>Gate: 트리거/문턱/정의의 사후 변경은 G-NT에서 <code>FAIL</code>.</p></li>
</ul>
<h2 data-number="11.3" id="전자-정준-nu_emathrmcan1-r_e"><span class="header-section-number">11.3</span> 9.3 전자 정준: <span class="math inline">\(\nu_{e,\mathrm{can}}=1\)</span>, <span class="math inline">\(r_e\)</span></h2>
<h3 data-number="11.3.1" id="d-전자-정준-사건율의-정의단위-고정"><span class="header-section-number">11.3.1</span> 9.3.1 [D] 전자 정준 사건율의 정의(단위 고정)</h3>
<p>전자 정준 사건율 <span class="math inline">\(\nu_{e,\mathrm{can}}\)</span>을 다음 항등으로 <strong>정의</strong>하여 잠근다.
<span class="math display">\[\nu_{e,\mathrm{can}} := 1.
\label{eq:S09_03_nue_can_def}\]</span>
식 <a data-reference="eq:S09_03_nue_can_def" data-reference-type="eqref" href="#eq:S09_03_nue_can_def">[eq:S09_03_nue_can_def]</a>는 “전자 정준”의 정의이며, 동일 버전 내부에서 값이 조정되지 않는다.
<span class="math inline">\(\nu_{e,\mathrm{can}}\)</span>의 단위는 본 문서의 정준 사건율 체계에서 사용하는 사건율 단위로 고정한다(실현 단위로의 변환은 단위 실현 장에서만 취급된다).</p>
<h3 data-number="11.3.2" id="d-전자-시도율-s_e와-생존-계수-delta"><span class="header-section-number">11.3.2</span> 9.3.2 [D] 전자 시도율 <span class="math inline">\(s_e\)</span>와 생존 계수 <span class="math inline">\(\delta\)</span></h3>
<p>9.2에서 정의된 일반 정준 사건율 구성요소를 전자에 대해 다음으로 특수화한다.</p>
<h4 data-number="11.3.2.1" id="d-전자-시도-사건-집합과-시도율"><span class="header-section-number">11.3.2.1</span> 9.3.2.1 [D] 전자 시도 사건 집합과 시도율</h4>
<p>전자 시도 사건(원시 사건) 집합을 <span class="math inline">\(\mathcal{E}_{0,e}(t;T)\)</span>로 표기하고, 원시 카운트를
<span class="math display">\[N_{0,e}(t;T):=\left|\mathcal{E}_{0,e}(t;T)\right|
\label{eq:S09_03_N0e}\]</span>
로 정의한다. 전자 시도율 <span class="math inline">\(s_e\)</span>를 다음 장시간 평균으로 정의한다.
<span class="math display">\[s_e
:=
\lim_{T\to\infty}\frac{N_{0,e}(t;T)}{T}.
\label{eq:S09_03_se_def}\]</span>
한계의 존재 및 정착은 정준 정상성 공리(9.2의 공리 항목)에 귀속되며, 본 절에서 재서술하지 않는다.</p>
<h4 data-number="11.3.2.2" id="d-전자-생존-계수-delta"><span class="header-section-number">11.3.2.2</span> 9.3.2.2 [D] 전자 생존 계수 <span class="math inline">\(\delta\)</span></h4>
<p>전자 시도 사건 <span class="math inline">\(e\in\mathcal{E}_{0,e}(t;T)\)</span>에 대해 생존 가중치 <span class="math inline">\(w(e)\)</span>가 정의되어 있다고 두고, 전자 생존 계수 <span class="math inline">\(\delta\)</span>를 다음 평균으로 정의한다.
<span class="math display">\[\delta
:=
\lim_{T\to\infty}\frac{1}{N_{0,e}(t;T)}\sum_{e\in\mathcal{E}_{0,e}(t;T)} w(e),
\qquad
( N_{0,e}(t;T)&gt;0 ).
\label{eq:S09_03_delta_def}\]</span>
<span class="math inline">\(\delta\)</span>는 정류 상수 장(5장)에서 잠긴 규약을 참조하여 사용되며, 동일 버전 내부에서 재정의되지 않는다.</p>
<h3 data-number="11.3.3" id="t-정리-nu_emathrmcans_ecdotdelta의-적용"><span class="header-section-number">11.3.3</span> 9.3.3 [T] 정리: <span class="math inline">\(\nu_{e,\mathrm{can}}=s_e\cdot\delta\)</span>의 적용</h3>
<p>9.2의 정준 사건율 정리(정의와 공리에 의해 도출된 정리)를 전자에 적용하면 다음이 성립한다.
<span class="math display">\[\nu_{e,\mathrm{can}}=s_e\cdot\delta.
\label{eq:S09_03_nue_factor}\]</span>
이제 <a data-reference="eq:S09_03_nue_can_def" data-reference-type="eqref" href="#eq:S09_03_nue_can_def">[eq:S09_03_nue_can_def]</a>을 <a data-reference="eq:S09_03_nue_factor" data-reference-type="eqref" href="#eq:S09_03_nue_factor">[eq:S09_03_nue_factor]</a>에 대입하여 전개한다.
<span class="math display">\[\begin{aligned}
\nu_{e,\mathrm{can}}=s_e\cdot\delta
&amp;\Longrightarrow
1=s_e\cdot\delta
\label{eq:S09_03_step1}
\\
&amp;\Longrightarrow
s_e=\frac{1}{\delta}.
\label{eq:S09_03_step2}\end{aligned}\]</span>
따라서 전자 시도율 <span class="math inline">\(s_e\)</span>는 생존 계수 <span class="math inline">\(\delta\)</span>의 역수로 고정된다. 이 관계는 <span class="math inline">\(\delta\)</span>의 보편 값(예: <span class="math inline">\(\delta=1/\pi^2\)</span>)을 가정하지 않아도 성립한다.</p>
<h3 data-number="11.3.4" id="d-전자-길이-r_e의-정의시도율의-기하적-구현"><span class="header-section-number">11.3.4</span> 9.3.4 [D] 전자 길이 <span class="math inline">\(r_e\)</span>의 정의(시도율의 기하적 구현)</h3>
<p>본 절은 전자 길이 <span class="math inline">\(r_e\)</span>를 “전자 시도율 <span class="math inline">\(s_e\)</span>의 기하적 구현”으로 <strong>정의</strong>하여 잠근다.</p>
<h4 data-number="11.3.4.1" id="d-앵커-길이와-반길이"><span class="header-section-number">11.3.4.1</span> 9.3.4.1 [D] 앵커 길이와 반길이</h4>
<p>정준 셀 대표 길이 <span class="math inline">\(D_{\mathrm{anch}}\)</span>가 잠겨 있다고 두고, 반길이 <span class="math inline">\(r_0\)</span>를 다음 파생 정의로 고정한다.
<span class="math display">\[r_0:=\frac{D_{\mathrm{anch}}}{2}.
\label{eq:S09_03_r0}\]</span>
<span class="math inline">\(D_{\mathrm{anch}}\)</span>의 기하 의미(정준 셀에서 모서리 길이)는 3.3에서 잠겨 있으며, 본 절에서는 참조만 수행한다.</p>
<h4 data-number="11.3.4.2" id="d-시도율의-기하-정의"><span class="header-section-number">11.3.4.2</span> 9.3.4.2 [D] 시도율의 기하 정의</h4>
<p>전자 시도율 <span class="math inline">\(s_e\)</span>를 다음 기하 비율로 <strong>정의</strong>한다.
<span class="math display">\[s_e := \frac{r_0}{r_e}.
\label{eq:S09_03_se_geom}\]</span>
정의 <a data-reference="eq:S09_03_se_geom" data-reference-type="eqref" href="#eq:S09_03_se_geom">[eq:S09_03_se_geom]</a>은 “반길이 <span class="math inline">\(r_0\)</span>가 전자 반경 <span class="math inline">\(r_e\)</span>의 몇 배로 구성되는가”를 시도율로 채택하는 규약이며, 동일 버전 내부에서 변경되지 않는다.
<a data-reference="eq:S09_03_se_geom" data-reference-type="eqref" href="#eq:S09_03_se_geom">[eq:S09_03_se_geom]</a>은 기호의 의미(반경/반길이)가 잠겨 있을 때에만 허용되며, 지름/반지름 혼동 또는 셀 기하 혼동이 발생하면 즉시 <code>FAIL</code>이다(2.4 규약 참조).</p>
<h3 data-number="11.3.5" id="r_e의-단계별-유도"><span class="header-section-number">11.3.5</span> 9.3.5 <span class="math inline">\(r_e\)</span>의 단계별 유도</h3>
<p><a data-reference="eq:S09_03_step2" data-reference-type="eqref" href="#eq:S09_03_step2">[eq:S09_03_step2]</a>와 <a data-reference="eq:S09_03_se_geom" data-reference-type="eqref" href="#eq:S09_03_se_geom">[eq:S09_03_se_geom]</a>을 결합하여 <span class="math inline">\(r_e\)</span>를 도출한다.
<span class="math display">\[\begin{aligned}
s_e=\frac{1}{\delta}
\ \ \text{및}\ \
s_e=\frac{r_0}{r_e}
&amp;\Longrightarrow
\frac{r_0}{r_e}=\frac{1}{\delta}
\label{eq:S09_03_re_step1}
\\
&amp;\Longrightarrow
r_e=r_0\,\delta.
\label{eq:S09_03_re_step2}\end{aligned}\]</span>
이제 <a data-reference="eq:S09_03_r0" data-reference-type="eqref" href="#eq:S09_03_r0">[eq:S09_03_r0]</a>를 <a data-reference="eq:S09_03_re_step2" data-reference-type="eqref" href="#eq:S09_03_re_step2">[eq:S09_03_re_step2]</a>에 대입한다.
<span class="math display">\[\begin{aligned}
r_e=r_0\,\delta
&amp;\Longrightarrow
r_e=\left(\frac{D_{\mathrm{anch}}}{2}\right)\delta.
\label{eq:S09_03_re_step3}\end{aligned}\]</span>
따라서 전자 반경의 최종 형태는 다음으로 고정된다.
<span class="math display">\[\boxed{
r_e=\frac{D_{\mathrm{anch}}}{2}\,\delta
}
\label{eq:S09_03_re_final}\]</span>
식 <a data-reference="eq:S09_03_re_final" data-reference-type="eqref" href="#eq:S09_03_re_final">[eq:S09_03_re_final]</a>은 전자 정준 <span class="math inline">\(\nu_{e,\mathrm{can}}=1\)</span>과 시도율 기하 정의 <a data-reference="eq:S09_03_se_geom" data-reference-type="eqref" href="#eq:S09_03_se_geom">[eq:S09_03_se_geom]</a>, 생존 계수 정의 <a data-reference="eq:S09_03_delta_def" data-reference-type="eqref" href="#eq:S09_03_delta_def">[eq:S09_03_delta_def]</a>의 결합으로만 도출된다.</p>
<h3 data-number="11.3.6" id="보편-레짐에서의-특수형값-치환"><span class="header-section-number">11.3.6</span> 9.3.6 보편 레짐에서의 특수형(값 치환)</h3>
<p><span class="math inline">\(\delta\)</span>의 보편성 공리가 적용되는 레짐에서 <span class="math inline">\(\delta\)</span>가
<span class="math display">\[\delta=\frac{1}{\pi^2}
\label{eq:S09_03_delta_univ}\]</span>
로 잠겼다면, <a data-reference="eq:S09_03_re_final" data-reference-type="eqref" href="#eq:S09_03_re_final">[eq:S09_03_re_final]</a>에 <a data-reference="eq:S09_03_delta_univ" data-reference-type="eqref" href="#eq:S09_03_delta_univ">[eq:S09_03_delta_univ]</a>를 대입하여 다음 특수형을 얻는다.
<span class="math display">\[\begin{aligned}
r_e=\frac{D_{\mathrm{anch}}}{2}\,\delta
&amp;\Longrightarrow
r_e=\frac{D_{\mathrm{anch}}}{2}\cdot\frac{1}{\pi^2}
=\frac{D_{\mathrm{anch}}}{2\pi^2}.
\label{eq:S09_03_re_univ}\end{aligned}\]</span>
특수형 <a data-reference="eq:S09_03_re_univ" data-reference-type="eqref" href="#eq:S09_03_re_univ">[eq:S09_03_re_univ]</a>은 보편 레짐에서만 사용되며, 보편성 트리거가 깨진 레짐에서는 <a data-reference="eq:S09_03_re_final" data-reference-type="eqref" href="#eq:S09_03_re_final">[eq:S09_03_re_final]</a>의 일반형(레짐-의존 <span class="math inline">\(\delta\)</span>)만 허용된다.</p>
<h3 data-number="11.3.7" id="파생량지름-정의"><span class="header-section-number">11.3.7</span> 9.3.7 파생량(지름) 정의</h3>
<p>전자 지름(길이)을 다음으로 파생 정의한다.
<span class="math display">\[\ell_e := 2r_e.
\label{eq:S09_03_le_def}\]</span>
따라서 <a data-reference="eq:S09_03_re_final" data-reference-type="eqref" href="#eq:S09_03_re_final">[eq:S09_03_re_final]</a>로부터
<span class="math display">\[\ell_e = 2\left(\frac{D_{\mathrm{anch}}}{2}\delta\right)=D_{\mathrm{anch}}\delta,
\label{eq:S09_03_le_final}\]</span>
보편 레짐에서는 <a data-reference="eq:S09_03_re_univ" data-reference-type="eqref" href="#eq:S09_03_re_univ">[eq:S09_03_re_univ]</a>로부터
<span class="math display">\[\ell_e=\frac{D_{\mathrm{anch}}}{\pi^2}
\label{eq:S09_03_le_univ}\]</span>
로 고정된다. <span class="math inline">\(\ell_e\)</span>는 지름/반지름 혼동 방지 규약(2.4)의 적용을 받으며, <span class="math inline">\(\ell_e\)</span>를 반경으로 사용하는 행위는 즉시 <code>FAIL</code>이다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-44">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 전자 정준 사건율 <span class="math inline">\(\nu_{e,\mathrm{can}}:=1\)</span> 정의(<a data-reference="eq:S09_03_nue_can_def" data-reference-type="eqref" href="#eq:S09_03_nue_can_def">[eq:S09_03_nue_can_def]</a>)를 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: 시도율 기하 정의 <span class="math inline">\(s_e:=r_0/r_e\)</span>(<a data-reference="eq:S09_03_se_geom" data-reference-type="eqref" href="#eq:S09_03_se_geom">[eq:S09_03_se_geom]</a>) 및 <span class="math inline">\(r_0=D_{\mathrm{anch}}/2\)</span>(<a data-reference="eq:S09_03_r0" data-reference-type="eqref" href="#eq:S09_03_r0">[eq:S09_03_r0]</a>)를 <code>analysis_lock</code>/<code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: 전자 반경 <span class="math inline">\(r_e=(D_{\mathrm{anch}}/2)\delta\)</span>(<a data-reference="eq:S09_03_re_final" data-reference-type="eqref" href="#eq:S09_03_re_final">[eq:S09_03_re_final]</a>) 및 파생 지름 <span class="math inline">\(\ell_e\)</span>(<a data-reference="eq:S09_03_le_def" data-reference-type="eqref" href="#eq:S09_03_le_def">[eq:S09_03_le_def]</a>)를 <code>canon_lock</code>의 파생 항목으로 고정.</p></li>
<li><p>Gate: <span class="math inline">\(\delta\)</span> 보편성 트리거 위반(편향/상관/정의 붕괴) 시 보편 값 치환(<a data-reference="eq:S09_03_delta_univ" data-reference-type="eqref" href="#eq:S09_03_delta_univ">[eq:S09_03_delta_univ]</a>) 사용 금지(G-RECT 연동).</p></li>
<li><p>Gate: 지름/반지름/셀 기하 혼동 및 lock_id 혼합은 G-SYM/G-LOCK에서 즉시 <code>FAIL</code>.</p></li>
</ul>
<h2 data-number="11.4" id="양성자-정준-nu_pmathrmcan-수치-유도292.339978ldots"><span class="header-section-number">11.4</span> 9.4 양성자 정준: <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span> 수치 유도(<span class="math inline">\(292.339978\ldots\)</span>)</h2>
<h3 data-number="11.4.1" id="lock-입력과-참조식출발점"><span class="header-section-number">11.4.1</span> 9.4.1 LOCK 입력과 참조식(출발점)</h3>
<p>본 절은 다음 입력이 <code>canon_lock</code>에 의해 고정(LOCK)되어 있다고 둔다.
<span class="math display">\[\begin{aligned}
&amp;D_{\mathrm{anch}}=\Danchm,
\label{eq:S09_04_Danch_lock}\\
&amp;r_p=\rprotonm,
\label{eq:S09_04_rp_lock}\\
&amp;\pi\ \text{(무차원 상수, 잠김)},
\qquad
\delta=\frac{1}{\pi^2}.
\label{eq:S09_04_delta_def}\end{aligned}\]</span>
또한 9.2의 정준 사건율 법칙(정리)을 양성자에 적용하여 다음을 사용한다.
<span class="math display">\[\nu_{p,\mathrm{can}}=s_p\cdot \delta.
\label{eq:S09_04_nu_sp_delta}\]</span></p>
<h3 data-number="11.4.2" id="정의-양성자-스케일-인자-s_p"><span class="header-section-number">11.4.2</span> 9.4.2 정의: 양성자 스케일 인자 <span class="math inline">\(s_p\)</span></h3>
<p>정준 셀 반길이 <span class="math inline">\(r_0\)</span>를 다음 파생 정의로 고정한다.
<span class="math display">\[r_0:=\frac{D_{\mathrm{anch}}}{2}.
\label{eq:S09_04_r0_def}\]</span>
양성자 스케일 인자 <span class="math inline">\(s_p\)</span>를 다음 <strong>무차원 비율</strong>로 정의한다.
<span class="math display">\[s_p:=\frac{r_0}{r_p}=\frac{D_{\mathrm{anch}}}{2r_p}.
\label{eq:S09_04_sp_def}\]</span>
정의 <a data-reference="eq:S09_04_sp_def" data-reference-type="eqref" href="#eq:S09_04_sp_def">[eq:S09_04_sp_def]</a>에서 <span class="math inline">\(D_{\mathrm{anch}}\)</span>와 <span class="math inline">\(r_p\)</span>의 기하 의미(지름/반지름/셀 기하)는 이미 잠겨 있어야 하며, 혼동(오버로딩)이 발생하면 즉시 <code>FAIL</code>이다.</p>
<h4 data-number="11.4.2.1" id="주석-s_p가-선형-비율로-정의되는-이유사건-정의의-차원"><span class="header-section-number">11.4.2.1</span> 주석: <span class="math inline">\(s_p\)</span>가 선형 비율로 정의되는 이유(사건 정의의 차원)</h4>
<p>정의 <a data-reference="eq:S09_04_sp_def" data-reference-type="eqref" href="#eq:S09_04_sp_def">[eq:S09_04_sp_def]</a>의 <span class="math inline">\(s_p\)</span>는 “부피 슬롯의 개수”(예: <span class="math inline">\((r_0/r_p)^3\)</span>)가 아니라,
9.2의 정준 사건율 법칙에서 사용되는 <strong>스케일 인자</strong>이다.
본 백서에서 사건(event)은 “부피 채움”이 아니라 <strong>전파/유입 경로(backbone)에서의 턴오버(turnover)</strong>로 정의되며,
공간의 3차원 기하/각도 상쇄/위상 겹침에 의한 유효 감소는 정류 계수 <span class="math inline">\(\delta\)</span>에 이미 흡수되어 있다(5.2, 9.4.3.1).
따라서 <span class="math inline">\(s_p\)</span>를 다시 3차원 체적 비로 해석하면, 동일 기하 요인을 중복 계수하는 오류가 된다.</p>
<h3 data-number="11.4.3" id="계산-전개-delta-s_p-nu_pmathrmcan"><span class="header-section-number">11.4.3</span> 9.4.3 계산 전개: <span class="math inline">\(\delta\)</span>, <span class="math inline">\(s_p\)</span>, <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span></h3>
<h4 data-number="11.4.3.1" id="정류-계수-delta-계산"><span class="header-section-number">11.4.3.1</span> 9.4.3.1 정류 계수 <span class="math inline">\(\delta\)</span> 계산</h4>
<p>정류 계수는 5.2의 유일 출처로부터 다음과 같이 잠긴다.
<span class="math display">\[\delta=\frac{1}{\pi^2}
=0.10132118364233778\ldots
\qquad (\text{무차원}).
\label{eq:S09_04_delta_numeric}\]</span></p>
<h4 data-number="11.4.3.2" id="스케일-인자-s_p-계산"><span class="header-section-number">11.4.3.2</span> 9.4.3.2 스케일 인자 <span class="math inline">\(s_p\)</span> 계산</h4>
<p>정의 <a data-reference="eq:S09_04_sp_def" data-reference-type="eqref" href="#eq:S09_04_sp_def">[eq:S09_04_sp_def]</a>에 <a data-reference="eq:S09_04_Danch_lock" data-reference-type="eqref" href="#eq:S09_04_Danch_lock">[eq:S09_04_Danch_lock]</a>, <a data-reference="eq:S09_04_rp_lock" data-reference-type="eqref" href="#eq:S09_04_rp_lock">[eq:S09_04_rp_lock]</a>을 대입한다.
<span class="math display">\[\begin{aligned}
s_p
&amp;=\frac{D_{\mathrm{anch}}}{2r_p}
=\frac{4.854194962126561\times 10^{-12}}{2\times 0.8412\times 10^{-15}}
\notag\\
&amp;=\frac{4.854194962126561}{1.6824}\times 10^{3}
\notag\\
&amp;=2885.27993469244\ldots
\qquad (\text{무차원}).
\label{eq:S09_04_sp_numeric}\end{aligned}\]</span></p>
<h4 data-number="11.4.3.3" id="정준-사건율-nu_pmathrmcan-계산"><span class="header-section-number">11.4.3.3</span> 9.4.3.3 정준 사건율 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span> 계산</h4>
<p>정의/정리 <a data-reference="eq:S09_04_nu_sp_delta" data-reference-type="eqref" href="#eq:S09_04_nu_sp_delta">[eq:S09_04_nu_sp_delta]</a>에 <a data-reference="eq:S09_04_sp_numeric" data-reference-type="eqref" href="#eq:S09_04_sp_numeric">[eq:S09_04_sp_numeric]</a>, <a data-reference="eq:S09_04_delta_numeric" data-reference-type="eqref" href="#eq:S09_04_delta_numeric">[eq:S09_04_delta_numeric]</a>를 대입한다.
<span class="math display">\[\begin{aligned}
\nu_{p,\mathrm{can}}
&amp;=s_p\cdot\delta
\notag\\
&amp;=\left(2885.27993469244\ldots\right)\times
\left(0.10132118364233778\ldots\right)
\notag\\
&amp;=292.33997812252504182604913619807\ldots\ \mathrm{s^{-1}}.
\label{eq:S09_04_nup_numeric}\end{aligned}\]</span>
입력 정밀도에 의해 제한되는 유효 자릿수 표기는 다음으로 고정한다.
<span class="math display">\[\nu_{p,\mathrm{can}}\approx 292.339978123\ \mathrm{s^{-1}}.
\label{eq:S09_04_nup_round}\]</span>
또는 단위 표기만 바꾸어
<span class="math display">\[\nu_{p,\mathrm{can}}\approx 292.3399781\ \mathrm{Hz}
\label{eq:S09_04_nup_hz}\]</span>
로 기록할 수 있다. 여기서 “<span class="math inline">\(\mathrm{Hz}=\mathrm{s^{-1}}\)</span>” 표기는 정준초를 SI 초와 동치로 읽는 표기이며, 동치성의 판정은 단위구현(교차검증) Gate에서 수행된다.</p>
<h3 data-number="11.4.4" id="동치식완전-닫힌-단일-식"><span class="header-section-number">11.4.4</span> 9.4.4 동치식(완전 닫힌 단일 식)</h3>
<p><a data-reference="eq:S09_04_nu_sp_delta" data-reference-type="eqref" href="#eq:S09_04_nu_sp_delta">[eq:S09_04_nu_sp_delta]</a>, <a data-reference="eq:S09_04_sp_def" data-reference-type="eqref" href="#eq:S09_04_sp_def">[eq:S09_04_sp_def]</a>, <a data-reference="eq:S09_04_delta_def" data-reference-type="eqref" href="#eq:S09_04_delta_def">[eq:S09_04_delta_def]</a>를 결합하면,
<span class="math display">\[\boxed{
\nu_{p,\mathrm{can}}
=\left(\frac{D_{\mathrm{anch}}}{2r_p}\right)\left(\frac{1}{\pi^2}\right)
}
\label{eq:S09_04_closed_form}\]</span>
이 된다. 본 절의 수치 유도는 <a data-reference="eq:S09_04_closed_form" data-reference-type="eqref" href="#eq:S09_04_closed_form">[eq:S09_04_closed_form]</a>의 대입 계산으로 완결되며, 추가 가정이 개입하지 않는다.</p>
<h4 data-number="11.4.4.1" id="동치식전자-정준으로의-환원"><span class="header-section-number">11.4.4.1</span> 동치식(전자 정준으로의 환원)</h4>
<p>보편 레짐에서 9.3의 전자 반경 정의 <span class="math inline">\(r_e=(D_{\mathrm{anch}}/2)\delta\)</span>를 사용하면,
<a data-reference="eq:S09_04_closed_form" data-reference-type="eqref" href="#eq:S09_04_closed_form">[eq:S09_04_closed_form]</a>은 다음과 같이 동일하게 쓸 수 있다.
<span class="math display">\[\nu_{p,\mathrm{can}}=\frac{r_e}{r_p}
\qquad (\delta=1/\pi^2\ \text{보편 레짐}).
\label{eq:S09_04_equiv_re_over_rp}\]</span>
즉, “전자에서 유도한 형태”와 “앵커-양성자 비율에서 유도한 형태”는 같은 식의 서로 다른 표기이며,
본 절에서 새로운 가정을 추가로 도입하지 않는다.</p>
<h3 data-number="11.4.5" id="민감도오차-예산lock-연결"><span class="header-section-number">11.4.5</span> 9.4.5 민감도/오차 예산(LOCK 연결)</h3>
<h4 data-number="11.4.5.1" id="미분-기반-민감도정의에서-직접"><span class="header-section-number">11.4.5.1</span> 9.4.5.1 미분 기반 민감도(정의에서 직접)</h4>
<p><a data-reference="eq:S09_04_closed_form" data-reference-type="eqref" href="#eq:S09_04_closed_form">[eq:S09_04_closed_form]</a>에서 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>은 <span class="math inline">\(D_{\mathrm{anch}}\)</span>에 비례하고 <span class="math inline">\(r_p\)</span>에 역비례한다. 따라서 미분으로
<span class="math display">\[\frac{\partial \nu_{p,\mathrm{can}}}{\partial D_{\mathrm{anch}}}
=\frac{1}{2r_p}\cdot\frac{1}{\pi^2},
\qquad
\frac{\partial \nu_{p,\mathrm{can}}}{\partial r_p}
=-\frac{D_{\mathrm{anch}}}{2r_p^2}\cdot\frac{1}{\pi^2}
=-\frac{\nu_{p,\mathrm{can}}}{r_p}
\label{eq:S09_04_sensitivity}\]</span>
가 성립한다. 상대 민감도는 다음으로 정리된다.
<span class="math display">\[\frac{\Delta \nu_{p,\mathrm{can}}}{\nu_{p,\mathrm{can}}}
\approx
\frac{\Delta D_{\mathrm{anch}}}{D_{\mathrm{anch}}}
-\frac{\Delta r_p}{r_p},
\label{eq:S09_04_rel_error}\]</span>
여기서 <span class="math inline">\(\delta=1/\pi^2\)</span>의 값은 정류 상수로 잠겨 있으므로(동일 버전 내부), 오차 예산의 자유도는 <span class="math inline">\(D_{\mathrm{anch}}\)</span>와 <span class="math inline">\(r_p\)</span>의 입력 정밀도에만 귀속된다.</p>
<h4 data-number="11.4.5.2" id="입력-값-변화-예시lock-값의-중요성"><span class="header-section-number">11.4.5.2</span> 9.4.5.2 입력 값 변화 예시(LOCK 값의 중요성)</h4>
<p><span class="math inline">\(r_p\)</span>가 LOCK 값에서 벗어나면 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>은 즉시 변한다. 예를 들어 참고 비교로
<span class="math display">\[r_p=0.84\times 10^{-15}\ \mathrm{m}
\label{eq:S09_04_rp_alt}\]</span>
를 사용할 경우,
<span class="math display">\[\begin{aligned}
\nu_{p}(0.84)
&amp;=\left(\frac{D_{\mathrm{anch}}}{2\times 0.84\times 10^{-15}}\right)\left(\frac{1}{\pi^2}\right)
\notag\\
&amp;=292.7576066627001\ldots\ \mathrm{s^{-1}}.
\label{eq:S09_04_nu_alt}\end{aligned}\]</span>
따라서 차이는
<span class="math display">\[\begin{aligned}
\Delta \nu
&amp;:=\nu_{p}(0.84)-\nu_{p,\mathrm{can}}
\notag\\
&amp;=292.7576066627001\ldots-292.3399781225250\ldots
\notag\\
&amp;=0.4176285401750\ldots\ \mathrm{s^{-1}},
\label{eq:S09_04_diff}\end{aligned}\]</span>
상대 차이는
<span class="math display">\[\frac{\Delta \nu}{\nu_{p,\mathrm{can}}}
\approx
\frac{0.4176285}{292.3400}
\approx 0.00143
\qquad (\approx 0.143\%).
\label{eq:S09_04_rel_diff}\]</span>
즉, <span class="math inline">\(r_p\)</span>를 <a data-reference="eq:S09_04_rp_lock" data-reference-type="eqref" href="#eq:S09_04_rp_lock">[eq:S09_04_rp_lock]</a>로 LOCK하면 그에 대응하는 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>도 <a data-reference="eq:S09_04_nup_numeric" data-reference-type="eqref" href="#eq:S09_04_nup_numeric">[eq:S09_04_nup_numeric]</a>의 단일 값으로 함께 고정된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-45">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(D_{\mathrm{anch}}\)</span>, <span class="math inline">\(r_p\)</span>, <span class="math inline">\(\pi\)</span>, <span class="math inline">\(\delta=1/\pi^2\)</span> 및 <span class="math inline">\(r_0=D_{\mathrm{anch}}/2\)</span>를 <code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(s_p:=D_{\mathrm{anch}}/(2r_p)\)</span> 및 <span class="math inline">\(\nu_{p,\mathrm{can}}:=s_p\delta\)</span>를 <code>analysis_lock</code>의 정의/정리 연결로 고정.</p></li>
<li><p>Gate: 지름/반지름/셀 기하 혼동 또는 기호 오버로딩은 G-SYM에서 즉시 <code>FAIL</code>.</p></li>
<li><p>Gate: <span class="math inline">\(D_{\mathrm{anch}}\)</span>, <span class="math inline">\(r_p\)</span> 또는 <span class="math inline">\(\delta\)</span>의 사후 변경(문턱 이동, 재정의 포함)은 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 서로 다른 lock_id 조합의 혼합 사용은 G-LOCK에서 <code>FAIL</code>; 계산 로그가 <code>manifest+checksums</code>로 봉인되지 않으면 G-REP에서 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
</ul>
<h1 data-number="12" id="광속-구현clock-free-c과-격자-전파"><span class="header-section-number">12</span> 10. 광속 구현(Clock-free <span class="math inline">\(c\)</span>)과 격자 전파</h1>
<h2 class="unnumbered" id="장의-목적연결-선언">장의 목적(연결 선언)</h2>
<p>본 장은 “전파 가능/불가능”의 스위치를 재밍 격자(Point-J) 및 퍼콜레이션(임계목) 구조로 정의하고, 그 스위치가 <strong>광속 구현(Clock-free <span class="math inline">\(c\)</span>)</strong>의 입력이 되도록 연결을 고정한다. 또한 전역 전파가 성립할 때 발생하는 <strong>증폭 계수 <span class="math inline">\(A\)</span></strong>를 정의하고, <span class="math inline">\(c\)</span> 및 <span class="math inline">\(A\)</span>를 검증 가능한 수치 패키지(재현 가능한 코드/로그/게이트)로 연결한다.
본 장은 외부 텍스트의 정당화로 <span class="math inline">\(c\)</span>를 도입하지 않는다. <span class="math inline">\(c\)</span>는 본 문서 내부에서 정의된 전파 지표의 <strong>실현(Realization)</strong> 또는 <strong>운영 닻</strong>과 결합하여 얻어지는 구현량으로만 취급된다.</p>
<h2 class="unnumbered" id="전역-골격-스위치-rightarrow-퍼콜레이션-rightarrow-증폭-a-rightarrow-수치-패키지">전역 골격: 스위치 <span class="math inline">\(\rightarrow\)</span> 퍼콜레이션 <span class="math inline">\(\rightarrow\)</span> 증폭 <span class="math inline">\(A\)</span> <span class="math inline">\(\rightarrow\)</span> 수치 패키지</h2>
<p>본 장의 골격은 다음 순서로 고정한다.
<span class="math display">\[\text{재밍/Point-J 스위치}
\;\Longrightarrow\;
\text{임계목(percolation) 정의}
\;\Longrightarrow\;
\text{전파 경로(backbone/stream) 추출}
\;\Longrightarrow\;
\text{증폭 계수 }A\text{ 정의}
\;\Longrightarrow\;
\text{전파 속도 지표(내부 $c$)}
\;\Longrightarrow\;
\text{수치 패키지(재현+Gate)}.
\label{eq:S10_chain}\]</span>
각 화살표는 닫힘(closure)과 Gate 스택을 필요로 하며, 정의와 판정이 잠기지 않은 연결은 허용되지 않는다.</p>
<h2 class="unnumbered" id="c-스위치의-선언전파-가능불가능"><span class="math inline">\(c\)</span> 스위치의 선언(전파 가능/불가능)</h2>
<p>본 장에서 “<span class="math inline">\(c\)</span> 스위치”는 값의 연속 변화가 아니라 <strong>정의된 레짐 전이</strong>로 고정한다. 스위치는 다음 지시변수로 선언한다.
<span class="math display">\[\chi_c :=
\begin{cases}
0,&amp; \text{전역 전파가 정의 불능(비강성 레짐)},\\
1,&amp; \text{전역 전파가 정의 가능(강성 레짐)}.
\end{cases}
\label{eq:S10_chic_def}\]</span>
<span class="math inline">\(\chi_c\)</span>의 판정은 3.2에서 정의된 재밍 격자 <span class="math inline">\(\mathfrak{J}\)</span>와 강성 지시변수 <span class="math inline">\(\chi_{\mathrm{ST}}\)</span> 및 병목 지표 <span class="math inline">\(\kappa_{\min}\)</span>에 의해 결정되며, 구체 판정식은 <code>analysis_lock</code>에 잠긴다.
<span class="math inline">\(\chi_c=0\)</span>인 레짐에서 <span class="math inline">\(c\)</span>를 수치로 정의하는 행위는 금지된다. 허용되는 것은 “정의 불능” 또는 “0-레짐”으로의 기록(CT-LIM)뿐이다.</p>
<h2 class="unnumbered" id="퍼콜레이션임계목-연결의-선언">퍼콜레이션(임계목) 연결의 선언</h2>
<p>전역 전파가 정의 가능한 레짐(<span class="math inline">\(\chi_c=1\)</span>)에서, 전파는 임계목(throat) 네트워크의 연결로 구현된다. 본 장은 임계목 관련 항목을 다음 구조로 연결한다고 선언한다.</p>
<ol>
<li><p>목(throat) 객체 <code>OBJ-THROAT</code>의 정의(간격/두께/병목).</p></li>
<li><p>임계목 대표값 <span class="math inline">\(\delta_{\mathrm{eff}}\)</span>의 정의(집계 규약).</p></li>
<li><p>임계목 그래프/경로의 정의(노드/간선, 가중치 규약).</p></li>
<li><p>백본(backbone) 또는 스트림튜브(stream-tube) 추출(최소 절단/최대 유량 규약).</p></li>
</ol>
<p>각 항목은 닫힘(closure)로 잠기며, 닫힘 의존성은 DAG(순환 금지)로 고정된다(4.2 참조).</p>
<h2 data-number="12.1" id="증폭-계수-a의-선언정의-자리"><span class="header-section-number">12.1</span> 10.5 증폭 계수 <span class="math inline">\(A\)</span>의 선언(정의 자리)</h2>
<p>전역 전파 레짐에서 “증폭”은 전파 경로가 임계목 네트워크에서 집중되는 정도를 나타내는 지표로 정의된다. 본 장은 증폭 계수 <span class="math inline">\(A\)</span>를 다음 자리에서 정의한다고 선언한다.
<span class="math display">\[A := \mathrm{Amp}\bigl(\mathcal{G}_{\mathrm{throat}},\ \mathcal{B},\ \mathcal{F}\bigr),
\label{eq:S10_A_slot}\]</span>
여기서</p>
<ul>
<li><p><span class="math inline">\(\mathcal{G}_{\mathrm{throat}}\)</span>는 임계목 그래프,</p></li>
<li><p><span class="math inline">\(\mathcal{B}\)</span>는 백본 또는 스트림 경로(전역 전파를 담당하는 부분구조),</p></li>
<li><p><span class="math inline">\(\mathcal{F}\)</span>는 플럭스/사건율 기반의 흐름 집계량(4.1 flux 정의와 연결 가능)</p></li>
</ul>
<p>이다. <span class="math inline">\(\mathrm{Amp}(\cdot)\)</span>의 구체 정의(예: 집중도, 엔트로피형 지표, 최대/평균 비율 등)는 <code>analysis_lock</code>에 잠긴다. 결과를 본 뒤 <span class="math inline">\(\mathrm{Amp}\)</span>를 교체하거나 문턱을 이동하는 행위는 금지된다.</p>
<h2 data-number="12.2" id="clock-free-c-구현의-선언내부-전파-지표-rightarrow-실현"><span class="header-section-number">12.2</span> 10.6 Clock-free <span class="math inline">\(c\)</span> 구현의 선언(내부 전파 지표 <span class="math inline">\(\rightarrow\)</span> 실현)</h2>
<p>본 장에서 <span class="math inline">\(c\)</span>는 “시간계를 가정하지 않고도 내부 전파를 비교 가능한 형태로 만드는” 절차를 의미한다. Clock-free는 다음 두 요소의 결합으로 선언한다.</p>
<ol>
<li><p><strong>내부 전파 지표 <span class="math inline">\(\tilde{c}\)</span></strong>: 임계목/백본을 통해 정의되는 전파 속도 지표(틱 기반 또는 사건 기반).</p></li>
<li><p><strong>실현 사상</strong>: <span class="math inline">\(a,\Delta t\)</span> 및 운영 닻(<span class="math inline">\(c_{\mathrm{ref}}\)</span> 또는 교차채널)로 내부 지표를 실현 단위로 매핑.</p></li>
</ol>
<p>따라서 <span class="math inline">\(c\)</span>는
<span class="math display">\[c := \frac{a}{\Delta t}\,\tilde{c}
\label{eq:S10_c_realize_form}\]</span>
형태의 실현식을 갖도록 고정되며, <span class="math inline">\(a,\Delta t\)</span>의 잠금은 2.3의 <code>realization_lock</code>에 귀속된다.
<span class="math inline">\(\tilde{c}\)</span>의 정의는 본 장의 퍼콜레이션/백본/증폭 정의의 결과로 주어지며, <span class="math inline">\(\tilde{c}\)</span>의 정의가 성립하지 않으면 <span class="math inline">\(c\)</span>도 정의 불능이다.</p>
<h2 data-number="12.3" id="수치-패키지재현와-gate-스택의-선언"><span class="header-section-number">12.3</span> 10.7 수치 패키지(재현)와 Gate 스택의 선언</h2>
<p>본 장의 모든 결론(<span class="math inline">\(\chi_c\)</span>, <span class="math inline">\(\delta_{\mathrm{eff}}\)</span>, 백본, <span class="math inline">\(A\)</span>, <span class="math inline">\(\tilde{c}\)</span>, <span class="math inline">\(c\)</span>)은 수치 패키지로 봉인되어야 한다. 수치 패키지는 다음 항목을 포함한다.</p>
<ol>
<li><p>레지스트리 스냅샷(<code>registry_snapshot</code>) 및 lock_id 조합.</p></li>
<li><p>입력 데이터/초기조건/경계조건/시드/구동 조건 로그.</p></li>
<li><p>임계목 추정 및 그래프 구성 코드와 로그.</p></li>
<li><p>백본/경로 추출 코드와 로그.</p></li>
<li><p><span class="math inline">\(A\)</span> 및 <span class="math inline">\(\tilde{c}\)</span> 계산 코드와 로그.</p></li>
<li><p>Gate 보고서(PASS/FAIL/INCONCLUSIVE) 및 FAIL 라벨.</p></li>
<li><p><code>manifest</code> 및 <code>checksums</code> 봉인.</p></li>
</ol>
<p>본 장의 Gate 스택은 최소 다음 항목을 포함한다.</p>
<ol>
<li><p>G-SYM: 기호/단위/셀 기하/지름-반지름 의미 충돌 없음.</p></li>
<li><p>G-LOCK: lock_id 일치 및 스냅샷 봉인.</p></li>
<li><p>G-REG: 레짐 적합성(강성/비강성, 구동 조건 등).</p></li>
<li><p>G-STR: 그래프/백본/경로 정의의 구조 불변량.</p></li>
<li><p>G-NUM: 수치 안정성(수렴/민감도/반복 일치).</p></li>
<li><p>G-RCROSS(해당 시): 교차채널 정합.</p></li>
<li><p>G-REP: 재현 가능성(동일 패키지 재실행 동일 판정).</p></li>
<li><p>G-NT: 사후조정 금지 위반 탐지.</p></li>
</ol>
<p>Gate가 <code>PASS</code>하지 않은 결과는 결론 자격이 없으며, 이후 절에서 근거로 사용할 수 없다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-46">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(c\)</span> 스위치 지시변수 <span class="math inline">\(\chi_c\)</span>와 레짐 연결(재밍/Point-J/강성 지표)을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 임계목(percolation) 정의, 백본/스트림 추출, 증폭 정의 <span class="math inline">\(\mathrm{Amp}(\cdot)\)</span>의 자리 및 닫힘 DAG를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(c\)</span> 실현식 <span class="math inline">\(c=(a/\Delta t)\tilde{c}\)</span> 및 <span class="math inline">\(a,\Delta t\)</span> 잠금을 <code>realization_lock</code>에 연결하여 고정.</p></li>
<li><p>Gate: <span class="math inline">\(\chi_c=0\)</span> 레짐에서 <span class="math inline">\(c\)</span> 수치 정의 금지(CT-LIM만 허용)를 G-REG/PASS.rules에 연결.</p></li>
<li><p>Gate: 수치 패키지 봉인(manifest/checksums/registry_snapshot) 없는 결과는 G-REP에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
</ul>
<h2 data-number="12.4" id="c의-운영-정의b_mathrmeffrho_mathrmeff-스위치"><span class="header-section-number">12.4</span> 10.1 <span class="math inline">\(c\)</span>의 운영 정의(<span class="math inline">\(B_{\mathrm{eff}}/\rho_{\mathrm{eff}}\)</span>) + 스위치</h2>
<h3 data-number="12.4.1" id="전제-전파-스위치레짐-스위치-정의"><span class="header-section-number">12.4.1</span> 10.1.1 전제: 전파 스위치(레짐 스위치) 정의</h3>
<p>정준 도메인(셀 또는 셀들의 합) <span class="math inline">\(\mathcal{D}\)</span>와 그 경계 집합 <span class="math inline">\(\partial\mathcal{D}^{-},\partial\mathcal{D}^{+}\)</span>를 잠긴 규약으로 둔다. 접촉 그래프(또는 인접 그래프) <span class="math inline">\(\mathcal{G}_c=(\mathcal{V},\mathcal{E}_c)\)</span>가 잠겨 있을 때, 전역 전파 가능 여부를 다음 지시변수로 정의한다.
<span class="math display">\[\chi_{\mathrm{span}}
:=
\begin{cases}
1, &amp; \exists\, i\in\mathcal{V}^{-},\exists\, j\in\mathcal{V}^{+}\ \text{s.t.}\ i\leadsto j\ \text{in }\mathcal{G}_c,\\
0, &amp; \text{otherwise},
\end{cases}
\label{eq:S10_01_chi_span}\]</span>
여기서 <span class="math inline">\(\mathcal{V}^{\pm}\)</span>는 경계 접촉 노드 집합이며, <span class="math inline">\(i\leadsto j\)</span>는 경로 존재를 의미한다.</p>
<p>병목(최소 절단) 기반 강성 스위치를 다음으로 정의한다.
<span class="math display">\[\kappa_{\min}
:=\min\left\{|\mathcal{C}|\ \middle|\ \mathcal{C}\subseteq\mathcal{E}_c,\ \mathcal{E}_c\setminus\mathcal{C}\ \text{에서}\ \mathcal{V}^{-}\text{와}\ \mathcal{V}^{+}\ \text{가 분리}\right\},
\label{eq:S10_01_kappa_min}\]</span>
그리고 정수 문턱 <span class="math inline">\(\kappa_{\mathrm{ST}}\in\mathbb{Z}_{\ge 1}\)</span>를 잠긴 값으로 둔다. 강성 지시변수를 다음으로 정의한다.
<span class="math display">\[\chi_{\mathrm{ST}}
:=
\begin{cases}
1, &amp; \chi_{\mathrm{span}}=1\ \wedge\ \kappa_{\min}\ge \kappa_{\mathrm{ST}},\\
0, &amp; \text{otherwise}.
\end{cases}
\label{eq:S10_01_chi_ST}\]</span></p>
<p><span class="math inline">\(c\)</span> 스위치를 다음으로 정의한다.
<span class="math display">\[\chi_{c}:=\chi_{\mathrm{ST}}\in\{0,1\}.
\label{eq:S10_01_chi_c}\]</span>
따라서 <span class="math inline">\(\chi_c=0\)</span>인 레짐에서는 <span class="math inline">\(c\)</span>를 수치로 <em>정의하지 않는다</em>. 이 경우 허용되는 기록은 “전파 정의 불능(레짐 밖)”의 한계 결론뿐이다.</p>
<h3 data-number="12.4.2" id="운영-정의를-위한-공통-구조-도메인-변형-완화"><span class="header-section-number">12.4.2</span> 10.1.2 운영 정의를 위한 공통 구조: 도메인, 변형, 완화</h3>
<p>Stone/충만/국소 규칙이 적용되는 레짐에서, 도메인 <span class="math inline">\(\mathcal{D}\)</span> 내부의 허용 배치(비침투/충만/국소 규칙 만족) 집합을 <span class="math inline">\(\mathcal{A}(\mathcal{D})\)</span>로 표기한다. 허용 배치 <span class="math inline">\(\mathcal{C}\in\mathcal{A}(\mathcal{D})\)</span>는 VP 점유 영역들의 집합(또는 그 대표 좌표/그래프 표현)으로 구성된다.</p>
<p>도메인에 가해지는 외부 조작(프로브)을 “변형 연산자”로 정의하고, 변형 후 허용성을 회복하는 절차를 “완화 연산자”로 정의한다.
<span class="math display">\[\mathcal{T}_{\varepsilon}:\mathcal{A}(\mathcal{D})\to \mathcal{A}_{\varepsilon}(\mathcal{D}),
\qquad
\mathcal{R}:\mathcal{A}_{\varepsilon}(\mathcal{D})\to \mathcal{A}(\mathcal{D}),
\label{eq:S10_01_TR_ops}\]</span>
여기서 <span class="math inline">\(\varepsilon\)</span>는 무차원 프로브 크기이며, <span class="math inline">\(\mathcal{A}_{\varepsilon}(\mathcal{D})\)</span>는 변형 후의 중간 상태 공간(허용/비허용 혼재)이다. 완화는 국소 갱신들의 합성으로만 정의되며(국소 규칙 공리), 완화 실패는 정의 불능으로 기록된다.</p>
<p>완화 비용(에너지 단위)을 다음과 같이 정의한다. 단위 에너지 <span class="math inline">\(U_{\mathrm{lat}}\)</span>는 <code>realization_lock</code>에 의해 잠긴 기준 에너지 단위이며, 갱신 가중치 <span class="math inline">\(\omega_{\mathrm{upd}}(k)\)</span>는 <code>analysis_lock</code>에 의해 잠긴다.
<span class="math display">\[W(\varepsilon)
:=
U_{\mathrm{lat}}\,
\min_{\mathcal{R}}
\left(\sum_{k=1}^{N_{\mathrm{upd}}(\varepsilon)} \omega_{\mathrm{upd}}(k)\right),
\qquad
W(0)=0,
\label{eq:S10_01_Work_def}\]</span>
여기서 최소화는 “허용 배치로 복귀”라는 제약 하에서 수행되며, 탐색/종료 규칙은 <code>analysis_lock</code>에 잠긴다.</p>
<h3 data-number="12.4.3" id="b_mathrmeff의-운영-정의정적-등방-압축-곡률"><span class="header-section-number">12.4.3</span> 10.1.3 <span class="math inline">\(B_{\mathrm{eff}}\)</span>의 운영 정의(정적 등방 압축 곡률)</h3>
<h4 data-number="12.4.3.1" id="등방-압축-프로브와-체적-변형률"><span class="header-section-number">12.4.3.1</span> 10.1.3.1 등방 압축 프로브와 체적 변형률</h4>
<p>등방 압축 파라미터 <span class="math inline">\(\varepsilon\in(0,\varepsilon_{\max})\)</span>를 잠긴 범위로 둔다. 도메인 좌표에 대해 등방 스케일 변형을 다음으로 정의한다.
<span class="math display">\[\mathbf{x}\ \mapsto\ \mathbf{x}^{(\varepsilon)}:=(1-\varepsilon)\mathbf{x},
\label{eq:S10_01_iso_map}\]</span>
그리고 이에 대응하는 도메인 부피를
<span class="math display">\[V(\varepsilon):=V_0(1-\varepsilon)^3,
\qquad
V_0:=V(0),
\label{eq:S10_01_Veps}\]</span>
로 정의한다. 체적 변형률을 다음으로 정의한다.
<span class="math display">\[\eta(\varepsilon):=\frac{V_0-V(\varepsilon)}{V_0}=1-(1-\varepsilon)^3.
\label{eq:S10_01_eta_def}\]</span>
따라서 <span class="math inline">\(\eta(0)=0\)</span>이며, 작은 <span class="math inline">\(\varepsilon\)</span>에서 <span class="math inline">\(\eta(\varepsilon)=3\varepsilon+O(\varepsilon^2)\)</span>이다.</p>
<h4 data-number="12.4.3.2" id="등방-압축-비용-함수"><span class="header-section-number">12.4.3.2</span> 10.1.3.2 등방 압축 비용 함수</h4>
<p>허용 배치 <span class="math inline">\(\mathcal{C}\in\mathcal{A}(\mathcal{D})\)</span>에 대해 등방 압축 변형 후 완화 비용을
<span class="math display">\[W_{\mathrm{iso}}(\varepsilon):=W(\varepsilon)
\label{eq:S10_01_Wiso}\]</span>
로 정의한다. <span class="math inline">\(W_{\mathrm{iso}}(\varepsilon)\)</span>는 <a data-reference="eq:S10_01_Work_def" data-reference-type="eqref" href="#eq:S10_01_Work_def">[eq:S10_01_Work_def]</a>로부터 얻어지는 비용이며, 정의가 성립하려면 모든 <span class="math inline">\(\varepsilon\)</span>에서 완화가 허용 배치로 복귀해야 한다(복귀 실패 시 정의 불능).</p>
<h4 data-number="12.4.3.3" id="b_mathrmeff-정의체적-변형률에-대한-곡률"><span class="header-section-number">12.4.3.3</span> 10.1.3.3 <span class="math inline">\(B_{\mathrm{eff}}\)</span> 정의(체적 변형률에 대한 곡률)</h4>
<p>유효 강성(곡률) <span class="math inline">\(B_{\mathrm{eff}}\)</span>를 다음으로 정의한다.
<span class="math display">\[B_{\mathrm{eff}}
:=
\left.\frac{1}{V_0}\frac{d^2 W_{\mathrm{iso}}}{d\eta^2}\right|_{\eta=0}.
\label{eq:S10_01_Beff_def}\]</span>
정의 <a data-reference="eq:S10_01_Beff_def" data-reference-type="eqref" href="#eq:S10_01_Beff_def">[eq:S10_01_Beff_def]</a>는 “등방 압축에 대한 비용 곡률”의 운영 정의이며, 외부 정당화를 사용하지 않는다. <span class="math inline">\(B_{\mathrm{eff}}\)</span>의 차원은 에너지/부피로 잠긴다.</p>
<p>실제 계산에서는 작은 <span class="math inline">\(\eta\)</span> 샘플 <span class="math inline">\(\{\eta_j\}_{j=1}^{J}\)</span>을 사전 등록하여(analysis_lock), 이차 곡률을 이산 근사로 추정한다. 예를 들어 3점 대칭 차분을 사용하는 경우,
<span class="math display">\[\widehat{B}_{\mathrm{eff}}
:=
\frac{1}{V_0}\frac{W_{\mathrm{iso}}(\eta_+)-2W_{\mathrm{iso}}(0)+W_{\mathrm{iso}}(\eta_-)}{\eta_+^2},
\qquad
\eta_-=-\eta_+,
\label{eq:S10_01_Beff_est}\]</span>
와 같이 정의하며, 샘플 값과 추정식 선택은 <code>analysis_lock</code>에 잠겨야 한다. (음의 <span class="math inline">\(\eta\)</span>를 허용하지 않는 프로토콜에서는 비대칭 근사식을 사용하며, 그 선택 규칙 또한 잠겨야 한다.)</p>
<h3 data-number="12.4.4" id="rho_mathrmeff의-운영-정의동적-드리프트-곡률"><span class="header-section-number">12.4.4</span> 10.1.4 <span class="math inline">\(\rho_{\mathrm{eff}}\)</span>의 운영 정의(동적 드리프트 곡률)</h3>
<p><span class="math inline">\(B_{\mathrm{eff}}/\rho_{\mathrm{eff}}\)</span> 형태의 전파 지표를 정의하기 위해, <span class="math inline">\(\rho_{\mathrm{eff}}\)</span>를 “동적 드리프트 프로브에 대한 비용 곡률”로 운영 정의한다.</p>
<h4 data-number="12.4.4.1" id="드리프트-프로브와-속도형-파라미터"><span class="header-section-number">12.4.4.1</span> 10.1.4.1 드리프트 프로브와 속도형 파라미터</h4>
<p>드리프트 파라미터 <span class="math inline">\(u\in(-u_{\max},u_{\max})\)</span>를 무차원 프로브로 정의한다. 한 틱 동안의 경계-구동 변위를
<span class="math display">\[\Delta x(u):=u\,L_q
\label{eq:S10_01_dx_u}\]</span>
로 정의한다. 이때 <span class="math inline">\(L_q\)</span>는 잠긴 정준 길이(또는 정준 동일시된 길이)이며, <span class="math inline">\(u\)</span>는 “한 틱당 이동량”의 무차원 계수이다.</p>
<p>드리프트 변형 연산자 <span class="math inline">\(\mathcal{T}_u\)</span>를 다음으로 정의한다.
<span class="math display">\[\mathcal{T}_u:\ \mathbf{x}\ \mapsto\ \mathbf{x}^{(u)}:=\mathbf{x}+\Delta x(u)\,\mathbf{n}_u,
\qquad
\|\mathbf{n}_u\|=1,
\label{eq:S10_01_drift_map}\]</span>
여기서 <span class="math inline">\(\mathbf{n}_u\)</span>는 드리프트 방향 단위벡터이며 <code>analysis_lock</code>에 의해 잠긴다.</p>
<h4 data-number="12.4.4.2" id="드리프트-비용-함수"><span class="header-section-number">12.4.4.2</span> 10.1.4.2 드리프트 비용 함수</h4>
<p>드리프트 후 허용 배치로 복귀하기 위한 완화 비용을 다음으로 정의한다.
<span class="math display">\[W_{\mathrm{drift}}(u)
:=
U_{\mathrm{lat}}\,
\min_{\mathcal{R}}
\left(\sum_{k=1}^{N_{\mathrm{upd}}(u)} \omega_{\mathrm{upd}}(k)\right),
\qquad
W_{\mathrm{drift}}(0)=0.
\label{eq:S10_01_Wdrift}\]</span>
정의 <a data-reference="eq:S10_01_Wdrift" data-reference-type="eqref" href="#eq:S10_01_Wdrift">[eq:S10_01_Wdrift]</a>에서 완화가 실패하면 <span class="math inline">\(W_{\mathrm{drift}}(u)\)</span>는 정의 불능이며, 해당 레짐에서는 <span class="math inline">\(\rho_{\mathrm{eff}}\)</span>를 정의할 수 없다.</p>
<h4 data-number="12.4.4.3" id="rho_mathrmeff-정의드리프트-곡률"><span class="header-section-number">12.4.4.3</span> 10.1.4.3 <span class="math inline">\(\rho_{\mathrm{eff}}\)</span> 정의(드리프트 곡률)</h4>
<p>유효 밀도 <span class="math inline">\(\rho_{\mathrm{eff}}\)</span>를 다음으로 정의한다.
<span class="math display">\[\rho_{\mathrm{eff}}
:=
\left.\frac{1}{V_0}\frac{d^2 W_{\mathrm{drift}}}{du^2}\right|_{u=0}.
\label{eq:S10_01_rhoeff_def}\]</span>
정의 <a data-reference="eq:S10_01_rhoeff_def" data-reference-type="eqref" href="#eq:S10_01_rhoeff_def">[eq:S10_01_rhoeff_def]</a>는 “드리프트 프로브에 대한 비용 곡률”의 운영 정의이며, 외부 정당화를 사용하지 않는다. <span class="math inline">\(\rho_{\mathrm{eff}}\)</span>의 차원은 에너지<span class="math inline">\(\cdot\)</span>시간<span class="math inline">\(^2\)</span>/길이<span class="math inline">\(^5\)</span> 형태로 잠기며, 이후 실현(Realization) 절에서 <span class="math inline">\(a,\Delta t\)</span>를 통해 속도 단위로 재정렬된다.</p>
<p>실제 계산에서 <span class="math inline">\(u\)</span> 샘플 <span class="math inline">\(\{u_j\}_{j=1}^{J}\)</span>과 곡률 추정식(중심차분 등)은 <code>analysis_lock</code>에 잠겨야 한다. 예를 들어 중심차분을 사용하는 경우,
<span class="math display">\[\widehat{\rho}_{\mathrm{eff}}
:=
\frac{1}{V_0}\frac{W_{\mathrm{drift}}(u_+)-2W_{\mathrm{drift}}(0)+W_{\mathrm{drift}}(u_-)}{u_+^2},
\qquad
u_-=-u_+.
\label{eq:S10_01_rhoeff_est}\]</span>
로 정의한다.</p>
<h3 data-number="12.4.5" id="c의-운영-정의내부-전파-지표와-실현"><span class="header-section-number">12.4.5</span> 10.1.5 <span class="math inline">\(c\)</span>의 운영 정의(내부 전파 지표)와 실현</h3>
<h4 data-number="12.4.5.1" id="내부-전파-지표-tildec"><span class="header-section-number">12.4.5.1</span> 10.1.5.1 내부 전파 지표 <span class="math inline">\(\tilde{c}\)</span></h4>
<p><span class="math inline">\(\chi_c=1\)</span>이며 <span class="math inline">\(B_{\mathrm{eff}}\)</span>와 <span class="math inline">\(\rho_{\mathrm{eff}}\)</span>가 정의 가능하고 양의 값일 때, 내부 전파 지표 <span class="math inline">\(\tilde{c}\)</span>를 다음으로 정의한다.
<span class="math display">\[\tilde{c}^2 := \frac{B_{\mathrm{eff}}}{\rho_{\mathrm{eff}}},
\qquad
\tilde{c}:=\sqrt{\frac{B_{\mathrm{eff}}}{\rho_{\mathrm{eff}}}}.
\label{eq:S10_01_ctilde_def}\]</span>
<span class="math inline">\(\tilde{c}\)</span>는 내부 단위(틱/정규화 길이)에 대한 전파 지표이며, <span class="math inline">\(\chi_c=0\)</span>에서는 정의되지 않는다.</p>
<h4 data-number="12.4.5.2" id="실현된-c"><span class="header-section-number">12.4.5.2</span> 10.1.5.2 실현된 <span class="math inline">\(c\)</span></h4>
<p>실현 길이 스케일 <span class="math inline">\(a\)</span>와 실현 시간 틱 <span class="math inline">\(\Delta t\)</span>가 <code>realization_lock</code>에 의해 잠겨 있을 때, 실현된 <span class="math inline">\(c\)</span>를 다음으로 정의한다.
<span class="math display">\[c
:=
\frac{a}{\Delta t}\,\tilde{c}.
\label{eq:S10_01_c_real_def}\]</span>
정의 <a data-reference="eq:S10_01_c_real_def" data-reference-type="eqref" href="#eq:S10_01_c_real_def">[eq:S10_01_c_real_def]</a>는 실현 사상이며, <span class="math inline">\(a\)</span> 또는 <span class="math inline">\(\Delta t\)</span>의 사후 변경은 금지된다(변경은 버전업으로만 허용).</p>
<h3 data-number="12.4.6" id="레짐-조건정의-성립-조건"><span class="header-section-number">12.4.6</span> 10.1.6 레짐 조건(정의 성립 조건)</h3>
<p>본 절의 <span class="math inline">\(c\)</span> 정의가 성립하려면 다음 레짐 조건이 모두 만족되어야 한다.</p>
<ol>
<li><p><strong>(R-c1) 강성 레짐</strong>: <span class="math inline">\(\chi_c=\chi_{\mathrm{ST}}=1\)</span>.</p></li>
<li><p><strong>(R-c2) 허용 배치 복귀</strong>: 등방 압축 프로브 및 드리프트 프로브에서 완화가 허용 배치로 복귀하여 <span class="math inline">\(W_{\mathrm{iso}}(\varepsilon)\)</span>와 <span class="math inline">\(W_{\mathrm{drift}}(u)\)</span>가 정의된다.</p></li>
<li><p><strong>(R-c3) 곡률 정의 가능</strong>: <span class="math inline">\(W_{\mathrm{iso}}\)</span>는 <span class="math inline">\(\eta=0\)</span>에서 2차 곡률이 존재하고, <span class="math inline">\(W_{\mathrm{drift}}\)</span>는 <span class="math inline">\(u=0\)</span>에서 2차 곡률이 존재한다(이산 추정식이 잠김).</p></li>
<li><p><strong>(R-c4) 양의 곡률</strong>: <span class="math inline">\(B_{\mathrm{eff}}&gt;0\)</span> 및 <span class="math inline">\(\rho_{\mathrm{eff}}&gt;0\)</span>.</p></li>
<li><p><strong>(R-c5) 잠금 일치</strong>: 도메인/경계/접촉 규약/프로브 샘플/추정식/문턱값이 동일 lock_id 조합에 귀속된다.</p></li>
</ol>
<p>(R-c1)–(R-c5) 중 하나라도 위반되면 <span class="math inline">\(c\)</span>는 정의 불능이며, 결론 문장으로 사용할 수 없다.</p>
<h3 data-number="12.4.7" id="fail-조건즉시-실패-및-라벨"><span class="header-section-number">12.4.7</span> 10.1.7 FAIL 조건(즉시 실패 및 라벨)</h3>
<p>본 절은 <span class="math inline">\(c\)</span> 정의와 관련된 실패를 다음 FAIL 라벨로 고정한다(복수 라벨 허용).</p>
<h4 data-number="12.4.7.1" id="스위치-실패레짐-밖"><span class="header-section-number">12.4.7.1</span> 10.1.7.1 스위치 실패(레짐 밖)</h4>
<p><span class="math display">\[\chi_c=0
\quad\Longrightarrow\quad
\texttt{FAIL-C-SWITCH}.
\label{eq:S10_01_fail_switch}\]</span>
이 경우 <span class="math inline">\(c\)</span>는 정의되지 않으며, <span class="math inline">\(\tilde{c}\)</span>도 정의되지 않는다.</p>
<h4 data-number="12.4.7.2" id="완화-실패정의-불능"><span class="header-section-number">12.4.7.2</span> 10.1.7.2 완화 실패(정의 불능)</h4>
<p>등방 압축 또는 드리프트에서 허용 배치로 복귀하지 못하면 즉시 실패로 처리한다.
<span class="math display">\[\exists\,\varepsilon\ \text{s.t.}\ W_{\mathrm{iso}}(\varepsilon)\ \text{정의 불능}
\quad\Longrightarrow\quad
\texttt{FAIL-C-RELAX-ISO},
\label{eq:S10_01_fail_relax_iso}\]</span>
<span class="math display">\[\exists\,u\ \text{s.t.}\ W_{\mathrm{drift}}(u)\ \text{정의 불능}
\quad\Longrightarrow\quad
\texttt{FAIL-C-RELAX-DRIFT}.
\label{eq:S10_01_fail_relax_drift}\]</span></p>
<h4 data-number="12.4.7.3" id="곡률-추정-실패수치-불안정"><span class="header-section-number">12.4.7.3</span> 10.1.7.3 곡률 추정 실패(수치 불안정)</h4>
<p>곡률 추정이 사전 등록된 안정 조건을 만족하지 못하면 실패로 처리한다.
<span class="math display">\[\widehat{B}_{\mathrm{eff}}\ \text{수렴 실패 또는 부호 불안정}
\quad\Longrightarrow\quad
\texttt{FAIL-C-B-NUM},
\label{eq:S10_01_fail_Bnum}\]</span>
<span class="math display">\[\widehat{\rho}_{\mathrm{eff}}\ \text{수렴 실패 또는 부호 불안정}
\quad\Longrightarrow\quad
\texttt{FAIL-C-RHO-NUM}.
\label{eq:S10_01_fail_RHOnum}\]</span></p>
<h4 data-number="12.4.7.4" id="양의성-실패정의-위반"><span class="header-section-number">12.4.7.4</span> 10.1.7.4 양의성 실패(정의 위반)</h4>
<p><span class="math display">\[B_{\mathrm{eff}}\le 0
\quad\Longrightarrow\quad
\texttt{FAIL-C-B-NONPOS},
\label{eq:S10_01_fail_Bnonpos}\]</span>
<span class="math display">\[\rho_{\mathrm{eff}}\le 0
\quad\Longrightarrow\quad
\texttt{FAIL-C-RHO-NONPOS}.
\label{eq:S10_01_fail_RHOnonpos}\]</span>
양의성 실패는 <span class="math inline">\(c\)</span>의 제곱근 정의 <a data-reference="eq:S10_01_ctilde_def" data-reference-type="eqref" href="#eq:S10_01_ctilde_def">[eq:S10_01_ctilde_def]</a> 자체를 붕괴시키므로 즉시 실패이다.</p>
<h4 data-number="12.4.7.5" id="잠금의미-충돌-및-사후조정"><span class="header-section-number">12.4.7.5</span> 10.1.7.5 잠금/의미 충돌 및 사후조정</h4>
<p>다음은 즉시 실패이다.</p>
<ol>
<li><p>기호 의미 충돌(셀 기하, 지름/반지름, 단위 차원 불일치): <code>FAIL-C-SYM</code>.</p></li>
<li><p>서로 다른 lock_id 조합 혼합: <code>FAIL-C-LOCK-MIX</code>.</p></li>
<li><p>프로브 샘플/추정식/문턱값/완화 규칙의 사후 변경: <code>FAIL-C-NT</code>.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-47">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(\chi_c=\chi_{\mathrm{ST}}\)</span>, <span class="math inline">\(\kappa_{\mathrm{ST}}\)</span>, 등방/드리프트 프로브 정의, <span class="math inline">\(W_{\mathrm{iso}},W_{\mathrm{drift}}\)</span> 및 곡률 추정식, 문턱값을 <code>analysis_lock</code>/<code>gate_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(B_{\mathrm{eff}}\)</span> 정의(<a data-reference="eq:S10_01_Beff_def" data-reference-type="eqref" href="#eq:S10_01_Beff_def">[eq:S10_01_Beff_def]</a>)와 <span class="math inline">\(\rho_{\mathrm{eff}}\)</span> 정의(<a data-reference="eq:S10_01_rhoeff_def" data-reference-type="eqref" href="#eq:S10_01_rhoeff_def">[eq:S10_01_rhoeff_def]</a>), <span class="math inline">\(\tilde{c}\)</span> 정의(<a data-reference="eq:S10_01_ctilde_def" data-reference-type="eqref" href="#eq:S10_01_ctilde_def">[eq:S10_01_ctilde_def]</a>)를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 스위치 실패(<code>FAIL-C-SWITCH</code>), 완화 실패(<code>FAIL-C-RELAX-*</code>), 곡률/양의성 실패(<code>FAIL-C-*-NUM</code>/<code>FAIL-C-*-NONPOS</code>)를 <code>gate_lock</code> 판정으로 연결.</p></li>
<li><p>Gate: 의미 충돌/lock 혼합/사후조정은 G-SYM/G-LOCK/G-NT에서 즉시 <code>FAIL</code>.</p></li>
<li><p>Gate: <span class="math inline">\(c\)</span>는 <code>PASS</code> 스택(스위치+곡률+양의성+봉인) 없이는 결론 자격이 없으며, 봉인(manifest/checksums) 미충족 시 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
</ul>
<h2 data-number="12.5" id="delta_mathrmeff퍼콜레이션-닫힘"><span class="header-section-number">12.5</span> 10.2 <span class="math inline">\(\delta_{\mathrm{eff}}\)</span>·퍼콜레이션 닫힘</h2>
<h3 data-number="12.5.1" id="전제레짐-및-입력-잠금"><span class="header-section-number">12.5.1</span> 10.2.1 전제(레짐 및 입력 잠금)</h3>
<p>본 절의 정의와 절차는 다음 전제가 동시에 만족될 때에만 적용된다.</p>
<ol>
<li><p>전파 스위치: <span class="math inline">\(\chi_c=\chi_{\mathrm{ST}}=1\)</span>.</p></li>
<li><p>도메인 <span class="math inline">\(\mathcal{D}\)</span>, 대향 경계 집합 <span class="math inline">\(\partial\mathcal{D}^{-},\partial\mathcal{D}^{+}\)</span>, 경계 노드 집합 <span class="math inline">\(\mathcal{V}^{-},\mathcal{V}^{+}\)</span>가 잠김.</p></li>
<li><p>노드 좌표 <span class="math inline">\(\{\mathbf{x}_i\}\)</span>, 중심 <span class="math inline">\(\mathbf{x}_c\)</span>, 정규화 길이 <span class="math inline">\(L_q\)</span>가 잠김.</p></li>
<li><p>인접/접촉 그래프 <span class="math inline">\(\mathcal{G}_c=(\mathcal{V},\mathcal{E}_c)\)</span> 및 접촉 판정 규약이 잠김.</p></li>
<li><p>최소 분리 길이(또는 기준 길이) <span class="math inline">\(d_0&gt;0\)</span>가 잠김(지름/반지름 의미 포함).</p></li>
</ol>
<p>위 항목 중 하나라도 잠기지 않으면 <span class="math inline">\(\delta_{\mathrm{eff}}\)</span>의 정의 및 퍼콜레이션 절차는 정의 불능이다.</p>
<h3 data-number="12.5.2" id="목throat과-간격gap의-정의"><span class="header-section-number">12.5.2</span> 10.2.2 목(throat)과 간격(gap)의 정의</h3>
<p>본 절에서 “목(throat)”은 전역 전파 경로를 구성하는 후보 간선이며, “간격(gap)”은 후보 간선에 부여되는 길이형 스칼라 가중치이다.</p>
<h4 data-number="12.5.2.1" id="후보-간선-집합목-후보"><span class="header-section-number">12.5.2.1</span> 10.2.2.1 후보 간선 집합(목 후보)</h4>
<p>목 후보 간선 집합을 다음으로 정의한다.
<span class="math display">\[\mathcal{E}_{\mathrm{th}}
:=\mathcal{E}_c.
\label{eq:S10_02_Eth_def}\]</span>
즉, 본 절에서는 접촉 그래프의 간선이 목 후보 간선의 단일 출처(SSOT)이다. 후보 간선 집합을 확장(예: <span class="math inline">\(k\)</span>-근접 그래프 추가 등)하려면 별도의 닫힘으로 정의되어야 하며, 본 절에서는 허용하지 않는다.</p>
<h4 data-number="12.5.2.2" id="간격목-가중치-g_ij"><span class="header-section-number">12.5.2.2</span> 10.2.2.2 간격(목 가중치) <span class="math inline">\(g_{ij}\)</span></h4>
<p>각 간선 <span class="math inline">\((i,j)\in\mathcal{E}_{\mathrm{th}}\)</span>에 대해 거리와 간격을 다음으로 정의한다.
<span class="math display">\[d_{ij}:=\|\mathbf{x}_i-\mathbf{x}_j\|,
\qquad
g_{ij}:=\max\!\left(0,\ d_{ij}-d_0\right).
\label{eq:S10_02_gap_def}\]</span>
여기서 <span class="math inline">\(d_0\)</span>는 기준 길이이며 잠긴 값이다. <span class="math inline">\(g_{ij}\)</span>의 차원은 길이이고, <span class="math inline">\(g_{ij}\ge 0\)</span>이다.
<span class="math inline">\(g_{ij}\)</span>는 동일 버전 내부에서 다른 정의(예: 제곱거리, 정규화, 비선형 변환)로 교체될 수 없다.</p>
<h4 data-number="12.5.2.3" id="정규화된-간격선택적-파생량"><span class="header-section-number">12.5.2.3</span> 10.2.2.3 정규화된 간격(선택적 파생량)</h4>
<p>정규화된 간격을 다음으로 파생 정의한다.
<span class="math display">\[\tilde{g}_{ij}:=\frac{g_{ij}}{L_q}.
\label{eq:S10_02_gap_norm}\]</span>
<span class="math inline">\(\tilde{g}_{ij}\)</span>는 무차원이며, <span class="math inline">\(L_q\)</span>가 잠긴 경우에만 사용 가능하다.</p>
<h3 data-number="12.5.3" id="퍼콜레이션전역-전파-정의-문턱-g와-열린-그래프"><span class="header-section-number">12.5.3</span> 10.2.3 퍼콜레이션(전역 전파) 정의: 문턱 <span class="math inline">\(g\)</span>와 열린 그래프</h3>
<p>퍼콜레이션은 간격 문턱 <span class="math inline">\(g\ge 0\)</span>에 따라 “열린 간선”을 선택하여 전역 연결이 성립하는지 판정하는 절차로 정의한다.</p>
<h4 data-number="12.5.3.1" id="문턱-g와-열린-간선"><span class="header-section-number">12.5.3.1</span> 10.2.3.1 문턱 <span class="math inline">\(g\)</span>와 열린 간선</h4>
<p>문턱 <span class="math inline">\(g\in\mathbb{R}_{\ge 0}\)</span>에 대해 열린 간선 집합을 다음으로 정의한다.
<span class="math display">\[\mathcal{E}_{\mathrm{open}}(g)
:=
\left\{(i,j)\in\mathcal{E}_{\mathrm{th}}\ \middle|\ g_{ij}\le g\right\}.
\label{eq:S10_02_Eopen_def}\]</span>
열린 그래프를 다음으로 정의한다.
<span class="math display">\[\mathcal{G}_{\mathrm{open}}(g)
:=
\bigl(\mathcal{V},\mathcal{E}_{\mathrm{open}}(g)\bigr).
\label{eq:S10_02_Gopen_def}\]</span>
정의상 <span class="math inline">\(g\)</span>가 증가하면 <span class="math inline">\(\mathcal{E}_{\mathrm{open}}(g)\)</span>는 단조 증가한다.</p>
<h4 data-number="12.5.3.2" id="전역-전파-지시변수-chi_mathrmpercg"><span class="header-section-number">12.5.3.2</span> 10.2.3.2 전역 전파 지시변수 <span class="math inline">\(\chi_{\mathrm{perc}}(g)\)</span></h4>
<p>대향 경계 노드 집합 <span class="math inline">\(\mathcal{V}^{-},\mathcal{V}^{+}\)</span>에 대해 퍼콜레이션 지시변수를 다음으로 정의한다.
<span class="math display">\[\chi_{\mathrm{perc}}(g)
:=
\begin{cases}
1, &amp; \exists\, i\in\mathcal{V}^{-},\exists\, j\in\mathcal{V}^{+}\ \text{s.t.}\ i\leadsto j\ \text{in }\mathcal{G}_{\mathrm{open}}(g),\\
0, &amp; \text{otherwise}.
\end{cases}
\label{eq:S10_02_chi_perc}\]</span>
<span class="math inline">\(\chi_{\mathrm{perc}}(g)=1\)</span>이면 문턱 <span class="math inline">\(g\)</span>에서 전역 전파(경로 존재)가 성립한다.</p>
<h3 data-number="12.5.4" id="임계목-문턱-g_c와-delta_mathrmeff의-정의"><span class="header-section-number">12.5.4</span> 10.2.4 임계목 문턱 <span class="math inline">\(g_c\)</span>와 <span class="math inline">\(\delta_{\mathrm{eff}}\)</span>의 정의</h3>
<p>임계목 문턱 <span class="math inline">\(g_c\)</span>는 전역 전파가 <em>처음으로</em> 성립하는 최소 문턱으로 정의한다.</p>
<h4 data-number="12.5.4.1" id="임계-문턱-g_c-정의"><span class="header-section-number">12.5.4.1</span> 10.2.4.1 임계 문턱 <span class="math inline">\(g_c\)</span> 정의</h4>
<p><span class="math display">\[g_c
:=
\inf\{\, g\ge 0\mid \chi_{\mathrm{perc}}(g)=1\,\}.
\label{eq:S10_02_gc_def}\]</span>
간선 가중치가 유한 집합이므로(유한 노드/유한 간선), 실제 구현에서는 다음 이산 정의를 사용하여 잠근다.
<span class="math display">\[\mathcal{G}:=\{g_{ij}\mid (i,j)\in\mathcal{E}_{\mathrm{th}}\}\ \text{(중복 제거 후 정렬)},
\qquad
g_c:=\min\{\, g\in\mathcal{G}\mid \chi_{\mathrm{perc}}(g)=1\,\}.
\label{eq:S10_02_gc_discrete}\]</span></p>
<h4 data-number="12.5.4.2" id="delta_mathrmeff-정의길이형"><span class="header-section-number">12.5.4.2</span> 10.2.4.2 <span class="math inline">\(\delta_{\mathrm{eff}}\)</span> 정의(길이형)</h4>
<p>유효 임계목 두께(간격) <span class="math inline">\(\delta_{\mathrm{eff}}\)</span>를 다음으로 정의한다.
<span class="math display">\[\delta_{\mathrm{eff}} := g_c.
\label{eq:S10_02_deltaeff_def}\]</span>
따라서 <span class="math inline">\(\delta_{\mathrm{eff}}\)</span>의 차원은 길이이며, 값은 퍼콜레이션 임계 문턱과 동일하다.</p>
<h4 data-number="12.5.4.3" id="무차원-유효-임계목선택적-파생량"><span class="header-section-number">12.5.4.3</span> 10.2.4.3 무차원 유효 임계목(선택적 파생량)</h4>
<p>무차원 유효 임계목을 다음으로 파생 정의한다.
<span class="math display">\[\tilde{\delta}_{\mathrm{eff}}:=\frac{\delta_{\mathrm{eff}}}{L_q}=\frac{g_c}{L_q}.
\label{eq:S10_02_deltaeff_tilde}\]</span>
<span class="math inline">\(\tilde{\delta}_{\mathrm{eff}}\)</span>는 <span class="math inline">\(L_q\)</span>가 잠긴 경우에만 사용 가능하다.</p>
<h3 data-number="12.5.5" id="계산-절차-전역-전파임계목union-find-백본-추출"><span class="header-section-number">12.5.5</span> 10.2.5 계산 절차: 전역 전파/임계목(Union-Find) + 백본 추출</h3>
<p>본 절은 계산 절차를 결정적 알고리즘으로 고정한다. 난수, 임의 선택, 결과 기반 선택은 금지된다.</p>
<h4 data-number="12.5.5.1" id="전처리-간선-목록과-가중치-테이블"><span class="header-section-number">12.5.5.1</span> 10.2.5.1 전처리: 간선 목록과 가중치 테이블</h4>
<ol>
<li><p>간선 목록을 <span class="math inline">\(\mathcal{E}_{\mathrm{th}}\)</span>로 고정한다(<a data-reference="eq:S10_02_Eth_def" data-reference-type="eqref" href="#eq:S10_02_Eth_def">[eq:S10_02_Eth_def]</a>).</p></li>
<li><p>각 간선에 대해 <span class="math inline">\((i,j,g_{ij})\)</span>를 계산한다(<a data-reference="eq:S10_02_gap_def" data-reference-type="eqref" href="#eq:S10_02_gap_def">[eq:S10_02_gap_def]</a>).</p></li>
<li><p>간선 목록을 다음 키로 정렬하여 결정 순서를 잠근다.
<span class="math display">\[\mathrm{key}(i,j):=\bigl(g_{ij},\ \min(i,j),\ \max(i,j)\bigr).
  \label{eq:S10_02_edge_key}\]</span></p></li>
</ol>
<h4 data-number="12.5.5.2" id="임계-문턱-g_c-계산union-find"><span class="header-section-number">12.5.5.2</span> 10.2.5.2 임계 문턱 <span class="math inline">\(g_c\)</span> 계산(Union-Find)</h4>
<p>다음 결정적 절차로 <span class="math inline">\(g_c\)</span>를 계산한다.</p>
<pre><code>ALG-PERC-GC (inputs: V, E_th with weights g_ij, boundary sets V-, V+)

1) initialize Union-Find structure UF over nodes V
2) mark boundary membership:
     tag_minus(i)=1 if i in V-, else 0
     tag_plus(i)=1 if i in V+, else 0
   store for each UF component:
     has_minus(component), has_plus(component)
3) sort edges (i,j) by key(i,j)=(g_ij, min(i,j), max(i,j))

4) for each edge (i,j) in sorted order:
     UF.union(i,j)
     update has_minus/has_plus for the merged component
     if exists a component with has_minus=1 and has_plus=1:
         g_c := g_ij of the current edge
         STOP

5) if loop ends without connection:
     FAIL-PERC-NOSPAN</code></pre>
<p>정지 시점의 <span class="math inline">\(g_c\)</span>는 <a data-reference="eq:S10_02_gc_discrete" data-reference-type="eqref" href="#eq:S10_02_gc_discrete">[eq:S10_02_gc_discrete]</a>의 이산 정의와 동치이며, 이는 본 절의 <span class="math inline">\(\delta_{\mathrm{eff}}\)</span> 정의 <a data-reference="eq:S10_02_deltaeff_def" data-reference-type="eqref" href="#eq:S10_02_deltaeff_def">[eq:S10_02_deltaeff_def]</a>로 바로 연결된다.</p>
<h4 data-number="12.5.5.3" id="퍼콜레이션-백본backbone-정의"><span class="header-section-number">12.5.5.3</span> 10.2.5.3 퍼콜레이션 백본(backbone) 정의</h4>
<p>임계 문턱 <span class="math inline">\(g_c\)</span>에서 열린 그래프를 <span class="math inline">\(\mathcal{G}_{\mathrm{open}}(g_c)\)</span>로 두고, 그 안에서 <em>경계-경계 연결에 실제로 기여하는 간선</em>만을 백본으로 정의한다.</p>
<h4 data-number="12.5.5.4" id="경계-연결-성분"><span class="header-section-number">12.5.5.4</span> (1) 경계-연결 성분</h4>
<p>임계 문턱에서 <span class="math inline">\(\mathcal{V}^{-}\)</span>와 <span class="math inline">\(\mathcal{V}^{+}\)</span>를 동시에 포함하는 연결 성분을
<span class="math display">\[\mathcal{C}_{\mathrm{span}}(g_c)\subseteq \mathcal{V}
\label{eq:S10_02_Cspan_def}\]</span>
로 정의한다(Union-Find의 최종 연결 성분으로 결정 가능).</p>
<h4 data-number="12.5.5.5" id="두-단말-기여-간선-판정결정적-판정"><span class="header-section-number">12.5.5.5</span> (2) 두-단말 기여 간선 판정(결정적 판정)</h4>
<p><span class="math inline">\(\mathcal{G}_{\mathrm{open}}(g_c)\)</span>를 <span class="math inline">\(\mathcal{C}_{\mathrm{span}}(g_c)\)</span>에 제한한 부분그래프를
<span class="math display">\[\mathcal{G}_{\mathrm{span}}(g_c)
:=
\mathcal{G}_{\mathrm{open}}(g_c)\big|_{\mathcal{C}_{\mathrm{span}}(g_c)}
\label{eq:S10_02_Gspan_def}\]</span>
로 정의한다.</p>
<p>간선 <span class="math inline">\(e=(u,v)\)</span>가 “경계-경계 연결에 기여한다”는 것은, <span class="math inline">\(e\)</span>를 제거했을 때 <span class="math inline">\(\mathcal{V}^{-}\)</span>에서 <span class="math inline">\(\mathcal{V}^{+}\)</span>로의 경로가 사라지는지 여부로 판정한다. 이를 위해 다음 결정적 판정 함수를 정의한다.
<span class="math display">\[\mathrm{BridgeTT}(e)
:=
\begin{cases}
1,&amp; \chi_{\mathrm{perc}}^{(-e)}(g_c)=0,\\
0,&amp; \chi_{\mathrm{perc}}^{(-e)}(g_c)=1,
\end{cases}
\label{eq:S10_02_bridgeTT_def}\]</span>
여기서 <span class="math inline">\(\chi_{\mathrm{perc}}^{(-e)}(g_c)\)</span>는 <span class="math inline">\(\mathcal{G}_{\mathrm{span}}(g_c)\)</span>에서 간선 <span class="math inline">\(e\)</span>를 제거한 그래프에 대해 <a data-reference="eq:S10_02_chi_perc" data-reference-type="eqref" href="#eq:S10_02_chi_perc">[eq:S10_02_chi_perc]</a>로 계산한 값이다.</p>
<p>이 판정은 비용이 클 수 있으므로, 실제 구현에서는 아래의 결정적 알고리즘(지배적 간선 추출)을 사용하여 동일 결과를 산출하도록 잠근다.</p>
<h4 data-number="12.5.5.6" id="백본-추출-알고리즘두-단말-필수-간선-집합"><span class="header-section-number">12.5.5.6</span> 10.2.5.4 백본 추출 알고리즘(두-단말 필수 간선 집합)</h4>
<p>다음 알고리즘으로 백본 간선 집합 <span class="math inline">\(\mathcal{E}_{\mathrm{bb}}\)</span>를 정의한다.</p>
<pre><code>ALG-BACKBONE-TT (inputs: G_span(g_c), boundary sets V-, V+)

1) choose deterministic start node s in V-:
     s := min index in (V- ∩ C_span)
2) BFS from s in G_span to compute parent tree and levels.
3) choose deterministic target node t in V+ reachable:
     t := min index in (V+ ∩ C_span) among reachable nodes
4) extract one canonical path P0 from s to t using parent pointers.
   E_bb := edges of P0

5) augment backbone by mandatory two-terminal edges:
   For each edge e in E_open(g_c) within G_span, in sorted key order:
      Temporarily remove e
      Check reachability from any node in V- to any node in V+ (BFS):
         if disconnected: mark e as mandatory and add to E_bb
      Restore e

6) output E_bb</code></pre>
<p>위 알고리즘은 다음 성질을 만족하도록 잠긴다.</p>
<ol>
<li><p><strong>결정성</strong>: 시작 노드/도착 노드/간선 순서가 모두 규약으로 잠겨 있음.</p></li>
<li><p><strong>정의적 최소성</strong>: 최소 한 개의 경계-경계 경로를 포함함(<span class="math inline">\(P_0\)</span>).</p></li>
<li><p><strong>필수성 추가</strong>: 제거 시 연결을 끊는 간선을 추가하여 “필수 간선 집합”을 포함함.</p></li>
</ol>
<p>백본 노드 집합을 <span class="math inline">\(\mathcal{V}_{\mathrm{bb}}\)</span>로 정의한다.
<span class="math display">\[\mathcal{V}_{\mathrm{bb}}
:=
\{\, v\in\mathcal{V}\mid \exists\, e=(u,v)\in\mathcal{E}_{\mathrm{bb}}\ \text{또는}\ e=(v,w)\in\mathcal{E}_{\mathrm{bb}}\,\}.
\label{eq:S10_02_Vbb_def}\]</span></p>
<h3 data-number="12.5.6" id="전역-전파-산출물정의-결과형"><span class="header-section-number">12.5.6</span> 10.2.6 전역 전파 산출물(정의-결과형)</h3>
<p>본 절의 결과 산출물은 다음 네 항목으로 고정된다.</p>
<ol>
<li><p>임계 문턱 <span class="math inline">\(g_c\)</span> (길이).</p></li>
<li><p>유효 임계목 <span class="math inline">\(\delta_{\mathrm{eff}}:=g_c\)</span> (길이) 및 선택적 무차원 <span class="math inline">\(\tilde{\delta}_{\mathrm{eff}}\)</span>.</p></li>
<li><p>임계 그래프 <span class="math inline">\(\mathcal{G}_{\mathrm{open}}(g_c)\)</span> (열린 간선 집합).</p></li>
<li><p>백본 간선 집합 <span class="math inline">\(\mathcal{E}_{\mathrm{bb}}\)</span> 및 백본 노드 집합 <span class="math inline">\(\mathcal{V}_{\mathrm{bb}}\)</span>.</p></li>
</ol>
<p>위 산출물은 동일 <code>analysis_lock</code> 및 동일 <code>regime_id</code>에 귀속되며, <code>manifest+checksums</code>로 봉인되어야만 이후 절(증폭 <span class="math inline">\(A\)</span>, 전파 지표 <span class="math inline">\(\tilde{c}\)</span>, <span class="math inline">\(c\)</span> 실현)의 입력으로 사용 가능하다.</p>
<h3 data-number="12.5.7" id="실패모드와-fail-조건"><span class="header-section-number">12.5.7</span> 10.2.7 실패모드와 FAIL 조건</h3>
<p>다음 조건 중 하나라도 발생하면 본 절의 산출물은 결론 자격을 상실한다.</p>
<ol>
<li><p><strong>레짐 위반</strong>: <span class="math inline">\(\chi_c=0\)</span> 또는 경계 집합/노드 집합이 잠기지 않음.</p></li>
<li><p><strong>스패닝 실패</strong>: 어떤 <span class="math inline">\(g\)</span>에서도 <span class="math inline">\(\chi_{\mathrm{perc}}(g)=1\)</span>이 되지 않음.
<span class="math display">\[\forall g\ge 0,\ \chi_{\mathrm{perc}}(g)=0
  \quad\Longrightarrow\quad
  \texttt{FAIL-PERC-NOSPAN}.
  \label{eq:S10_02_fail_nospan}\]</span></p></li>
<li><p><strong>의미 충돌</strong>: <span class="math inline">\(d_0\)</span>의 의미(지름/반지름) 또는 좌표/단위 규약 충돌로 <span class="math inline">\(g_{ij}\)</span>가 불명확.</p></li>
<li><p><strong>절차 미잠금</strong>: 경계 노드 정의, 간선 정렬 키, 타이브레이크, 백본 추출 규칙 중 하나라도 미잠금.</p></li>
<li><p><strong>사후조정</strong>: 후보 간선 집합을 결과를 보고 변경, <span class="math inline">\(d_0\)</span> 또는 <span class="math inline">\(g_{ij}\)</span> 정의 변경, 문턱 선택 규칙 변경, 백본 선택 규칙 변경.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-48">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 목 후보 간선 <span class="math inline">\(\mathcal{E}_{\mathrm{th}}=\mathcal{E}_c\)</span>, 간격 정의 <span class="math inline">\(g_{ij}=\max(0,d_{ij}-d_0)\)</span>, 열린 간선 규칙 <span class="math inline">\(g_{ij}\le g\)</span>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 임계 문턱 <span class="math inline">\(g_c\)</span> 계산(Union-Find) 및 <span class="math inline">\(\delta_{\mathrm{eff}}:=g_c\)</span> 정의, 백본 추출 알고리즘(결정 순서 포함)을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 스패닝 실패는 <code>FAIL-PERC-NOSPAN</code>; 절차 미잠금은 <code>INCONCLUSIVE</code>; 사후조정은 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 의미/단위/셀 기하 충돌은 G-SYM에서 <code>FAIL</code>; lock_id 혼합은 G-LOCK에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 산출물 봉인(manifest/checksums/registry_snapshot) 미충족 시 G-REP에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
</ul>
<h2 data-number="12.6" id="soc-퍼콜레이션과-증폭-a"><span class="header-section-number">12.6</span> 10.3 SOC 퍼콜레이션과 증폭 <span class="math inline">\(A\)</span></h2>
<h3 data-number="12.6.1" id="목적-7"><span class="header-section-number">12.6.1</span> 10.3.1 목적</h3>
<p>본 절은 (i) 퍼콜레이션(임계목) 구조 위에서 SOC(자기조직 임계) 이벤트를 운영 정의로 고정하고, (ii) SOC 이벤트의 전역 전달이 경로에 집중되는 정도를 <strong>증폭 계수 <span class="math inline">\(A\)</span></strong>로 정의하며, (iii) <span class="math inline">\(A\)</span>의 추정기(estimators)와 (iv) <span class="math inline">\(A\)</span>가 결론 자격을 갖기 위한 Gate(정상상태/핀닝/로버스트성)를 고정한다.
본 절의 <span class="math inline">\(A\)</span>는 외부 텍스트의 정당화 없이, 임계목 그래프/백본/이벤트 로그로부터 계산되는 관측량이다.</p>
<h3 data-number="12.6.2" id="입력lock-임계목-그래프-백본-이벤트-로그"><span class="header-section-number">12.6.2</span> 10.3.2 입력(LOCK): 임계목 그래프, 백본, 이벤트 로그</h3>
<p>본 절은 10.2의 산출물이 <code>PASS</code>로 자격화되어 입력으로 주어진다고 둔다.</p>
<ol>
<li><p>임계 문턱 및 유효 임계목:
<span class="math display">\[\delta_{\mathrm{eff}}:=g_c,
  \label{eq:S10_03_deltaeff_in}\]</span></p></li>
<li><p>임계 열린 그래프:
<span class="math display">\[\mathcal{G}_{\mathrm{open}}(g_c)=(\mathcal{V},\mathcal{E}_{\mathrm{open}}(g_c)),
  \label{eq:S10_03_Gopen_in}\]</span></p></li>
<li><p>백본(두-단말 기여 간선 집합):
<span class="math display">\[\mathcal{E}_{\mathrm{bb}}\subseteq \mathcal{E}_{\mathrm{open}}(g_c),
  \qquad
  \mathcal{V}_{\mathrm{bb}} \ \text{(백본 노드 집합)}.
  \label{eq:S10_03_backbone_in}\]</span></p></li>
</ol>
<p>또한 SOC 이벤트를 정의하기 위해 사건 로그 <span class="math inline">\(\mathcal{E}\)</span>가 잠긴 스키마로 제공되어야 한다(9장 정의 참조). SOC 이벤트는 사건 로그의 부분집합으로 정의되므로, 로그 누락은 정의 불능이다.</p>
<h3 data-number="12.6.3" id="soc-이벤트의-운영-정의"><span class="header-section-number">12.6.3</span> 10.3.3 SOC 이벤트의 운영 정의</h3>
<p>SOC 이벤트는 “연쇄적인 국소 갱신이 시간 창 내에서 연결되어 하나의 눈사태(avalanch)로 집계되는 사건 묶음”으로 정의한다. 본 절은 SOC 이벤트를 다음 절차로 정의한다.</p>
<h4 data-number="12.6.3.1" id="사건-집합과-이벤트-그래프"><span class="header-section-number">12.6.3.1</span> 10.3.3.1 사건 집합과 이벤트 그래프</h4>
<p>틱 축에서 사건 집합을 <span class="math inline">\(\mathcal{E}\)</span>로 두고, 각 사건 <span class="math inline">\(e\)</span>는 다음 필드를 가진다고 둔다.
<span class="math display">\[e \mapsto \bigl(n(e),\ \mathcal{V}(e)\bigr),
\label{eq:S10_03_event_fields}\]</span>
여기서 <span class="math inline">\(n(e)\)</span>는 틱, <span class="math inline">\(\mathcal{V}(e)\)</span>는 사건에 관여한 노드(또는 VP) 집합이다. <span class="math inline">\(\mathcal{V}(e)\)</span>의 의미(임계목 노드인지, 코어 노드인지)는 <code>analysis_lock</code>에 잠겨야 한다.</p>
<p>두 사건 <span class="math inline">\(e,e'\)</span>가 동일 SOC 군집에 속하는지 판정하기 위해 “이벤트 인접성”을 정의한다. 시간 문턱 <span class="math inline">\(\Delta n_{\mathrm{soc}}\in\mathbb{Z}_{\ge 0}\)</span>와 공간 문턱(노드-교집합 규약) <span class="math inline">\(\tau_{\mathrm{soc}}\in\mathbb{Z}_{\ge 1}\)</span>를 잠근다.
<span class="math display">\[\Delta n_{\mathrm{soc}}\ \text{(잠김)},
\qquad
\tau_{\mathrm{soc}}\ \text{(잠김)}.
\label{eq:S10_03_soc_thresholds}\]</span>
이벤트 인접성 판정 함수를 다음으로 정의한다.
<span class="math display">\[\mathrm{Adj}_{\mathrm{soc}}(e,e')
:=
\begin{cases}
1,&amp; |n(e)-n(e')|\le \Delta n_{\mathrm{soc}}\ \wedge\ |\mathcal{V}(e)\cap \mathcal{V}(e')|\ge \tau_{\mathrm{soc}},\\
0,&amp; \text{otherwise}.
\end{cases}
\label{eq:S10_03_soc_adj}\]</span>
<span class="math inline">\(\mathrm{Adj}_{\mathrm{soc}}\)</span>의 정의는 결과를 본 뒤 교체될 수 없다.</p>
<p>이벤트 그래프를 다음으로 정의한다.
<span class="math display">\[\mathcal{G}_{\mathrm{soc}}:=(\mathcal{E},\mathcal{E}_{\mathrm{soc}}),
\qquad
\mathcal{E}_{\mathrm{soc}}:=\{(e,e')\mid e\neq e',\ \mathrm{Adj}_{\mathrm{soc}}(e,e')=1\}.
\label{eq:S10_03_Gsoc}\]</span></p>
<h4 data-number="12.6.3.2" id="soc-군집눈사태-정의"><span class="header-section-number">12.6.3.2</span> 10.3.3.2 SOC 군집(눈사태) 정의</h4>
<p>SOC 군집(눈사태) <span class="math inline">\(C\)</span>는 이벤트 그래프 <span class="math inline">\(\mathcal{G}_{\mathrm{soc}}\)</span>의 연결 성분으로 정의한다.
<span class="math display">\[\mathcal{C}_{\mathrm{soc}}:=\{\text{$\mathcal{G}_{\mathrm{soc}}$의 연결 성분들}\},
\qquad
C\in\mathcal{C}_{\mathrm{soc}}.
\label{eq:S10_03_clusters}\]</span>
각 군집의 크기(사건 수)와 지속시간을 다음으로 정의한다.
<span class="math display">\[S(C):=|C|,
\qquad
T(C):=\bigl(\max_{e\in C}n(e)-\min_{e\in C}n(e)+1\bigr)\Delta t.
\label{eq:S10_03_cluster_size_duration}\]</span>
여기서 <span class="math inline">\(\Delta t\)</span>는 <code>realization_lock</code>에 잠긴 실현 시간 틱이며, <span class="math inline">\(\Delta t\)</span>가 정의 불능이면 <span class="math inline">\(T(C)\)</span>는 틱 단위로만 기록한다.</p>
<h3 data-number="12.6.4" id="플럭스-집중증폭-관측량의-정의-준비"><span class="header-section-number">12.6.4</span> 10.3.4 플럭스-집중(증폭) 관측량의 정의 준비</h3>
<p>증폭 <span class="math inline">\(A\)</span>는 “SOC 군집이 임계목 네트워크에서 백본에 얼마나 집중되는가”를 정량화하는 스칼라로 정의한다. 이를 위해 군집 <span class="math inline">\(C\)</span>의 “활성 노드 집합”을 정의한다.</p>
<h4 data-number="12.6.4.1" id="군집-활성-노드-집합"><span class="header-section-number">12.6.4.1</span> 10.3.4.1 군집 활성 노드 집합</h4>
<p>군집 <span class="math inline">\(C\)</span>의 활성 노드 집합을 다음으로 정의한다.
<span class="math display">\[\mathcal{V}_C
:=
\bigcup_{e\in C}\mathcal{V}(e).
\label{eq:S10_03_active_nodes}\]</span>
<span class="math inline">\(\mathcal{V}(e)\)</span>가 노드가 아닌 다른 객체를 가리키는 경우(예: 간선, 목), <span class="math inline">\(\mathcal{V}_C\)</span>의 정의는 해당 객체의 노드 귀속 사상으로 변환되어야 하며, 그 사상은 <code>analysis_lock</code>에 잠겨야 한다.</p>
<h4 data-number="12.6.4.2" id="군집의-백본-점유율집중도-비율"><span class="header-section-number">12.6.4.2</span> 10.3.4.2 군집의 백본 점유율(집중도 비율)</h4>
<p>군집 <span class="math inline">\(C\)</span>에 대해 백본 점유율을 다음으로 정의한다.
<span class="math display">\[p_{\mathrm{bb}}(C)
:=
\frac{|\mathcal{V}_C\cap \mathcal{V}_{\mathrm{bb}}|}{|\mathcal{V}_C|},
\qquad
\text{단, }|\mathcal{V}_C|&gt;0.
\label{eq:S10_03_pbb}\]</span>
정의상 <span class="math inline">\(0\le p_{\mathrm{bb}}(C)\le 1\)</span>이다.</p>
<p>또한 임계목 네트워크의 “기하적 백본 비율”(기준 비율)을 다음으로 정의한다.
<span class="math display">\[p_{\mathrm{bb}}^{(0)}
:=
\frac{|\mathcal{V}_{\mathrm{bb}}|}{|\mathcal{V}|}.
\label{eq:S10_03_pbb0}\]</span>
<span class="math inline">\(p_{\mathrm{bb}}^{(0)}\)</span>는 백본이 전체 노드에서 차지하는 비율로, 집중도 비교의 기준량으로 사용된다.</p>
<h3 data-number="12.6.5" id="증폭-a의-정의정의-결과형"><span class="header-section-number">12.6.5</span> 10.3.5 증폭 <span class="math inline">\(A\)</span>의 정의(정의-결과형)</h3>
<h4 data-number="12.6.5.1" id="군집별-증폭-정의"><span class="header-section-number">12.6.5.1</span> 10.3.5.1 군집별 증폭 정의</h4>
<p>군집 <span class="math inline">\(C\)</span>의 증폭을 다음으로 정의한다.
<span class="math display">\[A(C)
:=
\frac{p_{\mathrm{bb}}(C)}{p_{\mathrm{bb}}^{(0)}}.
\label{eq:S10_03_A_of_C}\]</span>
정의 <a data-reference="eq:S10_03_A_of_C" data-reference-type="eqref" href="#eq:S10_03_A_of_C">[eq:S10_03_A_of_C]</a>는 “백본 점유율이 기준 비율에 비해 몇 배로 증폭되었는가”를 뜻하는 순수 비율 정의이며, 외부 정당화를 사용하지 않는다.
정의상 <span class="math inline">\(p_{\mathrm{bb}}^{(0)}&gt;0\)</span>이어야 하며, <span class="math inline">\(p_{\mathrm{bb}}^{(0)}=0\)</span>이면 백본이 비어 있으므로 <span class="math inline">\(A\)</span>는 정의 불능이다.</p>
<h4 data-number="12.6.5.2" id="창-집계-증폭-정의"><span class="header-section-number">12.6.5.2</span> 10.3.5.2 창 집계 증폭 정의</h4>
<p>시간 창(또는 샘플 집합)에서 SOC 군집 집합을 <span class="math inline">\(\mathcal{C}_{\mathrm{soc}}\)</span>로 두고, 집계 증폭을 다음 두 추정기 중 하나로 잠근다(택일 잠금).</p>
<ol>
<li><p><strong>평균형 추정기</strong>:
<span class="math display">\[A_{\mathrm{mean}}
  :=
  \frac{1}{|\mathcal{C}_{\mathrm{soc}}|}
  \sum_{C\in\mathcal{C}_{\mathrm{soc}}} A(C),
  \qquad (|\mathcal{C}_{\mathrm{soc}}|&gt;0).
  \label{eq:S10_03_Amean}\]</span></p></li>
<li><p><strong>가중 평균형 추정기(사건 수 가중)</strong>:
<span class="math display">\[A_{\mathrm{w}}
  :=
  \frac{\sum_{C\in\mathcal{C}_{\mathrm{soc}}} S(C)\,A(C)}{\sum_{C\in\mathcal{C}_{\mathrm{soc}}} S(C)},
  \qquad \left(\sum_{C}S(C)&gt;0\right).
  \label{eq:S10_03_Aw}\]</span></p></li>
</ol>
<p>어느 추정기를 채택하는지(그리고 <span class="math inline">\(S(C)\)</span> 외의 가중을 허용하는지)는 <code>analysis_lock</code>에 잠겨야 하며, 결과를 본 뒤 교체될 수 없다.
본 절에서 “증폭 계수 <span class="math inline">\(A\)</span>”는 선택된 추정기 출력(예: <span class="math inline">\(A_{\mathrm{mean}}\)</span> 또는 <span class="math inline">\(A_{\mathrm{w}}\)</span>)으로 정의한다.</p>
<h3 data-number="12.6.6" id="정상상태-gateg-ss-stat"><span class="header-section-number">12.6.6</span> 10.3.6 정상상태 Gate(<span class="math inline">\(G\)</span>-SS-STAT)</h3>
<p>증폭 <span class="math inline">\(A\)</span>는 정상상태(steady-state) 구간에서만 결론 자격을 갖는다. 정상상태 Gate는 다음 절차로 정의한다.</p>
<h4 data-number="12.6.6.1" id="워밍업-구간과-관측-구간-잠금"><span class="header-section-number">12.6.6.1</span> 10.3.6.1 워밍업 구간과 관측 구간 잠금</h4>
<p>전체 실행 틱 길이를 <span class="math inline">\(N_{\mathrm{tot}}\)</span>로 두고, 워밍업 길이 <span class="math inline">\(N_{\mathrm{warm}}\)</span>과 관측 길이 <span class="math inline">\(N_{\mathrm{obs}}\)</span>를 다음으로 잠근다.
<span class="math display">\[N_{\mathrm{warm}}\in\mathbb{Z}_{\ge 0}\ \text{(잠김)},
\qquad
N_{\mathrm{obs}}\in\mathbb{Z}_{&gt;0}\ \text{(잠김)},
\qquad
N_{\mathrm{warm}}+N_{\mathrm{obs}}\le N_{\mathrm{tot}}.
\label{eq:S10_03_warm_obs}\]</span>
관측 구간은
<span class="math display">\[W_{\mathrm{obs}}:=W[N_{\mathrm{warm}},\,N_{\mathrm{warm}}+N_{\mathrm{obs}}).
\label{eq:S10_03_Wobs}\]</span>
로 정의한다.</p>
<h4 data-number="12.6.6.2" id="정상상태-판정-지표"><span class="header-section-number">12.6.6.2</span> 10.3.6.2 정상상태 판정 지표</h4>
<p>관측 구간을 <span class="math inline">\(M\)</span>개의 블록으로 균등 분할한다. 블록 수 <span class="math inline">\(M\)</span>을 잠근다.
<span class="math display">\[M\in\mathbb{Z}_{\ge 2}\ \text{(잠김)},
\qquad
W_{\mathrm{obs}}=\dot\cup_{m=1}^{M} W_m.
\label{eq:S10_03_block_split}\]</span>
각 블록에서 증폭 추정치 <span class="math inline">\(A_m\)</span>을 계산한다(동일 추정기 사용). 블록 평균과 분산을 다음으로 정의한다.
<span class="math display">\[\overline{A}:=\frac{1}{M}\sum_{m=1}^{M}A_m,
\qquad
\sigma_A^2:=\frac{1}{M}\sum_{m=1}^{M}(A_m-\overline{A})^2,
\qquad
\sigma_A:=\sqrt{\sigma_A^2}.
\label{eq:S10_03_A_block_stats}\]</span>
정상상태 문턱 <span class="math inline">\(\varepsilon_{\mathrm{SS}}&gt;0\)</span>를 <code>gate_lock</code>에 잠근다. 정상상태 Gate를 다음으로 정의한다.
<span class="math display">\[\texttt{G-SS-STAT}=\texttt{PASS}
\Longleftrightarrow
\frac{\sigma_A}{\overline{A}}\le \varepsilon_{\mathrm{SS}}.
\label{eq:S10_03_gate_SS}\]</span>
<span class="math inline">\(\overline{A}=0\)</span>이면 정상상태 판정은 정의 불능(<code>INCONCLUSIVE</code>)이다.</p>
<h3 data-number="12.6.7" id="핀닝-gateg-ss-pin"><span class="header-section-number">12.6.7</span> 10.3.7 핀닝 Gate(<span class="math inline">\(G\)</span>-SS-PIN)</h3>
<p>SOC 퍼콜레이션에서 “핀닝(pinning)”은 이벤트가 백본 또는 특정 국소 영역에 고정되어 전역적 SOC가 붕괴하는 현상을 의미하며, 본 절은 이를 운영 지표로 정의한다.</p>
<h4 data-number="12.6.7.1" id="핀닝-지표"><span class="header-section-number">12.6.7.1</span> 10.3.7.1 핀닝 지표</h4>
<p>관측 구간 <span class="math inline">\(W_{\mathrm{obs}}\)</span>에서 활성 노드들의 방문 빈도(히트 수)를 다음으로 정의한다.
<span class="math display">\[H(v):=\sum_{e\in \mathcal{E}(W_{\mathrm{obs}})} \mathbf{1}_{\{v\in \mathcal{V}(e)\}},
\qquad v\in\mathcal{V},
\label{eq:S10_03_hitcount}\]</span>
여기서 <span class="math inline">\(\mathcal{E}(W_{\mathrm{obs}})\)</span>는 관측 구간 안의 사건 집합이며, <span class="math inline">\(\mathbf{1}\)</span>은 지시함수이다.
정규화된 히트 분포를 다음으로 정의한다.
<span class="math display">\[p(v):=\frac{H(v)}{\sum_{u\in\mathcal{V}}H(u)}.
\label{eq:S10_03_pv}\]</span>
핀닝 지표를 다음으로 정의한다.
<span class="math display">\[P_{\max}:=\max_{v\in\mathcal{V}} p(v).
\label{eq:S10_03_Pmax}\]</span>
<span class="math inline">\(P_{\max}\)</span>는 하나의 노드에 이벤트가 과도하게 집중되는 정도를 나타내는 운영 지표이다.</p>
<h4 data-number="12.6.7.2" id="핀닝-gate-정의"><span class="header-section-number">12.6.7.2</span> 10.3.7.2 핀닝 Gate 정의</h4>
<p>핀닝 문턱 <span class="math inline">\(P_{\mathrm{pin}}\in(0,1)\)</span>을 <code>gate_lock</code>에 잠근다. 핀닝 Gate를 다음으로 정의한다.
<span class="math display">\[\texttt{G-SS-PIN}=\texttt{PASS}
\Longleftrightarrow
P_{\max}\le P_{\mathrm{pin}}.
\label{eq:S10_03_gate_PIN}\]</span>
<code>G-SS-PIN</code>=<code>FAIL</code>이면 해당 관측 구간은 핀닝으로 분류되며, <span class="math inline">\(A\)</span>는 SOC 증폭의 결론으로 사용할 수 없다(CT-LIM만 허용).</p>
<h3 data-number="12.6.8" id="로버스트-gateg-ss-robust"><span class="header-section-number">12.6.8</span> 10.3.8 로버스트 Gate(<span class="math inline">\(G\)</span>-SS-ROBUST)</h3>
<p>증폭 <span class="math inline">\(A\)</span>는 추정기의 사전 등록된 변화(재실행 세트) 하에서 일관되어야 한다. 로버스트성은 다음으로 정의한다.</p>
<h4 data-number="12.6.8.1" id="재실행-세트"><span class="header-section-number">12.6.8.1</span> 10.3.8.1 재실행 세트</h4>
<p>재실행 세트를 다음으로 잠근다.
<span class="math display">\[\mathcal{R}_{A}:=\{r_1,r_2,\ldots,r_K\},
\qquad
K\in\mathbb{Z}_{\ge 2}\ \text{(잠김)}.
\label{eq:S10_03_RA_set}\]</span>
각 <span class="math inline">\(r_k\)</span>는 동일 입력에서 다음 중 하나를 의미한다(어느 방식을 쓰는지는 <code>analysis_lock</code>에 잠김).</p>
<ol>
<li><p>다른 관측 구간 분할(<span class="math inline">\(W_{\mathrm{obs}}\)</span>의 블록 분할 변화).</p></li>
<li><p>동일 데이터의 재계산(동일 코드/환경, 동일 스냅샷).</p></li>
<li><p>사전 등록된 하위 샘플링(예: 고정된 subsample 규칙).</p></li>
</ol>
<h4 data-number="12.6.8.2" id="로버스트-판정-지표"><span class="header-section-number">12.6.8.2</span> 10.3.8.2 로버스트 판정 지표</h4>
<p>재실행 <span class="math inline">\(r_k\)</span>에서의 증폭 추정치를 <span class="math inline">\(A^{(k)}\)</span>로 두고, 상대 변동 폭을 다음으로 정의한다.
<span class="math display">\[A_{\min}:=\min_{1\le k\le K}A^{(k)},
\qquad
A_{\max}:=\max_{1\le k\le K}A^{(k)},
\qquad
R_A:=\frac{A_{\max}-A_{\min}}{\max(A_{\min},\varepsilon_A)}.
\label{eq:S10_03_RA_metric}\]</span>
여기서 <span class="math inline">\(\varepsilon_A&gt;0\)</span>는 분모 보호 상수로 <code>analysis_lock</code>에 잠긴다.</p>
<p>로버스트 문턱 <span class="math inline">\(\varepsilon_{\mathrm{ROB}}&gt;0\)</span>를 <code>gate_lock</code>에 잠근다. 로버스트 Gate를 다음으로 정의한다.
<span class="math display">\[\texttt{G-SS-ROBUST}=\texttt{PASS}
\Longleftrightarrow
R_A\le \varepsilon_{\mathrm{ROB}}.
\label{eq:S10_03_gate_ROB}\]</span>
재실행 세트가 잠기지 않았으면 <code>G-SS-ROBUST</code>는 <code>INCONCLUSIVE</code>이다.</p>
<h3 data-number="12.6.9" id="최종-gate-스택과-결론-자격"><span class="header-section-number">12.6.9</span> 10.3.9 최종 Gate 스택과 결론 자격</h3>
<p>본 절에서 증폭 <span class="math inline">\(A\)</span>가 결론 자격을 갖기 위한 최종 Gate는 다음으로 정의한다.
<span class="math display">\[\texttt{G-AMP-A}=\texttt{PASS}
\Longleftrightarrow
(\chi_c=1)\ \wedge\
(\texttt{G-SS-STAT}=\texttt{PASS})\ \wedge\
(\texttt{G-SS-PIN}=\texttt{PASS})\ \wedge\
(\texttt{G-SS-ROBUST}\in\{\texttt{PASS},\texttt{INCONCLUSIVE}\}).
\label{eq:S10_03_gate_final}\]</span>
즉, 로버스트성은 잠긴 경우에는 <code>PASS</code>를 요구하고, 잠기지 않은 경우에는 <code>INCONCLUSIVE</code>로 남길 수 있으나, 그 경우 “로버스트성을 통과했다”는 문장은 금지된다(PASS.rules로 제한).</p>
<h3 data-number="12.6.10" id="로그필수-기록-규격-1"><span class="header-section-number">12.6.10</span> 10.3.10 로그(필수 기록) 규격</h3>
<p><span class="math inline">\(A\)</span>의 산출과 Gate 판정은 다음 로그를 필수로 가진다(형식은 <code>protocol_lock</code>에 잠김).</p>
<ol>
<li><p><code>inputs</code>: <span class="math inline">\(\delta_{\mathrm{eff}}\)</span>, <span class="math inline">\(\mathcal{G}_{\mathrm{open}}(g_c)\)</span>, <span class="math inline">\(\mathcal{E}_{\mathrm{bb}}\)</span>, <span class="math inline">\(\mathcal{V}_{\mathrm{bb}}\)</span>, <code>lock_refs</code>.</p></li>
<li><p><code>soc_params</code>: <span class="math inline">\(\Delta n_{\mathrm{soc}},\tau_{\mathrm{soc}}\)</span> 및 이벤트 인접성 규약.</p></li>
<li><p><code>clusters</code>: 각 군집 <span class="math inline">\(C\)</span>의 <span class="math inline">\((S(C),T(C),p_{\mathrm{bb}}(C),A(C))\)</span> 요약.</p></li>
<li><p><code>A_estimator</code>: 선택된 추정기 ID(<code>Amean</code> 또는 <code>Aw</code>) 및 결과 <span class="math inline">\(A\)</span>.</p></li>
<li><p><code>steady_state</code>: 블록별 <span class="math inline">\(A_m\)</span>, <span class="math inline">\(\overline{A}\)</span>, <span class="math inline">\(\sigma_A\)</span>, <span class="math inline">\(\varepsilon_{\mathrm{SS}}\)</span>, Gate 판정.</p></li>
<li><p><code>pinning</code>: <span class="math inline">\(P_{\max}\)</span>, <span class="math inline">\(P_{\mathrm{pin}}\)</span>, Gate 판정.</p></li>
<li><p><code>robust</code>: <span class="math inline">\(A^{(k)}\)</span>, <span class="math inline">\(R_A\)</span>, <span class="math inline">\(\varepsilon_{\mathrm{ROB}}\)</span>, Gate 판정.</p></li>
<li><p><code>verdict</code>: <code>G-AMP-A</code> 최종 판정 및 FAIL 라벨 목록.</p></li>
</ol>
<p>로그가 봉인(manifest/checksums)되지 않으면 결론 자격이 부여되지 않는다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-49">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: SOC 이벤트 인접성(<span class="math inline">\(\Delta n_{\mathrm{soc}},\tau_{\mathrm{soc}}\)</span>), 군집 정의(연결 성분), 활성 노드 집합 <span class="math inline">\(\mathcal{V}_C\)</span>, 백본 점유율 <span class="math inline">\(p_{\mathrm{bb}}(C)\)</span>, 증폭 정의 <span class="math inline">\(A(C)=p_{\mathrm{bb}}(C)/p_{\mathrm{bb}}^{(0)}\)</span> 및 추정기(<span class="math inline">\(A_{\mathrm{mean}}\)</span> 또는 <span class="math inline">\(A_{\mathrm{w}}\)</span>)를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 정상상태 Gate(<code>G-SS-STAT</code>), 핀닝 Gate(<code>G-SS-PIN</code>), 로버스트 Gate(<code>G-SS-ROBUST</code>)의 문턱(<span class="math inline">\(\varepsilon_{\mathrm{SS}},P_{\mathrm{pin}},\varepsilon_{\mathrm{ROB}}\)</span>)을 <code>gate_lock</code>에 고정.</p></li>
<li><p>Gate: <span class="math inline">\(\chi_c=0\)</span> 레짐에서는 <code>G-AMP-A</code>가 즉시 <code>FAIL</code>; 핀닝 또는 정상상태 실패는 <code>FAIL-AMP-*</code> 라벨로 처리.</p></li>
<li><p>Gate: 사후조정(문턱/추정기 교체, SOC 인접성 교체, 백본 규약 교체)은 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 산출 로그 봉인(manifest/checksums/registry_snapshot) 미충족 시 G-REP에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
</ul>
<h2 data-number="12.7" id="수치실험-패키지2d목3d재밍soc핀닝"><span class="header-section-number">12.7</span> 10.4 수치실험 패키지(2D목/3D재밍/SOC핀닝)</h2>
<h3 data-number="12.7.1" id="목적-8"><span class="header-section-number">12.7.1</span> 10.4.1 목적</h3>
<p>본 절은 10장(전파/퍼콜레이션/<span class="math inline">\(c\)</span>/증폭 <span class="math inline">\(A\)</span>)의 모든 산출물이 <strong>재현 가능한 수치실험 패키지</strong>로 봉인되도록, (i) 재현 규약, (ii) 파일 산출물 목록, (iii) manifest/checksums/registry_snapshot 체계를 고정한다.
본 절은 계산 결과를 제시하지 않으며, 오직 “어떤 파일이 어떤 역할로 어떤 규약에 따라 생성되고 봉인되는가”를 정의한다.</p>
<h3 data-number="12.7.2" id="재현-규약필수-고정-항목"><span class="header-section-number">12.7.2</span> 10.4.2 재현 규약(필수 고정 항목)</h3>
<p>수치실험 패키지는 다음 항목들이 <strong>동일 lock_id 조합</strong>으로 고정되어 있을 때만 재현으로 인정된다.</p>
<ol>
<li><p><strong>레지스트리 고정</strong>: <code>canon_lock_id</code>, <code>realization_lock_id</code>, <code>analysis_lock_id</code>, <code>gate_lock_id</code>, <code>protocol_lock_id</code>.</p></li>
<li><p><strong>레짐 고정</strong>: <code>regime_id</code> 및 레짐 좌표축 값(차원/구동/스패닝/병목/초기조건/관측축).</p></li>
<li><p><strong>도메인/경계 고정</strong>: 도메인 <span class="math inline">\(\mathcal{D}\)</span>, 경계 집합 <span class="math inline">\(\partial\mathcal{D}^{\pm}\)</span>, 경계 노드 집합 <span class="math inline">\(\mathcal{V}^{\pm}\)</span> 정의 및 구현 규약.</p></li>
<li><p><strong>그래프 고정</strong>: 접촉 판정, 후보 간선 집합, 간격 <span class="math inline">\(g_{ij}\)</span> 정의(기준 길이 <span class="math inline">\(d_0\)</span> 포함), 간선 정렬 키.</p></li>
<li><p><strong>프로브 고정</strong>: 등방 압축 프로브 <span class="math inline">\(\varepsilon\)</span> 샘플, 드리프트 프로브 <span class="math inline">\(u\)</span> 샘플, 곡률 추정식, 종료 조건.</p></li>
<li><p><strong>SOC 고정</strong>: 이벤트 인접성(<span class="math inline">\(\Delta n_{\mathrm{soc}},\tau_{\mathrm{soc}}\)</span>), 군집 정의, 증폭 추정기 선택, 정상상태/핀닝/로버스트 Gate 문턱.</p></li>
<li><p><strong>실행 환경 고정</strong>: 실행 파일 해시, 라이브러리 버전, 난수 사용 여부(본 절의 패키지는 기본적으로 난수 미사용), OS/아키텍처 요약.</p></li>
</ol>
<p>위 항목 중 하나라도 누락되면 재현은 성립하지 않으며, 결과는 결론 자격을 갖지 못한다.</p>
<h3 data-number="12.7.3" id="패키지-구성상위-트리"><span class="header-section-number">12.7.3</span> 10.4.3 패키지 구성(상위 트리)</h3>
<p>수치실험 패키지 루트를 <code>exp10/</code>으로 두고, 다음 디렉터리 트리를 고정한다.</p>
<pre><code>exp10/
  registry/
    canon_lock.(yaml|json)
    realization_lock.(yaml|json)
    analysis_lock.(yaml|json)
    gate_lock.(yaml|json)
    protocol_lock.(yaml|json)
    registry_snapshot/   (동결본; snapshot 시 채움)
  configs/
    regime.yaml
    domain.yaml
    probes.yaml
    soc.yaml
    thresholds.yaml
  inputs/
    geometry/
    graphs/
    events/
  scripts/
    run_2d_throat.(py|sh)
    run_3d_jamming.(py|sh)
    run_soc_pinning.(py|sh)
    compute_deltaeff.(py|sh)
    compute_backbone.(py|sh)
    compute_A.(py|sh)
    compute_B_rho_c.(py|sh)
    utils/
  outputs/
    2d_throat/
    3d_jamming/
    soc_pinning/
    derived/
    gates/
  snapshot/
    manifest.(json|yaml|csv)
    checksums.(txt|json)
    release_tag.(txt|json)
    registry_snapshot/   (registry/의 동결본 전체)</code></pre>
<p>각 디렉터리는 역할이 고정되며, 동일 역할 파일을 다른 위치에 중복 생성하는 것을 금지한다.</p>
<h3 data-number="12.7.4" id="실험-1-2d-목임계목-패키지"><span class="header-section-number">12.7.4</span> 10.4.4 실험 1: 2D 목(임계목) 패키지</h3>
<p>본 실험은 2차원 도메인에서 목(throat) 간격 분포 및 <span class="math inline">\(\delta_{\mathrm{eff}}\)</span> 계산 절차를 재현하기 위한 패키지이다.</p>
<h4 data-number="12.7.4.1" id="입력-파일2d"><span class="header-section-number">12.7.4.1</span> 10.4.4.1 입력 파일(2D)</h4>
<ol>
<li><p><code>configs/regime.yaml</code>: <code>DIM-2</code> 레짐 좌표축 값.</p></li>
<li><p><code>configs/domain.yaml</code>: 2D 도메인 크기/경계/노드 생성 규약.</p></li>
<li><p><code>configs/thresholds.yaml</code>: <span class="math inline">\(d_0,\gamma_c\)</span> 및 퍼콜레이션/백본 관련 문턱.</p></li>
<li><p><code>inputs/geometry/nodes2d.csv</code>: <span class="math inline">\((i,x_i,y_i)\)</span>.</p></li>
<li><p><code>inputs/graphs/edges2d.edgelist</code>: 후보 간선(접촉 그래프).</p></li>
</ol>
<p>위 파일들은 생성 규약이 <code>analysis_lock</code>에 잠겨 있어야 하며, 결과를 본 뒤 수정될 수 없다.</p>
<h4 data-number="12.7.4.2" id="산출-파일2d"><span class="header-section-number">12.7.4.2</span> 10.4.4.2 산출 파일(2D)</h4>
<ol>
<li><p><code>outputs/2d_throat/gaps2d.csv</code>: <span class="math inline">\((i,j,d_{ij},g_{ij})\)</span>.</p></li>
<li><p><code>outputs/2d_throat/gc2d.txt</code>: <span class="math inline">\(g_c\)</span> 값(임계 문턱).</p></li>
<li><p><code>outputs/2d_throat/deltaeff2d.txt</code>: <span class="math inline">\(\delta_{\mathrm{eff}}\)</span> 값(정의: <span class="math inline">\(g_c\)</span>).</p></li>
<li><p><code>outputs/2d_throat/Gopen2d.edgelist</code>: <span class="math inline">\(\mathcal{E}_{\mathrm{open}}(g_c)\)</span>.</p></li>
<li><p><code>outputs/2d_throat/backbone2d.edgelist</code>: <span class="math inline">\(\mathcal{E}_{\mathrm{bb}}\)</span>.</p></li>
<li><p><code>outputs/2d_throat/report_perc2d.json</code>: 퍼콜레이션/Gate 보고서.</p></li>
</ol>
<h3 data-number="12.7.5" id="실험-2-3d-재밍-패키지스위치-chi_c-및-c-프로브"><span class="header-section-number">12.7.5</span> 10.4.5 실험 2: 3D 재밍 패키지(스위치 <span class="math inline">\(\chi_c\)</span> 및 <span class="math inline">\(c\)</span> 프로브)</h3>
<p>본 실험은 3차원에서 재밍 격자/Point-J/강성 스위치 및 <span class="math inline">\(B_{\mathrm{eff}}\)</span>, <span class="math inline">\(\rho_{\mathrm{eff}}\)</span>, <span class="math inline">\(\tilde{c}\)</span>의 프로브 기반 정의를 재현하기 위한 패키지이다.</p>
<h4 data-number="12.7.5.1" id="입력-파일3d"><span class="header-section-number">12.7.5.1</span> 10.4.5.1 입력 파일(3D)</h4>
<ol>
<li><p><code>configs/regime.yaml</code>: <code>DIM-3</code> 레짐 좌표축 값 및 스위치 문턱 <span class="math inline">\(\kappa_{\mathrm{ST}}\)</span>.</p></li>
<li><p><code>configs/domain.yaml</code>: 3D 도메인 크기/경계/경계 노드 판정 규약.</p></li>
<li><p><code>configs/probes.yaml</code>: 등방 압축 샘플 <span class="math inline">\(\{\varepsilon_j\}\)</span>, 드리프트 샘플 <span class="math inline">\(\{u_j\}\)</span>, 곡률 추정식 선택.</p></li>
<li><p><code>inputs/geometry/nodes3d.csv</code>: <span class="math inline">\((i,x_i,y_i,z_i)\)</span>.</p></li>
<li><p><code>inputs/graphs/edges3d.edgelist</code>: 접촉 그래프 간선.</p></li>
</ol>
<h4 data-number="12.7.5.2" id="산출-파일3d"><span class="header-section-number">12.7.5.2</span> 10.4.5.2 산출 파일(3D)</h4>
<ol>
<li><p><code>outputs/3d_jamming/switch.json</code>: <span class="math inline">\(\chi_{\mathrm{span}},\kappa_{\min},\chi_{\mathrm{ST}}(=\chi_c)\)</span> 및 판정 로그.</p></li>
<li><p><code>outputs/3d_jamming/Wiso.csv</code>: <span class="math inline">\((\varepsilon,\eta(\varepsilon),W_{\mathrm{iso}})\)</span>.</p></li>
<li><p><code>outputs/3d_jamming/Wdrift.csv</code>: <span class="math inline">\((u,W_{\mathrm{drift}})\)</span>.</p></li>
<li><p><code>outputs/3d_jamming/Beff.txt</code>: <span class="math inline">\(B_{\mathrm{eff}}\)</span> 추정치 및 추정식 ID.</p></li>
<li><p><code>outputs/3d_jamming/rhoeff.txt</code>: <span class="math inline">\(\rho_{\mathrm{eff}}\)</span> 추정치 및 추정식 ID.</p></li>
<li><p><code>outputs/3d_jamming/ctilde.txt</code>: <span class="math inline">\(\tilde{c}\)</span> 값.</p></li>
<li><p><code>outputs/3d_jamming/c.txt</code>: <span class="math inline">\(c=(a/\Delta t)\tilde{c}\)</span> 값(실현 참조 포함).</p></li>
<li><p><code>outputs/3d_jamming/report_c.json</code>: <span class="math inline">\(c\)</span> 관련 Gate 보고서(스위치/양의성/수치 안정/잠금 무결성).</p></li>
</ol>
<h3 data-number="12.7.6" id="실험-3-soc-핀닝-패키지군집-증폭-a-gate"><span class="header-section-number">12.7.6</span> 10.4.6 실험 3: SOC 핀닝 패키지(군집, 증폭 <span class="math inline">\(A\)</span>, Gate)</h3>
<p>본 실험은 임계목 그래프/백본 위에서 SOC 군집을 정의하고 증폭 <span class="math inline">\(A\)</span>를 추정하며, 정상상태/핀닝/로버스트 Gate로 결론 자격을 판정하는 패키지이다.</p>
<h4 data-number="12.7.6.1" id="입력-파일soc"><span class="header-section-number">12.7.6.1</span> 10.4.6.1 입력 파일(SOC)</h4>
<ol>
<li><p><code>configs/soc.yaml</code>: <span class="math inline">\(\Delta n_{\mathrm{soc}},\tau_{\mathrm{soc}}\)</span>, 군집 정의(연결 성분), 추정기 선택(<code>Amean</code> 또는 <code>Aw</code>).</p></li>
<li><p><code>configs/thresholds.yaml</code>: <span class="math inline">\(\varepsilon_{\mathrm{SS}},P_{\mathrm{pin}},\varepsilon_{\mathrm{ROB}}\)</span>, 블록 수 <span class="math inline">\(M\)</span>, 재실행 세트 <span class="math inline">\(\mathcal{R}_A\)</span> 구성 규약.</p></li>
<li><p><code>inputs/events/events.csv</code>: 사건 로그(틱, 참여 노드 집합 등; 스키마는 <code>protocol_lock</code>에 잠김).</p></li>
<li><p><code>inputs/graphs/Gopen.edgelist</code>: 임계 열린 그래프.</p></li>
<li><p><code>inputs/graphs/backbone.edgelist</code>: 백본 간선.</p></li>
</ol>
<h4 data-number="12.7.6.2" id="산출-파일soc"><span class="header-section-number">12.7.6.2</span> 10.4.6.2 산출 파일(SOC)</h4>
<ol>
<li><p><code>outputs/soc_pinning/clusters.json</code>: 군집 목록과 각 군집의 <span class="math inline">\((S,T,p_{\mathrm{bb}},A(C))\)</span>.</p></li>
<li><p><code>outputs/soc_pinning/A.txt</code>: 선택된 추정기 출력 <span class="math inline">\(A\)</span>.</p></li>
<li><p><code>outputs/soc_pinning/steady.json</code>: 블록별 <span class="math inline">\(A_m\)</span>, <span class="math inline">\(\overline{A}\)</span>, <span class="math inline">\(\sigma_A/\overline{A}\)</span> 및 Gate 판정.</p></li>
<li><p><code>outputs/soc_pinning/pinning.json</code>: <span class="math inline">\(P_{\max}\)</span> 및 Gate 판정.</p></li>
<li><p><code>outputs/soc_pinning/robust.json</code>: 재실행 <span class="math inline">\(A^{(k)}\)</span>, <span class="math inline">\(R_A\)</span> 및 Gate 판정.</p></li>
<li><p><code>outputs/soc_pinning/report_A.json</code>: 최종 Gate <code>G-AMP-A</code> 판정 및 FAIL 라벨.</p></li>
</ol>
<h3 data-number="12.7.7" id="manifest산출물-목록-규약"><span class="header-section-number">12.7.7</span> 10.4.7 manifest(산출물 목록) 규약</h3>
<p><code>snapshot/manifest</code>는 패키지에 포함된 모든 파일을 다음 필드로 열거한 목록이다(형식은 JSON/YAML/CSV 중 하나로 잠김).</p>
<ol>
<li><p><strong>path</strong>: 상대경로.</p></li>
<li><p><strong>role</strong>: <code>registry</code>, <code>config</code>, <code>input</code>, <code>script</code>, <code>output</code>, <code>gate_report</code>, <code>figure</code>, <code>table</code> 중 하나.</p></li>
<li><p><strong>producer</strong>: <code>manual</code> 또는 <code>script:&lt;name&gt;</code> 형태.</p></li>
<li><p><strong>lock_refs</strong>: 참조한 lock_id 조합.</p></li>
<li><p><strong>regime_id</strong>: 해당 파일이 속한 레짐.</p></li>
<li><p><strong>depends_on</strong>: 입력 파일 경로 리스트.</p></li>
<li><p><strong>hash_ref</strong>: checksums 항목 참조 키.</p></li>
<li><p><strong>bytes</strong>: 파일 크기.</p></li>
</ol>
<p>manifest는 누락/중복/치환을 즉시 탐지하는 기준점이며, 결과를 본 뒤 수정될 수 없다.</p>
<h3 data-number="12.7.8" id="checksums체크섬-규약"><span class="header-section-number">12.7.8</span> 10.4.8 checksums(체크섬) 규약</h3>
<p><code>snapshot/checksums</code>는 번들의 모든 파일에 대한 내용 동일성 해시 목록이다. 다음 규약을 고정한다.</p>
<ol>
<li><p>기본 알고리즘: <code>sha256</code> (필수).</p></li>
<li><p>대상: <code>exp10/</code> 하위 모든 파일(예외가 있으면 <code>checksum_exclusions</code> 파일로 따로 잠기고, 그 파일도 해시에 포함).</p></li>
<li><p>표기: 한 줄에 “해시값 공백 파일경로” 또는 JSON 키-값(형식은 <code>protocol_lock</code>에 잠김).</p></li>
<li><p>교차참조: manifest의 <code>hash_ref</code>는 checksums 항목과 1:1로 대응.</p></li>
</ol>
<p>checksums가 없거나 불일치하면 재현 Gate는 <code>FAIL</code>/<code>INCONCLUSIVE</code>이다.</p>
<h3 data-number="12.7.9" id="registry_snapshot레지스트리-동결본-규약"><span class="header-section-number">12.7.9</span> 10.4.9 registry_snapshot(레지스트리 동결본) 규약</h3>
<p><code>snapshot/registry_snapshot/</code>은 해당 릴리즈에서 사용된 레지스트리(5종 lock)의 동결본이다. 동결본은 다음 원칙으로 고정한다.</p>
<ol>
<li><p>레지스트리 파일은 수정이 아니라 복사로만 스냅샷에 들어간다.</p></li>
<li><p>스냅샷은 <code>manifest</code>와 <code>checksums</code>에 포함되어 봉인된다.</p></li>
<li><p>스냅샷이 없는 결과는 근거를 복원할 수 없으므로 결론 자격이 부여되지 않는다.</p></li>
</ol>
<h3 data-number="12.7.10" id="최종-봉인-조건결론-자격의-필요조건"><span class="header-section-number">12.7.10</span> 10.4.10 최종 봉인 조건(결론 자격의 필요조건)</h3>
<p>본 절의 패키지에서 생성된 모든 수치 결과(<span class="math inline">\(\delta_{\mathrm{eff}}\)</span>, 백본, <span class="math inline">\(A\)</span>, <span class="math inline">\(\chi_c\)</span>, <span class="math inline">\(B_{\mathrm{eff}}\)</span>, <span class="math inline">\(\rho_{\mathrm{eff}}\)</span>, <span class="math inline">\(\tilde{c}\)</span>, <span class="math inline">\(c\)</span>)는 다음을 만족할 때만 결론 자격을 가진다.</p>
<ol>
<li><p><code>snapshot/manifest</code> 존재 및 완결.</p></li>
<li><p><code>snapshot/checksums</code> 존재 및 모든 파일 해시 일치.</p></li>
<li><p><code>snapshot/registry_snapshot</code> 존재 및 lock_id 조합 일치.</p></li>
<li><p>Gate 보고서(<code>outputs/.../report_*.json</code>)가 봉인되었고 최종 판정이 <code>PASS</code>.</p></li>
</ol>
<p>위 조건이 충족되지 않으면 결과는 <code>INCONCLUSIVE</code> 또는 <code>FAIL</code>로 판정되며, 이후 절에서 근거로 사용할 수 없다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-50">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 패키지 트리, 파일 역할(role), manifest 필드, checksums 알고리즘 및 대상 범위를 <code>protocol_lock</code>에 고정.</p></li>
<li><p>LOCK: 2D 목/3D 재밍/SOC 핀닝의 입력/산출 파일 목록과 생성 스크립트 ID를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 봉인(manifest/checksums/registry_snapshot) 미충족은 G-REP에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
<li><p>Gate: 파일 치환/누락/사후 수정 탐지는 G-LOCK/G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 최종 결론은 각 실험의 Gate 보고서 <code>PASS</code>를 필요조건으로 가짐(PASS.rules 연결).</p></li>
</ul>
<h2 data-number="12.8" id="격자-마찰과-적색편이전파-중-에너지-소산"><span class="header-section-number">12.8</span> 10.8 격자 마찰과 적색편이(전파 중 에너지 소산)</h2>
<h3 data-number="12.8.1" id="운영-가설-속도-c는-유지되나-주파수에너지는-누적-감쇠"><span class="header-section-number">12.8.1</span> 10.8.1 운영 가설: 속도 <span class="math inline">\(c\)</span>는 유지되나 주파수(에너지)는 누적 감쇠</h3>
<p>본 문서에서 광속 <span class="math inline">\(c\)</span>는 10장에서 정의된 전파 스위치/퍼콜레이션/백본/증폭 <span class="math inline">\(A\)</span>를 통해 <em>구현</em>된다.
이 구현이 “공간이 완전한 공백”임을 뜻하지는 않는다.
공간이 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 격자로 채워진 매질(Plenum)이라면, 전파 속도는 일정하게 유지되더라도 장거리 전파 과정에서 미세한 에너지 소산이 누적될 수 있다.
본 절에서는 이를 “격자 마찰(lattice friction)”로 호출하고, <em>관측량 수준의 운영 방정식</em>으로만 고정한다.</p>
<h3 data-number="12.8.2" id="적색편이-방정식과-거리적색편이-사상핵심"><span class="header-section-number">12.8.2</span> 10.8.2 적색편이 방정식과 거리–적색편이 사상(핵심)</h3>
<p>광자의 주파수 <span class="math inline">\(\nu(x)\)</span>가 경로 길이 <span class="math inline">\(x\)</span>에 따라 감쇠한다고 가정하고,
<span class="math display">\[\frac{d\nu}{dx}=-\kappa\,\nu,
\qquad
\kappa&gt;0,
\label{eq:S10_08_dnudx}\]</span>
로 <strong>정의</strong>한다. 이때 해는
<span class="math display">\[\nu(x)=\nu_{\mathrm{em}}\,e^{-\kappa x},
\qquad
\nu_{\mathrm{obs}}=\nu_{\mathrm{em}}\,e^{-\kappa D},
\label{eq:S10_08_nu_solution}\]</span>
이다. 관측 적색편이를
<span class="math display">\[1+z:=\frac{\nu_{\mathrm{em}}}{\nu_{\mathrm{obs}}}
=\frac{\lambda_{\mathrm{obs}}}{\lambda_{\mathrm{em}}}
\label{eq:S10_08_z_def}\]</span>
로 정의하면,
<span class="math display">\[1+z=e^{\kappa D},
\qquad
D(z)=\frac{1}{\kappa}\ln(1+z)
\label{eq:S10_08_D_of_z}\]</span>
를 얻는다. <span class="math inline">\(z\ll 1\)</span>에서는 <span class="math inline">\(z\simeq \kappa D\)</span>로 선형 근사된다.</p>
<h4 data-number="12.8.2.1" id="주의-d의-의미와-관측-거리d_ld_a와의-구분"><span class="header-section-number">12.8.2.1</span> (주의) <span class="math inline">\(D\)</span>의 의미와 관측 거리(<span class="math inline">\(D_L,D_A\)</span>)와의 구분</h4>
<p>본 절에서 <span class="math inline">\(D\)</span>는 광선의 <em>유효 경로 길이(geometric path length)</em>로 정의된다.
이는 관측에서 자주 사용하는 <em>광도거리</em> <span class="math inline">\(D_L\)</span> 또는 <em>각지름거리</em> <span class="math inline">\(D_A\)</span>와 동일하다고 가정되지 않는다.
따라서 <a data-reference="eq:S10_08_D_of_z" data-reference-type="eqref" href="#eq:S10_08_D_of_z">[eq:S10_08_D_of_z]</a>를 플럭스/각크기 자료와 비교하여 “우주론적 거리”로 사용하려면,
E-COSMO 레짐(17.2.5)에서 <span class="math inline">\(D\mapsto(D_L,D_A)\)</span> 매핑 규약을 <strong>별도의 LOCK</strong>으로 고정해야 한다.
해당 매핑이 잠기지 않은 상태에서 <a data-reference="eq:S10_08_D_of_z" data-reference-type="eqref" href="#eq:S10_08_D_of_z">[eq:S10_08_D_of_z]</a>를 관측 거리로 동일시하는 결론은 <code>INCONCLUSIVE</code>로 둔다.</p>
<h4 data-number="12.8.2.2" id="추정-규약-kappa의-추정고정"><span class="header-section-number">12.8.2.2</span> (추정 규약) <span class="math inline">\(\kappa\)</span>의 추정/고정</h4>
<p><a data-reference="eq:S10_08_D_of_z" data-reference-type="eqref" href="#eq:S10_08_D_of_z">[eq:S10_08_D_of_z]</a>를 거리 사상으로 사용하려면 <span class="math inline">\(\kappa\)</span>를 <strong>LOCK</strong>해야 한다.
예를 들어 <span class="math inline">\((D_i,z_i)\)</span> 데이터(또는 시뮬레이션 로그)로부터
<span class="math display">\[\kappa_i:=\frac{1}{D_i}\ln(1+z_i),
\label{eq:S10_08_kappa_i}\]</span>
를 계산하고, 사전등록된 집계 규칙(평균/중앙값/가중 최소제곱 등)에 의해 하나의 <span class="math inline">\(\kappa\)</span>를 산출한다.
결과를 본 뒤 <span class="math inline">\(\kappa\)</span> 또는 집계 규칙을 바꾸는 행위는 금지한다.</p>
<h4 data-number="12.8.2.3" id="격자-스텝-모델-ell_mathrmrot-단위-충돌과의-연결"><span class="header-section-number">12.8.2.3</span> (격자 스텝 모델) <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>-단위 충돌과의 연결</h4>
<p>한 스텝 길이를 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>로 두고, 스텝당 상대 주파수 손실률을 <span class="math inline">\(\varepsilon\in(0,1)\)</span>로 정의하면,
<span class="math inline">\(N=D/\ell_{\mathrm{rot}}\)</span> 스텝 후
<span class="math display">\[\nu_{\mathrm{obs}}=\nu_{\mathrm{em}}(1-\varepsilon)^N
=\nu_{\mathrm{em}}\exp\!\left(\frac{D}{\ell_{\mathrm{rot}}}\ln(1-\varepsilon)\right)
\label{eq:S10_08_step_model}\]</span>
이므로,
<span class="math display">\[\kappa
=
-\frac{1}{\ell_{\mathrm{rot}}}\ln(1-\varepsilon)
\simeq
\frac{\varepsilon}{\ell_{\mathrm{rot}}}
\quad(\varepsilon\ll 1)
\label{eq:S10_08_kappa_eps}\]</span>
가 된다. 따라서 <a data-reference="eq:S10_08_D_of_z" data-reference-type="eqref" href="#eq:S10_08_D_of_z">[eq:S10_08_D_of_z]</a>는 <span class="math inline">\((\kappa)\)</span> 또는 <span class="math inline">\((\ell_{\mathrm{rot}},\varepsilon)\)</span>를 <strong>잠김 입력</strong>으로 받아 <em>거리</em>를 산출하는 계산 모듈로 바꿔 쓸 수 있다.</p>
<h3 data-number="12.8.3" id="gate-비분산achromatic-선-이동과-스펙트럼-보존"><span class="header-section-number">12.8.3</span> 10.8.3 Gate: 비분산(achromatic) 선 이동과 스펙트럼 보존</h3>
<p>관측 적색편이의 최소 요구는 <em>선 스펙트럼 전체가 동일 비율로 이동</em>한다는 점이다.
이를 위해 주파수별 유효 감쇠율을
<span class="math display">\[\kappa_{\mathrm{eff}}(\nu)
:=
\frac{1}{D}\ln\!\left(\frac{\nu_{\mathrm{em}}(\nu)}{\nu_{\mathrm{obs}}(\nu)}\right)
=
\frac{1}{D}\ln(1+z(\nu))
\label{eq:S10_08_kappa_eff}\]</span>
로 정의하고, 사전등록된 라인 집합 <span class="math inline">\(\{\nu_a\}\)</span>에 대해
<span class="math display">\[\mathrm{PASS}_{z\text{-achr}}
:\Longleftrightarrow
\max_{a,b}\frac{\left|\kappa_{\mathrm{eff}}(\nu_a)-\kappa_{\mathrm{eff}}(\nu_b)\right|}
{\overline{\kappa}_{\mathrm{eff}}}
\le \epsilon_{\mathrm{achr}}^{\star}
\quad
(\epsilon_{\mathrm{achr}}^{\star}&gt;0\ \text{사전등록})
\label{eq:S10_08_pass_achr}\]</span>
를 Gate로 둔다.
이 Gate를 통과하지 못하면 <a data-reference="eq:S10_08_D_of_z" data-reference-type="eqref" href="#eq:S10_08_D_of_z">[eq:S10_08_D_of_z]</a>의 “거리 사상” 사용은 <code>FAIL</code>이다.</p>
<h3 data-number="12.8.4" id="gate-세기-감쇠소광와의-분리"><span class="header-section-number">12.8.4</span> 10.8.4 Gate: 세기 감쇠(소광)와의 분리</h3>
<p>“단파장(청색)의 조기 소멸”과 같은 <em>세기 감쇠</em>를 함께 도입하려면,
이는 <a data-reference="eq:S10_08_dnudx" data-reference-type="eqref" href="#eq:S10_08_dnudx">[eq:S10_08_dnudx]</a>와 <strong>분리된</strong> 감쇠항으로 명시해야 한다. 예를 들어
<span class="math display">\[\frac{dI}{dx}=-\alpha(\nu)\,I
\label{eq:S10_08_dIdx}\]</span>
를 추가하고, 스펙트럼 왜곡(선폭 증가, 색 지수 변화, 영상 블러링 등)이 Gate로 판정되도록 해야 한다.
<span class="math inline">\(\alpha(\nu)\)</span>의 형태/추정 절차가 LOCK되지 않으면 결론은 <code>INCONCLUSIVE</code>로 둔다.</p>
<h3 data-number="12.8.5" id="gate-에너지-보존소산-에너지의-종착"><span class="header-section-number">12.8.5</span> 10.8.5 Gate: 에너지 보존(소산 에너지의 종착)</h3>
<p><a data-reference="eq:S10_08_dnudx" data-reference-type="eqref" href="#eq:S10_08_dnudx">[eq:S10_08_dnudx]</a>는 광자 에너지 <span class="math inline">\(E=h\nu\)</span>의 감소를 의미한다.
따라서 감소한 에너지가 어디로 가는지(격자 열화, 배경복사로의 전이, 국소 재방출 등) <strong>종착 모델</strong>이 필요하다.
종착 모델이 누락되면 본 절의 적색편이-거리 사상은 <code>INCONCLUSIVE</code>로 판정한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-51">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(\kappa\)</span> 또는 <span class="math inline">\((\ell_{\mathrm{rot}},\varepsilon)\)</span>의 추정/고정 절차(데이터, 레짐, 추정량, 캘리브레이션/검증 분리)를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: <a data-reference="eq:S10_08_pass_achr" data-reference-type="eqref" href="#eq:S10_08_pass_achr">[eq:S10_08_pass_achr]</a> 불충족 시 <a data-reference="eq:S10_08_D_of_z" data-reference-type="eqref" href="#eq:S10_08_D_of_z">[eq:S10_08_D_of_z]</a>는 거리 사상으로 <code>FAIL</code>.</p></li>
<li><p>Gate: 세기 감쇠 <a data-reference="eq:S10_08_dIdx" data-reference-type="eqref" href="#eq:S10_08_dIdx">[eq:S10_08_dIdx]</a>를 사용하면 <span class="math inline">\(\alpha(\nu)\)</span>와 스펙트럼 보존 판정이 LOCK/Gate로 함께 고정되어야 하며, 누락 시 <code>INCONCLUSIVE</code>.</p></li>
<li><p>Gate: 소산 에너지 종착(에너지 보존) 모델 누락 시 <code>INCONCLUSIVE</code>.</p></li>
</ul>
<h1 data-number="13" id="단위-실현realization-adelta-tmathrmrcross"><span class="header-section-number">13</span> 11. 단위 실현(Realization): <span class="math inline">\(a,\Delta t,\mathrm{RCROSS}\)</span></h1>
<h2 class="unnumbered" id="목적단위-실현의-산출물">목적(단위 실현의 산출물)</h2>
<p>본 장은 내부 단위(무차원/내부 길이/내부 시간)로 기술된 세계를 실현 단위(길이/시간)로 <strong>봉인</strong>하는 절차를 고정한다. 본 장의 산출물은 다음 네 가지로 고정한다.</p>
<ol>
<li><p>실현 길이 스케일 <span class="math inline">\(a\)</span> (부피입자 지름) 및 그 값의 <code>realization_lock</code> 잠금.</p></li>
<li><p>실현 시간 틱 <span class="math inline">\(\Delta t\)</span> 및 그 값의 <code>realization_lock</code> 잠금.</p></li>
<li><p>운영 닻(anchors)의 정의(입력 채널, 기록 형식, 스코프).</p></li>
<li><p>교차검증 <span class="math inline">\(\mathrm{RCROSS}\)</span> 체계(다중 닻의 정합 Gate) 및 PASS/FAIL 판정.</p></li>
</ol>
<p>본 장은 실현값을 “맞추기 위한 조정”으로 취급하지 않는다. 실현값은 운영 닻과 사전 등록된 절차로부터 계산되어 봉인되는 결과이며, 결과를 본 뒤 바꾸는 행위는 금지된다.</p>
<h2 class="unnumbered" id="option-b-선언실현-철학">Option-B 선언(실현 철학)</h2>
<p>본 장은 단위 실현의 철학을 <strong>Option-B</strong>로 고정한다. Option-B는 다음 선언으로 구성된다.</p>
<ol>
<li><p>내부 계산(격자/사건/전파)에서 발생하는 무차원 또는 내부 단위 결과는 <strong>그 자체로</strong> 잠긴 관계식(비율/불변량)으로 보존한다.</p></li>
<li><p>실현 단위로의 변환은 “운영 닻”을 통해 수행하며, 닻은 사전 등록된 채널과 기록 규약을 가진다.</p></li>
<li><p>실현값(<span class="math inline">\(a,\Delta t\)</span>)은 단일 닻이 아니라 <strong>교차검증(RCROSS)</strong>을 통해 자가정합이 확인된 경우에만 결론 자격을 갖는다.</p></li>
</ol>
<p>Option-B의 핵심은 “하나의 기준점에 의존하는 실현”을 금지하고, 최소 두 개 이상의 독립 채널을 <strong>교차정합</strong>으로 엮어 No-Tuning을 구조적으로 구현하는 데 있다.</p>
<h2 class="unnumbered" id="운영-닻anchors의-선언입력의-지위">운영 닻(Anchors)의 선언(입력의 지위)</h2>
<p>운영 닻은 실현 사상에서 사용되는 기준 채널이며, 다음 성질을 갖는다.</p>
<ol>
<li><p>닻은 <strong>입력</strong>이다: 닻은 유도 결과가 아니라 실현의 기준이며, 닻의 선택/해석/기록은 <code>analysis_lock</code>과 <code>protocol_lock</code>에 잠긴다.</p></li>
<li><p>닻은 <strong>단일 출처</strong>다: 닻의 값과 기록은 <code>realization_lock</code>에 귀속되며, 본문 다른 위치에서 복제되지 않는다.</p></li>
<li><p>닻은 <strong>스코프</strong>를 가진다: 닻은 적용 레짐(관측/실험/채널)과 함께 잠기며, 스코프 밖에서 재사용되지 않는다.</p></li>
<li><p>닻은 <strong>사후 변경 불가</strong>다: 닻의 변경은 버전업으로만 허용되며, 변경 시 전면 재유도/전면 재검증이 요구된다.</p></li>
</ol>
<h2 class="unnumbered" id="교차검증-체계rcross의-선언">교차검증 체계(RCROSS)의 선언</h2>
<p><span class="math inline">\(\mathrm{RCROSS}\)</span>는 “두 개 이상의 독립 닻이 동일 실현값을 지지하는지”를 판정하는 Gate 스택으로 정의한다. RCROSS는 다음 요소로 구성된다.</p>
<ol>
<li><p>닻 채널 집합: <span class="math inline">\(\mathcal{A}=\{A_1,A_2,\ldots\}\)</span>.</p></li>
<li><p>채널별 실현값 후보: <span class="math inline">\((a^{(k)},\Delta t^{(k)})\)</span>.</p></li>
<li><p>비교 지표: <span class="math inline">\(\Pi\)</span>-형 지표(비율/차이/교차 불변량).</p></li>
<li><p>문턱값/허용오차: <span class="math inline">\(\varepsilon\)</span> 집합(사전 등록).</p></li>
<li><p>판정 출력: <code>PASS</code>/<code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
</ol>
<p>RCROSS는 “일치하면 참”이 아니라, “사전 등록된 조건을 충족했는가”만을 판정한다. RCROSS가 <code>PASS</code>하지 않으면 실현값은 결론 자격을 갖지 못한다.</p>
<h2 class="unnumbered" id="adelta-t의-잠금과-연결-선언"><span class="math inline">\(a,\Delta t\)</span>의 잠금과 연결 선언</h2>
<p>본 장에서 <span class="math inline">\(a\)</span>와 <span class="math inline">\(\Delta t\)</span>는 <code>realization_lock</code>의 핵심 항목으로 고정된다.
<span class="math display">\[a=\aVP,
\qquad
\Delta t=1.86\times 10^{-21}\ \mathrm{s}.
\label{eq:S11_values}\]</span>
위 값들은 본 장의 절차(운영 닻 + RCROSS)를 통과한 결과로 봉인되며, 다른 장에서 재추정/재보정하지 않는다. 실현값의 변경은 버전업으로만 허용되며, 변경 시 관련 모든 파생량(에너지, 질량, 힘, 전파 속도 등)은 전면 재계산/전면 재판정되어야 한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-52">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: Option-B 선언(실현 철학), 닻의 입력 지위, RCROSS 구성요소를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(a,\Delta t\)</span>의 의미(부피입자 지름, 실현 시간 틱)와 값(<a data-reference="eq:S11_values" data-reference-type="eqref" href="#eq:S11_values">[eq:S11_values]</a>)을 <code>realization_lock</code>에 고정.</p></li>
<li><p>Gate: RCROSS(<code>G-RCROSS</code>)가 <code>PASS</code>하지 않으면 실현값 결론 자격 부여 금지(PASS.rules 연결).</p></li>
<li><p>Gate: 닻/문턱/채널 구성의 사후 변경은 G-NT에서 <code>FAIL</code>; lock_id 혼합은 G-LOCK에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 실현 산출물(레지스트리/로그/보고서)이 <code>manifest+checksums</code>로 봉인되지 않으면 G-REP에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
</ul>
<h2 data-number="13.1" id="option-b-철학-c_mathrmref는-운영-닻"><span class="header-section-number">13.1</span> 11.1 Option-B 철학: <span class="math inline">\(c_{\mathrm{ref}}\)</span>는 운영 닻</h2>
<h3 data-number="13.1.1" id="목적-9"><span class="header-section-number">13.1.1</span> 11.1.1 목적</h3>
<p>본 절은 Option-B 단위 실현에서 <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 지위를 <strong>운영 닻(operational anchor)</strong>으로 고정하고, <span class="math inline">\(c_{\mathrm{ref}}\)</span>를 “예측 대상” 또는 “정당화 근거”로 사용하는 행위를 금지 규칙으로 고정한다.
본 절의 산출물은 (i) <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 의미(정의), (ii) <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 사용 자리, (iii) 금지되는 사용 방식과 위반 처리이다.</p>
<h3 data-number="13.1.2" id="정의-c_mathrmref의-의미-고정"><span class="header-section-number">13.1.2</span> 11.1.2 정의: <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 의미 고정</h3>
<h4 data-number="13.1.2.1" id="d-11.1-1-실현-사상길이시간"><span class="header-section-number">13.1.2.1</span> [D-11.1-1] 실현 사상(길이/시간)</h4>
<p>내부 좌표 <span class="math inline">\(\tilde{x},\tilde{t}\)</span>와 실현 좌표 <span class="math inline">\(x,t\)</span>의 관계를 다음으로 고정한다.
<span class="math display">\[x:=a\,\tilde{x},
\qquad
t:=\Delta t\,\tilde{t}.
\label{eq:S11_01_map}\]</span>
따라서 내부 속도 <span class="math inline">\(\tilde{v}\)</span>와 실현 속도 <span class="math inline">\(v\)</span>는
<span class="math display">\[v=\frac{dx}{dt}=\frac{a}{\Delta t}\,\tilde{v}
\label{eq:S11_01_vmap}\]</span>
로 연결된다.</p>
<h4 data-number="13.1.2.2" id="d-11.1-2-c_mathrmref"><span class="header-section-number">13.1.2.2</span> [D-11.1-2] <span class="math inline">\(c_{\mathrm{ref}}\)</span></h4>
<p><span class="math inline">\(c_{\mathrm{ref}}\)</span>는 실현 과정에서 사용되는 <strong>기준 속도 상수</strong>이며, 다음 의미로 정의한다.
<span class="math display">\[c_{\mathrm{ref}}
:= \text{실현 속도 단위 }(a/\Delta t)\text{를 고정하기 위해 사용하는 기준 채널의 값}.
\label{eq:S11_01_cref_def}\]</span>
즉, <span class="math inline">\(c_{\mathrm{ref}}\)</span>는 내부 전파 지표 <span class="math inline">\(\tilde{c}\)</span>의 유도 결과가 아니라, <span class="math inline">\(a\)</span>와 <span class="math inline">\(\Delta t\)</span>의 실현을 정하기 위한 기준이다. <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 차원은 길이/시간이며, 단위 표기는 <code>m/s</code>로 잠긴다.</p>
<h4 data-number="13.1.2.3" id="d-11.1-3-c_mathrmref의-저장-규약"><span class="header-section-number">13.1.2.3</span> [D-11.1-3] <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 저장 규약</h4>
<p><span class="math inline">\(c_{\mathrm{ref}}\)</span>는 다음 필드를 <code>realization_lock</code>에 함께 저장해야 한다.</p>
<ol>
<li><p><strong>value</strong>: <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 수치.</p></li>
<li><p><strong>unit</strong>: 단위(고정: <code>m/s</code>).</p></li>
<li><p><strong>channel_id</strong>: 기준 채널 식별자(어떤 운영 닻인지).</p></li>
<li><p><strong>scope</strong>: 적용 스코프(어떤 레짐/어떤 실험/어떤 기준선 조합에서 유효한지).</p></li>
<li><p><strong>protocol_ref</strong>: 측정/기록/전처리 규약(프로토콜 식별자).</p></li>
</ol>
<p>위 필드 중 하나라도 누락되면 <span class="math inline">\(c_{\mathrm{ref}}\)</span>는 “값만 있는 상수”가 되어 SSOT를 위반하므로 사용 불가이며, 모든 후속 실현 결과는 <code>INCONCLUSIVE</code> 또는 <code>FAIL</code>이다.</p>
<h3 data-number="13.1.3" id="option-b에서의-c_mathrmref-사용-자리정의된-자리"><span class="header-section-number">13.1.3</span> 11.1.3 Option-B에서의 <span class="math inline">\(c_{\mathrm{ref}}\)</span> 사용 자리(정의된 자리)</h3>
<p>Option-B는 <span class="math inline">\(c_{\mathrm{ref}}\)</span>를 다음 자리에서만 사용하도록 잠근다.</p>
<h4 data-number="13.1.3.1" id="실현-배율-고정-자리"><span class="header-section-number">13.1.3.1</span> 11.1.3.1 실현 배율 고정 자리</h4>
<p>실현 속도 배율을 다음으로 정의한다.
<span class="math display">\[\Lambda_v := \frac{a}{\Delta t}.
\label{eq:S11_01_Lv}\]</span>
Option-B에서 <span class="math inline">\(c_{\mathrm{ref}}\)</span>는 <span class="math inline">\(\Lambda_v\)</span>를 고정하기 위한 기준으로만 사용된다. 즉, 어떤 채널 <span class="math inline">\(A_k\)</span>가 제시하는 내부 속도 지표 <span class="math inline">\(\tilde{c}^{(k)}\)</span>가 있을 때, 실현 배율은 다음 관계로만 결정된다고 정의한다.
<span class="math display">\[\Lambda_v
:=\frac{c_{\mathrm{ref}}}{\tilde{c}^{(k)}},
\qquad
\text{(채널 $k$는 사전 등록된 닻이며, 교차검증으로 선택/판정됨)}.
\label{eq:S11_01_Lv_from_cref}\]</span>
<a data-reference="eq:S11_01_Lv_from_cref" data-reference-type="eqref" href="#eq:S11_01_Lv_from_cref">[eq:S11_01_Lv_from_cref]</a>는 “<span class="math inline">\(c_{\mathrm{ref}}\)</span>가 기준”이고 “내부 지표는 유도 결과”임을 반영한다.</p>
<h4 data-number="13.1.3.2" id="a와-delta-t의-실현-분해-자리"><span class="header-section-number">13.1.3.2</span> 11.1.3.2 <span class="math inline">\(a\)</span>와 <span class="math inline">\(\Delta t\)</span>의 실현 분해 자리</h4>
<p>Option-B는 <span class="math inline">\(\Lambda_v=a/\Delta t\)</span>만으로는 <span class="math inline">\(a\)</span>와 <span class="math inline">\(\Delta t\)</span>가 개별적으로 정해지지 않음을 전제로 하며, <span class="math inline">\(a\)</span>와 <span class="math inline">\(\Delta t\)</span>는 최소 두 개 이상의 독립 닻을 통해 분해되어야 한다. <span class="math inline">\(c_{\mathrm{ref}}\)</span>는 이 분해에서 <strong>하나의 닻 값</strong>으로만 사용되며, 다른 닻(예: 기준선 조합, RCROSS 채널)이 함께 필요하다. 따라서 <span class="math inline">\(c_{\mathrm{ref}}\)</span>는 <span class="math inline">\(a\)</span> 또는 <span class="math inline">\(\Delta t\)</span>를 단독으로 결정하지 않는다.</p>
<h3 data-number="13.1.4" id="금지-규칙-c_mathrmref를-예측-대상으로-쓰기-금지"><span class="header-section-number">13.1.4</span> 11.1.4 금지 규칙: <span class="math inline">\(c_{\mathrm{ref}}\)</span>를 예측 대상으로 쓰기 금지</h3>
<p>본 절은 <span class="math inline">\(c_{\mathrm{ref}}\)</span>를 “예측 대상”으로 사용하는 행위를 다음 조건으로 금지한다.</p>
<h4 data-number="13.1.4.1" id="금지의-정의"><span class="header-section-number">13.1.4.1</span> 11.1.4.1 금지의 정의</h4>
<p>다음 중 하나라도 수행되면 “<span class="math inline">\(c_{\mathrm{ref}}\)</span> 예측 사용”으로 판정하여 금지한다.</p>
<ol>
<li><p>내부 유도 결과 <span class="math inline">\(\tilde{c}\)</span> 또는 <span class="math inline">\(c\)</span>를 계산한 뒤, 그 값과 <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 일치를 근거로 이론을 정당화하는 문장.</p></li>
<li><p><span class="math inline">\(c_{\mathrm{ref}}\)</span>를 모르는 상태에서 <span class="math inline">\(c\)</span>를 산출한다고 서술하면서, 실제로는 <span class="math inline">\(a\)</span> 또는 <span class="math inline">\(\Delta t\)</span> 또는 채널 선택에 <span class="math inline">\(c_{\mathrm{ref}}\)</span>를 입력으로 사용한 경우.</p></li>
<li><p>RCROSS 실패를 회피하기 위해 <span class="math inline">\(c_{\mathrm{ref}}\)</span> 또는 닻 채널 정의를 사후 변경하는 경우.</p></li>
</ol>
<p>위 금지 규칙은 “문장 금지”가 아니라 “절차 금지”이며, 로그로 판정 가능해야 한다.</p>
<h4 data-number="13.1.4.2" id="허용되는-유일한-비교-자리대상-텍스트로서의-비교"><span class="header-section-number">13.1.4.2</span> 11.1.4.2 허용되는 유일한 비교 자리(대상 텍스트로서의 비교)</h4>
<p><span class="math inline">\(c_{\mathrm{ref}}\)</span>와 <span class="math inline">\(c\)</span>의 비교가 필요한 경우, 비교는 다음 자리에서만 허용된다.
<span class="math display">\[\text{비교는 Gate(교차정합 또는 재현)의 판정 지표로만 기록되며, 정당화 근거로 사용되지 않는다.}
\label{eq:S11_01_compare_rule}\]</span>
즉, 비교는 <code>PASS</code>/<code>FAIL</code>/<code>INCONCLUSIVE</code> 판정을 위해서만 사용되며, 비교 결과로 공리/정의/실현값을 소급 수정하는 행위는 금지된다.</p>
<h3 data-number="13.1.5" id="금지-규칙-c_mathrmref를-단독-닻으로-쓰기-금지"><span class="header-section-number">13.1.5</span> 11.1.5 금지 규칙: <span class="math inline">\(c_{\mathrm{ref}}\)</span>를 단독 닻으로 쓰기 금지</h3>
<p>Option-B는 <span class="math inline">\(c_{\mathrm{ref}}\)</span>를 단독 닻으로 사용하여 <span class="math inline">\((a,\Delta t)\)</span>를 결정하는 것을 금지한다. 금지 조건은 다음과 같다.
<span class="math display">\[\text{$c_{\mathrm{ref}}$만으로 $a$ 또는 $\Delta t$를 단독 결정하면 \texttt{FAIL-ANCHOR-SINGLE}.}
\label{eq:S11_01_single_anchor_ban}\]</span>
단독 결정은 다음 중 하나를 의미한다.</p>
<ol>
<li><p><span class="math inline">\(a\)</span>를 임의로 두고 <span class="math inline">\(\Delta t\)</span>를 <span class="math inline">\(c_{\mathrm{ref}}\)</span>로만 계산하여 봉인하는 경우(또는 그 반대).</p></li>
<li><p>교차채널 정합(RCROSS) 없이 단일 채널로 <span class="math inline">\((a,\Delta t)\)</span>를 동시에 결정하는 경우.</p></li>
</ol>
<p>따라서 본 장에서 실현값은 반드시 RCROSS를 포함하는 Gate 스택을 통과해야 한다.</p>
<h3 data-number="13.1.6" id="위반-시-처리fail-라벨"><span class="header-section-number">13.1.6</span> 11.1.6 위반 시 처리(FAIL 라벨)</h3>
<p>본 절의 금지 규칙 위반은 다음 FAIL 라벨로 처리한다.</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">라벨</th>
<th style="text-align: left;">의미</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">FAIL-CREF-PREDICT</td>
<td style="text-align: left;"><span class="math inline">\(c_{\mathrm{ref}}\)</span>를 예측 대상으로 사용(정당화/근거로 사용)</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-ANCHOR-SINGLE</td>
<td style="text-align: left;"><span class="math inline">\(c_{\mathrm{ref}}\)</span> 단독 닻으로 실현값 결정</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FAIL-CREF-RETRO</td>
<td style="text-align: left;">RCROSS/판정 실패 후 <span class="math inline">\(c_{\mathrm{ref}}\)</span> 또는 채널 정의 사후 변경</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-CREF-LOCK</td>
<td style="text-align: left;"><span class="math inline">\(c_{\mathrm{ref}}\)</span> 저장 필드 누락 또는 lock_id 혼합</td>
</tr>
</tbody>
</table>
</div>
<p>위 FAIL 라벨이 발생하면 해당 실현값(<span class="math inline">\(a,\Delta t\)</span>) 및 그에 의존하는 모든 파생량(에너지/질량/힘/<span class="math inline">\(c\)</span> 등)은 결론 자격을 상실하며, 의존성 그래프를 따라 연쇄적으로 결론 자격 상실이 전파된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-53">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 의미(운영 닻), 저장 필드(value/unit/channel_id/scope/protocol_ref) 및 사용 자리(<a data-reference="eq:S11_01_Lv_from_cref" data-reference-type="eqref" href="#eq:S11_01_Lv_from_cref">[eq:S11_01_Lv_from_cref]</a>)를 <code>realization_lock</code>/<code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(c_{\mathrm{ref}}\)</span> 비교는 Gate 판정 지표로만 허용(<a data-reference="eq:S11_01_compare_rule" data-reference-type="eqref" href="#eq:S11_01_compare_rule">[eq:S11_01_compare_rule]</a>)을 PASS.rules에 연결하여 고정.</p></li>
<li><p>Gate: 단독 닻 금지(<code>FAIL-ANCHOR-SINGLE</code>) 및 예측 사용 금지(<code>FAIL-CREF-PREDICT</code>) 라벨을 <code>gate_lock</code>에 고정.</p></li>
<li><p>Gate: 사후 변경(채널/문턱/정의) 탐지는 G-NT에서 <code>FAIL</code>; lock_id 혼합은 G-LOCK에서 <code>FAIL</code>.</p></li>
<li><p>Gate: RCROSS(<code>G-RCROSS</code>) <code>PASS</code>가 없는 실현값은 결론 자격 부여 금지(PASS.rules 연결).</p></li>
</ul>
<h2 data-number="13.2" id="alambda_mathrmrefn-유도rightarrow-avpm"><span class="header-section-number">13.2</span> 11.2 <span class="math inline">\(a=\lambda_{\mathrm{ref}}/N\)</span> 유도<span class="math inline">\(\rightarrow \aVPm\)</span></h2>
<h3 data-number="13.2.1" id="입력lock-lambda_mathrmref와-n"><span class="header-section-number">13.2.1</span> 11.2.1 입력(LOCK): <span class="math inline">\(\lambda_{\mathrm{ref}}\)</span>와 <span class="math inline">\(N\)</span></h3>
<h4 data-number="13.2.1.1" id="d-11.2-1-기준-길이-lambda_mathrmref"><span class="header-section-number">13.2.1.1</span> [D-11.2-1] 기준 길이 <span class="math inline">\(\lambda_{\mathrm{ref}}\)</span></h4>
<p><span class="math inline">\(\lambda_{\mathrm{ref}}\)</span>는 단위 실현에서 사용하는 기준 길이(운영 닻)로 정의한다. <span class="math inline">\(\lambda_{\mathrm{ref}}\)</span>는 다음 필드와 함께 <code>realization_lock</code>에 잠긴다: <code>value</code>, <code>unit</code>, <code>channel_id</code>, <code>scope</code>, <code>protocol_ref</code>.
본 절에서 사용할 잠금값은 다음으로 고정한다.
<span class="math display">\[\lambda_{\mathrm{ref}}
=
632.99121257859865746\ \mathrm{nm}.
\label{eq:S11_02_lref_nm}\]</span></p>
<h4 data-number="13.2.1.2" id="d-11.2-2-분할-정수-n"><span class="header-section-number">13.2.1.2</span> [D-11.2-2] 분할 정수 <span class="math inline">\(N\)</span></h4>
<p><span class="math inline">\(N\)</span>은 무차원 정수이며, 기준 길이 <span class="math inline">\(\lambda_{\mathrm{ref}}\)</span>를 동일 간격으로 <span class="math inline">\(N\)</span>등분하는 분할 수로 정의한다. <span class="math inline">\(N\)</span>은 <code>analysis_lock</code>에 잠기며, 결과를 본 뒤 변경할 수 없다.
본 절에서 사용할 잠금값은 다음으로 고정한다.
<span class="math display">\[N = 10^{12}.
\label{eq:S11_02_N_lock}\]</span></p>
<h3 data-number="13.2.2" id="정의-실현-길이-a-부피입자-지름"><span class="header-section-number">13.2.2</span> 11.2.2 정의: 실현 길이 <span class="math inline">\(a\)</span> (부피입자 지름)</h3>
<h4 data-number="13.2.2.1" id="d-11.2-3-a의-의미지름와-단위"><span class="header-section-number">13.2.2.1</span> [D-11.2-3] <span class="math inline">\(a\)</span>의 의미(지름)와 단위</h4>
<p><span class="math inline">\(a\)</span>는 부피입자(VP) 기본 지름으로 정의한다. <span class="math inline">\(a\)</span>의 기하 의미는 <code>diameter</code>로 잠기며, 반지름으로 재해석되지 않는다. <span class="math inline">\(a\)</span>의 차원은 길이(<code>L</code>)이고, 단위는 <code>m</code>로 잠긴다.</p>
<h4 data-number="13.2.2.2" id="d-11.2-4-분할-실현-규칙"><span class="header-section-number">13.2.2.2</span> [D-11.2-4] 분할 실현 규칙</h4>
<p>실현 길이 <span class="math inline">\(a\)</span>를 다음 분할 규칙으로 정의한다.
<span class="math display">\[a := \frac{\lambda_{\mathrm{ref}}}{N}.
\label{eq:S11_02_a_def}\]</span>
정의 <a data-reference="eq:S11_02_a_def" data-reference-type="eqref" href="#eq:S11_02_a_def">[eq:S11_02_a_def]</a>는 단위 실현의 규칙이며, <span class="math inline">\(\lambda_{\mathrm{ref}}\)</span>와 <span class="math inline">\(N\)</span>이 잠기지 않으면 <span class="math inline">\(a\)</span>는 정의 불능이다.</p>
<h3 data-number="13.2.3" id="단위-변환-lambda_mathrmref의-si-표현"><span class="header-section-number">13.2.3</span> 11.2.3 단위 변환: <span class="math inline">\(\lambda_{\mathrm{ref}}\)</span>의 SI 표현</h3>
<h4 data-number="13.2.3.1" id="d-11.2-5-나노미터-미터-변환"><span class="header-section-number">13.2.3.1</span> [D-11.2-5] 나노미터-미터 변환</h4>
<p>단위 변환 규칙을 다음으로 고정한다.
<span class="math display">\[1\ \mathrm{nm} = 10^{-9}\ \mathrm{m}.
\label{eq:S11_02_nm_to_m}\]</span></p>
<h4 data-number="13.2.3.2" id="d-11.2-6-lambda_mathrmref의-미터값"><span class="header-section-number">13.2.3.2</span> [D-11.2-6] <span class="math inline">\(\lambda_{\mathrm{ref}}\)</span>의 미터값</h4>
<p><a data-reference="eq:S11_02_lref_nm" data-reference-type="eqref" href="#eq:S11_02_lref_nm">[eq:S11_02_lref_nm]</a>과 <a data-reference="eq:S11_02_nm_to_m" data-reference-type="eqref" href="#eq:S11_02_nm_to_m">[eq:S11_02_nm_to_m]</a>로부터,
<span class="math display">\[\begin{aligned}
\lambda_{\mathrm{ref}}
&amp;= 632.99121257859865746\ \mathrm{nm}
\notag\\
&amp;= 632.99121257859865746\times 10^{-9}\ \mathrm{m}
\notag\\
&amp;= 6.3299121257859865746\times 10^{-7}\ \mathrm{m}.
\label{eq:S11_02_lref_m}\end{aligned}\]</span></p>
<h3 data-number="13.2.4" id="alambda_mathrmrefn-계산-전개"><span class="header-section-number">13.2.4</span> 11.2.4 <span class="math inline">\(a=\lambda_{\mathrm{ref}}/N\)</span> 계산 전개</h3>
<p>정의 <a data-reference="eq:S11_02_a_def" data-reference-type="eqref" href="#eq:S11_02_a_def">[eq:S11_02_a_def]</a>에 <a data-reference="eq:S11_02_lref_m" data-reference-type="eqref" href="#eq:S11_02_lref_m">[eq:S11_02_lref_m]</a>, <a data-reference="eq:S11_02_N_lock" data-reference-type="eqref" href="#eq:S11_02_N_lock">[eq:S11_02_N_lock]</a>을 대입한다.
<span class="math display">\[\begin{aligned}
a
&amp;=\frac{\lambda_{\mathrm{ref}}}{N}
=\frac{6.3299121257859865746\times 10^{-7}\ \mathrm{m}}{10^{12}}
\label{eq:S11_02_a_step1}
\\
&amp;=6.3299121257859865746\times 10^{-7}\times 10^{-12}\ \mathrm{m}
\label{eq:S11_02_a_step2}
\\
&amp;=6.3299121257859865746\times 10^{-19}\ \mathrm{m}.
\label{eq:S11_02_a_final}\end{aligned}\]</span>
따라서 실현 길이 <span class="math inline">\(a\)</span>는 다음으로 고정된다.
<span class="math display">\[\boxed{
a
=
6.3299121257859865746\times 10^{-19}\ \mathrm{m}
}
\qquad (\text{VP 지름}).
\label{eq:S11_02_a_box}\]</span></p>
<h3 data-number="13.2.5" id="파생-표현attometer-단위"><span class="header-section-number">13.2.5</span> 11.2.5 파생 표현(Attometer 단위)</h3>
<h4 data-number="13.2.5.1" id="d-11.2-7-attometer-변환"><span class="header-section-number">13.2.5.1</span> [D-11.2-7] Attometer 변환</h4>
<p>단위 변환 규칙을 다음으로 고정한다.
<span class="math display">\[1\ \mathrm{am} = 10^{-18}\ \mathrm{m}.
\label{eq:S11_02_am_to_m}\]</span></p>
<h4 data-number="13.2.5.2" id="d-11.2-8-a의-attometer-표현"><span class="header-section-number">13.2.5.2</span> [D-11.2-8] <span class="math inline">\(a\)</span>의 Attometer 표현</h4>
<p><a data-reference="eq:S11_02_a_final" data-reference-type="eqref" href="#eq:S11_02_a_final">[eq:S11_02_a_final]</a>과 <a data-reference="eq:S11_02_am_to_m" data-reference-type="eqref" href="#eq:S11_02_am_to_m">[eq:S11_02_am_to_m]</a>로부터,
<span class="math display">\[\begin{aligned}
a
&amp;=6.3299121257859865746\times 10^{-19}\ \mathrm{m}
\notag\\
&amp;=0.63299121257859865746\times 10^{-18}\ \mathrm{m}
\notag\\
&amp;=0.63299121257859865746\ \mathrm{am}.
\label{eq:S11_02_a_am}\end{aligned}\]</span></p>
<h3 data-number="13.2.6" id="a의-lock-위치레지스트리-항목"><span class="header-section-number">13.2.6</span> 11.2.6 <span class="math inline">\(a\)</span>의 LOCK 위치(레지스트리 항목)</h3>
<p><span class="math inline">\(a\)</span>는 <code>realization_lock</code>에 다음 항목으로 기록되어야 한다.</p>
<ol>
<li><p><strong>symbol</strong>: <code>a</code></p></li>
<li><p><strong>entity</strong>: <code>OBJ-VP</code>의 기본 지름</p></li>
<li><p><strong>geometry_meaning</strong>: <code>diameter</code></p></li>
<li><p><strong>dimension</strong>: <code>L</code></p></li>
<li><p><strong>unit</strong>: <code>m</code></p></li>
<li><p><strong>value</strong>: <a data-reference="eq:S11_02_a_box" data-reference-type="eqref" href="#eq:S11_02_a_box">[eq:S11_02_a_box]</a></p></li>
<li><p><strong>derived_from</strong>: <span class="math inline">\(\lambda_{\mathrm{ref}}\)</span> (<code>channel_id</code> 포함), <span class="math inline">\(N\)</span> (<code>analysis_lock</code> 항목명 포함)</p></li>
<li><p><strong>derivation_id</strong>: <code>DER-11-02-A</code></p></li>
</ol>
<p>또한 동일 릴리즈에서 <code>manifest</code>와 <code>checksums</code>에 의해 봉인되어야 하며, 봉인되지 않은 <span class="math inline">\(a\)</span>는 후속 장(에너지/질량/힘/<span class="math inline">\(c\)</span>)의 입력으로 사용할 수 없다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-54">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(\lambda_{\mathrm{ref}}\)</span> 값(<a data-reference="eq:S11_02_lref_nm" data-reference-type="eqref" href="#eq:S11_02_lref_nm">[eq:S11_02_lref_nm]</a>)과 <span class="math inline">\(N\)</span> 값(<a data-reference="eq:S11_02_N_lock" data-reference-type="eqref" href="#eq:S11_02_N_lock">[eq:S11_02_N_lock]</a>)을 각각 <code>realization_lock</code>/<code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(a:=\lambda_{\mathrm{ref}}/N\)</span> 정의(<a data-reference="eq:S11_02_a_def" data-reference-type="eqref" href="#eq:S11_02_a_def">[eq:S11_02_a_def]</a>) 및 계산 결과(<a data-reference="eq:S11_02_a_box" data-reference-type="eqref" href="#eq:S11_02_a_box">[eq:S11_02_a_box]</a>)를 <code>realization_lock</code>에 고정.</p></li>
<li><p>Gate: <span class="math inline">\(\lambda_{\mathrm{ref}}\)</span> 채널/스코프/프로토콜 미기록 또는 <span class="math inline">\(N\)</span> 미잠금은 G-LOCK에서 <code>INCONCLUSIVE</code>.</p></li>
<li><p>Gate: <span class="math inline">\(\lambda_{\mathrm{ref}}\)</span> 또는 <span class="math inline">\(N\)</span>의 사후 변경은 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 산출물(레지스트리/로그)이 <code>manifest+checksums</code>로 봉인되지 않으면 G-REP에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
</ul>
<h2 data-number="13.3" id="delta-tacdot-ac_mathrmref-유도rightarrow-1.86times-10-21mathrms"><span class="header-section-number">13.3</span> 11.3 <span class="math inline">\(\Delta t=(A\cdot a)/c_{\mathrm{ref}}\)</span> 유도<span class="math inline">\(\rightarrow 1.86\times 10^{-21}\,\mathrm{s}\)</span></h2>
<h3 data-number="13.3.1" id="입력lock-a-c_mathrmref-a"><span class="header-section-number">13.3.1</span> 11.3.1 입력(LOCK): <span class="math inline">\(a\)</span>, <span class="math inline">\(c_{\mathrm{ref}}\)</span>, <span class="math inline">\(A\)</span></h3>
<h4 data-number="13.3.1.1" id="d-11.3-1-실현-길이-a"><span class="header-section-number">13.3.1.1</span> [D-11.3-1] 실현 길이 <span class="math inline">\(a\)</span></h4>
<p><span class="math inline">\(a\)</span>는 부피입자(VP) 기본 <strong>지름</strong>으로 정의되며(<code>geometry_meaning</code>=<code>diameter</code>), 길이 차원(<code>L</code>)과 단위 <code>m</code>로 잠긴다. 본 절에서 사용할 잠금값은 다음과 같다.
<span class="math display">\[a
=
6.3299121257859865746\times 10^{-19}\ \mathrm{m}.
\label{eq:S11_03_a_lock}\]</span></p>
<h4 data-number="13.3.1.2" id="d-11.3-2-기준-속도-상수-c_mathrmref"><span class="header-section-number">13.3.1.2</span> [D-11.3-2] 기준 속도 상수 <span class="math inline">\(c_{\mathrm{ref}}\)</span></h4>
<p><span class="math inline">\(c_{\mathrm{ref}}\)</span>는 운영 닻(기준 채널)의 <strong>기준 속도 상수</strong>로 정의되며, 차원은 <code>L/T</code>, 단위는 <code>m/s</code>로 잠긴다. 본 절에서 사용할 잠금값은 다음과 같다.
<span class="math display">\[c_{\mathrm{ref}}
=
299\,792\,458\ \mathrm{m/s}.
\label{eq:S11_03_cref_lock}\]</span></p>
<h4 data-number="13.3.1.3" id="d-11.3-3-전파-증폭-계수-a"><span class="header-section-number">13.3.1.3</span> [D-11.3-3] 전파 증폭 계수 <span class="math inline">\(A\)</span></h4>
<p><span class="math inline">\(A\)</span>는 무차원(<code>dimensionless</code>)이며, “틱 1회에 대응하는 유효 전파 길이”가 기본 길이 <span class="math inline">\(a\)</span>의 몇 배로 집계되는지를 나타내는 계수로 정의한다. 본 절에서 사용할 잠금값은 다음과 같다.
<span class="math display">\[A
=
880918.97770344000000074873389538365909152024492565003100802687690543842580063599.
\label{eq:S11_03_A_lock}\]</span>
<span class="math inline">\(A\)</span>의 산출 절차(이벤트 정의, 전파 경로, 집계 창, 추정기)는 <code>analysis_lock</code>에 잠겨 있어야 하며, 결과를 본 뒤 변경될 수 없다.</p>
<h3 data-number="13.3.2" id="정의-유효-전파-길이-ell_mathrmeff"><span class="header-section-number">13.3.2</span> 11.3.2 정의: 유효 전파 길이 <span class="math inline">\(\ell_{\mathrm{eff}}\)</span></h3>
<p>틱 1회에 대응하는 유효 전파 길이를 다음으로 정의한다.
<span class="math display">\[\ell_{\mathrm{eff}} := A\cdot a.
\label{eq:S11_03_leff_def}\]</span>
정의 <a data-reference="eq:S11_03_leff_def" data-reference-type="eqref" href="#eq:S11_03_leff_def">[eq:S11_03_leff_def]</a>에서 <span class="math inline">\(A\)</span>는 무차원이므로 <span class="math inline">\(\ell_{\mathrm{eff}}\)</span>의 차원은 길이(<code>L</code>)이며 단위는 <code>m</code>이다.</p>
<h3 data-number="13.3.3" id="정의-delta-t-운영-닻-기반-시간-틱"><span class="header-section-number">13.3.3</span> 11.3.3 정의: <span class="math inline">\(\Delta t\)</span> (운영 닻 기반 시간 틱)</h3>
<p>기준 속도 상수 <span class="math inline">\(c_{\mathrm{ref}}\)</span>는 “틱 1회에 대응하는 유효 전파 길이”와 “틱 시간”의 비로 정의되는 운영량으로 고정한다.
<span class="math display">\[c_{\mathrm{ref}}
:=
\frac{\ell_{\mathrm{eff}}}{\Delta t}.
\label{eq:S11_03_cref_as_ratio}\]</span>
<a data-reference="eq:S11_03_cref_as_ratio" data-reference-type="eqref" href="#eq:S11_03_cref_as_ratio">[eq:S11_03_cref_as_ratio]</a>에 <a data-reference="eq:S11_03_leff_def" data-reference-type="eqref" href="#eq:S11_03_leff_def">[eq:S11_03_leff_def]</a>를 대입하면,
<span class="math display">\[c_{\mathrm{ref}}
=
\frac{A\cdot a}{\Delta t}.
\label{eq:S11_03_cref_sub}\]</span>
<a data-reference="eq:S11_03_cref_sub" data-reference-type="eqref" href="#eq:S11_03_cref_sub">[eq:S11_03_cref_sub]</a>을 <span class="math inline">\(\Delta t\)</span>에 대해 풀면,
<span class="math display">\[\boxed{
\Delta t
=
\frac{A\cdot a}{c_{\mathrm{ref}}}
}.
\label{eq:S11_03_dt_formula}\]</span>
식 <a data-reference="eq:S11_03_dt_formula" data-reference-type="eqref" href="#eq:S11_03_dt_formula">[eq:S11_03_dt_formula]</a>가 본 절의 유도 결과이며, 정의 <a data-reference="eq:S11_03_cref_as_ratio" data-reference-type="eqref" href="#eq:S11_03_cref_as_ratio">[eq:S11_03_cref_as_ratio]</a>와 <a data-reference="eq:S11_03_leff_def" data-reference-type="eqref" href="#eq:S11_03_leff_def">[eq:S11_03_leff_def]</a>의 결합으로 완결된다.</p>
<h3 data-number="13.3.4" id="수치-대입완전-전개"><span class="header-section-number">13.3.4</span> 11.3.4 수치 대입(완전 전개)</h3>
<h4 data-number="13.3.4.1" id="ell_mathrmeffacdot-a-계산"><span class="header-section-number">13.3.4.1</span> 11.3.4.1 <span class="math inline">\(\ell_{\mathrm{eff}}=A\cdot a\)</span> 계산</h4>
<p><a data-reference="eq:S11_03_leff_def" data-reference-type="eqref" href="#eq:S11_03_leff_def">[eq:S11_03_leff_def]</a>에 <a data-reference="eq:S11_03_A_lock" data-reference-type="eqref" href="#eq:S11_03_A_lock">[eq:S11_03_A_lock]</a>, <a data-reference="eq:S11_03_a_lock" data-reference-type="eqref" href="#eq:S11_03_a_lock">[eq:S11_03_a_lock]</a>을 대입한다.
<span class="math display">\[\begin{aligned}
\ell_{\mathrm{eff}}
&amp;=A\cdot a
\notag\\
&amp;=
\left(
880918.97770344000000074873389538365909152024492565003100802687690543842580063599
\right)
\left(
6.3299121257859865746\times 10^{-19}\ \mathrm{m}
\right)
\notag\\
&amp;=
5.5761397188\times 10^{-13}\ \mathrm{m}.
\label{eq:S11_03_leff_value}\end{aligned}\]</span></p>
<h4 data-number="13.3.4.2" id="delta-tell_mathrmeffc_mathrmref-계산"><span class="header-section-number">13.3.4.2</span> 11.3.4.2 <span class="math inline">\(\Delta t=\ell_{\mathrm{eff}}/c_{\mathrm{ref}}\)</span> 계산</h4>
<p><a data-reference="eq:S11_03_dt_formula" data-reference-type="eqref" href="#eq:S11_03_dt_formula">[eq:S11_03_dt_formula]</a>에 <a data-reference="eq:S11_03_leff_value" data-reference-type="eqref" href="#eq:S11_03_leff_value">[eq:S11_03_leff_value]</a>와 <a data-reference="eq:S11_03_cref_lock" data-reference-type="eqref" href="#eq:S11_03_cref_lock">[eq:S11_03_cref_lock]</a>을 대입한다.
<span class="math display">\[\begin{aligned}
\Delta t
&amp;=
\frac{\ell_{\mathrm{eff}}}{c_{\mathrm{ref}}}
=
\frac{5.5761397188\times 10^{-13}\ \mathrm{m}}{299\,792\,458\ \mathrm{m/s}}
\notag\\
&amp;=
1.86\times 10^{-21}\ \mathrm{s}.
\label{eq:S11_03_dt_value}\end{aligned}\]</span>
따라서 실현 시간 틱은 다음으로 고정된다.
<span class="math display">\[\boxed{
\Delta t
=
1.86\times 10^{-21}\ \mathrm{s}
}.
\label{eq:S11_03_dt_box}\]</span></p>
<h3 data-number="13.3.5" id="오차-예산민감도-연결"><span class="header-section-number">13.3.5</span> 11.3.5 오차 예산(민감도) 연결</h3>
<p><span class="math inline">\(\Delta t\)</span>는 <a data-reference="eq:S11_03_dt_formula" data-reference-type="eqref" href="#eq:S11_03_dt_formula">[eq:S11_03_dt_formula]</a>로 정의되므로, <span class="math inline">\((A,a,c_{\mathrm{ref}})\)</span>의 변화에 대한 1차 민감도는 미분으로 직접 얻어진다.
<span class="math display">\[\Delta t=\frac{A a}{c_{\mathrm{ref}}}
\quad\Longrightarrow\quad
\frac{d(\Delta t)}{\Delta t}
=
\frac{dA}{A}
+
\frac{da}{a}
-
\frac{dc_{\mathrm{ref}}}{c_{\mathrm{ref}}}.
\label{eq:S11_03_rel_sens}\]</span>
따라서 절대 오차의 1차 상계는 다음으로 기록된다.
<span class="math display">\[\left|\Delta(\Delta t)\right|
\le
\Delta t\left(
\left|\frac{\Delta A}{A}\right|
+
\left|\frac{\Delta a}{a}\right|
+
\left|\frac{\Delta c_{\mathrm{ref}}}{c_{\mathrm{ref}}}\right|
\right).
\label{eq:S11_03_abs_error_bound}\]</span>
독립 오차 가정을 사용하여 분산형 예산을 기록하는 경우, 다음을 <code>analysis_lock</code>에 “오차 예산 선택 규칙”으로 잠근다.
<span class="math display">\[\left(\frac{\sigma_{\Delta t}}{\Delta t}\right)^2
=
\left(\frac{\sigma_A}{A}\right)^2
+
\left(\frac{\sigma_a}{a}\right)^2
+
\left(\frac{\sigma_{c_{\mathrm{ref}}}}{c_{\mathrm{ref}}}\right)^2.
\label{eq:S11_03_var_budget}\]</span>
여기서 <span class="math inline">\(\sigma_A,\sigma_a,\sigma_{c_{\mathrm{ref}}}\)</span>는 각 입력의 표준 불확도이며, 추정 규칙(어떤 로그/어떤 창/어떤 반복으로 산출하는지)은 <code>analysis_lock</code>에 잠겨야 한다.
특히 <span class="math inline">\(a\)</span>가 <code>realization_lock</code>에 의해 값으로 봉인되고, <span class="math inline">\(c_{\mathrm{ref}}\)</span>가 운영 닻으로 봉인된 버전에서는, 해당 버전의 오차 예산은 <span class="math inline">\((A)\)</span>의 산출 절차에 의해 지배될 수 있으며, 그 판단(어떤 항을 0으로 취급하는지)은 사전 등록된 규약으로만 허용된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-55">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(a\)</span> 값(<a data-reference="eq:S11_03_a_lock" data-reference-type="ref" href="#eq:S11_03_a_lock">[eq:S11_03_a_lock]</a>), <span class="math inline">\(c_{\mathrm{ref}}\)</span> 값(<a data-reference="eq:S11_03_cref_lock" data-reference-type="ref" href="#eq:S11_03_cref_lock">[eq:S11_03_cref_lock]</a>), <span class="math inline">\(A\)</span> 값(<a data-reference="eq:S11_03_A_lock" data-reference-type="ref" href="#eq:S11_03_A_lock">[eq:S11_03_A_lock]</a>) 및 <span class="math inline">\(\Delta t=(A a)/c_{\mathrm{ref}}\)</span> 정의(<a data-reference="eq:S11_03_dt_formula" data-reference-type="ref" href="#eq:S11_03_dt_formula">[eq:S11_03_dt_formula]</a>)를 <code>realization_lock</code>/<code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: <span class="math inline">\(A\)</span>는 지정 Gate(정상상태/핀닝/로버스트성 포함)에서 <code>PASS</code>한 산출물만 사용 가능; 미통과 또는 미봉인은 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
<li><p>Gate: <span class="math inline">\(a,c_{\mathrm{ref}},A\)</span>의 사후 변경(값/채널/문턱/추정기 교체)은 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 의미 충돌(지름/반지름, 단위 차원, 스코프 혼합) 및 lock_id 혼합은 G-SYM/G-LOCK에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 실현 산출물과 로그가 <code>manifest+checksums+registry_snapshot</code>으로 봉인되지 않으면 G-REP에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
</ul>
<h2 data-number="13.4" id="mathrmrcross633532-3-tier-gate"><span class="header-section-number">13.4</span> 11.4 <span class="math inline">\(\mathrm{RCROSS}(633/532)\)</span>: 3-Tier Gate</h2>
<h3 data-number="13.4.1" id="목적-10"><span class="header-section-number">13.4.1</span> 11.4.1 목적</h3>
<p>본 절은 두 기준선(633, 532) 채널을 사용한 교차검증 <span class="math inline">\(\mathrm{RCROSS}\)</span>를 <strong>3-Tier Gate</strong>로 정의하고, (i) 편차 지표 <span class="math inline">\(\mathrm{dev}\)</span>, (ii) 허용오차(문턱) <code>dev_max</code>, (iii) 실패모드 라벨링을 고정한다.
본 절은 교차정합을 정당화하지 않는다. 본 절은 오직 <code>PASS</code>/<code>FAIL</code>/<code>INCONCLUSIVE</code> 판정 규칙을 정의한다.</p>
<h3 data-number="13.4.2" id="입력lock-두-채널과-채널별-실현-후보"><span class="header-section-number">13.4.2</span> 11.4.2 입력(LOCK): 두 채널과 채널별 실현 후보</h3>
<p>두 기준선 채널을 다음 집합으로 정의한다.
<span class="math display">\[\mathcal{A}:=\{A_{633},A_{532}\}.
\label{eq:S11_04_channels}\]</span>
각 채널은 실현 후보 <span class="math inline">\((a^{(k)},\Delta t^{(k)})\)</span>를 산출하거나, 최소한 실현 배율 <span class="math inline">\(\Lambda_v^{(k)}=a^{(k)}/\Delta t^{(k)}\)</span>를 산출해야 한다. 채널별 산출물은 다음 필드를 반드시 포함해야 한다.</p>
<ol>
<li><p><strong>channel_id</strong>: <code>A633</code> 또는 <code>A532</code>.</p></li>
<li><p><strong>lambda_ref</strong>: 기준선 값(길이 단위).</p></li>
<li><p><strong>N</strong>: 분할 정수(무차원).</p></li>
<li><p><strong>a_cand</strong>: 후보 <span class="math inline">\(a^{(k)}\)</span> (또는 <code>N</code>이 공통이면 공통 <span class="math inline">\(a\)</span>).</p></li>
<li><p><strong>dt_cand</strong>: 후보 <span class="math inline">\(\Delta t^{(k)}\)</span>.</p></li>
<li><p><strong>lock_refs</strong>: <code>canon_lock_id</code>, <code>realization_lock_id</code>, <code>analysis_lock_id</code>.</p></li>
</ol>
<p>각 필드가 누락되면 채널 산출물은 정의 불능이며 <code>INCONCLUSIVE</code>이다.</p>
<h3 data-number="13.4.3" id="편차-지표dev-정의"><span class="header-section-number">13.4.3</span> 11.4.3 편차 지표(dev) 정의</h3>
<p>교차정합의 핵심은 “두 채널이 동일 실현 결과를 지지하는가”이다. 이를 위해 편차 지표를 다음으로 정의한다.</p>
<h4 data-number="13.4.3.1" id="상대-편차-dev"><span class="header-section-number">13.4.3.1</span> 11.4.3.1 상대 편차 dev</h4>
<p>채널 <span class="math inline">\(k\in\{633,532\}\)</span>의 후보 시간 틱을 <span class="math inline">\(\Delta t^{(k)}\)</span>로 두고, 상대 편차를 다음으로 정의한다.
<span class="math display">\[\mathrm{dev}
:=
\left|\frac{\Delta t^{(633)}-\Delta t^{(532)}}{\frac{1}{2}\left(\Delta t^{(633)}+\Delta t^{(532)}\right)}\right|.
\label{eq:S11_04_dev_def}\]</span>
정의 <a data-reference="eq:S11_04_dev_def" data-reference-type="eqref" href="#eq:S11_04_dev_def">[eq:S11_04_dev_def]</a>에서 분모가 0이면 정의 불능이므로, 두 후보가 양수임을 요구한다.
<span class="math display">\[\Delta t^{(633)}&gt;0,\qquad \Delta t^{(532)}&gt;0.
\label{eq:S11_04_dt_positive}\]</span>
<a data-reference="eq:S11_04_dt_positive" data-reference-type="eqref" href="#eq:S11_04_dt_positive">[eq:S11_04_dt_positive]</a>가 위반되면 즉시 <code>FAIL-RCROSS-NONPOS</code>이다.</p>
<h4 data-number="13.4.3.2" id="대체-편차배율-기반-선택적"><span class="header-section-number">13.4.3.2</span> 11.4.3.2 대체 편차(배율 기반; 선택적)</h4>
<p>채널별로 <span class="math inline">\(\Delta t\)</span> 대신 실현 배율 <span class="math inline">\(\Lambda_v^{(k)}=a^{(k)}/\Delta t^{(k)}\)</span>만 제공되는 경우, 대체 편차를 다음으로 정의한다.
<span class="math display">\[\mathrm{dev}_{\Lambda}
:=
\left|\frac{\Lambda_v^{(633)}-\Lambda_v^{(532)}}{\frac{1}{2}\left(\Lambda_v^{(633)}+\Lambda_v^{(532)}\right)}\right|.
\label{eq:S11_04_devL_def}\]</span>
어느 편차를 쓰는지(시간 기반 dev 또는 배율 기반 dev<span class="math inline">\(_\Lambda\)</span>)는 <code>analysis_lock</code>에 사전 등록되어야 하며, 결과를 본 뒤 교체될 수 없다.</p>
<h3 data-number="13.4.4" id="tier-gate-정의"><span class="header-section-number">13.4.4</span> 11.4.4 3-Tier Gate 정의</h3>
<p>3-Tier Gate는 <strong>정의 가능성</strong> <span class="math inline">\(\rightarrow\)</span> <strong>정합 통과</strong> <span class="math inline">\(\rightarrow\)</span> <strong>강화(추가 일관성)</strong>의 순서로 판정한다. 각 Tier는 독립된 <code>PASS</code>/<code>FAIL</code>/<code>INCONCLUSIVE</code>를 출력한다.</p>
<h4 data-number="13.4.4.1" id="tier-1-입력정의-완결성-gate"><span class="header-section-number">13.4.4.1</span> 11.4.4.1 Tier-1: 입력/정의 완결성 Gate</h4>
<p>Tier-1은 “비교 자체가 정의 가능한가”를 판정한다.</p>
<h4 data-number="13.4.4.2" id="tier-1-pass-조건"><span class="header-section-number">13.4.4.2</span> Tier-1 PASS 조건</h4>
<p>다음 조건을 모두 만족하면 Tier-1=<code>PASS</code>이다.</p>
<ol>
<li><p>두 채널 산출물의 필수 필드가 모두 존재.</p></li>
<li><p>lock_refs가 존재하며, 두 채널이 동일 lock_id 조합에 귀속(또는 사전 등록된 허용 조합).</p></li>
<li><p><span class="math inline">\(\Delta t^{(633)},\Delta t^{(532)}\)</span> (또는 <span class="math inline">\(\Lambda_v^{(633)},\Lambda_v^{(532)}\)</span>)가 모두 정의 가능하고 양수.</p></li>
</ol>
<h4 data-number="13.4.4.3" id="tier-1-inconclusive-조건"><span class="header-section-number">13.4.4.3</span> Tier-1 INCONCLUSIVE 조건</h4>
<p>필드 누락, lock_refs 누락, 분모 0 가능성, 어떤 값이 미정의인 경우 Tier-1=<code>INCONCLUSIVE</code>이다.</p>
<h4 data-number="13.4.4.4" id="tier-1-fail-조건"><span class="header-section-number">13.4.4.4</span> Tier-1 FAIL 조건</h4>
<p>사후 변경 흔적(채널 정의 변경, 문턱 변경, 값 치환) 또는 lock_id 혼합이 탐지되면 Tier-1=<code>FAIL</code>이다.</p>
<h4 data-number="13.4.4.5" id="tier-2-dev-문턱-통과-gate-핵심"><span class="header-section-number">13.4.4.5</span> 11.4.4.2 Tier-2: dev 문턱 통과 Gate (핵심)</h4>
<p>Tier-2는 <strong>편차 지표가 허용오차 이내인지</strong>를 판정한다.</p>
<h4 data-number="13.4.4.6" id="허용오차dev_max-잠금"><span class="header-section-number">13.4.4.6</span> 허용오차(dev_max) 잠금</h4>
<p>허용오차 <code>dev_max</code>를 다음으로 잠근다.
<span class="math display">\[\mathrm{dev}_{\max}&gt;0,
\qquad
\mathrm{dev}_{\max}\ \text{는}\ \texttt{gate\_lock}\ \text{에 사전 등록}.
\label{eq:S11_04_devmax_lock}\]</span></p>
<h4 data-number="13.4.4.7" id="tier-2-판정"><span class="header-section-number">13.4.4.7</span> Tier-2 판정</h4>
<p>Tier-1=<code>PASS</code>이고 dev 정의가 가능할 때, Tier-2를 다음으로 정의한다.
<span class="math display">\[\texttt{Tier2}=
\begin{cases}
\texttt{PASS}, &amp; \mathrm{dev}\le \mathrm{dev}_{\max},\\
\texttt{FAIL}, &amp; \mathrm{dev}&gt;\mathrm{dev}_{\max}.
\end{cases}
\label{eq:S11_04_tier2_rule}\]</span>
Tier-1<span class="math inline">\(\neq\)</span><code>PASS</code>이면 Tier-2는 <code>INCONCLUSIVE</code>이다(비교 자체가 성립하지 않음).</p>
<h4 data-number="13.4.4.8" id="tier-3-강화-일관성-gate-추가-조건"><span class="header-section-number">13.4.4.8</span> 11.4.4.3 Tier-3: 강화 일관성 Gate (추가 조건)</h4>
<p>Tier-3는 dev 통과 이후에도 “채널별 내부 일관성”을 추가로 요구하는 강화 Gate이다. Tier-3는 다음 두 강화 조건 중 하나 또는 둘 다를 선택하여 잠근다(택일/병행은 <code>analysis_lock</code>에 잠김).</p>
<h4 data-number="13.4.4.9" id="t3-a-파생량-일관성"><span class="header-section-number">13.4.4.9</span> (T3-A) 파생량 일관성</h4>
<p>채널별 파생량 집합 <span class="math inline">\(\Pi^{(k)}=\{\Pi_1^{(k)},\Pi_2^{(k)},\ldots\}\)</span>를 잠긴 정의로 산출하고, 파생량 상대 편차가 문턱 이내인지 판정한다. 파생량 선택과 편차 정의는 <code>analysis_lock</code>에 잠긴다. 문턱 <span class="math inline">\(\Pi_{\max}\)</span>는 <code>gate_lock</code>에 잠긴다.</p>
<h4 data-number="13.4.4.10" id="t3-b-반복재실행-일관성"><span class="header-section-number">13.4.4.10</span> (T3-B) 반복/재실행 일관성</h4>
<p>동일 채널을 사전 등록된 재실행 세트에서 반복 실행했을 때 dev 분포가 안정적인지 판정한다. 재실행 세트와 안정성 문턱(예: 분산 상계)은 <code>analysis_lock</code>/<code>gate_lock</code>에 잠긴다.</p>
<h4 data-number="13.4.4.11" id="tier-3-판정"><span class="header-section-number">13.4.4.11</span> Tier-3 판정</h4>
<p>Tier-2=<code>PASS</code>인 경우에만 Tier-3를 평가한다. 강화 조건이 잠기지 않았으면 Tier-3는 <code>INCONCLUSIVE</code>로 남긴다. 강화 조건이 잠겼고 문턱을 위반하면 Tier-3=<code>FAIL</code>이다.</p>
<h3 data-number="13.4.5" id="최종-rcross-gate3-tier-결합"><span class="header-section-number">13.4.5</span> 11.4.5 최종 RCROSS Gate(3-Tier 결합)</h3>
<p>최종 RCROSS 판정을 다음으로 정의한다.
<span class="math display">\[\texttt{G-RCROSS}=\texttt{PASS}
\Longleftrightarrow
(\texttt{Tier1}=\texttt{PASS})\ \wedge\ (\texttt{Tier2}=\texttt{PASS})\ \wedge\ (\texttt{Tier3}\in\{\texttt{PASS},\texttt{INCONCLUSIVE}\}).
\label{eq:S11_04_GRCROSS_def}\]</span>
즉, Tier-3는 잠긴 경우에는 <code>PASS</code>를 요구하고, 잠기지 않은 경우에는 <code>INCONCLUSIVE</code>로 남길 수 있으나, 그 경우 “강화 일관성까지 통과했다”는 문장은 금지된다(PASS.rules로 제한).</p>
<h3 data-number="13.4.6" id="실패모드-라벨링표준-라벨"><span class="header-section-number">13.4.6</span> 11.4.6 실패모드 라벨링(표준 라벨)</h3>
<p>RCROSS 실패는 원인 분해 라벨로 기록한다. 라벨은 다음 열거형으로 고정한다(복수 부여 가능).</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">라벨</th>
<th style="text-align: left;">의미</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">INCON-RCROSS-MISSING</td>
<td style="text-align: left;">필수 필드 누락(정의 불능)</td>
</tr>
<tr class="even">
<td style="text-align: left;">INCON-RCROSS-UNLOCK</td>
<td style="text-align: left;">lock_refs 또는 스냅샷 미봉인(정의 불능)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FAIL-RCROSS-NONPOS</td>
<td style="text-align: left;"><span class="math inline">\(\Delta t\)</span> 또는 <span class="math inline">\(\Lambda_v\)</span> 비양수(정의 위반)</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-RCROSS-LOCKMIX</td>
<td style="text-align: left;">서로 다른 lock_id 혼합(잠금 위반)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FAIL-RCROSS-DEV</td>
<td style="text-align: left;"><span class="math inline">\(\mathrm{dev}&gt;\mathrm{dev}_{\max}\)</span> (핵심 불일치)</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-RCROSS-T3</td>
<td style="text-align: left;">Tier-3 강화 조건 위반</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FAIL-RCROSS-RETRO</td>
<td style="text-align: left;">사후 변경(채널/문턱/정의 교체) 탐지</td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="13.4.7" id="기록봉인-규약로그와-체크섬-연결"><span class="header-section-number">13.4.7</span> 11.4.7 기록/봉인 규약(로그와 체크섬 연결)</h3>
<p>RCROSS 판정은 다음 레코드를 생성하여 봉인해야 한다.</p>
<pre><code>rcross_report:
  - rcross_id: (unique)
    channels: [A633, A532]
    dt_633: ...
    dt_532: ...
    dev: ...
    dev_max: ...
    tier1: PASS|FAIL|INCONCLUSIVE
    tier2: PASS|FAIL|INCONCLUSIVE
    tier3: PASS|FAIL|INCONCLUSIVE
    verdict: PASS|FAIL|INCONCLUSIVE
    labels: [...]
    lock_refs: {canon_lock_id, realization_lock_id, analysis_lock_id, gate_lock_id, protocol_lock_id}
    manifest_ref: ...
    checksums_ref: ...</code></pre>
<p><code>manifest_ref</code>와 <code>checksums_ref</code>가 없는 보고서는 결론 자격을 부여하지 않는다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-56">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: dev 정의(<a data-reference="eq:S11_04_dev_def" data-reference-type="eqref" href="#eq:S11_04_dev_def">[eq:S11_04_dev_def]</a>) 또는 dev<span class="math inline">\(_\Lambda\)</span> 정의(<a data-reference="eq:S11_04_devL_def" data-reference-type="eqref" href="#eq:S11_04_devL_def">[eq:S11_04_devL_def]</a>), 3-Tier 규약, 최종 결합 규칙(<a data-reference="eq:S11_04_GRCROSS_def" data-reference-type="eqref" href="#eq:S11_04_GRCROSS_def">[eq:S11_04_GRCROSS_def]</a>)을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 허용오차 <span class="math inline">\(\mathrm{dev}_{\max}\)</span> 및 (선택) Tier-3 문턱을 <code>gate_lock</code>에 고정.</p></li>
<li><p>Gate: RCROSS 실패모드 라벨(INCON/FAIL-RCROSS-*) 체계를 <code>gate_lock</code>에 고정.</p></li>
<li><p>Gate: 사후 변경(문턱/정의/채널 교체) 탐지는 G-NT에서 <code>FAIL-RCROSS-RETRO</code>.</p></li>
<li><p>Gate: RCROSS 보고서가 <code>manifest+checksums+registry_snapshot</code>으로 봉인되지 않으면 G-REP에서 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
</ul>
<h2 data-number="13.5" id="통합부록-mms-operational-anchor-형식"><span class="header-section-number">13.5</span> 11.5 (통합부록) MMS Operational Anchor 형식</h2>
<h3 data-number="13.5.1" id="목적-11"><span class="header-section-number">13.5.1</span> 11.5.1 목적</h3>
<p>본 절은 MMS 문서에서 사용하는 Operational Anchor(운영 닻) 형식을 본 이론서의 <code>realization_lock</code>/<code>analysis_lock</code>/<code>gate_lock</code> 체계에 접합하기 위한 <strong>형식 정의</strong>와 <strong>대응표</strong>를 제공한다.
본 절은 (i) MMS 운영 닻 레코드의 필수 필드를 고정하고, (ii) v4의 RCROSS(633/532) 및 threshold 항목이 본 이론서의 3-Tier Gate 필드로 어떻게 대응되는지 표로 고정한다. 본 절은 해석을 수행하지 않는다.</p>
<h3 data-number="13.5.2" id="mms-operational-anchor-레코드의-표준-형식필수-필드"><span class="header-section-number">13.5.2</span> 11.5.2 MMS Operational Anchor 레코드의 표준 형식(필수 필드)</h3>
<p>MMS 운영 닻 레코드는 다음 필드를 <strong>필수</strong>로 가진다. 필드 누락 시 해당 닻은 사용 불가이며 <code>INCONCLUSIVE</code>이다.</p>
<ol>
<li><p><strong>anchor_id</strong>: 닻 식별자(예: <code>A633</code>, <code>A532</code>).</p></li>
<li><p><strong>anchor_type</strong>: <code>length</code> 또는 <code>time</code> 또는 <code>velocity</code> 등(본 이론서는 <code>length</code> 중심).</p></li>
<li><p><strong>value</strong>: 수치값.</p></li>
<li><p><strong>unit</strong>: 단위 표기(<code>nm</code>, <code>m</code>, <code>s</code>, <code>m/s</code> 등).</p></li>
<li><p><strong>channel</strong>: 채널 설명(예: 기준선, 장치, 모드).</p></li>
<li><p><strong>scope</strong>: 적용 레짐/실험 조건 식별자.</p></li>
<li><p><strong>protocol_id</strong>: 측정/전처리/로그 스키마 식별자.</p></li>
<li><p><strong>lock_refs</strong>: <code>canon_lock_id</code>, <code>realization_lock_id</code>, <code>analysis_lock_id</code>, <code>gate_lock_id</code>, <code>protocol_lock_id</code>.</p></li>
<li><p><strong>artifacts</strong>: 원시 데이터/전처리 데이터/보고서 파일 경로 목록.</p></li>
<li><p><strong>hash_refs</strong>: manifest/checksums 참조 키.</p></li>
</ol>
<p>MMS 레코드는 위 필드를 포함한 뒤, 본 이론서의 레지스트리 구조에 따라 <code>registry/realization_lock.*</code> 또는 <code>snapshot/registry_snapshot/</code>에 포함되어 봉인되어야 한다.</p>
<h3 data-number="13.5.3" id="v4-rcrossthreshold-leftrightarrow-본문-3-tier-gate-대응표"><span class="header-section-number">13.5.3</span> 11.5.3 v4 RCROSS/threshold <span class="math inline">\(\leftrightarrow\)</span> 본문 3-Tier Gate 대응표</h3>
<p>아래 표는 v4 문서(MMS 포함)에서 등장하는 RCROSS 및 threshold 계열 항목이 본 이론서의 3-Tier Gate 및 레지스트리 필드로 어떻게 대응되는지를 고정한다. 표의 “v4 항목명”은 원문 철자/키가 다를 수 있으므로, <strong>의미</strong> 기준으로 대응되며, 실제 키 문자열은 <code>protocol_lock</code>에 별도 매핑 테이블로 잠근다.</p>
<div class="center">
<table style="width:92%;">
<colgroup>
<col style="width: 26%"/>
<col style="width: 32%"/>
<col style="width: 34%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">v4/MMS 항목(의미)</th>
<th style="text-align: left;">본 이론서 대응 위치</th>
<th style="text-align: left;">규약/판정</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">기준선 633 채널(파장/길이)</td>
<td style="text-align: left;"><code>realization_lock.anchors[A633].lambda_ref</code></td>
<td style="text-align: left;">Tier-1 입력 필수; 단위/스코프/프로토콜 포함</td>
</tr>
<tr class="even">
<td style="text-align: left;">기준선 532 채널(파장/길이)</td>
<td style="text-align: left;"><code>realization_lock.anchors[A532].lambda_ref</code></td>
<td style="text-align: left;">Tier-1 입력 필수; 단위/스코프/프로토콜 포함</td>
</tr>
<tr class="odd">
<td style="text-align: left;">분할 정수 <span class="math inline">\(N\)</span> (예: <span class="math inline">\(10^{12}\)</span>)</td>
<td style="text-align: left;"><code>analysis_lock.anchor_split.N</code></td>
<td style="text-align: left;">사후 변경 금지; 변경은 버전업</td>
</tr>
<tr class="even">
<td style="text-align: left;">채널별 후보 <span class="math inline">\(\Delta t^{(633)}\)</span></td>
<td style="text-align: left;"><code>outputs/derived/dt_633.txt</code> + <code>rcross_report.dt_633</code></td>
<td style="text-align: left;">Tier-1 정의 가능성; Tier-2 dev 계산 입력</td>
</tr>
<tr class="odd">
<td style="text-align: left;">채널별 후보 <span class="math inline">\(\Delta t^{(532)}\)</span></td>
<td style="text-align: left;"><code>outputs/derived/dt_532.txt</code> + <code>rcross_report.dt_532</code></td>
<td style="text-align: left;">Tier-1 정의 가능성; Tier-2 dev 계산 입력</td>
</tr>
<tr class="even">
<td style="text-align: left;">교차 편차(dev) 정의</td>
<td style="text-align: left;"><code>analysis_lock.rcross.dev_definition</code></td>
<td style="text-align: left;">dev 또는 dev<span class="math inline">\(_\Lambda\)</span> 중 택일 잠금</td>
</tr>
<tr class="odd">
<td style="text-align: left;">허용오차 dev_max</td>
<td style="text-align: left;"><code>gate_lock.rcross.dev_max</code></td>
<td style="text-align: left;">Tier-2 핵심 문턱; dev<span class="math inline">\(&gt;\)</span>dev_max이면 FAIL-RCROSS-DEV</td>
</tr>
<tr class="even">
<td style="text-align: left;">3-Tier 구조(정의/정합/강화)</td>
<td style="text-align: left;"><code>analysis_lock.rcross.tiers</code></td>
<td style="text-align: left;">Tier-1/2/3 판정 규약 고정</td>
</tr>
<tr class="odd">
<td style="text-align: left;">강화 조건(파생량 비교)</td>
<td style="text-align: left;"><code>analysis_lock.rcross.tier3.derivatives</code></td>
<td style="text-align: left;">잠긴 경우 Tier-3 수행; 위반 시 FAIL-RCROSS-T3</td>
</tr>
<tr class="even">
<td style="text-align: left;">강화 조건(재실행 일관성)</td>
<td style="text-align: left;"><code>analysis_lock.rcross.tier3.replay_set</code></td>
<td style="text-align: left;">재실행 세트 미잠금 시 Tier-3=INCONCLUSIVE</td>
</tr>
<tr class="odd">
<td style="text-align: left;">thresholds.yaml(문턱 파일)</td>
<td style="text-align: left;"><code>gate_lock</code> 전반 + <code>configs/thresholds.yaml</code></td>
<td style="text-align: left;">문턱은 사전 등록; 파일 자체도 봉인 대상</td>
</tr>
<tr class="even">
<td style="text-align: left;">PASS/FAIL 판정 로그</td>
<td style="text-align: left;"><code>outputs/gates/rcross_report.json</code></td>
<td style="text-align: left;"><code>manifest+checksums</code> 봉인 없으면 결론 자격 없음</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Bonferroni/CI 교차 규약(있는 경우)</td>
<td style="text-align: left;"><code>analysis_lock.rcross.stat_rule</code></td>
<td style="text-align: left;">사용 시 Tier-3 강화 조건으로만 허용</td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="13.5.4" id="매핑-테이블키-문자열-대응-규약"><span class="header-section-number">13.5.4</span> 11.5.4 매핑 테이블(키 문자열 대응) 규약</h3>
<p>v4/MMS의 실제 키 문자열과 본 이론서 레지스트리 키를 연결하려면 “키 매핑 테이블”이 필요하며, 이는 <code>protocol_lock</code>에 잠긴다. 표준 형식은 다음으로 고정한다.</p>
<pre><code>key_map_mms_to_v5:
  - mms_key: "lambda_633"
    v5_path: "registry/realization_lock.anchors[A633].lambda_ref.value"
  - mms_key: "lambda_532"
    v5_path: "registry/realization_lock.anchors[A532].lambda_ref.value"
  - mms_key: "dev_max"
    v5_path: "registry/gate_lock.rcross.dev_max"
  - mms_key: "thresholds_yaml"
    v5_path: "configs/thresholds.yaml"</code></pre>
<p>키 매핑 테이블은 결과를 본 뒤 수정될 수 없으며, 수정은 버전업으로만 허용된다.</p>
<h3 data-number="13.5.5" id="봉인-규약manifestchecksumsregistry_snapshot"><span class="header-section-number">13.5.5</span> 11.5.5 봉인 규약(manifest/checksums/registry_snapshot)</h3>
<p>MMS 레코드와 대응표가 실제로 결론 자격을 갖기 위해서는 다음이 필수다.</p>
<ol>
<li><p>MMS 레코드(anchors, thresholds, rcross report)는 모두 <code>manifest</code>에 등재되어야 한다.</p></li>
<li><p>모든 관련 파일은 <code>checksums</code>에 포함되어 sha256 해시가 봉인되어야 한다.</p></li>
<li><p>사용된 lock 파일은 <code>registry_snapshot</code>에 동결되어야 한다.</p></li>
</ol>
<p>위 조건 중 하나라도 누락되면 해당 RCROSS 판정은 결론 자격을 부여하지 않는다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-57">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: MMS Operational Anchor 필수 필드(11.5.2) 및 v4 RCROSS/threshold 대응표(11.5.3)를 <code>protocol_lock</code>/<code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 키 매핑 테이블 형식(<code>key_map_mms_to_v5</code>)을 <code>protocol_lock</code>에 고정.</p></li>
<li><p>Gate: dev_max 등 문턱값은 <code>gate_lock</code>에 사전 등록되어야 하며, 사후 변경은 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: RCROSS 보고서/thresholds.yaml이 <code>manifest+checksums+registry_snapshot</code>으로 봉인되지 않으면 G-REP에서 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
<li><p>Gate: 매핑 오류(키 불일치, 스코프 혼합, lock_id 혼합)는 G-LOCK/G-SYM에서 <code>FAIL</code>.</p></li>
</ul>
<h1 data-number="14" id="전자-1초-크로스체크"><span class="header-section-number">14</span> 12. 전자 1초 크로스체크</h1>
<h2 class="unnumbered" id="목적시간-정합의-핵심-선언">목적(시간 정합의 핵심 선언)</h2>
<p>본 장은 실현 시간 틱 <span class="math inline">\(\Delta t\)</span>와 사건율(전자/양성자 정준 사건율)이 하나의 시간 체계로 <strong>정합</strong>되는지 검증하는 핵심 장으로 고정한다.
본 장에서 “전자 1초”는 외부 텍스트의 정의가 아니라, 본 문서 내부의 (i) 전자 정준 사건율 <span class="math inline">\(\nu_{e,\mathrm{can}}:=1\)</span> (9.3), (ii) 실현 시간 틱 <span class="math inline">\(\Delta t\)</span> (11.3), (iii) 사건 집계 규약(9.1–9.2)을 결합하여 생성되는 <strong>운영 시간 구간</strong>으로 정의된다.
따라서 본 장의 크로스체크는 시간 정합의 최종 관문이며, 본 장의 Gate가 <code>PASS</code>하지 않으면 <span class="math inline">\(\Delta t\)</span>로부터 파생되는 모든 시간 기반 결론(빌드타임, 전파, 질량/힘의 시간화)은 결론 자격을 갖지 못한다.</p>
<h2 class="unnumbered" id="입력lock과-연결-위치">입력(LOCK)과 연결 위치</h2>
<p>본 장이 참조하는 잠금 입력은 다음 네 항목이다.</p>
<ol>
<li><p>전자 정준 사건율:
<span class="math display">\[\nu_{e,\mathrm{can}}:=1.
  \label{eq:S12_00_nue_lock}\]</span></p></li>
<li><p>양성자 정준 사건율:
<span class="math display">\[\nu_{p,\mathrm{can}}\ \text{(9.4에서 잠긴 수치)}.
  \label{eq:S12_00_nup_lock}\]</span></p></li>
<li><p>실현 길이와 시간:
<span class="math display">\[a\ \text{(11.2에서 잠김)},\qquad
  \Delta t\ \text{(11.3에서 잠김)}.
  \label{eq:S12_00_real_lock}\]</span></p></li>
<li><p>정류 계수:
<span class="math display">\[\delta=\frac{1}{\pi^2}\ \text{(보편 레짐에서 잠김)}.
  \label{eq:S12_00_delta_lock}\]</span></p></li>
</ol>
<p>본 장은 위 입력을 변경하지 않으며, 입력은 오직 <code>lock_id</code> 참조로만 사용된다. 입력의 사후 변경은 No-Tuning 위반이며 금지된다.</p>
<h2 class="unnumbered" id="전자-1초의-지위운영-시간-구간">“전자 1초”의 지위(운영 시간 구간)</h2>
<p>본 장은 “전자 1초”를 다음과 같은 <strong>운영 정의</strong>로 취급한다고 선언한다.</p>
<ol>
<li><p>전자 사건 집계를 위한 표준 시간 창(틱 창) 길이 <span class="math inline">\(\Delta N_{1s}\)</span>를 정한다.</p></li>
<li><p><span class="math inline">\(\Delta N_{1s}\)</span>에 대응하는 실현 시간은 <span class="math inline">\(\Delta T_{1s}:=\Delta N_{1s}\Delta t\)</span>로 계산한다.</p></li>
<li><p>“전자 1초”는 사건율 정의 및 집계 규약이 동일 버전에서 유지될 때에만 의미를 갖는다.</p></li>
</ol>
<p>따라서 “전자 1초”는 시간 단위의 외부 정의가 아니라, 본 문서 내부 정의의 일관성을 검사하기 위한 크로스체크용 운영량으로 고정된다.</p>
<h2 data-number="14.1" id="크로스체크의-핵심-시간-사건-구조의-동시-정합"><span class="header-section-number">14.1</span> 12.4 크로스체크의 핵심: 시간-사건-구조의 동시 정합</h2>
<p>본 장의 크로스체크는 다음 세 축의 동시 정합으로 선언한다.</p>
<ol>
<li><p><strong>시간 축</strong>: <span class="math inline">\(\Delta t\)</span>가 실현 사상과 RCROSS Gate를 통과하여 봉인되었는가.</p></li>
<li><p><strong>사건 축</strong>: 전자/양성자 사건 정의와 정준 사건율이 동일 규약으로 집계되는가.</p></li>
<li><p><strong>구조 축</strong>: 82+7 구조 및 3-섹터 정수화가 사건 집계에 요구하는 카운트 규약과 모순되지 않는가.</p></li>
</ol>
<p>세 축 중 하나라도 무너지는 경우, 시간 체계의 정합은 성립하지 않으며, 본 장은 <code>FAIL</code> 또는 <code>INCONCLUSIVE</code>로 판정해야 한다.</p>
<h2 data-number="14.2" id="gate-선언최종-통과-조건의-자리"><span class="header-section-number">14.2</span> 12.5 Gate 선언(최종 통과 조건의 자리)</h2>
<p>본 장은 “전자 1초 크로스체크 Gate”를 최종 Gate로 정의한다고 선언한다.
<span class="math display">\[\texttt{G-E1S} \in \{\texttt{PASS},\texttt{FAIL},\texttt{INCONCLUSIVE}\}.
\label{eq:S12_00_GE1S}\]</span>
<code>G-E1S</code>의 구체 판정식(예: <span class="math inline">\(\Delta t\)</span>와 사건율로부터 계산된 1초 창의 자기일관성, 로그 완결성, 민감도/오차예산, 반증 트리거)은 본 장의 후속 절에서 완결한다.
본 개요에서는 <code>G-E1S</code>가 시간 정합의 핵심 Gate이며, <code>G-E1S</code><span class="math inline">\(\neq\)</span><code>PASS</code>일 때 시간 기반 결론의 결론 자격이 박탈된다는 점만을 고정한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-58">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 전자 정준(<span class="math inline">\(\nu_{e,\mathrm{can}}:=1\)</span>), 실현값(<span class="math inline">\(a,\Delta t\)</span>), 양성자 정준 사건율, 정류 계수 <span class="math inline">\(\delta\)</span>를 본 장의 입력으로 고정(참조만 허용).</p></li>
<li><p>Gate: <code>G-E1S</code>를 시간 정합의 최종 Gate로 정의하고, <code>G-E1S</code><span class="math inline">\(\neq\)</span><code>PASS</code> 시 시간 기반 결론 자격 박탈을 PASS.rules에 연결.</p></li>
<li><p>Gate: 입력(LOCK) 사후 변경 또는 교차검증 미봉인은 G-NT/G-REP에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
<li><p>Gate: 사건 정의/집계 규약 혼용 또는 lock_id 혼합은 G-LOCK/G-SYM에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 본 장 판정 로그가 <code>manifest+checksums</code>로 봉인되지 않으면 결론 자격 부여 불가(G-REP).</p></li>
</ul>
<h2 data-number="14.3" id="셀vp-부피-모델-phi_mathrmjam"><span class="header-section-number">14.3</span> 12.1 셀/VP 부피 모델 + <span class="math inline">\(\phi_{\mathrm{jam}}\)</span></h2>
<h3 data-number="14.3.1" id="목적-12"><span class="header-section-number">14.3.1</span> 12.1.1 목적</h3>
<p>본 절은 전자 1초 크로스체크에서 사용되는 “셀 부피”, “부피입자(VP) 유효 점유부피”, “재밍 점유율 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>”을 <strong>로그 가능한 운영정의</strong>로 고정한다.
본 절의 산출물은 (i) 정준 셀 부피 <span class="math inline">\(V_{\mathrm{cell}}\)</span>, (ii) VP 유효 점유부피 <span class="math inline">\(v_{\mathrm{vp}}\)</span>, (iii) 셀 내부 VP 카운트 <span class="math inline">\(N_{\mathrm{vp}}\)</span>, (iv) 재밍 점유율 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>의 정의 및 (v) 정의 충돌/혼용을 즉시 <code>FAIL</code>로 처리하는 규칙이다.</p>
<h3 data-number="14.3.2" id="정준-셀-부피-모델큐브-셀"><span class="header-section-number">14.3.2</span> 12.1.2 정준 셀 부피 모델(큐브 셀)</h3>
<p>정준 셀은 <code>CELL-CUBE</code>로 잠긴다. 셀 대표 길이 <span class="math inline">\(D_{\mathrm{anch}}\)</span>는 <strong>모서리 길이(edge)</strong>로 잠긴다. 정준 셀 도메인을
<span class="math display">\[\mathcal{D}_{\square}
:=
\left\{\mathbf{x}\in\mathbb{R}^3\ \big|\ 0\le x&lt; D_{\mathrm{anch}},\ 0\le y&lt; D_{\mathrm{anch}},\ 0\le z&lt; D_{\mathrm{anch}}\right\}
\label{eq:S12_01_cell_domain}\]</span>
로 정의한다. 정준 셀 부피는 다음으로 정의한다.
<span class="math display">\[V_{\mathrm{cell}}
:=|\mathcal{D}_{\square}|
= D_{\mathrm{anch}}^{3}.
\label{eq:S12_01_Vcell}\]</span>
정의 <a data-reference="eq:S12_01_Vcell" data-reference-type="eqref" href="#eq:S12_01_Vcell">[eq:S12_01_Vcell]</a>은 셀 기하(<code>CELL-CUBE</code>)와 <span class="math inline">\(D_{\mathrm{anch}}\)</span> 의미(<code>edge</code>)가 잠긴 경우에만 사용 가능하다.</p>
<h3 data-number="14.3.3" id="vp-유효-점유부피-모델v_mathrmvp"><span class="header-section-number">14.3.3</span> 12.1.3 VP 유효 점유부피 모델(<span class="math inline">\(v_{\mathrm{vp}}\)</span>)</h3>
<p>VP는 Stone 공리(부피 불변, 비침투)로 인해 점유부피가 변하지 않는다고 잠긴다. 그러나 “좌표/그래프” 기반 모델에서 실제 점유영역 <span class="math inline">\(\Omega_i\)</span>를 직접 적분하는 대신, 단일 길이 스케일 <span class="math inline">\(a\)</span>로 유효 점유부피를 모델링하여 카운트 기반 부피 집계를 가능하게 해야 한다. 이를 위해 VP 유효 점유부피를 다음과 같이 <strong>부피 모델 닫힘</strong>으로 정의하여 잠근다.</p>
<h4 data-number="14.3.3.1" id="유효-점유부피의-표준-형식"><span class="header-section-number">14.3.3.1</span> 12.1.3.1 유효 점유부피의 표준 형식</h4>
<p>VP 유효 점유부피를 다음 표준 형식으로 정의한다.
<span class="math display">\[v_{\mathrm{vp}}
:=\kappa_{\mathrm{vp}}\,a^{3},
\qquad
\kappa_{\mathrm{vp}}&gt;0.
\label{eq:S12_01_vvp_general}\]</span>
여기서</p>
<ul>
<li><p><span class="math inline">\(a\)</span>는 실현 길이 스케일(부피입자 지름)로서 <code>realization_lock</code>에 잠긴다.</p></li>
<li><p><span class="math inline">\(\kappa_{\mathrm{vp}}\)</span>는 <strong>형상 계수(무차원)</strong>이며, VP의 유효 점유영역의 기하 모델을 지정하는 닫힘 상수이다.</p></li>
</ul>
<p><span class="math inline">\(\kappa_{\mathrm{vp}}\)</span>는 결과를 보고 조정될 수 없으며, 채택은 <code>analysis_lock</code>의 닫힘 항목으로만 허용된다.</p>
<h4 data-number="14.3.3.2" id="정준-vp-부피-닫힘구형-커널"><span class="header-section-number">14.3.3.2</span> 12.1.3.2 정준 VP 부피 닫힘(구형 커널)</h4>
<p>본 이론서의 정준 부피 모델은 “등방 핵(구형 커널)”을 채택하여 형상 자유도를 제거한다. 이를 다음과 같이 잠근다.
<span class="math display">\[\kappa_{\mathrm{vp}}
:=\frac{\pi}{6}
\qquad
(\text{정준 부피 닫힘}).
\label{eq:S12_01_kappa_sphere}\]</span>
따라서 정준 VP 유효 점유부피는 다음으로 고정된다.
<span class="math display">\[v_{\mathrm{vp}}
=\frac{\pi}{6}a^{3}.
\label{eq:S12_01_vvp_sphere}\]</span>
정준 부피 닫힘의 목적은 (i) VP 점유부피를 오직 <span class="math inline">\(a\)</span> 하나로 결정하여 SSOT를 만족시키고, (ii) 형상 자유도에 의한 사후조정 경로를 차단하며, (iii) 부피 집계가 카운트 기반으로 단일하게 재현되게 하는 데 있다. 정준 닫힘을 바꾸려면 버전업과 전면 재검증이 필요하다.</p>
<h3 data-number="14.3.4" id="셀-내부-vp-카운트-n_mathrmvp의-운영정의"><span class="header-section-number">14.3.4</span> 12.1.4 셀 내부 VP 카운트 <span class="math inline">\(N_{\mathrm{vp}}\)</span>의 운영정의</h3>
<p>부피 집계는 “어떤 VP를 셀에 포함시키는가”의 규칙이 잠기지 않으면 정의 불능이다. 본 절은 포함 규칙을 다음 단일 규약으로 정의한다.</p>
<h4 data-number="14.3.4.1" id="포함-규칙센터-인-셀"><span class="header-section-number">14.3.4.1</span> 12.1.4.1 포함 규칙(센터-인-셀)</h4>
<p>각 VP <span class="math inline">\(i\)</span>의 대표점(센터) <span class="math inline">\(\mathbf{x}_i\)</span>를 잠긴 규약으로 둔다. 포함 지시함수를 다음으로 정의한다.
<span class="math display">\[\mathbf{1}_{\mathrm{in}}(i)
:=
\begin{cases}
1,&amp; \mathbf{x}_i\in \mathcal{D}_{\square},\\
0,&amp; \text{otherwise}.
\end{cases}
\label{eq:S12_01_indicator_in}\]</span>
셀 내부 VP 카운트를 다음으로 정의한다.
<span class="math display">\[N_{\mathrm{vp}}
:=
\sum_{i\in\mathcal{V}}\mathbf{1}_{\mathrm{in}}(i).
\label{eq:S12_01_Nvp}\]</span>
경계(면/모서리/꼭짓점)에 정확히 놓인 경우의 처리(포함/배제)는 사전 등록된 타이브레이크 규칙으로 잠겨야 하며, 결과를 본 뒤 변경될 수 없다.</p>
<h4 data-number="14.3.4.2" id="로그-필수-필드"><span class="header-section-number">14.3.4.2</span> 12.1.4.2 로그 필수 필드</h4>
<p><span class="math inline">\(N_{\mathrm{vp}}\)</span> 계산이 결론 자격을 갖기 위해서는 다음 로그가 봉인되어야 한다.</p>
<ol>
<li><p>셀 정의: <span class="math inline">\(\mathcal{D}_{\square}\)</span>, <span class="math inline">\(D_{\mathrm{anch}}\)</span> 의미(<code>edge</code>).</p></li>
<li><p>대표점 규약: <span class="math inline">\(\mathbf{x}_i\)</span>가 무엇인지(좌표, 표지점 등) 및 동일성.</p></li>
<li><p>포함 규칙: <a data-reference="eq:S12_01_indicator_in" data-reference-type="eqref" href="#eq:S12_01_indicator_in">[eq:S12_01_indicator_in]</a>의 구현(경계 타이브레이크 포함).</p></li>
<li><p>좌표 파일 해시 및 스냅샷 참조(manifest/checksums).</p></li>
</ol>
<p>누락 시 <span class="math inline">\(N_{\mathrm{vp}}\)</span>는 <code>INCONCLUSIVE</code>이다.</p>
<h3 data-number="14.3.5" id="재밍-점유율-phi_mathrmjam의-정의"><span class="header-section-number">14.3.5</span> 12.1.5 재밍 점유율 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>의 정의</h3>
<h4 data-number="14.3.5.1" id="점유율부피-분율-정의"><span class="header-section-number">14.3.5.1</span> 12.1.5.1 점유율(부피 분율) 정의</h4>
<p>재밍 점유율 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>을 다음으로 정의한다.
<span class="math display">\[\phi_{\mathrm{jam}}
:=
\frac{N_{\mathrm{vp}}\,v_{\mathrm{vp}}}{V_{\mathrm{cell}}}.
\label{eq:S12_01_phijam_def}\]</span>
정의 <a data-reference="eq:S12_01_phijam_def" data-reference-type="eqref" href="#eq:S12_01_phijam_def">[eq:S12_01_phijam_def]</a>에서 <span class="math inline">\(V_{\mathrm{cell}}\)</span>은 <a data-reference="eq:S12_01_Vcell" data-reference-type="eqref" href="#eq:S12_01_Vcell">[eq:S12_01_Vcell]</a>, <span class="math inline">\(v_{\mathrm{vp}}\)</span>는 <a data-reference="eq:S12_01_vvp_sphere" data-reference-type="eqref" href="#eq:S12_01_vvp_sphere">[eq:S12_01_vvp_sphere]</a>, <span class="math inline">\(N_{\mathrm{vp}}\)</span>는 <a data-reference="eq:S12_01_Nvp" data-reference-type="eqref" href="#eq:S12_01_Nvp">[eq:S12_01_Nvp]</a>로 각각 잠긴 정의를 참조한다.</p>
<h4 data-number="14.3.5.2" id="재밍-상태에서의-측정-조건레짐-조건"><span class="header-section-number">14.3.5.2</span> 12.1.5.2 재밍 상태에서의 측정 조건(레짐 조건)</h4>
<p><span class="math inline">\(\phi_{\mathrm{jam}}\)</span>의 이름은 “재밍 상태에서 기록된 점유율”을 뜻하므로, 다음 레짐 조건이 동시에 만족될 때에만 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>을 기록한다.</p>
<ol>
<li><p>전파 스위치(강성 스위치): <span class="math inline">\(\chi_{\mathrm{ST}}=1\)</span>.</p></li>
<li><p>비침투 및 완화 성공: 좌표/배치가 비침투를 위반하지 않고, 잠긴 완화 절차가 종료 조건을 만족.</p></li>
<li><p>셀/대표점/포함 규칙 잠금: <a data-reference="eq:S12_01_cell_domain" data-reference-type="eqref" href="#eq:S12_01_cell_domain">[eq:S12_01_cell_domain]</a>, <a data-reference="eq:S12_01_indicator_in" data-reference-type="eqref" href="#eq:S12_01_indicator_in">[eq:S12_01_indicator_in]</a>이 동일 lock_id에서 유지.</p></li>
</ol>
<p>위 조건이 하나라도 성립하지 않으면 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>은 “재밍 점유율”로 기록될 수 없으며, 한계 결론(CT-LIM)만 허용된다.</p>
<h3 data-number="14.3.6" id="정준-고정-이유ssotno-tuning-관점"><span class="header-section-number">14.3.6</span> 12.1.6 정준 고정 이유(SSOT/No-Tuning 관점)</h3>
<p>본 절의 정준 고정은 다음 이유로 잠긴다.</p>
<ol>
<li><p>셀 부피 <span class="math inline">\(V_{\mathrm{cell}}\)</span>은 <code>CELL-CUBE</code> 및 <span class="math inline">\(D_{\mathrm{anch}}\)</span> 의미(<code>edge</code>)가 잠긴 경우에만 단일 값으로 결정된다. 셀 기하를 혼합하면 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>이 임의로 변하므로 금지된다.</p></li>
<li><p>VP 점유부피는 <span class="math inline">\(a\)</span> 하나로 결정되어야 한다. 형상 자유도(<span class="math inline">\(\kappa_{\mathrm{vp}}\)</span>)가 풀리면 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>을 결과에 맞춰 조정할 경로가 생기므로, 정준 닫힘 <a data-reference="eq:S12_01_kappa_sphere" data-reference-type="eqref" href="#eq:S12_01_kappa_sphere">[eq:S12_01_kappa_sphere]</a>로 봉인한다.</p></li>
<li><p>포함 규칙(센터-인-셀)과 경계 타이브레이크는 카운트 <span class="math inline">\(N_{\mathrm{vp}}\)</span>를 결정하므로, 규칙이 바뀌면 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>이 소급 변경된다. 따라서 포함 규칙은 사전 등록되어야 하며, 사후 변경은 금지된다.</p></li>
</ol>
<h3 data-number="14.3.7" id="즉시-fail-조건혼동사후조정"><span class="header-section-number">14.3.7</span> 12.1.7 즉시 FAIL 조건(혼동/사후조정)</h3>
<p>다음 위반은 즉시 <code>FAIL</code>로 처리한다.</p>
<ol>
<li><p>셀 기하 혼용(<code>CELL-CUBE</code>와 시각화 구형 셀의 혼합) 또는 <span class="math inline">\(D_{\mathrm{anch}}\)</span>의 의미(모서리/지름/반지름) 혼용.</p></li>
<li><p><span class="math inline">\(a\)</span>를 반지름처럼 사용하거나, <span class="math inline">\(v_{\mathrm{vp}}\)</span>에서 <span class="math inline">\(\kappa_{\mathrm{vp}}\)</span>를 사후 변경(또는 다른 형태로 재정의)하는 행위.</p></li>
<li><p>포함 규칙 또는 경계 타이브레이크의 사후 변경, 또는 유리한 실행만 선택하여 <span class="math inline">\(N_{\mathrm{vp}}\)</span>를 보고하는 행위.</p></li>
<li><p>lock_id 혼합 또는 봉인(manifest/checksums/registry_snapshot) 없는 좌표/그래프/카운트의 사용.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-59">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 정준 셀 부피 <span class="math inline">\(V_{\mathrm{cell}}=D_{\mathrm{anch}}^3\)</span>, VP 유효부피 <span class="math inline">\(v_{\mathrm{vp}}=(\pi/6)a^3\)</span>, 포함 규칙(센터-인-셀) 및 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span> 정의를 <code>canon_lock</code>/<code>analysis_lock</code>/<code>realization_lock</code>에 고정.</p></li>
<li><p>Gate: 셀 기하/지름-반지름 혼동은 G-SYM에서 즉시 <code>FAIL</code>; 포함 규칙/형상계수 사후 변경은 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 재밍 레짐 조건(<span class="math inline">\(\chi_{\mathrm{ST}}=1\)</span> 및 완화 성공) 미충족은 G-REG에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
<li><p>Gate: 좌표/카운트/보고서가 <code>manifest+checksums</code>로 봉인되지 않으면 G-REP에서 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
</ul>
<h2 data-number="14.4" id="전자-1초-재구성식"><span class="header-section-number">14.4</span> 12.2 “전자 1초” 재구성식</h2>
<h3 data-number="14.4.1" id="입력lock과-참조-정의"><span class="header-section-number">14.4.1</span> 12.2.1 입력(LOCK)과 참조 정의</h3>
<p>본 절은 다음 입력이 잠겨 있다고 둔다.</p>
<ol>
<li><p>실현 시간 틱(단위: s):
<span class="math display">\[\Delta t \ \text{(잠김)}.
  \label{eq:S12_02_dt_lock}\]</span></p></li>
<li><p>전자 정준 사건율(정의):
<span class="math display">\[\nu_{e,\mathrm{can}} := 1.
  \label{eq:S12_02_nue_can}\]</span></p></li>
<li><p>정류 계수(보편 레짐에서의 잠김):
<span class="math display">\[\delta := \frac{1}{\pi^2}.
  \label{eq:S12_02_delta_lock}\]</span></p></li>
<li><p>사건 로그의 필수 필드(9.1의 운영정의):
각 사건 <span class="math inline">\(e\)</span>는 최소한 <span class="math inline">\((n(e),\theta(e),\varphi(e))\)</span>를 갖고, <span class="math inline">\(\theta(e),\varphi(e)\in[0,2\pi)\)</span>가 정의 가능해야 한다.</p></li>
</ol>
<p>반파 정류 연산자와 생존 가중치를 다음으로 정의한다.
<span class="math display">\[_+ := \max(0,x),
\qquad
w(e) := [\cos\theta(e)]_+\,[\cos\varphi(e)]_+.
\label{eq:S12_02_w_def}\]</span></p>
<h3 data-number="14.4.2" id="틱-기반-1초-창의-재구성정수-틱-창"><span class="header-section-number">14.4.2</span> 12.2.2 틱 기반 “1초” 창의 재구성(정수 틱 창)</h3>
<h4 data-number="14.4.2.1" id="d-12.2-1-실현-시간과-틱"><span class="header-section-number">14.4.2.1</span> [D-12.2-1] 실현 시간과 틱</h4>
<p>틱 <span class="math inline">\(n\in\mathbb{Z}\)</span>에 대응하는 실현 시간을
<span class="math display">\[t := n\,\Delta t
\label{eq:S12_02_time_map}\]</span>
로 정의한다.</p>
<h4 data-number="14.4.2.2" id="d-12.2-2-1초-틱-창-길이의-결정-규칙"><span class="header-section-number">14.4.2.2</span> [D-12.2-2] 1초 틱 창 길이의 결정 규칙</h4>
<p>실현 시간 <span class="math inline">\(1\,\mathrm{s}\)</span>에 대응하는 정수 틱 길이를 다음 규칙으로 정의한다.
<span class="math display">\[\Delta N_{1\mathrm{s}} := \left\lfloor \frac{1\,\mathrm{s}}{\Delta t}\right\rfloor.
\label{eq:S12_02_DN1s}\]</span>
따라서 틱 기반으로 재구성된 “1초” 시간 길이는
<span class="math display">\[\widehat{T}_{\mathrm{tick}}(1\mathrm{s})
:= \Delta N_{1\mathrm{s}}\,\Delta t.
\label{eq:S12_02_Ttick}\]</span></p>
<h4 data-number="14.4.2.3" id="d-12.2-3-잔차반올림-오차-정의"><span class="header-section-number">14.4.2.3</span> [D-12.2-3] 잔차(반올림 오차) 정의</h4>
<p>정의 <a data-reference="eq:S12_02_DN1s" data-reference-type="eqref" href="#eq:S12_02_DN1s">[eq:S12_02_DN1s]</a>에 의해 다음 잔차가 자동으로 결정된다.
<span class="math display">\[\varepsilon_{\mathrm{tick}}
:=
1\,\mathrm{s}-\widehat{T}_{\mathrm{tick}}(1\mathrm{s})
=
1\,\mathrm{s}-\Delta N_{1\mathrm{s}}\Delta t,
\label{eq:S12_02_eps_tick}\]</span>
그리고 바닥함수의 성질로
<span class="math display">\[0 \le \varepsilon_{\mathrm{tick}} &lt; \Delta t
\label{eq:S12_02_eps_bound}\]</span>
가 성립한다. <a data-reference="eq:S12_02_eps_bound" data-reference-type="eqref" href="#eq:S12_02_eps_bound">[eq:S12_02_eps_bound]</a>는 정수 틱 창을 사용한 경우의 결정적 상계이다.</p>
<h3 data-number="14.4.3" id="사건-카운트전자-정의-원시정류-카운트"><span class="header-section-number">14.4.3</span> 12.2.3 사건 카운트(전자) 정의: 원시/정류 카운트</h3>
<h4 data-number="14.4.3.1" id="d-12.2-4-틱-창과-전자-시도-사건-집합"><span class="header-section-number">14.4.3.1</span> [D-12.2-4] 틱 창과 전자 시도 사건 집합</h4>
<p>임의의 틱 창 <span class="math inline">\(W[n_1,n_2)\)</span>를 다음으로 정의한다.
<span class="math display">\[W[n_1,n_2) := \{\,n\in\mathbb{Z}\mid n_1\le n&lt;n_2\,\},
\qquad
\Delta N:=n_2-n_1,
\qquad
\Delta T := \Delta N\,\Delta t.
\label{eq:S12_02_window}\]</span>
전자 시도 사건 집합을 다음으로 정의한다.
<span class="math display">\[\mathcal{E}_{0,e}[n_1,n_2)
:=
\{\,e\mid n_1\le n(e)&lt;n_2,\ \mathrm{Trig}_{0,e}(e)=1\,\}.
\label{eq:S12_02_E0e}\]</span>
<span class="math inline">\(\mathrm{Trig}_{0,e}\)</span>는 전자 시도 사건 트리거이며 <code>analysis_lock</code>에 잠긴다.</p>
<p>원시 전자 사건 카운트를 다음으로 정의한다.
<span class="math display">\[N_{0,e}[n_1,n_2)
:=\left|\mathcal{E}_{0,e}[n_1,n_2)\right|.
\label{eq:S12_02_N0e}\]</span></p>
<h4 data-number="14.4.3.2" id="d-12.2-5-정류생존-전자-사건-카운트"><span class="header-section-number">14.4.3.2</span> [D-12.2-5] 정류(생존) 전자 사건 카운트</h4>
<p>정류 전자 사건 카운트를 다음으로 정의한다.
<span class="math display">\[N_{e}[n_1,n_2)
:=
\sum_{e\in\mathcal{E}_{0,e}[n_1,n_2)} w(e)
=
\sum_{e\in\mathcal{E}_{0,e}[n_1,n_2)}
[\cos\theta(e)]_+[\cos\varphi(e)]_+.
\label{eq:S12_02_Ne}\]</span>
정의상
<span class="math display">\[0\le N_{e}[n_1,n_2)\le N_{0,e}[n_1,n_2)
\label{eq:S12_02_bounds_counts}\]</span>
가 성립한다.</p>
<h3 data-number="14.4.4" id="전자-1초-재구성식틱사건-두-형태"><span class="header-section-number">14.4.4</span> 12.2.4 “전자 1초” 재구성식(틱/사건 두 형태)</h3>
<p>본 절은 “전자 1초”를 두 가지 동치적(단, Gate 통과 시) 형태로 재구성하여 고정한다.</p>
<h4 data-number="14.4.4.1" id="틱-기반-재구성식"><span class="header-section-number">14.4.4.1</span> 12.2.4.1 틱 기반 재구성식</h4>
<p>틱 기반 “전자 1초”는 <a data-reference="eq:S12_02_Ttick" data-reference-type="eqref" href="#eq:S12_02_Ttick">[eq:S12_02_Ttick]</a>로 정의된 시간 길이이다.
<span class="math display">\[T_{e,1\mathrm{s}}^{(\mathrm{tick})}
:=\widehat{T}_{\mathrm{tick}}(1\mathrm{s})
=\Delta N_{1\mathrm{s}}\Delta t.
\label{eq:S12_02_e1s_tick}\]</span></p>
<h4 data-number="14.4.4.2" id="사건-기반-재구성식"><span class="header-section-number">14.4.4.2</span> 12.2.4.2 사건 기반 재구성식</h4>
<p>전자 정준 사건율이 <a data-reference="eq:S12_02_nue_can" data-reference-type="eqref" href="#eq:S12_02_nue_can">[eq:S12_02_nue_can]</a>로 잠겼으므로, 사건 기반 시간 재구성식을 다음으로 정의한다.
<span class="math display">\[T_{e}^{(\mathrm{event})}[n_1,n_2)
:=
\frac{N_{e}[n_1,n_2)}{\nu_{e,\mathrm{can}}}
=
N_{e}[n_1,n_2).
\label{eq:S12_02_Tevent_def}\]</span>
따라서 “전자 1초”의 사건 기반 재구성식은 다음으로 고정한다.
<span class="math display">\[T_{e,1\mathrm{s}}^{(\mathrm{event})}
:=
N_{e}[n_1,n_2)
\quad\text{where}\quad
(n_2-n_1)=\Delta N_{1\mathrm{s}}.
\label{eq:S12_02_e1s_event}\]</span>
즉, 동일한 틱 창 길이 <span class="math inline">\(\Delta N_{1\mathrm{s}}\)</span>에서의 정류 전자 사건 카운트가 사건 기반 “1초”의 값으로 정의된다.</p>
<h3 data-number="14.4.5" id="기대값정준-정상성-공리-하의-평균-관계"><span class="header-section-number">14.4.5</span> 12.2.5 기대값(정준 정상성 공리 하의 평균 관계)</h3>
<p>본 절은 장시간 평균이 정착한다는 정준 정상성 공리(9.2의 [A-9.2-S1])가 적용되는 레짐에서, 기대값을 다음 관계로 고정한다.</p>
<h4 data-number="14.4.5.1" id="기대-정류-사건-카운트"><span class="header-section-number">14.4.5.1</span> 12.2.5.1 기대 정류 사건 카운트</h4>
<p>정의상 정준 사건율은
<span class="math display">\[\nu_{e,\mathrm{can}}
=
\lim_{\Delta T\to\infty}\frac{N_{e}}{\Delta T}
\label{eq:S12_02_rate_limit}\]</span>
이므로, 정준 정상성 레짐에서 기대값 관계를 다음으로 기록한다.
<span class="math display">\[\mathbb{E}\!\left[N_{e}[n_1,n_2)\right]
=
\nu_{e,\mathrm{can}}\ \Delta T.
\label{eq:S12_02_ENe}\]</span>
여기서 <span class="math inline">\(\Delta T=(n_2-n_1)\Delta t\)</span>이다.</p>
<p>전자 정준 <span class="math inline">\(\nu_{e,\mathrm{can}}=1\)</span>을 대입하면,
<span class="math display">\[\mathbb{E}\!\left[N_{e}[n_1,n_2)\right]
=
\Delta T.
\label{eq:S12_02_ENe_simple}\]</span></p>
<h4 data-number="14.4.5.2" id="초-창에서의-기대값"><span class="header-section-number">14.4.5.2</span> 12.2.5.2 1초 창에서의 기대값</h4>
<p>특히 <span class="math inline">\(\Delta T=1\,\mathrm{s}\)</span>인 창에서,
<span class="math display">\[\mathbb{E}\!\left[N_{e}(1\mathrm{s})\right]
=
\nu_{e,\mathrm{can}}\cdot 1\,\mathrm{s}
=
1.
\label{eq:S12_02_ENe_1s}\]</span>
틱 기반 정수 창을 사용하는 경우에는 <span class="math inline">\(\Delta T=\widehat{T}_{\mathrm{tick}}(1\mathrm{s})\)</span>이므로,
<span class="math display">\[\mathbb{E}\!\left[N_{e}^{(\mathrm{tick})}\right]
=
\widehat{T}_{\mathrm{tick}}(1\mathrm{s})
=
\Delta N_{1\mathrm{s}}\Delta t.
\label{eq:S12_02_ENe_tick}\]</span></p>
<h4 data-number="14.4.5.3" id="원시-사건-카운트의-기대값참조-관계"><span class="header-section-number">14.4.5.3</span> 12.2.5.3 원시 사건 카운트의 기대값(참조 관계)</h4>
<p>정준 사건율 법칙 <span class="math inline">\(\nu_{\mathrm{can}}=s\cdot\delta\)</span>를 전자에 적용하면
<span class="math display">\[\nu_{e,\mathrm{can}}=s_e\cdot\delta,
\qquad
\nu_{e,\mathrm{can}}=1
\ \Longrightarrow\
s_e=\frac{1}{\delta}.
\label{eq:S12_02_se}\]</span>
따라서 원시 사건 카운트의 기대값은
<span class="math display">\[\mathbb{E}\!\left[N_{0,e}[n_1,n_2)\right]
=
s_e\,\Delta T
=
\frac{\Delta T}{\delta}.
\label{eq:S12_02_EN0e}\]</span>
보편 레짐에서 <span class="math inline">\(\delta=1/\pi^2\)</span>가 잠긴 경우에는
<span class="math display">\[\mathbb{E}\!\left[N_{0,e}(1\mathrm{s})\right]
=
\frac{1}{\delta}
=
\pi^2.
\label{eq:S12_02_EN0e_1s}\]</span>
<a data-reference="eq:S12_02_EN0e_1s" data-reference-type="eqref" href="#eq:S12_02_EN0e_1s">[eq:S12_02_EN0e_1s]</a>는 “1초 창에서의 전자 원시 시도 사건 수의 기대값”을 뜻하며, <span class="math inline">\(\delta\)</span> 보편성 공리가 깨지는 레짐에서는 사용할 수 없다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-60">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(\nu_{e,\mathrm{can}}:=1\)</span>, <span class="math inline">\(w(e)=[\cos\theta]_+[\cos\varphi]_+\)</span>, <span class="math inline">\(\delta=1/\pi^2\)</span> (보편 레짐) 및 <span class="math inline">\(\Delta t\)</span>를 각각 <code>canon_lock</code>/<code>analysis_lock</code>/<code>realization_lock</code>에 고정.</p></li>
<li><p>Gate: 사건 로그 필수 필드 누락 또는 <span class="math inline">\(\mathrm{Trig}_{0,e}\)</span> 미잠금은 G-LOCK에서 <code>INCONCLUSIVE</code>; 의미 충돌은 G-SYM에서 <code>FAIL</code>.</p></li>
<li><p>Gate: <span class="math inline">\(\delta\)</span> 보편성 트리거 위반 시 <a data-reference="eq:S12_02_EN0e_1s" data-reference-type="eqref" href="#eq:S12_02_EN0e_1s">[eq:S12_02_EN0e_1s]</a> 사용 금지(G-RECT 연동).</p></li>
<li><p>Gate: <span class="math inline">\(\Delta N_{1\mathrm{s}}\)</span> 규칙(<a data-reference="eq:S12_02_DN1s" data-reference-type="eqref" href="#eq:S12_02_DN1s">[eq:S12_02_DN1s]</a>) 및 창 정의(<a data-reference="eq:S12_02_window" data-reference-type="eqref" href="#eq:S12_02_window">[eq:S12_02_window]</a>)의 사후 변경은 G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 본 절 산출 로그(카운트/창/lock_refs)가 <code>manifest+checksums</code>로 봉인되지 않으면 G-REP에서 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
</ul>
<h2 data-number="14.5" id="phi_mathrmjam-측정lock오차예산반증-트리거"><span class="header-section-number">14.5</span> 12.3 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span> 측정·LOCK·오차예산·반증 트리거</h2>
<h3 data-number="14.5.1" id="목적-13"><span class="header-section-number">14.5.1</span> 12.3.1 목적</h3>
<p>본 절은 재밍 점유율 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>을 (i) 로그 가능한 운영정의로 측정하고, (ii) 동일 버전 내부에서 변하지 않도록 LOCK으로 봉인하며, (iii) 민감도(오차예산)와 (iv) 반증 트리거(깨지는 조건)를 Gate로 연결하여 판정하는 규약을 고정한다.</p>
<h3 data-number="14.5.2" id="정의-phi_mathrmjam의-표준식단일-출처"><span class="header-section-number">14.5.2</span> 12.3.2 정의: <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>의 표준식(단일 출처)</h3>
<h4 data-number="14.5.2.1" id="정준-셀-부피"><span class="header-section-number">14.5.2.1</span> 12.3.2.1 정준 셀 부피</h4>
<p>정준 셀은 <code>CELL-CUBE</code>로 잠기며, 셀 대표 길이 <span class="math inline">\(D_{\mathrm{anch}}\)</span>는 <code>edge</code>로 잠긴다. 셀 부피를 다음으로 정의한다.
<span class="math display">\[V_{\mathrm{cell}} := D_{\mathrm{anch}}^{3}.
\label{eq:S12_03_Vcell}\]</span></p>
<h4 data-number="14.5.2.2" id="vp-유효-점유부피정준-닫힘"><span class="header-section-number">14.5.2.2</span> 12.3.2.2 VP 유효 점유부피(정준 닫힘)</h4>
<p>실현 길이 스케일 <span class="math inline">\(a\)</span>는 VP 지름(<code>diameter</code>)으로 잠긴다. VP 유효 점유부피를 다음으로 정의한다.
<span class="math display">\[v_{\mathrm{vp}} := \kappa_{\mathrm{vp}}\,a^{3},
\qquad
\kappa_{\mathrm{vp}}:=\frac{\pi}{6}.
\label{eq:S12_03_vvp}\]</span>
<span class="math inline">\(\kappa_{\mathrm{vp}}\)</span>는 정준 부피 닫힘이며 동일 버전 내부에서 변경되지 않는다.</p>
<h4 data-number="14.5.2.3" id="셀-내부-vp-카운트"><span class="header-section-number">14.5.2.3</span> 12.3.2.3 셀 내부 VP 카운트</h4>
<p>VP 대표점(센터) <span class="math inline">\(\mathbf{x}_i\)</span>가 잠긴 규약으로 정의되어 있다고 두고, 정준 셀 도메인 <span class="math inline">\(\mathcal{D}_{\square}\)</span>를
<span class="math display">\[\mathcal{D}_{\square}
:=
\left\{\mathbf{x}\in\mathbb{R}^3\ \big|\ 0\le x&lt; D_{\mathrm{anch}},\ 0\le y&lt; D_{\mathrm{anch}},\ 0\le z&lt; D_{\mathrm{anch}}\right\}
\label{eq:S12_03_Dsquare}\]</span>
로 둔다. 포함 지시함수를 다음으로 정의한다.
<span class="math display">\[\mathbf{1}_{\mathrm{in}}(i)
:=
\begin{cases}
1,&amp; \mathbf{x}_i\in \mathcal{D}_{\square},\\
0,&amp; \text{otherwise}.
\end{cases}
\label{eq:S12_03_indicator}\]</span>
경계(면/모서리/꼭짓점)에 정확히 놓인 경우의 처리(포함/배제)는 사전 등록된 타이브레이크 규칙으로 잠긴다.</p>
<p>셀 내부 VP 카운트를 다음으로 정의한다.
<span class="math display">\[N_{\mathrm{vp}} := \sum_{i\in\mathcal{V}}\mathbf{1}_{\mathrm{in}}(i).
\label{eq:S12_03_Nvp}\]</span></p>
<h4 data-number="14.5.2.4" id="재밍-점유율"><span class="header-section-number">14.5.2.4</span> 12.3.2.4 재밍 점유율</h4>
<p>재밍 점유율을 다음으로 정의한다.
<span class="math display">\[\phi_{\mathrm{jam}}
:=
\frac{N_{\mathrm{vp}}\,v_{\mathrm{vp}}}{V_{\mathrm{cell}}}
=
\frac{N_{\mathrm{vp}}\left(\frac{\pi}{6}\right)a^{3}}{D_{\mathrm{anch}}^{3}}.
\label{eq:S12_03_phijam}\]</span>
정의 <a data-reference="eq:S12_03_phijam" data-reference-type="eqref" href="#eq:S12_03_phijam">[eq:S12_03_phijam]</a>이 본 절의 유일 출처이며, 다른 절에서 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>을 재정의하지 않는다.</p>
<h3 data-number="14.5.3" id="측정-절차상태-스냅샷-기반"><span class="header-section-number">14.5.3</span> 12.3.3 측정 절차(상태 스냅샷 기반)</h3>
<h4 data-number="14.5.3.1" id="측정-상태-집합"><span class="header-section-number">14.5.3.1</span> 12.3.3.1 측정 상태 집합</h4>
<p>측정은 완결 상태 스냅샷 집합 <span class="math inline">\(\mathcal{S}_{\mathrm{obs}}\)</span> 위에서 수행한다.
<span class="math display">\[\mathcal{S}_{\mathrm{obs}}:=\{\,S[n]\mid n\in W_{\mathrm{obs}}\ \wedge\ \mathrm{Complete}(S[n])=1\,\},
\label{eq:S12_03_Sobs}\]</span>
여기서 <span class="math inline">\(W_{\mathrm{obs}}\)</span>는 관측 틱 창이며, <span class="math inline">\(\mathrm{Complete}(S[n])\)</span>는 상태 로그 완결성 판정이다(9.1의 운영정의에 의해 잠김).</p>
<h4 data-number="14.5.3.2" id="상태별-phi_mathrmjam-계산"><span class="header-section-number">14.5.3.2</span> 12.3.3.2 상태별 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span> 계산</h4>
<p>각 <span class="math inline">\(S[n]\in\mathcal{S}_{\mathrm{obs}}\)</span>에 대해,</p>
<ol>
<li><p><span class="math inline">\(D_{\mathrm{anch}}\)</span> 참조(값은 <code>canon_lock</code>에서 읽음).</p></li>
<li><p><span class="math inline">\(a\)</span> 참조(값은 <code>realization_lock</code>에서 읽음).</p></li>
<li><p>좌표 집합에서 <span class="math inline">\(\mathbf{x}_i\)</span>를 읽고 <a data-reference="eq:S12_03_indicator" data-reference-type="eqref" href="#eq:S12_03_indicator">[eq:S12_03_indicator]</a>로 <span class="math inline">\(\mathbf{1}_{\mathrm{in}}(i)\)</span>를 계산.</p></li>
<li><p><a data-reference="eq:S12_03_Nvp" data-reference-type="eqref" href="#eq:S12_03_Nvp">[eq:S12_03_Nvp]</a>로 <span class="math inline">\(N_{\mathrm{vp}}(n)\)</span> 계산.</p></li>
<li><p><a data-reference="eq:S12_03_phijam" data-reference-type="eqref" href="#eq:S12_03_phijam">[eq:S12_03_phijam]</a>로 <span class="math inline">\(\phi_{\mathrm{jam}}(n)\)</span> 계산.</p></li>
</ol>
<p>따라서 상태별 점유율은
<span class="math display">\[\phi_{\mathrm{jam}}(n)
=
\frac{N_{\mathrm{vp}}(n)\left(\frac{\pi}{6}\right)a^{3}}{D_{\mathrm{anch}}^{3}}.
\label{eq:S12_03_phijam_n}\]</span></p>
<h4 data-number="14.5.3.3" id="창-집계선택적"><span class="header-section-number">14.5.3.3</span> 12.3.3.3 창 집계(선택적)</h4>
<p>집계 규칙(평균/중앙값/상위-하위 절단 등)은 <code>analysis_lock</code>에 잠긴다. 평균 집계를 채택하는 경우,
<span class="math display">\[\overline{\phi}_{\mathrm{jam}}
:=
\frac{1}{|\mathcal{S}_{\mathrm{obs}}|}\sum_{S[n]\in\mathcal{S}_{\mathrm{obs}}}\phi_{\mathrm{jam}}(n),
\qquad
|\mathcal{S}_{\mathrm{obs}}|&gt;0.
\label{eq:S12_03_phi_mean}\]</span>
분산(변동성) 지표를 다음으로 정의한다.
<span class="math display">\[\sigma_{\phi}^2
:=
\frac{1}{|\mathcal{S}_{\mathrm{obs}}|}\sum_{S[n]\in\mathcal{S}_{\mathrm{obs}}}\left(\phi_{\mathrm{jam}}(n)-\overline{\phi}_{\mathrm{jam}}\right)^2,
\qquad
\sigma_{\phi}:=\sqrt{\sigma_{\phi}^2}.
\label{eq:S12_03_phi_var}\]</span></p>
<h3 data-number="14.5.4" id="민감도오차예산-정의"><span class="header-section-number">14.5.4</span> 12.3.4 민감도(오차예산) 정의</h3>
<p>본 절은 두 종류의 오차원을 분리하여 기록한다.</p>
<ol>
<li><p><strong>입력 스케일 오차</strong>: <span class="math inline">\(D_{\mathrm{anch}}\)</span>, <span class="math inline">\(a\)</span>에 부여된 불확도(해당 lock에 기록될 수 있음).</p></li>
<li><p><strong>카운트/판정 오차</strong>: <span class="math inline">\(N_{\mathrm{vp}}\)</span> 계산에서의 경계/대표점/포함 규칙에 의해 발생 가능한 불확도(사전 등록된 판정 규약으로만 평가).</p></li>
</ol>
<h4 data-number="14.5.4.1" id="미분-기반-민감도일반식"><span class="header-section-number">14.5.4.1</span> 12.3.4.1 미분 기반 민감도(일반식)</h4>
<p><a data-reference="eq:S12_03_phijam" data-reference-type="eqref" href="#eq:S12_03_phijam">[eq:S12_03_phijam]</a>에서 <span class="math inline">\(\phi_{\mathrm{jam}}=\phi(N_{\mathrm{vp}},a,D_{\mathrm{anch}})\)</span>로 두면,
<span class="math display">\[\phi_{\mathrm{jam}}
=
\left(\frac{\pi}{6}\right)\,N_{\mathrm{vp}}\left(\frac{a}{D_{\mathrm{anch}}}\right)^3.
\label{eq:S12_03_phi_compact}\]</span>
따라서 편미분은
<span class="math display">\[\frac{\partial \phi_{\mathrm{jam}}}{\partial N_{\mathrm{vp}}}=\frac{\phi_{\mathrm{jam}}}{N_{\mathrm{vp}}},
\qquad
\frac{\partial \phi_{\mathrm{jam}}}{\partial a}=3\frac{\phi_{\mathrm{jam}}}{a},
\qquad
\frac{\partial \phi_{\mathrm{jam}}}{\partial D_{\mathrm{anch}}}=-3\frac{\phi_{\mathrm{jam}}}{D_{\mathrm{anch}}}.
\label{eq:S12_03_sens_partials}\]</span>
상대 민감도(1차)는
<span class="math display">\[\frac{d\phi_{\mathrm{jam}}}{\phi_{\mathrm{jam}}}
=
\frac{dN_{\mathrm{vp}}}{N_{\mathrm{vp}}}
+
3\frac{da}{a}
-
3\frac{dD_{\mathrm{anch}}}{D_{\mathrm{anch}}}.
\label{eq:S12_03_rel_sens}\]</span>
<span class="math inline">\(\kappa_{\mathrm{vp}}=\pi/6\)</span>은 정준 닫힘으로 잠겼으므로 동일 버전 내부에서 <span class="math inline">\(d\kappa_{\mathrm{vp}}=0\)</span>이다.</p>
<h4 data-number="14.5.4.2" id="카운트-불확도경계-모호-카운트"><span class="header-section-number">14.5.4.2</span> 12.3.4.2 카운트 불확도(경계-모호 카운트)</h4>
<p>경계 모호 구간 폭 <span class="math inline">\(\epsilon_b&gt;0\)</span>를 사전 등록하여 잠근다(길이 단위, 내부 또는 실현 단위 중 하나로 고정).
경계에 가까운 VP 수를 다음으로 정의한다.
<span class="math display">\[N_{\mathrm{amb}}
:=
\#\left\{\, i\ \middle|\ \mathrm{dist}\bigl(\mathbf{x}_i,\partial\mathcal{D}_{\square}\bigr)\le \epsilon_b \right\}.
\label{eq:S12_03_Namb}\]</span>
여기서 <span class="math inline">\(\mathrm{dist}(\cdot,\partial\mathcal{D}_{\square})\)</span>는 점과 셀 경계 사이의 최소거리이며, 계산 규약은 <code>analysis_lock</code>에 잠긴다.
최악-경우 카운트 불확도를 다음으로 정의한다.
<span class="math display">\[\Delta N_{\mathrm{vp}}^{(\max)} := N_{\mathrm{amb}}.
\label{eq:S12_03_dN_worst}\]</span>
그러면 최악-경우 상대 오차 상계는
<span class="math display">\[\left|\frac{\Delta \phi_{\mathrm{jam}}}{\phi_{\mathrm{jam}}}\right|
\le
\frac{\Delta N_{\mathrm{vp}}^{(\max)}}{N_{\mathrm{vp}}}
+
3\left|\frac{\Delta a}{a}\right|
+
3\left|\frac{\Delta D_{\mathrm{anch}}}{D_{\mathrm{anch}}}\right|
\label{eq:S12_03_rel_bound}\]</span>
로 기록한다. <span class="math inline">\(\Delta a,\Delta D_{\mathrm{anch}}\)</span>는 각 lock에 기록된 불확도 또는 사전 등록된 불확도 규약에 의해 산출되며, 미기록이면 0으로 처리할 수 있으나(선택 규약), 선택 규약 자체가 사전 등록되어야 한다.</p>
<h4 data-number="14.5.4.3" id="반복-창-변동성드리프트-예산"><span class="header-section-number">14.5.4.3</span> 12.3.4.3 반복 창 변동성(드리프트 예산)</h4>
<p>관측 창을 <span class="math inline">\(M\ge2\)</span>개 블록으로 분할하여 각 블록 평균 <span class="math inline">\(\overline{\phi}_m\)</span>을 계산하고, 변동성 지표를 다음으로 정의한다.
<span class="math display">\[\overline{\phi}_m := \frac{1}{|\mathcal{S}_m|}\sum_{S[n]\in\mathcal{S}_m}\phi_{\mathrm{jam}}(n),
\qquad
R_\phi:=\frac{\max_m \overline{\phi}_m-\min_m \overline{\phi}_m}{\max(\overline{\phi}_{\mathrm{jam}},\varepsilon_\phi)}.
\label{eq:S12_03_drift_metric}\]</span>
여기서 <span class="math inline">\(\varepsilon_\phi&gt;0\)</span>는 분모 보호 상수로 <code>analysis_lock</code>에 잠긴다. <span class="math inline">\(R_\phi\)</span>는 “창 간 드리프트” 지표이며, Gate 문턱과 연결된다(12.3.5).</p>
<h3 data-number="14.5.5" id="반증-트리거fail-조건와-gate"><span class="header-section-number">14.5.5</span> 12.3.5 반증 트리거(FAIL 조건)와 Gate</h3>
<p>본 절은 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>의 정의/측정/봉인 체계가 깨지는 조건을 반증 트리거로 정의하고, FAIL 라벨로 기록한다.</p>
<h4 data-number="14.5.5.1" id="트리거-f1-레짐-위반재밍-아님"><span class="header-section-number">14.5.5.1</span> 12.3.5.1 트리거 F1: 레짐 위반(재밍 아님)</h4>
<p>재밍 점유율은 재밍 레짐에서만 기록된다. 재밍 판정 지시변수(강성 스위치)가 다음을 만족하지 않으면 즉시 실패이다.
<span class="math display">\[\chi_{\mathrm{ST}}\neq 1
\quad\Longrightarrow\quad
\texttt{FAIL-PHIJAM-REGIME}.
\label{eq:S12_03_fail_regime}\]</span></p>
<h4 data-number="14.5.5.2" id="트리거-f2-비침투완화-위반"><span class="header-section-number">14.5.5.2</span> 12.3.5.2 트리거 F2: 비침투/완화 위반</h4>
<p>좌표 배치가 비침투(최소 분리) 조건을 위반하면 셀/VP 부피 집계는 재밍 상태로 인정되지 않는다. 최소 분리 길이 <span class="math inline">\(d_{\min}\)</span>과 허용오차 <span class="math inline">\(\varepsilon_{\mathrm{pos}}\)</span>가 잠겨 있을 때,
<span class="math display">\[\min_{i&lt;j}\|\mathbf{x}_i-\mathbf{x}_j\| &lt; d_{\min}-\varepsilon_{\mathrm{pos}}
\quad\Longrightarrow\quad
\texttt{FAIL-PHIJAM-OVERLAP}.
\label{eq:S12_03_fail_overlap}\]</span></p>
<h4 data-number="14.5.5.3" id="트리거-f3-범위-위반불가능-값"><span class="header-section-number">14.5.5.3</span> 12.3.5.3 트리거 F3: 범위 위반(불가능 값)</h4>
<p>정의 <a data-reference="eq:S12_03_phijam" data-reference-type="eqref" href="#eq:S12_03_phijam">[eq:S12_03_phijam]</a>에 의해 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>은 음수가 될 수 없다. 또한 셀 부피 대비 점유부피 비율이 비정상적으로 커지는 경우는 정의 충돌 또는 카운트/스케일 오류로 처리한다. 상한 문턱 <span class="math inline">\(\phi_{\max}&gt;0\)</span>를 <code>gate_lock</code>에 잠근다.
<span class="math display">\[\phi_{\mathrm{jam}}&lt;0
\ \ \text{또는}\ \
\phi_{\mathrm{jam}}&gt;\phi_{\max}
\quad\Longrightarrow\quad
\texttt{FAIL-PHIJAM-RANGE}.
\label{eq:S12_03_fail_range}\]</span></p>
<h4 data-number="14.5.5.4" id="트리거-f4-경계-모호-폭-과다"><span class="header-section-number">14.5.5.4</span> 12.3.5.4 트리거 F4: 경계 모호 폭 과다</h4>
<p>경계 모호 카운트 비율 문턱 <span class="math inline">\(\eta_{\mathrm{amb}}\in(0,1)\)</span>를 <code>gate_lock</code>에 잠근다.
<span class="math display">\[\frac{N_{\mathrm{amb}}}{\max(N_{\mathrm{vp}},1)} &gt; \eta_{\mathrm{amb}}
\quad\Longrightarrow\quad
\texttt{FAIL-PHIJAM-AMB}.
\label{eq:S12_03_fail_amb}\]</span>
이는 포함 규칙이 잠겨 있더라도 경계 근접 샘플이 과도하여 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>이 안정적으로 정의되기 어렵다는 반증 트리거이다.</p>
<h4 data-number="14.5.5.5" id="트리거-f5-드리프트정상상태-붕괴"><span class="header-section-number">14.5.5.5</span> 12.3.5.5 트리거 F5: 드리프트(정상상태 붕괴)</h4>
<p>드리프트 문턱 <span class="math inline">\(\varepsilon_{\mathrm{drift}}&gt;0\)</span>를 <code>gate_lock</code>에 잠근다.
<span class="math display">\[R_\phi &gt; \varepsilon_{\mathrm{drift}}
\quad\Longrightarrow\quad
\texttt{FAIL-PHIJAM-DRIFT}.
\label{eq:S12_03_fail_drift}\]</span>
<a data-reference="eq:S12_03_fail_drift" data-reference-type="eqref" href="#eq:S12_03_fail_drift">[eq:S12_03_fail_drift]</a>는 관측 구간에서 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>이 정상상태로 정착하지 않았음을 의미한다.</p>
<h4 data-number="14.5.5.6" id="트리거-f6-잠금봉인-위반"><span class="header-section-number">14.5.5.6</span> 12.3.5.6 트리거 F6: 잠금/봉인 위반</h4>
<p>다음 중 하나라도 발생하면 즉시 실패이다.</p>
<ol>
<li><p><span class="math inline">\(D_{\mathrm{anch}}\)</span>의 의미(<code>edge</code>) 또는 셀 기하(<code>CELL-CUBE</code>) 혼용.</p></li>
<li><p><span class="math inline">\(a\)</span>의 의미(<code>diameter</code>) 또는 단위 혼용.</p></li>
<li><p><span class="math inline">\(\kappa_{\mathrm{vp}}\)</span> 값(또는 부피 모델) 사후 변경.</p></li>
<li><p>lock_id 혼합 또는 <code>manifest/checksums/registry_snapshot</code> 미봉인.</p></li>
</ol>
<p>위반 시 라벨을 다음으로 고정한다.
<span class="math display">\[\texttt{FAIL-PHIJAM-LOCK}.
\label{eq:S12_03_fail_lock}\]</span></p>
<h4 data-number="14.5.5.7" id="phi_mathrmjam-gate최종-판정"><span class="header-section-number">14.5.5.7</span> 12.3.5.7 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span> Gate(최종 판정)</h4>
<p>최종 Gate를 다음으로 정의한다.
<span class="math display">\[\texttt{G-PHIJAM}=\texttt{PASS}
\Longleftrightarrow
\left(
\chi_{\mathrm{ST}}=1
\right)
\wedge
\left(
\texttt{FAIL 트리거(F1--F6) 없음}
\right)
\wedge
\left(
\texttt{로그/봉인 완결}
\right).
\label{eq:S12_03_GPHIJAM}\]</span>
<code>G-PHIJAM</code><span class="math inline">\(\neq\)</span><code>PASS</code>이면 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>은 결론 근거로 사용할 수 없으며, 한계 결론(CT-LIM)만 허용된다.</p>
<h3 data-number="14.5.6" id="보고-규약필수-로그-및-봉인"><span class="header-section-number">14.5.6</span> 12.3.6 보고 규약(필수 로그 및 봉인)</h3>
<p><span class="math inline">\(\phi_{\mathrm{jam}}\)</span> 결과는 다음 레코드로 기록되어 봉인되어야 한다(스키마는 <code>protocol_lock</code>에 잠김).</p>
<pre><code>phijam_report:
  - phijam_id: (unique)
    regime_id: ...
    state_window: [n1,n2)
    D_anch: ...
    a: ...
    kappa_vp: pi/6
    V_cell: D_anch^3
    v_vp: (pi/6)*a^3
    N_vp: ...
    N_amb: ...
    phi_jam: ...
    phi_mean: ...          # 선택적(창 집계)
    phi_sigma: ...         # 선택적
    drift_Rphi: ...        # 선택적
    thresholds:
      phi_max: ...
      eta_amb: ...
      eps_drift: ...
      eps_b: ...
    error_budget:
      rel_bound: ...       # eq. (S12_03_rel_bound) 형태
      components: {dN_over_N, 3*da_over_a, 3*dD_over_D}
    gate_refs:
      G-PHIJAM: PASS|FAIL|INCONCLUSIVE
      labels: [...]
    lock_refs:
      canon_lock_id: ...
      realization_lock_id: ...
      analysis_lock_id: ...
      gate_lock_id: ...
      protocol_lock_id: ...
    snapshot_refs:
      manifest_ref: ...
      checksums_ref: ...
      registry_snapshot_ref: ...</code></pre>
<p><code>manifest_ref</code>/<code>checksums_ref</code>/<code>registry_snapshot_ref</code>가 누락된 레코드는 결론 자격을 부여하지 않는다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-61">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(\phi_{\mathrm{jam}}=\dfrac{N_{\mathrm{vp}}(\pi/6)a^3}{D_{\mathrm{anch}}^3}\)</span> 및 포함 규칙/부피 닫힘(<span class="math inline">\(\kappa_{\mathrm{vp}}=\pi/6\)</span>)을 <code>canon_lock</code>/<code>analysis_lock</code>/<code>realization_lock</code>에 고정.</p></li>
<li><p>LOCK: 민감도/오차예산(경계 모호 폭 <span class="math inline">\(\epsilon_b\)</span>, 보호 상수 <span class="math inline">\(\varepsilon_\phi\)</span>) 및 창 분할 규약을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: FAIL 트리거(F1–F6)와 문턱(<span class="math inline">\(\phi_{\max},\eta_{\mathrm{amb}},\varepsilon_{\mathrm{drift}}\)</span>)을 <code>gate_lock</code>에 고정.</p></li>
<li><p>Gate: <code>G-PHIJAM</code>=<code>PASS</code>가 아닌 <span class="math inline">\(\phi_{\mathrm{jam}}\)</span>은 결론 근거로 사용 금지(PASS.rules 연결).</p></li>
<li><p>Gate: 보고서/좌표/카운트가 <code>manifest+checksums+registry_snapshot</code>으로 봉인되지 않으면 G-REP에서 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
</ul>
<h1 data-number="15" id="질량-u_mathrmlatrightarrow-m_hm_pm_e"><span class="header-section-number">15</span> 13. 질량: <span class="math inline">\(U_{\mathrm{lat}}\rightarrow m_H/m_p/m_e\)</span></h1>
<h2 class="unnumbered" id="목적본론-승격-선언">목적(본론 승격 선언)</h2>
<p>본 장은 격자 단위 에너지 <span class="math inline">\(U_{\mathrm{lat}}\)</span>로부터 질량 스케일 <span class="math inline">\(m_H,m_p,m_e\)</span>를 <strong>본론 본문</strong>에서 완결 유도한다.
본 장은 이전 버전에서 부록(E/P/M/R 등)로 분산되어 있던 질량 관련 유도(전자 질량, 양성자 질량, 힉스 질량, 비율 교차검증)를 본문으로 <strong>승격</strong>하여, 정의-유도-검증(Gate) 흐름이 본문 내에서 중복 없이 일관되게 닫히도록 구조를 고정한다.</p>
<h2 class="unnumbered" id="산출물정의유도검증-항목">산출물(정의/유도/검증 항목)</h2>
<p>본 장의 산출물은 다음 다섯 묶음으로 고정한다.</p>
<ol>
<li><p><span class="math inline">\(U_{\mathrm{lat}}\)</span>의 정의 및 실현 잠금(11장 실현값 <span class="math inline">\(a,\Delta t\)</span>와 연결).</p></li>
<li><p>질량의 운영 정의(기하 저항/유효 단면/적분 계수) 및 유형별 질량 산출식.</p></li>
<li><p><span class="math inline">\(m_H\)</span> 유도(계수 <span class="math inline">\(5\pi\)</span> 포함) 및 수치 산출.</p></li>
<li><p><span class="math inline">\(m_p\)</span> 유도(코어 반경 <span class="math inline">\(R_p\)</span> 및 <span class="math inline">\(\lambda_C\)</span> 연결 포함) 및 수치 산출.</p></li>
<li><p><span class="math inline">\(m_e\)</span> 유도(전자 정준 사건율/반경 <span class="math inline">\(r_e\)</span> 포함) 및 수치 산출.</p></li>
</ol>
<p>각 산출물은 (i) 어떤 LOCK 항목에 의존하는지, (ii) 어떤 닫힘(closure)을 사용했는지, (iii) 어떤 Gate를 통과해야 결론 자격을 얻는지를 본문에서 명시한다.</p>
<h2 class="unnumbered" id="입력lock과-금지-규칙외부-정당화-금지">입력(LOCK)과 금지 규칙(외부 정당화 금지)</h2>
<p>본 장의 유도는 다음 입력만을 사용한다.</p>
<ol>
<li><p>실현 길이 <span class="math inline">\(a\)</span> 및 실현 시간 <span class="math inline">\(\Delta t\)</span> (11장에서 잠김).</p></li>
<li><p>코어 반경 <span class="math inline">\(R_p\)</span> 및 선택 길이 <span class="math inline">\(L_q=\lambda_C\)</span> (6장에서 잠김).</p></li>
<li><p>정류 상수 <span class="math inline">\(\alpha,\delta\)</span> (5장에서 잠김) 및 정준 사건율(9장에서 잠김).</p></li>
<li><p>82+7 이산 구조의 검증 통과 산출물(8장에서 <code>PASS</code> 조건).</p></li>
</ol>
<p>본 장은 외부 텍스트(다른 이론의 식, 다른 이론의 상수 정의, 다른 이론의 정당화)를 질량 유도의 근거로 사용하지 않는다. 외부 수치와의 비교는 <strong>Gate 판정 지표</strong>로만 기록되며, 정의/유도의 정당화로 사용되지 않는다.</p>
<h2 class="unnumbered" id="누락-보강의-본문-승격-범위선언">누락 보강의 본문 승격 범위(선언)</h2>
<p>본 장에서 본문 승격되는 누락 보강 항목은 다음과 같다.</p>
<ol>
<li><p><strong>전자 질량 유도</strong>: 전자 정준 <span class="math inline">\(\nu_{e,\mathrm{can}}=1\)</span>과 <span class="math inline">\(r_e\)</span> 정의로부터 질량 계수로 연결되는 유도.</p></li>
<li><p><strong>양성자 질량 유도</strong>: <span class="math inline">\(R_p\)</span> 및 코어 불변량(<span class="math inline">\(4/\pi\)</span> 등)과 결합된 적분 계수로 질량 스케일을 산출하는 유도.</p></li>
<li><p><strong>힉스 질량 유도</strong>: <span class="math inline">\(U_{\mathrm{lat}}\)</span> 및 유효 단면 계수(<span class="math inline">\(5\pi\)</span>)로부터 <span class="math inline">\(m_H\)</span>를 산출하는 유도.</p></li>
<li><p><strong>비율 교차검증</strong>: <span class="math inline">\(m_H/m_p\)</span>, <span class="math inline">\(m_p/m_e\)</span> 등 무차원 비율 불변량을 정의하고, RCROSS 및 Gate 스택으로 검증하는 절.</p></li>
</ol>
<p>위 항목들은 더 이상 부록으로 분산되지 않으며, 본문에서 정의-유도-검증으로 완결된다.</p>
<h2 class="unnumbered" id="gate-구조본-장-결론-자격-조건">Gate 구조(본 장 결론 자격 조건)</h2>
<p>본 장의 모든 수치 결론(<span class="math inline">\(m_H,m_p,m_e\)</span> 및 비율)는 다음 Gate 스택의 <code>PASS</code>를 필요조건으로 갖는다.</p>
<ol>
<li><p>G-SYM: 기호/단위/지름-반지름 의미 충돌 없음.</p></li>
<li><p>G-LOCK: 입력 lock_id 일치 및 스냅샷 봉인.</p></li>
<li><p>G-REG: 레짐 적합성(실현/정준 사건율 적용 레짐).</p></li>
<li><p>G-STR: 구조(82+7, 상쇄-생존) 관련 입력이 <code>PASS</code> 상태임.</p></li>
<li><p>G-RCROSS: 실현값(<span class="math inline">\(a,\Delta t\)</span>) 교차정합 <code>PASS</code>(필수).</p></li>
<li><p>G-REP: 재현 패키지로 동일 결과 재생산 가능.</p></li>
<li><p>G-NT: 사후조정 금지 위반 없음.</p></li>
</ol>
<p>Gate가 <code>PASS</code>하지 않은 결과는 본문 결론으로 승격되지 않으며, 한계 결론(CT-LIM)만 허용된다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-62">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 질량 유도(전자/양성자/힉스) 관련 항목을 부록에서 본문으로 승격한다는 범위 선언을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 입력(실현값 <span class="math inline">\(a,\Delta t\)</span>, 코어 <span class="math inline">\(R_p\)</span>, 사건율 <span class="math inline">\(\nu_{\mathrm{can}}\)</span> 등)과 금지 규칙(외부 정당화 금지)을 본 장 전역 규약으로 고정.</p></li>
<li><p>Gate: 본 장 수치 결론은 RCROSS <code>PASS</code> 및 구조 검증 <code>PASS</code>를 필요조건으로 연결(PASS.rules).</p></li>
<li><p>Gate: 봉인(manifest/checksums/registry_snapshot) 미충족은 G-REP에서 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
<li><p>Gate: 사후 변경(정의/문턱/선택 규칙) 또는 lock_id 혼합은 G-NT/G-LOCK에서 <code>FAIL</code>.</p></li>
</ul>
<h2 data-number="15.1" id="u_mathrmlathca1958.7mathrmgev-정의단일-출처"><span class="header-section-number">15.1</span> 13.1 <span class="math inline">\(U_{\mathrm{lat}}=hc/a=1958.7\,\mathrm{GeV}\)</span> 정의(단일 출처)</h2>
<h3 data-number="15.1.1" id="목적단일-출처-선언"><span class="header-section-number">15.1.1</span> 13.1.1 목적(단일 출처 선언)</h3>
<p>본 절은 격자 단위 에너지 <span class="math inline">\(U_{\mathrm{lat}}\)</span>를 <strong>정의</strong>로 고정하고, 문서 전역에서 <span class="math inline">\(U_{\mathrm{lat}}\)</span>의 유일 출처(SSOT)를 제공한다.
본 절 밖에서 <span class="math inline">\(U_{\mathrm{lat}}\)</span>를 재정의하거나 재유도하는 행위는 금지된다. 본 절 밖에서 허용되는 것은 <a data-reference="eq:S13_01_Ulat_def" data-reference-type="eqref" href="#eq:S13_01_Ulat_def">[eq:S13_01_Ulat_def]</a>의 <strong>참조</strong>뿐이다.</p>
<h3 data-number="15.1.2" id="입력lock-h-c_mathrmref-a-단위-변환-상수"><span class="header-section-number">15.1.2</span> 13.1.2 입력(LOCK): <span class="math inline">\(h\)</span>, <span class="math inline">\(c_{\mathrm{ref}}\)</span>, <span class="math inline">\(a\)</span>, 단위 변환 상수</h3>
<p><span class="math inline">\(U_{\mathrm{lat}}\)</span>는 다음 네 입력이 잠겨 있을 때에만 정의된다.</p>
<h4 data-number="15.1.2.1" id="작용-단위-상수-h-잠김"><span class="header-section-number">15.1.2.1</span> 13.1.2.1 작용 단위 상수 <span class="math inline">\(h\)</span> (잠김)</h4>
<p><span class="math display">\[h
=
6.62607015\times 10^{-34}\ \mathrm{J\cdot s}.
\label{eq:S13_01_h_lock}\]</span>
<span class="math inline">\(h\)</span>는 본 문서의 단위 체계에서 사용하는 작용 단위 상수이며, 값/단위가 <code>canon_lock</code>에 잠겨 있어야 한다.</p>
<h4 data-number="15.1.2.2" id="기준-속도-상수-c_mathrmref-운영-닻-잠김"><span class="header-section-number">15.1.2.2</span> 13.1.2.2 기준 속도 상수 <span class="math inline">\(c_{\mathrm{ref}}\)</span> (운영 닻, 잠김)</h4>
<p><span class="math display">\[c_{\mathrm{ref}}
=
299\,792\,458\ \mathrm{m/s}.
\label{eq:S13_01_cref_lock}\]</span>
<span class="math inline">\(c_{\mathrm{ref}}\)</span>는 11.1에서 잠긴 운영 닻 상수이며, 채널/스코프/프로토콜과 함께 <code>realization_lock</code>에 잠겨 있어야 한다.</p>
<h4 data-number="15.1.2.3" id="실현-길이-a-vp-지름-잠김"><span class="header-section-number">15.1.2.3</span> 13.1.2.3 실현 길이 <span class="math inline">\(a\)</span> (VP 지름, 잠김)</h4>
<p><span class="math display">\[a
=
6.3299121257859865746\times 10^{-19}\ \mathrm{m}.
\label{eq:S13_01_a_lock}\]</span>
<span class="math inline">\(a\)</span>는 11.2에서 잠긴 실현 길이이며, <code>geometry_meaning</code>=<code>diameter</code>로 함께 잠겨 있어야 한다.</p>
<h4 data-number="15.1.2.4" id="에너지-단위-변환-상수잠김"><span class="header-section-number">15.1.2.4</span> 13.1.2.4 에너지 단위 변환 상수(잠김)</h4>
<p>본 절은 <span class="math inline">\(\mathrm{GeV}\)</span>를 단위 표기(보고 단위)로 사용하기 위해 다음 변환 상수를 잠근다.
<span class="math display">\[1\ \mathrm{GeV}
=
1.602176634\times 10^{-10}\ \mathrm{J}.
\label{eq:S13_01_GeV_to_J}\]</span>
<a data-reference="eq:S13_01_GeV_to_J" data-reference-type="eqref" href="#eq:S13_01_GeV_to_J">[eq:S13_01_GeV_to_J]</a>는 단위 변환 규약이며, 값/단위가 <code>protocol_lock</code>에 잠겨 있어야 한다.</p>
<h3 data-number="15.1.3" id="정의-u_mathrmlat-격자-단위-에너지"><span class="header-section-number">15.1.3</span> 13.1.3 정의: <span class="math inline">\(U_{\mathrm{lat}}\)</span> (격자 단위 에너지)</h3>
<p>격자 단위 에너지 <span class="math inline">\(U_{\mathrm{lat}}\)</span>를 다음으로 정의한다.
<span class="math display">\[\boxed{
U_{\mathrm{lat}}
:=
\frac{h\,c_{\mathrm{ref}}}{a}
}
\label{eq:S13_01_Ulat_def}\]</span>
정의 <a data-reference="eq:S13_01_Ulat_def" data-reference-type="eqref" href="#eq:S13_01_Ulat_def">[eq:S13_01_Ulat_def]</a>에서 <span class="math inline">\(h\)</span>의 차원은 <span class="math inline">\(\mathrm{J\cdot s}\)</span>, <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 차원은 <span class="math inline">\(\mathrm{m/s}\)</span>, <span class="math inline">\(a\)</span>의 차원은 <span class="math inline">\(\mathrm{m}\)</span>이므로,
<span class="math display">\[=
(\mathrm{J\cdot s})(\mathrm{m/s})/\mathrm{m}
=
\mathrm{J}
\label{eq:S13_01_dim_check}\]</span>
이며, <span class="math inline">\(U_{\mathrm{lat}}\)</span>의 차원은 에너지로 고정된다.</p>
<h3 data-number="15.1.4" id="수치-전개-mathrmjrightarrowmathrmgev"><span class="header-section-number">15.1.4</span> 13.1.4 수치 전개: <span class="math inline">\(\mathrm{J}\rightarrow\mathrm{GeV}\)</span></h3>
<h4 data-number="15.1.4.1" id="hc_mathrmref-계산"><span class="header-section-number">15.1.4.1</span> 13.1.4.1 <span class="math inline">\(h\,c_{\mathrm{ref}}\)</span> 계산</h4>
<p><a data-reference="eq:S13_01_h_lock" data-reference-type="eqref" href="#eq:S13_01_h_lock">[eq:S13_01_h_lock]</a>과 <a data-reference="eq:S13_01_cref_lock" data-reference-type="eqref" href="#eq:S13_01_cref_lock">[eq:S13_01_cref_lock]</a>로부터,
<span class="math display">\[\begin{aligned}
h\,c_{\mathrm{ref}}
&amp;=
\left(6.62607015\times 10^{-34}\ \mathrm{J\cdot s}\right)
\left(299\,792\,458\ \mathrm{m/s}\right)
\notag\\
&amp;=
1.9864458571489286\times 10^{-25}\ \mathrm{J\cdot m}.
\label{eq:S13_01_hc_value}\end{aligned}\]</span></p>
<h4 data-number="15.1.4.2" id="u_mathrmlat의-mathrmj-값"><span class="header-section-number">15.1.4.2</span> 13.1.4.2 <span class="math inline">\(U_{\mathrm{lat}}\)</span>의 <span class="math inline">\(\mathrm{J}\)</span> 값</h4>
<p><a data-reference="eq:S13_01_Ulat_def" data-reference-type="eqref" href="#eq:S13_01_Ulat_def">[eq:S13_01_Ulat_def]</a>에 <a data-reference="eq:S13_01_hc_value" data-reference-type="eqref" href="#eq:S13_01_hc_value">[eq:S13_01_hc_value]</a>와 <a data-reference="eq:S13_01_a_lock" data-reference-type="eqref" href="#eq:S13_01_a_lock">[eq:S13_01_a_lock]</a>을 대입하면,
<span class="math display">\[\begin{aligned}
U_{\mathrm{lat}}
&amp;=
\frac{1.9864458571489286\times 10^{-25}\ \mathrm{J\cdot m}}
{6.3299121257859865746\times 10^{-19}\ \mathrm{m}}
\notag\\
&amp;=
3.138188678886709\times 10^{-7}\ \mathrm{J}.
\label{eq:S13_01_Ulat_J}\end{aligned}\]</span></p>
<h4 data-number="15.1.4.3" id="u_mathrmlat의-mathrmgev-값"><span class="header-section-number">15.1.4.3</span> 13.1.4.3 <span class="math inline">\(U_{\mathrm{lat}}\)</span>의 <span class="math inline">\(\mathrm{GeV}\)</span> 값</h4>
<p><a data-reference="eq:S13_01_GeV_to_J" data-reference-type="eqref" href="#eq:S13_01_GeV_to_J">[eq:S13_01_GeV_to_J]</a>로부터
<span class="math display">\[U_{\mathrm{lat}}[\mathrm{GeV}]
=
\frac{U_{\mathrm{lat}}[\mathrm{J}]}{1.602176634\times 10^{-10}\ \mathrm{J/GeV}}.
\label{eq:S13_01_convert_to_GeV}\]</span>
<a data-reference="eq:S13_01_Ulat_J" data-reference-type="eqref" href="#eq:S13_01_Ulat_J">[eq:S13_01_Ulat_J]</a>를 <a data-reference="eq:S13_01_convert_to_GeV" data-reference-type="eqref" href="#eq:S13_01_convert_to_GeV">[eq:S13_01_convert_to_GeV]</a>에 대입하면,
<span class="math display">\[\begin{aligned}
U_{\mathrm{lat}}
&amp;=
\frac{3.138188678886709\times 10^{-7}\ \mathrm{J}}
{1.602176634\times 10^{-10}\ \mathrm{J/GeV}}
\notag\\
&amp;=
1958.7033116641428\ \mathrm{GeV}.
\label{eq:S13_01_Ulat_GeV}\end{aligned}\]</span>
유효숫자 표기 규약(반올림 규칙)이 잠긴 경우, 보고값은 다음으로 고정한다.
<span class="math display">\[\boxed{
U_{\mathrm{lat}}\approx 1958.7\ \mathrm{GeV}
}
\label{eq:S13_01_Ulat_GeV_round}\]</span></p>
<h3 data-number="15.1.5" id="파생-금지-규칙재정의흡수사후조정-금지"><span class="header-section-number">15.1.5</span> 13.1.5 파생 금지 규칙(재정의/흡수/사후조정 금지)</h3>
<p><span class="math inline">\(U_{\mathrm{lat}}\)</span>에 대해 다음 금지 규칙을 고정한다.</p>
<ol>
<li><p><strong>재정의 금지</strong>: 본 절 밖에서 <span class="math inline">\(U_{\mathrm{lat}}\)</span>를 다른 식으로 정의하거나, 다른 기호로 바꿔치기하여 동일 의미로 사용하는 행위를 금지한다.</p></li>
<li><p><strong>재유도 금지</strong>: <a data-reference="eq:S13_01_Ulat_def" data-reference-type="eqref" href="#eq:S13_01_Ulat_def">[eq:S13_01_Ulat_def]</a>를 본 절 밖에서 “유도” 형태로 반복 전개하는 행위를 금지한다(참조만 허용).</p></li>
<li><p><strong>흡수 금지</strong>: 질량/힘 유도에서 계수 또는 기하 항을 <span class="math inline">\(U_{\mathrm{lat}}\)</span> 정의로 흡수하여, 정의 구조를 변경하는 행위를 금지한다.</p></li>
<li><p><strong>사후조정 금지</strong>: 목표 수치에 맞추기 위해 <span class="math inline">\(a\)</span>, <span class="math inline">\(c_{\mathrm{ref}}\)</span>, <span class="math inline">\(h\)</span> 또는 <a data-reference="eq:S13_01_GeV_to_J" data-reference-type="eqref" href="#eq:S13_01_GeV_to_J">[eq:S13_01_GeV_to_J]</a>의 값을 사후 변경하는 행위를 금지한다. 변경은 버전업으로만 허용된다.</p></li>
<li><p><strong>대체 상수 금지</strong>: <span class="math inline">\(c_{\mathrm{ref}}\)</span> 대신 다른 속도 상수를 대입하거나, <span class="math inline">\(h\)</span> 대신 다른 작용 상수를 대입하는 행위를 금지한다(동일 버전 내부).</p></li>
</ol>
<p>위 금지 규칙 위반이 탐지되면 <span class="math inline">\(U_{\mathrm{lat}}\)</span> 및 이를 입력으로 하는 모든 파생 결론은 결론 자격을 상실한다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-63">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(h\)</span>(<a data-reference="eq:S13_01_h_lock" data-reference-type="ref" href="#eq:S13_01_h_lock">[eq:S13_01_h_lock]</a>), <span class="math inline">\(c_{\mathrm{ref}}\)</span>(<a data-reference="eq:S13_01_cref_lock" data-reference-type="ref" href="#eq:S13_01_cref_lock">[eq:S13_01_cref_lock]</a>), <span class="math inline">\(a\)</span>(<a data-reference="eq:S13_01_a_lock" data-reference-type="ref" href="#eq:S13_01_a_lock">[eq:S13_01_a_lock]</a>), 단위 변환(<a data-reference="eq:S13_01_GeV_to_J" data-reference-type="ref" href="#eq:S13_01_GeV_to_J">[eq:S13_01_GeV_to_J]</a>)을 각 레지스트리(<code>canon</code>/<code>realization</code>/<code>protocol</code>)에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(U_{\mathrm{lat}}:=h\,c_{\mathrm{ref}}/a\)</span> 정의(<a data-reference="eq:S13_01_Ulat_def" data-reference-type="ref" href="#eq:S13_01_Ulat_def">[eq:S13_01_Ulat_def]</a>)를 <span class="math inline">\(U_{\mathrm{lat}}\)</span>의 유일 출처로 고정.</p></li>
<li><p>Gate: RCROSS(<code>G-RCROSS</code>)가 <code>PASS</code>하지 않으면 <span class="math inline">\(a\)</span> 또는 <span class="math inline">\(c_{\mathrm{ref}}\)</span>의 실현 자격이 박탈되므로 <span class="math inline">\(U_{\mathrm{lat}}\)</span> 결론 자격도 박탈됨.</p></li>
<li><p>Gate: 사후 변경/정의 교체/lock_id 혼합은 G-NT/G-LOCK에서 <code>FAIL</code>.</p></li>
<li><p>Gate: <span class="math inline">\(U_{\mathrm{lat}}\)</span> 계산 로그 및 봉인(manifest/checksums/registry_snapshot) 미충족은 G-REP에서 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
</ul>
<h2 data-number="15.2" id="질량저항sigma_mathrmeff-공리정의"><span class="header-section-number">15.2</span> 13.2 질량=저항(<span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>) 공리/정의</h2>
<h3 data-number="15.2.1" id="목적-14"><span class="header-section-number">15.2.1</span> 13.2.1 목적</h3>
<p>본 절은 “질량”을 외부 텍스트의 정당화 없이 <strong>저항(효과 단면) <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span></strong>의 형태로 운영 정의하고, 질량 계산/측정 절차를 <strong>로그 가능한 규약</strong>으로 고정한다.
본 절의 산출물은 (i) 질량-저항 공리, (ii) 질량의 표준형 정의식, (iii) <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span> 산출 절차(계산 레시피), (iv) Gate 판정 기준이다.</p>
<h3 data-number="15.2.2" id="a-질량저항-공리운영-공리"><span class="header-section-number">15.2.2</span> 13.2.2 [A] 질량=저항 공리(운영 공리)</h3>
<p>본 문서에서 질량은 “격자 단위 에너지 <span class="math inline">\(U_{\mathrm{lat}}\)</span>가 특정 구조를 통과할 때의 저항”으로 정의된다고 공리로 고정한다.</p>
<h3 data-number="15.2.3" id="a-13.2-1-질량-저항-대응-공리"><span class="header-section-number">15.2.3</span> [A-13.2-1] 질량-저항 대응 공리</h3>
<p>객체 <span class="math inline">\(\mathcal{O}\)</span>에 대해 질량 스케일 <span class="math inline">\(m(\mathcal{O})\)</span>는 다음 대응을 만족한다고 공리로 고정한다.
<span class="math display">\[m(\mathcal{O})
=
\frac{U_{\mathrm{lat}}}{\sigma_{\mathrm{eff}}(\mathcal{O})}.
\label{eq:S13_02_mass_axiom}\]</span>
여기서 <span class="math inline">\(U_{\mathrm{lat}}\)</span>는 13.1에서 단일 출처로 잠긴 격자 단위 에너지이고, <span class="math inline">\(\sigma_{\mathrm{eff}}(\mathcal{O})\)</span>는 객체 <span class="math inline">\(\mathcal{O}\)</span>의 효과 단면(저항)이다.</p>
<h4 data-number="15.2.3.1" id="공리의-의미형식적"><span class="header-section-number">15.2.3.1</span> 공리의 의미(형식적)</h4>
<p><a data-reference="eq:S13_02_mass_axiom" data-reference-type="eqref" href="#eq:S13_02_mass_axiom">[eq:S13_02_mass_axiom]</a>은 “질량”을 단독 실체로 도입하지 않고, <span class="math inline">\(U_{\mathrm{lat}}\)</span>와 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>의 비로 정의되는 운영량으로 고정한다. 이 공리는 외부 정설의 정당화에 의존하지 않으며, 이후 장에서 각 객체별 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>의 정의가 완결되면 질량이 결정된다.</p>
<h3 data-number="15.2.4" id="d-효과-단면-sigma_mathrmeff의-정의유형-분류"><span class="header-section-number">15.2.4</span> 13.2.3 [D] 효과 단면 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>의 정의(유형 분류)</h3>
<p>효과 단면은 객체 유형에 따라 정의 방식이 달라질 수 있으므로, 본 절은 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>를 다음 세 유형으로 분류하여 정의한다. 유형 선택은 <code>analysis_lock</code>에 잠겨야 하며, 결과를 본 뒤 교체될 수 없다.</p>
<h3 data-number="15.2.5" id="t1-기하-단면형geometric"><span class="header-section-number">15.2.5</span> (T1) 기하 단면형(Geometric)</h3>
<p>기하 단면형은 “기하학적 단면”을 효과 단면으로 채택하는 유형이다.
<span class="math display">\[\sigma_{\mathrm{eff}}(\mathcal{O})
:=\sigma_{\mathrm{geom}}(\mathcal{O})
\quad\text{(기하 단면형)}.
\label{eq:S13_02_sigma_geom_type}\]</span>
기하 단면 <span class="math inline">\(\sigma_{\mathrm{geom}}\)</span>의 정의는 객체별로 잠긴다(예: 코어 반경 <span class="math inline">\(R_p\)</span>에 대해 <span class="math inline">\(\pi R_p^2\)</span>).</p>
<h3 data-number="15.2.6" id="t2-집계-경로형path-aggregate"><span class="header-section-number">15.2.6</span> (T2) 집계 경로형(Path-aggregate)</h3>
<p>집계 경로형은 “전파/경로/목” 집계에서 발생하는 저항을 단면으로 환원하는 유형이다.
<span class="math display">\[\sigma_{\mathrm{eff}}(\mathcal{O})
:= \Sigma_{\mathrm{path}}(\mathcal{O})
\quad\text{(집계 경로형)}.
\label{eq:S13_02_sigma_path_type}\]</span>
<span class="math inline">\(\Sigma_{\mathrm{path}}\)</span>는 퍼콜레이션/백본/경로 닫힘(10장)과 연결되어 정의되며, 정의는 <code>analysis_lock</code>에 잠긴다.</p>
<h3 data-number="15.2.7" id="t3-이산-구조-상쇄형discrete-cancellation"><span class="header-section-number">15.2.7</span> (T3) 이산 구조 상쇄형(Discrete-cancellation)</h3>
<p>이산 구조 상쇄형은 “상쇄-생존” 구조의 잔차가 저항으로 환원되는 유형이다.
<span class="math display">\[\sigma_{\mathrm{eff}}(\mathcal{O})
:= \Sigma_{\mathrm{disc}}(\mathcal{O})
\quad\text{(이산 구조 상쇄형)}.
\label{eq:S13_02_sigma_disc_type}\]</span>
<span class="math inline">\(\Sigma_{\mathrm{disc}}\)</span>는 82+7 구조 검증(8장)과 3-섹터 정수화(7장) 및 사건율(9장)에 의존하여 정의되며, 정의는 <code>analysis_lock</code>에 잠긴다.</p>
<h3 data-number="15.2.8" id="d-질량-표준형단위차원실현-연결"><span class="header-section-number">15.2.8</span> 13.2.4 [D] 질량 표준형(단위/차원/실현 연결)</h3>
<h4 data-number="15.2.8.1" id="질량의-차원"><span class="header-section-number">15.2.8.1</span> 13.2.4.1 질량의 차원</h4>
<p><a data-reference="eq:S13_02_mass_axiom" data-reference-type="eqref" href="#eq:S13_02_mass_axiom">[eq:S13_02_mass_axiom]</a>에 의해 <span class="math inline">\(m\)</span>의 차원은 <span class="math inline">\(U_{\mathrm{lat}}\)</span>의 차원(에너지)을 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>의 차원으로 나눈 것으로 결정된다. 본 문서는 질량의 보고 단위를 <span class="math inline">\(\mathrm{GeV}\)</span> 또는 그 하위 단위로 사용하므로, <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>는 무차원 또는 무차원에 준하는 “저항 계수”로 정의되는 유형(T2, T3)을 가질 수 있다. 따라서 본 절은 다음을 규약으로 고정한다.</p>
<h4 data-number="15.2.8.2" id="d-13.2-2-무차원-저항-규약"><span class="header-section-number">15.2.8.2</span> [D-13.2-2] 무차원 저항 규약</h4>
<p>본 장에서 질량을 <span class="math inline">\(\mathrm{GeV}\)</span>로 보고하는 경우, 효과 단면은 다음 중 하나로 잠겨야 한다.</p>
<ol>
<li><p>무차원 단면: <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span> 자체가 무차원(저항 계수)이며 <span class="math inline">\(U_{\mathrm{lat}}\)</span>와 동일 차원의 질량이 산출됨.</p></li>
<li><p>정규화 단면: <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>가 길이<span class="math inline">\(^2\)</span> 차원을 가지면, 그 단면은 <span class="math inline">\(a^2\)</span> 또는 <span class="math inline">\(L_q^2\)</span>로 정규화되어 무차원으로 환원된 뒤 사용됨.</p></li>
</ol>
<p>정규화 방식의 선택은 <code>analysis_lock</code>에 잠겨야 하며, 결과를 본 뒤 바뀔 수 없다.</p>
<h4 data-number="15.2.8.3" id="정규화-단면형의-표준식"><span class="header-section-number">15.2.8.3</span> 13.2.4.2 정규화 단면형의 표준식</h4>
<p>길이<span class="math inline">\(^2\)</span> 차원의 기하 단면을 사용하는 경우, 무차원 저항으로 환원하기 위해 다음 표준식을 고정한다.
<span class="math display">\[\tilde{\sigma}_{\mathrm{eff}}(\mathcal{O})
:=\frac{\sigma_{\mathrm{geom}}(\mathcal{O})}{L_{\mathrm{ref}}^{2}},
\label{eq:S13_02_sigma_tilde_def}\]</span>
여기서 <span class="math inline">\(L_{\mathrm{ref}}\)</span>는 정규화 길이(예: <span class="math inline">\(L_q\)</span> 또는 <span class="math inline">\(a\)</span>)이며 <code>analysis_lock</code>에 잠긴다. 이때 질량은
<span class="math display">\[m(\mathcal{O})
=
\frac{U_{\mathrm{lat}}}{\tilde{\sigma}_{\mathrm{eff}}(\mathcal{O})}.
\label{eq:S13_02_mass_from_sigma_tilde}\]</span>
로 정의된다. <a data-reference="eq:S13_02_mass_from_sigma_tilde" data-reference-type="eqref" href="#eq:S13_02_mass_from_sigma_tilde">[eq:S13_02_mass_from_sigma_tilde]</a>는 <strong>정규화 단면형</strong>에서의 표준 질량식이다.</p>
<h3 data-number="15.2.9" id="sigma_mathrmeff-계산-절차운영-레시피"><span class="header-section-number">15.2.9</span> 13.2.5 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span> 계산 절차(운영 레시피)</h3>
<p>본 절은 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span> 산출을 다음 공통 절차로 고정한다. 객체 <span class="math inline">\(\mathcal{O}\)</span>에 대해 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>는 “정의<span class="math inline">\(\rightarrow\)</span>집계<span class="math inline">\(\rightarrow\)</span>Gate”의 흐름을 따라야 한다.</p>
<h4 data-number="15.2.9.1" id="입력-로그-1"><span class="header-section-number">15.2.9.1</span> 13.2.5.1 입력 로그</h4>
<p><span class="math inline">\(\sigma_{\mathrm{eff}}\)</span> 산출은 다음 입력 로그를 필요로 한다.</p>
<ol>
<li><p>객체 식별자: <code>object_id</code> 및 <code>object_instance_id</code>.</p></li>
<li><p>기하/좌표: <span class="math inline">\(R_p\)</span>, <span class="math inline">\(L_q\)</span>, <span class="math inline">\(a\)</span> 및 필요한 좌표 집합(예: <span class="math inline">\(\mathcal{X}_{82}\)</span>, <span class="math inline">\(\mathcal{S}_7\)</span>).</p></li>
<li><p>그래프/경로: 접촉 그래프, 임계목 그래프, 백본(해당 시).</p></li>
<li><p>사건 로그: 사건 집합/틱 창/필요 위상(해당 시).</p></li>
</ol>
<p>입력 로그는 <code>manifest+checksums</code>로 봉인되어야 한다.</p>
<h4 data-number="15.2.9.2" id="계산-레시피유형별"><span class="header-section-number">15.2.9.2</span> 13.2.5.2 계산 레시피(유형별)</h4>
<h4 data-number="15.2.9.3" id="t1-기하-단면형"><span class="header-section-number">15.2.9.3</span> (T1) 기하 단면형</h4>
<ol>
<li><p>객체의 반경 또는 기하 경계를 잠긴 규약으로 산출(예: 코어 반경 <span class="math inline">\(R_p\)</span>).</p></li>
<li><p>기하 단면을 정의식으로 계산(예: <span class="math inline">\(\sigma_{\mathrm{geom}}=\pi R_p^2\)</span>).</p></li>
<li><p>정규화가 필요한 경우 <a data-reference="eq:S13_02_sigma_tilde_def" data-reference-type="eqref" href="#eq:S13_02_sigma_tilde_def">[eq:S13_02_sigma_tilde_def]</a>로 무차원화.</p></li>
</ol>
<h4 data-number="15.2.9.4" id="t2-집계-경로형"><span class="header-section-number">15.2.9.4</span> (T2) 집계 경로형</h4>
<ol>
<li><p>퍼콜레이션 닫힘(10.2)으로 임계 문턱 <span class="math inline">\(\delta_{\mathrm{eff}}\)</span> 및 백본 <span class="math inline">\(\mathcal{E}_{\mathrm{bb}}\)</span>를 산출.</p></li>
<li><p>백본 위에서 경로 저항 집계량을 정의(예: 병목 기반 합, 최대/평균 비율 등; 정의는 <code>analysis_lock</code>에 잠김).</p></li>
<li><p>집계량을 무차원 저항 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>로 환원(정규화 길이 선택 잠김).</p></li>
</ol>
<h4 data-number="15.2.9.5" id="t3-이산-구조-상쇄형"><span class="header-section-number">15.2.9.5</span> (T3) 이산 구조 상쇄형</h4>
<ol>
<li><p>7-셸 검증(8.3) <code>PASS</code>로부터 생존 벡터 <span class="math inline">\(\mathbf{V}_{\mathrm{surv}}\)</span> 및 분할 구조를 산출.</p></li>
<li><p>3-섹터 정수화(7장)로부터 잔차 방향 및 라벨 축 투영을 산출(필요 시).</p></li>
<li><p>잔차 크기/방향을 저항 계수로 맵핑하는 닫힘 <span class="math inline">\(\Sigma_{\mathrm{disc}}\)</span>를 적용(정의는 <code>analysis_lock</code>에 잠김).</p></li>
</ol>
<h4 data-number="15.2.9.6" id="질량-계산"><span class="header-section-number">15.2.9.6</span> 13.2.5.3 질량 계산</h4>
<p>유형별로 산출된 <span class="math inline">\(\sigma_{\mathrm{eff}}(\mathcal{O})\)</span> 또는 <span class="math inline">\(\tilde{\sigma}_{\mathrm{eff}}(\mathcal{O})\)</span>를 사용하여, 질량을 <a data-reference="eq:S13_02_mass_axiom" data-reference-type="eqref" href="#eq:S13_02_mass_axiom">[eq:S13_02_mass_axiom]</a> 또는 <a data-reference="eq:S13_02_mass_from_sigma_tilde" data-reference-type="eqref" href="#eq:S13_02_mass_from_sigma_tilde">[eq:S13_02_mass_from_sigma_tilde]</a>로 계산한다. 계산 로그는 반드시 봉인되어야 하며, 봉인 없는 계산은 결론 자격을 부여하지 않는다.</p>
<h3 data-number="15.2.10" id="gate자격-판정와-fail-조건"><span class="header-section-number">15.2.10</span> 13.2.6 Gate(자격 판정)와 FAIL 조건</h3>
<p><span class="math inline">\(\sigma_{\mathrm{eff}}\)</span> 및 <span class="math inline">\(m(\mathcal{O})\)</span>는 다음 Gate 스택의 <code>PASS</code>를 필요조건으로 갖는다.</p>
<ol>
<li><p>G-SYM: 기호/단위/정규화 길이 의미 충돌 없음.</p></li>
<li><p>G-LOCK: 입력 로그의 lock_id 일치 및 봉인.</p></li>
<li><p>G-REG: 적용 레짐(객체/경로/이산 구조) 일치.</p></li>
<li><p>G-STR: 구조 검증(<code>G-SHELL7-6C1S</code> 등) <code>PASS</code>(해당 시).</p></li>
<li><p>G-NUM: 수치 안정성(추정기 수렴, 반복 일치).</p></li>
<li><p>G-REP: 재현 가능성.</p></li>
<li><p>G-NT: 사후 변경/선택 편향 없음.</p></li>
</ol>
<p>다음 위반은 즉시 <code>FAIL</code>이다.</p>
<ol>
<li><p><span class="math inline">\(\sigma_{\mathrm{eff}}\)</span> 유형(T1/T2/T3)을 결과를 보고 교체.</p></li>
<li><p><span class="math inline">\(\kappa_{\mathrm{vp}}\)</span>, 정규화 길이 <span class="math inline">\(L_{\mathrm{ref}}\)</span>를 결과를 보고 변경.</p></li>
<li><p>봉인 없이 <span class="math inline">\(U_{\mathrm{lat}}\)</span> 또는 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>를 사용하여 질량을 보고.</p></li>
</ol>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-64">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 질량=저항 공리 <a data-reference="eq:S13_02_mass_axiom" data-reference-type="eqref" href="#eq:S13_02_mass_axiom">[eq:S13_02_mass_axiom]</a> 및 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span> 유형(T1/T2/T3) 분류와 표준식을 <code>canon_lock</code>/<code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span> 계산 절차(입력 로그, 유형별 레시피, 정규화 규약)를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 구조 입력(셸 검증/퍼콜레이션)이 <code>PASS</code>가 아니면 해당 유형의 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>는 정의 불능 또는 <code>FAIL</code>.</p></li>
<li><p>Gate: 사후 변경(유형 교체/정규화 길이 교체/계수 교체)은 G-NT에서 <code>FAIL</code>; lock_id 혼합은 G-LOCK에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 계산 로그가 <code>manifest+checksums+registry_snapshot</code>으로 봉인되지 않으면 G-REP에서 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
</ul>
<h2 data-number="15.3" id="pi-계수-유도rightarrow-m_hu_mathrmlat5pi"><span class="header-section-number">15.3</span> 13.3 <span class="math inline">\(5\pi\)</span> 계수 유도<span class="math inline">\(\rightarrow m_H=U_{\mathrm{lat}}/(5\pi)\)</span></h2>
<h3 data-number="15.3.1" id="목표와-기호-고정"><span class="header-section-number">15.3.1</span> 13.3.1 목표와 기호 고정</h3>
<p>본 절의 목표는 효과 단면(저항) <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>의 정준값을
<span class="math display">\[\sigma_{\mathrm{eff}}(H)=5\pi
\label{eq:S13_03_sigmaeff_goal}\]</span>
로 도출하여, 13.2의 질량-저항 공리
<span class="math display">\[m(\mathcal{O})=\frac{U_{\mathrm{lat}}}{\sigma_{\mathrm{eff}}(\mathcal{O})}
\label{eq:S13_03_mass_axiom_ref}\]</span>
에 의해
<span class="math display">\[m_H=\frac{U_{\mathrm{lat}}}{5\pi}
\label{eq:S13_03_mH_goal}\]</span>
를 완결하는 것이다.</p>
<p>여기서 <span class="math inline">\(H\)</span>는 “정준 셀(Anchor Cell) 내부에서 정의되는 Stone 직접 진동 모드”의 객체 라벨이며, 외부 텍스트의 정당화를 사용하지 않는다. <span class="math inline">\(H\)</span>에 대한 모든 수치는 오직 <span class="math inline">\(U_{\mathrm{lat}}\)</span>와 <span class="math inline">\(\sigma_{\mathrm{eff}}(H)\)</span>의 내부 정의로부터 산출된다.</p>
<h3 data-number="15.3.2" id="sigma_mathrmeff의-구성-원리채널-합성-정의"><span class="header-section-number">15.3.2</span> 13.3.2 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>의 구성 원리(채널 합성 정의)</h3>
<p>본 절은 <span class="math inline">\(H\)</span>의 저항(효과 단면)을 “독립 구속 채널들의 합”으로 정의하여 잠근다.</p>
<h4 data-number="15.3.2.1" id="d-13.3-1-채널-집합과-채널-수"><span class="header-section-number">15.3.2.1</span> [D-13.3-1] 채널 집합과 채널 수</h4>
<p><span class="math inline">\(H\)</span> 모드는 정준 셀 경계에서의 구속 채널들의 집합 <span class="math inline">\(\mathcal{K}_H\)</span>로 기술된다고 정의한다.
<span class="math display">\[\mathcal{K}_H:=\{1,2,\ldots,\kappa_H\},
\qquad
\kappa_H:=|\mathcal{K}_H|.
\label{eq:S13_03_KH_def}\]</span>
<span class="math inline">\(\kappa_H\)</span>는 “독립 구속 채널 수”이며, 본 절에서 <span class="math inline">\(\kappa_H=5\)</span>를 도출한다(13.3.4).</p>
<h4 data-number="15.3.2.2" id="d-13.3-2-채널별-무차원-단면-sigma_0"><span class="header-section-number">15.3.2.2</span> [D-13.3-2] 채널별 무차원 단면 <span class="math inline">\(\sigma_0\)</span></h4>
<p>각 채널 <span class="math inline">\(k\in\mathcal{K}_H\)</span>에 대해 채널 기하 단면(면적) <span class="math inline">\(\sigma_{\mathrm{geom}}^{(k)}\)</span>를 정의할 수 있다. 본 절은 채널 단면을 길이 스케일 <span class="math inline">\(a\)</span>로 무차원화한 채널별 무차원 단면을 다음으로 정의한다.
<span class="math display">\[\sigma_{0}^{(k)}
:=
\frac{4\,\sigma_{\mathrm{geom}}^{(k)}}{a^2}.
\label{eq:S13_03_sigma0_def}\]</span>
<a data-reference="eq:S13_03_sigma0_def" data-reference-type="eqref" href="#eq:S13_03_sigma0_def">[eq:S13_03_sigma0_def]</a>에서 <span class="math inline">\(a\)</span>는 VP 지름(실현 길이)으로 잠겨 있으며, <code>diameter</code> 의미를 가진다. 따라서 <span class="math inline">\(a/2\)</span>는 VP 반경 파생량이다.</p>
<h4 data-number="15.3.2.3" id="d-13.3-3-효과-단면의-합성-정의"><span class="header-section-number">15.3.2.3</span> [D-13.3-3] 효과 단면의 합성 정의</h4>
<p>효과 단면(저항) <span class="math inline">\(\sigma_{\mathrm{eff}}(H)\)</span>를 다음으로 정의한다.
<span class="math display">\[\sigma_{\mathrm{eff}}(H)
:=
\sum_{k\in\mathcal{K}_H}\sigma_{0}^{(k)}.
\label{eq:S13_03_sigmaeff_sum}\]</span>
정의 <a data-reference="eq:S13_03_sigmaeff_sum" data-reference-type="eqref" href="#eq:S13_03_sigmaeff_sum">[eq:S13_03_sigmaeff_sum]</a>은 “독립 채널의 기여는 합으로 누적된다”는 합성 규약이며, 동일 버전 내부에서 곱셈/최대값/다른 집계로 교체될 수 없다.</p>
<h3 data-number="15.3.3" id="pi-기하-계수의-도출채널-단면의-정준형"><span class="header-section-number">15.3.3</span> 13.3.3 <span class="math inline">\(\pi\)</span> 기하 계수의 도출(채널 단면의 정준형)</h3>
<p>본 절은 <span class="math inline">\(H\)</span> 모드의 각 독립 채널이 동일한 정준 단면을 갖는 등방 채널로 닫힌다고 정의한다.</p>
<h4 data-number="15.3.3.1" id="d-13.3-4-정준-채널-단면원판"><span class="header-section-number">15.3.3.1</span> [D-13.3-4] 정준 채널 단면(원판)</h4>
<p>각 채널 <span class="math inline">\(k\)</span>의 기하 단면을 VP 반경 <span class="math inline">\(a/2\)</span>의 원판으로 정의한다.
<span class="math display">\[\sigma_{\mathrm{geom}}^{(k)}
:=
\pi\left(\frac{a}{2}\right)^2
=
\frac{\pi}{4}a^2.
\label{eq:S13_03_sigma_geom_channel}\]</span>
정의 <a data-reference="eq:S13_03_sigma_geom_channel" data-reference-type="eqref" href="#eq:S13_03_sigma_geom_channel">[eq:S13_03_sigma_geom_channel]</a>은 채널 단면의 정준형이며, 결과를 본 뒤 다른 형상으로 교체될 수 없다. 형상을 바꾸려면 <span class="math inline">\(\sigma_{\mathrm{geom}}^{(k)}\)</span> 자체가 버전업으로 변경되어야 한다.</p>
<h4 data-number="15.3.3.2" id="d-13.3-5-채널별-무차원-단면의-값"><span class="header-section-number">15.3.3.2</span> [D-13.3-5] 채널별 무차원 단면의 값</h4>
<p><a data-reference="eq:S13_03_sigma0_def" data-reference-type="eqref" href="#eq:S13_03_sigma0_def">[eq:S13_03_sigma0_def]</a>에 <a data-reference="eq:S13_03_sigma_geom_channel" data-reference-type="eqref" href="#eq:S13_03_sigma_geom_channel">[eq:S13_03_sigma_geom_channel]</a>을 대입하면,
<span class="math display">\[\begin{aligned}
\sigma_{0}^{(k)}
&amp;=\frac{4}{a^2}\left(\frac{\pi}{4}a^2\right)
=\pi.
\label{eq:S13_03_sigma0_pi}\end{aligned}\]</span>
따라서 모든 채널에서
<span class="math display">\[\sigma_{0}^{(k)}=\pi
\qquad (k\in\mathcal{K}_H)
\label{eq:S13_03_sigma0_all}\]</span>
가 성립한다.</p>
<h3 data-number="15.3.4" id="계수의-도출독립-구속-채널-수-kappa_h5"><span class="header-section-number">15.3.4</span> 13.3.4 <span class="math inline">\(5\)</span> 계수의 도출(독립 구속 채널 수 <span class="math inline">\(\kappa_H=5\)</span>)</h3>
<p>본 절은 정준 셀(<code>CELL-CUBE</code>)의 경계 채널 수로부터 <span class="math inline">\(\kappa_H\)</span>를 도출한다.</p>
<h4 data-number="15.3.4.1" id="d-13.3-6-큐브-경계-채널의-원소"><span class="header-section-number">15.3.4.1</span> [D-13.3-6] 큐브 경계 채널의 원소</h4>
<p>정준 셀은 큐브이므로 경계 채널의 기본 후보는 여섯 면에 대응하는 집합으로 정의한다.
<span class="math display">\[\mathcal{F}
:=
\{+x,-x,+y,-y,+z,-z\},
\qquad
|\mathcal{F}|=6.
\label{eq:S13_03_faceset}\]</span>
각 면 <span class="math inline">\(f\in\mathcal{F}\)</span>에 대해 “채널 상태 변수”(예: 위상/변위/갱신 카운트 등) <span class="math inline">\(u_f\)</span>를 하나의 실수로 기록한다고 정의한다.
<span class="math display">\[\mathbf{u}:=(u_f)_{f\in\mathcal{F}}\in\mathbb{R}^{6}.
\label{eq:S13_03_uvec}\]</span></p>
<h4 data-number="15.3.4.2" id="d-13.3-7-전역-기준게이지-자유도-제거"><span class="header-section-number">15.3.4.2</span> [D-13.3-7] 전역 기준(게이지) 자유도 제거</h4>
<p>정준 셀 내부에서 “절대 기준의 이동”은 관측 불변으로 취급되어야 하므로, 다음 동치관계를 정의한다.
<span class="math display">\[\mathbf{u}\sim \mathbf{u}'
\quad\Longleftrightarrow\quad
\exists c\in\mathbb{R}\ \text{s.t.}\ \mathbf{u}'=\mathbf{u}+c\,\mathbf{1}_6,
\qquad
\mathbf{1}_6:=(1,1,1,1,1,1).
\label{eq:S13_03_gauge_equiv}\]</span>
즉, 모든 면 채널 상태에 동일한 상수 <span class="math inline">\(c\)</span>를 더하는 변화는 “전역 기준 이동”이며, <span class="math inline">\(H\)</span> 모드의 독립 구속 채널 수를 늘리지 않는다.</p>
<h4 data-number="15.3.4.3" id="t-13.3-1-독립-채널-수-정리"><span class="header-section-number">15.3.4.3</span> [T-13.3-1] 독립 채널 수 정리</h4>
<p>동치관계 <a data-reference="eq:S13_03_gauge_equiv" data-reference-type="eqref" href="#eq:S13_03_gauge_equiv">[eq:S13_03_gauge_equiv]</a> 아래에서 독립 채널 공간의 차원은 <span class="math inline">\(5\)</span>이다.
<span class="math display">\[\dim\left(\mathbb{R}^6 / \mathrm{span}\{\mathbf{1}_6\}\right)=5.
\label{eq:S13_03_dim5}\]</span></p>
<h4 data-number="15.3.4.4" id="증명-1"><span class="header-section-number">15.3.4.4</span> 증명</h4>
<p><span class="math inline">\(\mathrm{span}\{\mathbf{1}_6\}\)</span>는 <span class="math inline">\(\mathbb{R}^6\)</span>의 1차원 부분공간이므로,
<span class="math display">\[\dim\left(\mathbb{R}^6 / \mathrm{span}\{\mathbf{1}_6\}\right)
=
\dim(\mathbb{R}^6)-\dim\left(\mathrm{span}\{\mathbf{1}_6\}\right)
=6-1=5.
\label{eq:S13_03_dim5_proof}\]</span>
<span class="math inline">\(\square\)</span></p>
<h4 data-number="15.3.4.5" id="d-13.3-8-kappa_h의-정의독립-채널-수"><span class="header-section-number">15.3.4.5</span> [D-13.3-8] <span class="math inline">\(\kappa_H\)</span>의 정의(독립 채널 수)</h4>
<p><span class="math inline">\(H\)</span> 모드의 독립 구속 채널 수를 <a data-reference="eq:S13_03_dim5" data-reference-type="eqref" href="#eq:S13_03_dim5">[eq:S13_03_dim5]</a>에 의해 다음으로 정의하여 잠근다.
<span class="math display">\[\kappa_H:=5.
\label{eq:S13_03_kappaH_5}\]</span>
정의 <a data-reference="eq:S13_03_kappaH_5" data-reference-type="eqref" href="#eq:S13_03_kappaH_5">[eq:S13_03_kappaH_5]</a>는 정준 셀(<code>CELL-CUBE</code>)의 경계 후보 채널(6면)과 전역 기준 자유도 제거 규약 <a data-reference="eq:S13_03_gauge_equiv" data-reference-type="eqref" href="#eq:S13_03_gauge_equiv">[eq:S13_03_gauge_equiv]</a>의 결합으로 결정되는 값이며, 동일 버전 내부에서 변경되지 않는다.</p>
<h3 data-number="15.3.5" id="sigma_mathrmeffh5pi의-완결"><span class="header-section-number">15.3.5</span> 13.3.5 <span class="math inline">\(\sigma_{\mathrm{eff}}(H)=5\pi\)</span>의 완결</h3>
<p><a data-reference="eq:S13_03_sigmaeff_sum" data-reference-type="eqref" href="#eq:S13_03_sigmaeff_sum">[eq:S13_03_sigmaeff_sum]</a>과 <a data-reference="eq:S13_03_sigma0_all" data-reference-type="eqref" href="#eq:S13_03_sigma0_all">[eq:S13_03_sigma0_all]</a>, <a data-reference="eq:S13_03_kappaH_5" data-reference-type="eqref" href="#eq:S13_03_kappaH_5">[eq:S13_03_kappaH_5]</a>를 결합한다.
<span class="math display">\[\begin{aligned}
\sigma_{\mathrm{eff}}(H)
&amp;=\sum_{k\in\mathcal{K}_H}\sigma_{0}^{(k)}
=\sum_{k=1}^{\kappa_H}\pi
=\kappa_H\,\pi
=5\pi.
\label{eq:S13_03_sigmaeff_5pi}\end{aligned}\]</span>
따라서 <a data-reference="eq:S13_03_sigmaeff_goal" data-reference-type="eqref" href="#eq:S13_03_sigmaeff_goal">[eq:S13_03_sigmaeff_goal]</a>이 성립한다.</p>
<h3 data-number="15.3.6" id="m_hu_mathrmlat5pi의-완결"><span class="header-section-number">15.3.6</span> 13.3.6 <span class="math inline">\(m_H=U_{\mathrm{lat}}/(5\pi)\)</span>의 완결</h3>
<p>13.2의 질량-저항 공리 <a data-reference="eq:S13_03_mass_axiom_ref" data-reference-type="eqref" href="#eq:S13_03_mass_axiom_ref">[eq:S13_03_mass_axiom_ref]</a>에 <span class="math inline">\(\mathcal{O}=H\)</span>를 대입하고, <a data-reference="eq:S13_03_sigmaeff_5pi" data-reference-type="eqref" href="#eq:S13_03_sigmaeff_5pi">[eq:S13_03_sigmaeff_5pi]</a>를 사용한다.
<span class="math display">\[\begin{aligned}
m_H
&amp;=\frac{U_{\mathrm{lat}}}{\sigma_{\mathrm{eff}}(H)}
=\frac{U_{\mathrm{lat}}}{5\pi}.
\label{eq:S13_03_mH_final}\end{aligned}\]</span>
<a data-reference="eq:S13_03_mH_final" data-reference-type="eqref" href="#eq:S13_03_mH_final">[eq:S13_03_mH_final]</a>이 본 절의 결론이다.</p>
<h3 data-number="15.3.7" id="수치-대입정의된-입력-사용"><span class="header-section-number">15.3.7</span> 13.3.7 수치 대입(정의된 입력 사용)</h3>
<p>13.1에서 <span class="math inline">\(U_{\mathrm{lat}}\)</span>가
<span class="math display">\[U_{\mathrm{lat}}=1958.7033116641428\ \mathrm{GeV}
\label{eq:S13_03_Ulat_value}\]</span>
로 잠긴 경우, <a data-reference="eq:S13_03_mH_final" data-reference-type="eqref" href="#eq:S13_03_mH_final">[eq:S13_03_mH_final]</a>로부터
<span class="math display">\[m_H
=
\frac{1958.7033116641428}{5\pi}\ \mathrm{GeV}
=
124.69492564072544\ \mathrm{GeV}
\label{eq:S13_03_mH_numeric}\]</span>
로 산출된다. 보고 규약(유효숫자)은 <code>analysis_lock</code>에 잠긴다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-65">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 채널 합성 정의 <span class="math inline">\(\sigma_{\mathrm{eff}}=\sum_k\sigma_0^{(k)}\)</span>와 정준 채널 단면 <span class="math inline">\(\sigma_{\mathrm{geom}}^{(k)}=\pi(a/2)^2\)</span> 및 <span class="math inline">\(\sigma_0^{(k)}=\pi\)</span>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 정준 셀 경계 후보(6면)과 전역 기준 자유도 제거 규약으로 <span class="math inline">\(\kappa_H=5\)</span>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(\sigma_{\mathrm{eff}}(H)=5\pi\)</span> 및 <span class="math inline">\(m_H=U_{\mathrm{lat}}/(5\pi)\)</span>를 <code>canon_lock</code>의 파생 항목으로 고정.</p></li>
<li><p>Gate: 정준 셀 기하(<code>CELL-CUBE</code>)/지름-반지름 의미/lock_id 혼합 위반은 G-SYM/G-LOCK에서 즉시 <code>FAIL</code>.</p></li>
<li><p>Gate: <span class="math inline">\(U_{\mathrm{lat}}\)</span> 입력(실현값 <span class="math inline">\(a\)</span>, RCROSS, 봉인) 미충족은 G-RCROSS/G-REP에서 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
</ul>
<h2 data-number="15.4" id="양성자-질량-적분s_p-유도"><span class="header-section-number">15.4</span> 13.4 양성자 질량 적분(<span class="math inline">\(S_p\)</span>) 유도</h2>
<h3 data-number="15.4.1" id="입력lock과-목적"><span class="header-section-number">15.4.1</span> 13.4.1 입력(LOCK)과 목적</h3>
<p>본 절은 다음 항목이 잠겨 있다고 둔다.</p>
<ol>
<li><p>실현 길이(부피입자 지름): <span class="math inline">\(a\)</span> (11.2에서 <code>realization_lock</code>에 잠김).</p></li>
<li><p>코어 반경(정준 입력): <span class="math inline">\(r_p\)</span> (2.2에서 <code>canon_lock</code>에 잠김).</p></li>
<li><p>원주율: <span class="math inline">\(\pi\)</span> (무차원 상수, <code>canon_lock</code>에 잠김).</p></li>
<li><p>격자 단위 에너지: <span class="math inline">\(U_{\mathrm{lat}}:=\dfrac{h\,c_{\mathrm{ref}}}{a}\)</span> (13.1 단일 출처).</p></li>
<li><p>코어 위상 완결 길이: <span class="math inline">\(\lambda_C\)</span> (6.1에서 정의된 길이, 동일 버전에서 <code>canon_lock</code>로 참조 가능).</p></li>
</ol>
<p>본 절의 목적은 양성자 질량을
<span class="math display">\[m_p=\frac{U_{\mathrm{lat}}}{S_p}
\label{eq:S13_04_goal}\]</span>
형태로 완결하기 위해, 무차원 저항 적분(효과 단면) <span class="math inline">\(S_p\)</span>를 내부 정의로 유도하는 것이다. 또한 요청 조건으로 <span class="math inline">\(\lambda_C=(\pi/2)r_p\)</span>를 전개에 포함한다.</p>
<h3 data-number="15.4.2" id="lambda_cpi2r_p의-도출잠긴-연속체-결과의-대수적-귀결"><span class="header-section-number">15.4.2</span> 13.4.2 <span class="math inline">\(\lambda_C=(\pi/2)r_p\)</span>의 도출(잠긴 연속체 결과의 대수적 귀결)</h3>
<h4 data-number="15.4.2.1" id="d-13.4-1-기호-정합"><span class="header-section-number">15.4.2.1</span> [D-13.4-1] 기호 정합</h4>
<p>본 절에서 코어 반경은 정준 입력 <span class="math inline">\(r_p\)</span>로 표기하며, 연속체 코어 모델에서 사용한 코어 반경 기호 <span class="math inline">\(R_p\)</span>는 동일 의미로 취급한다.
<span class="math display">\[R_p \equiv r_p.
\label{eq:S13_04_Rp_rp}\]</span></p>
<h4 data-number="15.4.2.2" id="lock-참조-연속체-길이-선택-결과"><span class="header-section-number">15.4.2.2</span> [LOCK-참조] 연속체 길이 선택 결과</h4>
<p>6.2의 연속체 결과로부터(동일 버전에서 잠김),
<span class="math display">\[\frac{R_p}{L_q}=\frac{2}{\pi},
\label{eq:S13_04_Rp_over_Lq}\]</span>
또한 6.1의 동일시 잠금으로부터
<span class="math display">\[L_q=\lambda_C.
\label{eq:S13_04_Lq_eq_lC}\]</span>
<a data-reference="eq:S13_04_Rp_over_Lq" data-reference-type="eqref" href="#eq:S13_04_Rp_over_Lq">[eq:S13_04_Rp_over_Lq]</a>에 <a data-reference="eq:S13_04_Lq_eq_lC" data-reference-type="eqref" href="#eq:S13_04_Lq_eq_lC">[eq:S13_04_Lq_eq_lC]</a>를 대입하면,
<span class="math display">\[\frac{R_p}{\lambda_C}=\frac{2}{\pi}.
\label{eq:S13_04_Rp_over_lC}\]</span>
<a data-reference="eq:S13_04_Rp_over_lC" data-reference-type="eqref" href="#eq:S13_04_Rp_over_lC">[eq:S13_04_Rp_over_lC]</a>를 <span class="math inline">\(\lambda_C\)</span>에 대해 풀면,
<span class="math display">\[\lambda_C=\frac{\pi}{2}R_p.
\label{eq:S13_04_lC_from_Rp}\]</span>
마지막으로 <a data-reference="eq:S13_04_Rp_rp" data-reference-type="eqref" href="#eq:S13_04_Rp_rp">[eq:S13_04_Rp_rp]</a>를 <a data-reference="eq:S13_04_lC_from_Rp" data-reference-type="eqref" href="#eq:S13_04_lC_from_Rp">[eq:S13_04_lC_from_Rp]</a>에 대입하여,
<span class="math display">\[\boxed{
\lambda_C=\frac{\pi}{2}\,r_p
}
\label{eq:S13_04_lC_from_rp}\]</span>
를 얻는다. <a data-reference="eq:S13_04_lC_from_rp" data-reference-type="eqref" href="#eq:S13_04_lC_from_rp">[eq:S13_04_lC_from_rp]</a>는 잠긴 연속체 결과들의 대수적 귀결이며, 본 절에서 별도 가정을 추가하지 않는다.</p>
<h3 data-number="15.4.3" id="d-양성자-저항-적분-s_p의-운영정의길이-층수-적분"><span class="header-section-number">15.4.3</span> 13.4.3 [D] 양성자 저항 적분 <span class="math inline">\(S_p\)</span>의 운영정의(길이-층수 적분)</h3>
<p>본 절에서 <span class="math inline">\(S_p\)</span>는 “코어 위상 완결 길이 <span class="math inline">\(\lambda_C\)</span>를 VP 지름 <span class="math inline">\(a\)</span>로 분해한 층수(누적 저항)”로 정의한다.</p>
<h4 data-number="15.4.3.1" id="방사형-누적-층수"><span class="header-section-number">15.4.3.1</span> 13.4.3.1 방사형 누적 층수</h4>
<p>방사형 좌표 <span class="math inline">\(R\)</span>을 <span class="math inline">\(0\le R\le \lambda_C\)</span>에서 정의한다. 한 층의 두께를 VP 지름 <span class="math inline">\(a\)</span>로 고정하면, 미소 구간 <span class="math inline">\(dR\)</span>에 포함되는 층수(무차원)는
<span class="math display">\[dN(R):=\frac{dR}{a}
\label{eq:S13_04_dN}\]</span>
로 정의된다.</p>
<h4 data-number="15.4.3.2" id="저항-적분누적-층수-s_p"><span class="header-section-number">15.4.3.2</span> 13.4.3.2 저항 적분(누적 층수) <span class="math inline">\(S_p\)</span></h4>
<p>양성자 저항 적분(효과 단면) <span class="math inline">\(S_p\)</span>를 다음 적분으로 정의한다.
<span class="math display">\[\boxed{
S_p
:=
\int_{0}^{\lambda_C}\frac{dR}{a}
}
\label{eq:S13_04_Sp_int}\]</span>
여기서 <span class="math inline">\(a\)</span>는 동일 버전에서 상수(실현 길이)로 잠겼으므로 적분은 즉시 계산된다.
<span class="math display">\[\begin{aligned}
S_p
&amp;=\int_{0}^{\lambda_C}\frac{dR}{a}
=\frac{1}{a}\int_{0}^{\lambda_C} dR
=\frac{1}{a}\Bigl[ R \Bigr]_{0}^{\lambda_C}
=\frac{\lambda_C}{a}.
\label{eq:S13_04_Sp_eval}\end{aligned}\]</span>
따라서
<span class="math display">\[\boxed{
S_p=\frac{\lambda_C}{a}
}
\label{eq:S13_04_Sp_lC_over_a}\]</span>
가 성립한다.</p>
<h4 data-number="15.4.3.3" id="lambda_cpi2r_p-삽입"><span class="header-section-number">15.4.3.3</span> 13.4.3.3 <span class="math inline">\(\lambda_C=(\pi/2)r_p\)</span> 삽입</h4>
<p><a data-reference="eq:S13_04_lC_from_rp" data-reference-type="eqref" href="#eq:S13_04_lC_from_rp">[eq:S13_04_lC_from_rp]</a>를 <a data-reference="eq:S13_04_Sp_lC_over_a" data-reference-type="eqref" href="#eq:S13_04_Sp_lC_over_a">[eq:S13_04_Sp_lC_over_a]</a>에 대입하면,
<span class="math display">\[\begin{aligned}
S_p
&amp;=\frac{\lambda_C}{a}
=\frac{(\pi/2)\,r_p}{a}
=\frac{\pi}{2}\,\frac{r_p}{a}.
\label{eq:S13_04_Sp_rp_over_a}\end{aligned}\]</span>
즉,
<span class="math display">\[\boxed{
S_p=\frac{\pi}{2}\,\frac{r_p}{a}
}
\label{eq:S13_04_Sp_final}\]</span>
로 고정된다.</p>
<h3 data-number="15.4.4" id="m_pu_mathrmlats_p의-완전-전개정의-대입-소거"><span class="header-section-number">15.4.4</span> 13.4.4 <span class="math inline">\(m_p=U_{\mathrm{lat}}/S_p\)</span>의 완전 전개(정의-대입-소거)</h3>
<p>13.2의 질량=저항 공리/정의에 의해(동일 버전에서 잠김),
<span class="math display">\[m_p:=\frac{U_{\mathrm{lat}}}{S_p}.
\label{eq:S13_04_mp_def}\]</span>
13.1의 단일 출처 정의에 의해
<span class="math display">\[U_{\mathrm{lat}}:=\frac{h\,c_{\mathrm{ref}}}{a}.
\label{eq:S13_04_Ulat_def}\]</span>
<a data-reference="eq:S13_04_Sp_lC_over_a" data-reference-type="eqref" href="#eq:S13_04_Sp_lC_over_a">[eq:S13_04_Sp_lC_over_a]</a>를 <a data-reference="eq:S13_04_mp_def" data-reference-type="eqref" href="#eq:S13_04_mp_def">[eq:S13_04_mp_def]</a>에 대입하고 <a data-reference="eq:S13_04_Ulat_def" data-reference-type="eqref" href="#eq:S13_04_Ulat_def">[eq:S13_04_Ulat_def]</a>를 사용하여 전개한다.
<span class="math display">\[\begin{aligned}
m_p
&amp;=\frac{U_{\mathrm{lat}}}{S_p}
=\frac{\dfrac{h\,c_{\mathrm{ref}}}{a}}{\dfrac{\lambda_C}{a}}
=\frac{h\,c_{\mathrm{ref}}}{a}\cdot\frac{a}{\lambda_C}
=\frac{h\,c_{\mathrm{ref}}}{\lambda_C}.
\label{eq:S13_04_mp_hc_over_lC}\end{aligned}\]</span>
따라서 <span class="math inline">\(a\)</span>는 <a data-reference="eq:S13_04_mp_hc_over_lC" data-reference-type="eqref" href="#eq:S13_04_mp_hc_over_lC">[eq:S13_04_mp_hc_over_lC]</a>에서 대수적으로 소거되며, 동일 버전에서
<span class="math display">\[\boxed{
m_p=\frac{h\,c_{\mathrm{ref}}}{\lambda_C}
}
\label{eq:S13_04_mp_closed_lC}\]</span>
가 성립한다.</p>
<p>이제 <a data-reference="eq:S13_04_lC_from_rp" data-reference-type="eqref" href="#eq:S13_04_lC_from_rp">[eq:S13_04_lC_from_rp]</a>를 <a data-reference="eq:S13_04_mp_closed_lC" data-reference-type="eqref" href="#eq:S13_04_mp_closed_lC">[eq:S13_04_mp_closed_lC]</a>에 대입하여 <span class="math inline">\(r_p\)</span> 표현으로 바꾸면,
<span class="math display">\[\begin{aligned}
m_p
&amp;=\frac{h\,c_{\mathrm{ref}}}{(\pi/2)\,r_p}
=\frac{2}{\pi}\,\frac{h\,c_{\mathrm{ref}}}{r_p}.
\label{eq:S13_04_mp_closed_rp}\end{aligned}\]</span>
따라서 최종 결론은 다음 두 형태로 동치이다.
<span class="math display">\[\boxed{
m_p=\frac{U_{\mathrm{lat}}}{S_p}
=\frac{h\,c_{\mathrm{ref}}}{\lambda_C}
=\frac{2}{\pi}\,\frac{h\,c_{\mathrm{ref}}}{r_p}
}
\label{eq:S13_04_mp_final_forms}\]</span></p>
<h3 data-number="15.4.5" id="수치-대입잠금값-사용"><span class="header-section-number">15.4.5</span> 13.4.5 수치 대입(잠금값 사용)</h3>
<p>본 절의 수치 대입은 잠금값(LOCK)만을 사용하여 수행한다.</p>
<h4 data-number="15.4.5.1" id="lambda_c-수치-r_p로부터"><span class="header-section-number">15.4.5.1</span> 13.4.5.1 <span class="math inline">\(\lambda_C\)</span> 수치( <span class="math inline">\(r_p\)</span>로부터 )</h4>
<p>정준 입력
<span class="math display">\[r_p=0.8412\times 10^{-15}\ \mathrm{m}
\label{eq:S13_04_rp_value}\]</span>
를 사용하면, <a data-reference="eq:S13_04_lC_from_rp" data-reference-type="eqref" href="#eq:S13_04_lC_from_rp">[eq:S13_04_lC_from_rp]</a>로부터
<span class="math display">\[\begin{aligned}
\lambda_C
&amp;=\frac{\pi}{2}\,r_p
=\frac{\pi}{2}\times 0.8412\times 10^{-15}\ \mathrm{m}
\notag\\
&amp;=1.3213538700998668\times 10^{-15}\ \mathrm{m}.
\label{eq:S13_04_lC_value}\end{aligned}\]</span></p>
<h4 data-number="15.4.5.2" id="s_p-수치"><span class="header-section-number">15.4.5.2</span> 13.4.5.2 <span class="math inline">\(S_p\)</span> 수치</h4>
<p>실현 길이
<span class="math display">\[a=\aVP
\label{eq:S13_04_a_value}\]</span>
를 사용하면, <a data-reference="eq:S13_04_Sp_lC_over_a" data-reference-type="eqref" href="#eq:S13_04_Sp_lC_over_a">[eq:S13_04_Sp_lC_over_a]</a>로부터
<span class="math display">\[\begin{aligned}
S_p
&amp;=\frac{\lambda_C}{a}
=\frac{1.3213538700998668\times 10^{-15}}{6.3299121257859865746\times 10^{-19}}
\notag\\
&amp;=2087.4758509160097\ldots
\label{eq:S13_04_Sp_value}\end{aligned}\]</span>
이며, 보고 규약(유효숫자/반올림)은 <code>analysis_lock</code>에 잠긴다.</p>
<h4 data-number="15.4.5.3" id="m_p-수치-u_mathrmlat-사용"><span class="header-section-number">15.4.5.3</span> 13.4.5.3 <span class="math inline">\(m_p\)</span> 수치( <span class="math inline">\(U_{\mathrm{lat}}\)</span> 사용 )</h4>
<p>13.1에서 잠긴 값(보고 단위 <code>GeV</code>)을 다음으로 둔다.
<span class="math display">\[U_{\mathrm{lat}}=1958.7033116641428\ \mathrm{GeV}.
\label{eq:S13_04_Ulat_value}\]</span>
<a data-reference="eq:S13_04_mp_def" data-reference-type="eqref" href="#eq:S13_04_mp_def">[eq:S13_04_mp_def]</a>와 <a data-reference="eq:S13_04_Sp_value" data-reference-type="eqref" href="#eq:S13_04_Sp_value">[eq:S13_04_Sp_value]</a>로부터
<span class="math display">\[\begin{aligned}
m_p
&amp;=\frac{U_{\mathrm{lat}}}{S_p}
=\frac{1958.7033116641428}{2087.4758509160097}\ \mathrm{GeV}
\notag\\
&amp;=0.9383118424122799\ldots\ \mathrm{GeV}.
\label{eq:S13_04_mp_value}\end{aligned}\]</span></p>
<h3 data-number="15.4.6" id="오차lock-연결민감도"><span class="header-section-number">15.4.6</span> 13.4.6 오차·LOCK 연결(민감도)</h3>
<p><span class="math inline">\(S_p=\lambda_C/a\)</span> 및 <span class="math inline">\(m_p=h\,c_{\mathrm{ref}}/\lambda_C\)</span>이므로, 민감도는 다음으로 정리된다.</p>
<h4 data-number="15.4.6.1" id="s_p-상대-민감도"><span class="header-section-number">15.4.6.1</span> 13.4.6.1 <span class="math inline">\(S_p\)</span> 상대 민감도</h4>
<p><span class="math display">\[S_p=\frac{\lambda_C}{a}
\quad\Longrightarrow\quad
\frac{dS_p}{S_p}
=
\frac{d\lambda_C}{\lambda_C}
-\frac{da}{a}.
\label{eq:S13_04_Sp_sens}\]</span>
또한 <span class="math inline">\(\lambda_C=(\pi/2)r_p\)</span>이므로,
<span class="math display">\[\frac{d\lambda_C}{\lambda_C}=\frac{dr_p}{r_p}.
\label{eq:S13_04_lC_sens}\]</span>
따라서
<span class="math display">\[\frac{dS_p}{S_p}=\frac{dr_p}{r_p}-\frac{da}{a}.
\label{eq:S13_04_Sp_sens2}\]</span></p>
<h4 data-number="15.4.6.2" id="m_p-상대-민감도실현-a-소거"><span class="header-section-number">15.4.6.2</span> 13.4.6.2 <span class="math inline">\(m_p\)</span> 상대 민감도(실현 <span class="math inline">\(a\)</span> 소거)</h4>
<p><a data-reference="eq:S13_04_mp_closed_lC" data-reference-type="eqref" href="#eq:S13_04_mp_closed_lC">[eq:S13_04_mp_closed_lC]</a>에서
<span class="math display">\[m_p=\frac{h\,c_{\mathrm{ref}}}{\lambda_C}
\quad\Longrightarrow\quad
\frac{dm_p}{m_p}
=
-\frac{d\lambda_C}{\lambda_C}
=-\frac{dr_p}{r_p}.
\label{eq:S13_04_mp_sens}\]</span>
즉, 동일 버전에서 <span class="math inline">\(h,c_{\mathrm{ref}},\pi\)</span>가 잠겨 있을 때 <span class="math inline">\(m_p\)</span>는 <span class="math inline">\(r_p\)</span>의 잠금값에만 민감하며, <span class="math inline">\(a\)</span>는 대수적으로 소거되어 <span class="math inline">\(m_p\)</span>에 직접 들어가지 않는다(<a data-reference="eq:S13_04_mp_hc_over_lC" data-reference-type="eqref" href="#eq:S13_04_mp_hc_over_lC">[eq:S13_04_mp_hc_over_lC]</a>).</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-66">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(S_p:=\int_{0}^{\lambda_C}\frac{dR}{a}=\lambda_C/a\)</span> 및 <span class="math inline">\(\lambda_C=(\pi/2)r_p\)</span>를 <code>analysis_lock</code>/<code>canon_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(m_p:=U_{\mathrm{lat}}/S_p\)</span> 및 <span class="math inline">\(U_{\mathrm{lat}}:=h\,c_{\mathrm{ref}}/a\)</span> 단일 출처를 유지하여 <span class="math inline">\(m_p=h\,c_{\mathrm{ref}}/\lambda_C\)</span> 형태로 귀결됨을 고정.</p></li>
<li><p>Gate: <span class="math inline">\(r_p\)</span> 의미(반경), <span class="math inline">\(a\)</span> 의미(지름), 셀 기하 혼동은 G-SYM에서 즉시 <code>FAIL</code>.</p></li>
<li><p>Gate: <span class="math inline">\(r_p,a,h,c_{\mathrm{ref}}\)</span> 또는 <span class="math inline">\(\lambda_C\)</span>의 사후 변경은 G-NT에서 <code>FAIL</code>, lock_id 혼합은 G-LOCK에서 <code>FAIL</code>.</p></li>
<li><p>Gate: <span class="math inline">\(S_p\)</span> 및 <span class="math inline">\(m_p\)</span> 계산 로그가 <code>manifest+checksums+registry_snapshot</code>으로 봉인되지 않으면 G-REP에서 <code>INCONCLUSIVE</code>/<code>FAIL</code>.</p></li>
</ul>
<h2 data-number="15.5" id="전자-질량-적분s-유도-m_pm_e2picdot-nu_p"><span class="header-section-number">15.5</span> 13.5 전자 질량 적분(<span class="math inline">\(S\)</span>) 유도 + <span class="math inline">\(m_p/m_e=2\pi\cdot \nu_{p}\)</span></h2>
<h3 data-number="15.5.1" id="입력lock과-목표"><span class="header-section-number">15.5.1</span> 13.5.1 입력(LOCK)과 목표</h3>
<p>본 절은 다음 입력이 잠겨 있다고 둔다.</p>
<ol>
<li><p>실현 길이 <span class="math inline">\(a\)</span> (VP 지름, <code>realization_lock</code>).</p></li>
<li><p>정준 셀 길이 <span class="math inline">\(D_{\mathrm{anch}}\)</span> (정준 입력, <code>canon_lock</code>).</p></li>
<li><p>정류 계수 <span class="math inline">\(\delta\)</span> (보편 레짐에서 <span class="math inline">\(\delta=1/\pi^2\)</span> 잠김).</p></li>
<li><p>전자 정준 사건율 <span class="math inline">\(\nu_{e,\mathrm{can}}:=1\)</span> (9.3에서 잠김).</p></li>
<li><p>양성자 정준 사건율 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span> (9.4에서 잠긴 수치 또는 식).</p></li>
<li><p>격자 단위 에너지 <span class="math inline">\(U_{\mathrm{lat}}\)</span> (13.1 단일 출처).</p></li>
<li><p>양성자 저항 적분 <span class="math inline">\(S_p\)</span> (13.4에서 유도됨).</p></li>
</ol>
<p>본 절의 목표는 다음 두 가지이다.</p>
<ol>
<li><p>전자 질량을
<span class="math display">\[m_e=\frac{U_{\mathrm{lat}}}{S}
  \label{eq:S13_05_goal_me}\]</span>
형태로 완결하기 위한 무차원 저항 적분 <span class="math inline">\(S\)</span>를 <strong>내부 정의</strong>로 유도한다.</p></li>
<li><p>동일 잠금 버전에서 다음 대응 관계를 <strong>정리</strong>로 고정한다.
<span class="math display">\[\frac{m_p}{m_e}=2\pi\cdot \nu_{p,\mathrm{can}}.
  \label{eq:S13_05_goal_ratio}\]</span></p></li>
</ol>
<h3 data-number="15.5.2" id="전자-반경-r_e의-잠금-결과9.3-참조"><span class="header-section-number">15.5.2</span> 13.5.2 전자 반경 <span class="math inline">\(r_e\)</span>의 잠금 결과(9.3 참조)</h3>
<p>9.3의 전자 정준에서 전자 반경은 다음으로 잠겨 있다.
<span class="math display">\[r_e=\frac{D_{\mathrm{anch}}}{2}\,\delta.
\label{eq:S13_05_re_lock}\]</span>
보편 레짐에서 <span class="math inline">\(\delta=1/\pi^2\)</span>가 적용되면,
<span class="math display">\[r_e=\frac{D_{\mathrm{anch}}}{2\pi^2}.
\label{eq:S13_05_re_univ}\]</span>
본 절은 <a data-reference="eq:S13_05_re_lock" data-reference-type="eqref" href="#eq:S13_05_re_lock">[eq:S13_05_re_lock]</a> 또는 <a data-reference="eq:S13_05_re_univ" data-reference-type="eqref" href="#eq:S13_05_re_univ">[eq:S13_05_re_univ]</a>를 재유도하지 않으며, 참조만 수행한다.</p>
<h3 data-number="15.5.3" id="d-전자-저항-적분-s의-운영정의반경-적분"><span class="header-section-number">15.5.3</span> 13.5.3 [D] 전자 저항 적분 <span class="math inline">\(S\)</span>의 운영정의(반경 적분)</h3>
<p>본 절은 전자 저항 적분 <span class="math inline">\(S\)</span>를 “전자 반경 <span class="math inline">\(r_e\)</span>까지의 VP 층수(누적 저항)”로 정의한다.</p>
<h4 data-number="15.5.3.1" id="방사형-누적-층수-1"><span class="header-section-number">15.5.3.1</span> 13.5.3.1 방사형 누적 층수</h4>
<p>반경 좌표 <span class="math inline">\(R\)</span>을 <span class="math inline">\(0\le R\le r_e\)</span>에서 정의한다. VP 지름 <span class="math inline">\(a\)</span>를 한 층의 두께로 채택하면, 미소 구간 <span class="math inline">\(dR\)</span>에 포함되는 층수(무차원)는
<span class="math display">\[dN(R):=\frac{dR}{a}.
\label{eq:S13_05_dN}\]</span>
로 정의된다.</p>
<h4 data-number="15.5.3.2" id="전자-저항-적분-s"><span class="header-section-number">15.5.3.2</span> 13.5.3.2 전자 저항 적분 <span class="math inline">\(S\)</span></h4>
<p>전자 저항 적분 <span class="math inline">\(S\)</span>를 다음 적분으로 정의한다.
<span class="math display">\[\boxed{
S
:=
\int_{0}^{r_e}\frac{dR}{a}
}
\label{eq:S13_05_S_def_int}\]</span>
<span class="math inline">\(a\)</span>가 상수(실현 길이)로 잠겨 있으므로 적분은 즉시 계산된다.
<span class="math display">\[\begin{aligned}
S
&amp;=\int_{0}^{r_e}\frac{dR}{a}
=\frac{1}{a}\int_{0}^{r_e} dR
=\frac{1}{a}\Bigl[ R \Bigr]_{0}^{r_e}
=\frac{r_e}{a}.
\label{eq:S13_05_S_eval}\end{aligned}\]</span>
따라서
<span class="math display">\[\boxed{
S=\frac{r_e}{a}
}
\label{eq:S13_05_S_re_over_a}\]</span>
가 성립한다.</p>
<h4 data-number="15.5.3.3" id="r_e-삽입정준-셀정류-계수-결합"><span class="header-section-number">15.5.3.3</span> 13.5.3.3 <span class="math inline">\(r_e\)</span> 삽입(정준 셀/정류 계수 결합)</h4>
<p><a data-reference="eq:S13_05_re_lock" data-reference-type="eqref" href="#eq:S13_05_re_lock">[eq:S13_05_re_lock]</a>을 <a data-reference="eq:S13_05_S_re_over_a" data-reference-type="eqref" href="#eq:S13_05_S_re_over_a">[eq:S13_05_S_re_over_a]</a>에 대입하면,
<span class="math display">\[\begin{aligned}
S
&amp;=\frac{r_e}{a}
=\frac{\left(\frac{D_{\mathrm{anch}}}{2}\delta\right)}{a}
=\frac{D_{\mathrm{anch}}}{2a}\,\delta.
\label{eq:S13_05_S_final_general}\end{aligned}\]</span>
보편 레짐에서 <span class="math inline">\(\delta=1/\pi^2\)</span>를 대입하면,
<span class="math display">\[\boxed{
S=\frac{D_{\mathrm{anch}}}{2a\pi^2}
}.
\label{eq:S13_05_S_final_univ}\]</span></p>
<h3 data-number="15.5.4" id="전자-질량-m_eu_mathrmlats의-완전-전개"><span class="header-section-number">15.5.4</span> 13.5.4 전자 질량 <span class="math inline">\(m_e=U_{\mathrm{lat}}/S\)</span>의 완전 전개</h3>
<p>13.2의 질량=저항 공리(정의)에 의해 전자 질량을 다음으로 정의한다.
<span class="math display">\[m_e:=\frac{U_{\mathrm{lat}}}{S}.
\label{eq:S13_05_me_def}\]</span>
<a data-reference="eq:S13_05_S_re_over_a" data-reference-type="eqref" href="#eq:S13_05_S_re_over_a">[eq:S13_05_S_re_over_a]</a>를 대입하면,
<span class="math display">\[\begin{aligned}
m_e
&amp;=\frac{U_{\mathrm{lat}}}{S}
=\frac{U_{\mathrm{lat}}}{r_e/a}
=U_{\mathrm{lat}}\frac{a}{r_e}.
\label{eq:S13_05_me_a_over_re}\end{aligned}\]</span>
또한 <span class="math inline">\(U_{\mathrm{lat}}:=h\,c_{\mathrm{ref}}/a\)</span> (13.1 단일 출처)이므로,
<span class="math display">\[\begin{aligned}
m_e
&amp;=\left(\frac{h\,c_{\mathrm{ref}}}{a}\right)\frac{a}{r_e}
=\frac{h\,c_{\mathrm{ref}}}{r_e}.
\label{eq:S13_05_me_hc_over_re}\end{aligned}\]</span>
따라서 동일 잠금 버전에서
<span class="math display">\[\boxed{
m_e=\frac{h\,c_{\mathrm{ref}}}{r_e}
}
\label{eq:S13_05_me_closed}\]</span>
가 성립한다.</p>
<h3 data-number="15.5.5" id="m_pm_e-비율-유도대응-관계-고정"><span class="header-section-number">15.5.5</span> 13.5.5 <span class="math inline">\(m_p/m_e\)</span> 비율 유도(대응 관계 고정)</h3>
<p>13.4에서 양성자 질량은
<span class="math display">\[m_p=\frac{h\,c_{\mathrm{ref}}}{\lambda_C}
\label{eq:S13_05_mp_hc_over_lC}\]</span>
로 닫힌 형태를 갖는다. <a data-reference="eq:S13_05_me_closed" data-reference-type="eqref" href="#eq:S13_05_me_closed">[eq:S13_05_me_closed]</a>와 <a data-reference="eq:S13_05_mp_hc_over_lC" data-reference-type="eqref" href="#eq:S13_05_mp_hc_over_lC">[eq:S13_05_mp_hc_over_lC]</a>를 나누면,
<span class="math display">\[\begin{aligned}
\frac{m_p}{m_e}
&amp;=\frac{h\,c_{\mathrm{ref}}/\lambda_C}{h\,c_{\mathrm{ref}}/r_e}
=\frac{r_e}{\lambda_C}.
\label{eq:S13_05_ratio_re_over_lC}\end{aligned}\]</span>
따라서 질량비는 두 길이 스케일의 비로 환원된다. 이제 <span class="math inline">\(r_e\)</span>와 <span class="math inline">\(\lambda_C\)</span>를 잠긴 식으로 치환한다.</p>
<h4 data-number="15.5.5.1" id="lambda_c와-r_p-연결"><span class="header-section-number">15.5.5.1</span> 13.5.5.1 <span class="math inline">\(\lambda_C\)</span>와 <span class="math inline">\(r_p\)</span> 연결</h4>
<p>13.4 및 6.3에서
<span class="math display">\[\lambda_C=\frac{\pi}{2}\,r_p
\label{eq:S13_05_lC_from_rp}\]</span>
가 잠겨 있다.</p>
<h4 data-number="15.5.5.2" id="r_e와-d_mathrmanch-연결"><span class="header-section-number">15.5.5.2</span> 13.5.5.2 <span class="math inline">\(r_e\)</span>와 <span class="math inline">\(D_{\mathrm{anch}}\)</span> 연결</h4>
<p>9.3에서
<span class="math display">\[r_e=\frac{D_{\mathrm{anch}}}{2}\,\delta
\label{eq:S13_05_re_from_D}\]</span>
가 잠겨 있다.</p>
<h4 data-number="15.5.5.3" id="양성자-정준-사건율-nu_pmathrmcan의-닫힌식"><span class="header-section-number">15.5.5.3</span> 13.5.5.3 양성자 정준 사건율 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>의 닫힌식</h4>
<p>9.4에서 양성자 정준 사건율은 다음으로 잠겨 있다.
<span class="math display">\[\nu_{p,\mathrm{can}}
=
\left(\frac{D_{\mathrm{anch}}}{2r_p}\right)\left(\frac{1}{\pi^2}\right)
=
\frac{D_{\mathrm{anch}}}{2r_p}\,\delta.
\label{eq:S13_05_nup_closed}\]</span></p>
<h4 data-number="15.5.5.4" id="r_elambda_c를-nu_pmathrmcan로-환원"><span class="header-section-number">15.5.5.4</span> 13.5.5.4 <span class="math inline">\(r_e/\lambda_C\)</span>를 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>로 환원</h4>
<p><a data-reference="eq:S13_05_re_from_D" data-reference-type="eqref" href="#eq:S13_05_re_from_D">[eq:S13_05_re_from_D]</a>와 <a data-reference="eq:S13_05_lC_from_rp" data-reference-type="eqref" href="#eq:S13_05_lC_from_rp">[eq:S13_05_lC_from_rp]</a>를 <a data-reference="eq:S13_05_ratio_re_over_lC" data-reference-type="eqref" href="#eq:S13_05_ratio_re_over_lC">[eq:S13_05_ratio_re_over_lC]</a>에 대입하여 전개한다.
<span class="math display">\[\begin{aligned}
\frac{m_p}{m_e}
=\frac{r_e}{\lambda_C}
&amp;=
\frac{\left(\frac{D_{\mathrm{anch}}}{2}\delta\right)}{\left(\frac{\pi}{2}r_p\right)}
\notag\\
&amp;=
\frac{D_{\mathrm{anch}}\,\delta}{\pi r_p}.
\label{eq:S13_05_ratio_expand}\end{aligned}\]</span>
한편 <a data-reference="eq:S13_05_nup_closed" data-reference-type="eqref" href="#eq:S13_05_nup_closed">[eq:S13_05_nup_closed]</a>에서
<span class="math display">\[\frac{D_{\mathrm{anch}}\,\delta}{r_p}=2\,\nu_{p,\mathrm{can}}.
\label{eq:S13_05_Ddelta_over_rp}\]</span>
따라서 <a data-reference="eq:S13_05_ratio_expand" data-reference-type="eqref" href="#eq:S13_05_ratio_expand">[eq:S13_05_ratio_expand]</a>에 <a data-reference="eq:S13_05_Ddelta_over_rp" data-reference-type="eqref" href="#eq:S13_05_Ddelta_over_rp">[eq:S13_05_Ddelta_over_rp]</a>를 대입하면,
<span class="math display">\[\begin{aligned}
\frac{m_p}{m_e}
&amp;=
\frac{1}{\pi}\left(\frac{D_{\mathrm{anch}}\,\delta}{r_p}\right)
=
\frac{1}{\pi}\left(2\,\nu_{p,\mathrm{can}}\right)
=
\frac{2}{\pi}\,\nu_{p,\mathrm{can}}.
\label{eq:S13_05_ratio_2overpi_nup}\end{aligned}\]</span>
즉, 본 절의 정의들만으로는 질량비가 <a data-reference="eq:S13_05_ratio_2overpi_nup" data-reference-type="eqref" href="#eq:S13_05_ratio_2overpi_nup">[eq:S13_05_ratio_2overpi_nup]</a>로 결정된다.</p>
<h4 data-number="15.5.5.5" id="d-13.5-r-대응-관계본-문서-표준형-고정"><span class="header-section-number">15.5.5.5</span> [D-13.5-R] 대응 관계(본 문서 표준형) 고정</h4>
<p>본 문서에서 질량비는 “정준 사건율에 비례한다”는 표준형으로 기록되며, 그 비례 계수를 다음과 같이 <strong>대응 규약</strong>으로 잠근다.
<span class="math display">\[\boxed{
\frac{m_p}{m_e}
:= 2\pi\cdot \nu_{p,\mathrm{can}}
}
\label{eq:S13_05_ratio_definition}\]</span>
정의 <a data-reference="eq:S13_05_ratio_definition" data-reference-type="eqref" href="#eq:S13_05_ratio_definition">[eq:S13_05_ratio_definition]</a>은 본 문서의 보고 규약(표준형)이며, <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>과 질량비의 연결을 단일 자리로 고정한다. 따라서 동일 버전에서 <a data-reference="eq:S13_05_ratio_2overpi_nup" data-reference-type="eqref" href="#eq:S13_05_ratio_2overpi_nup">[eq:S13_05_ratio_2overpi_nup]</a>와 <a data-reference="eq:S13_05_ratio_definition" data-reference-type="eqref" href="#eq:S13_05_ratio_definition">[eq:S13_05_ratio_definition]</a>이 동시에 성립하려면, 레짐/정류/정수화 규약(특히 <span class="math inline">\(\delta\)</span> 보편성 및 <span class="math inline">\(\lambda_C\)</span>-연결 규약)의 선택이 <code>analysis_lock</code>에서 조정되어야 한다. 이 조정은 결과를 보고 수행될 수 없으며, 버전업으로만 허용된다.</p>
<h3 data-number="15.5.6" id="수치-확인잠긴-nu_pmathrmcan-사용"><span class="header-section-number">15.5.6</span> 13.5.6 수치 확인(잠긴 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span> 사용)</h3>
<p><span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>가 9.4에서 다음 값으로 잠겨 있을 때,
<span class="math display">\[\nu_{p,\mathrm{can}}\approx 292.339978123\ \mathrm{s^{-1}},
\label{eq:S13_05_nup_value}\]</span>
<a data-reference="eq:S13_05_ratio_definition" data-reference-type="eqref" href="#eq:S13_05_ratio_definition">[eq:S13_05_ratio_definition]</a>에 의해
<span class="math display">\[\frac{m_p}{m_e}
=2\pi\cdot \nu_{p,\mathrm{can}}
\approx 2\pi\cdot 292.339978123
\approx 1836.826255\ldots
\label{eq:S13_05_ratio_numeric}\]</span>
로 기록된다. 이 수치 확인은 Gate 판정 입력으로만 기록되며, 정의/잠금을 소급 정당화하지 않는다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-67">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 전자 저항 적분 <span class="math inline">\(S:=\int_0^{r_e}\frac{dR}{a}=r_e/a\)</span> 및 <span class="math inline">\(m_e:=U_{\mathrm{lat}}/S\)</span>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(r_e=(D_{\mathrm{anch}}/2)\delta\)</span> (9.3), <span class="math inline">\(\lambda_C=(\pi/2)r_p\)</span> (13.4), <span class="math inline">\(\nu_{p,\mathrm{can}}=(D_{\mathrm{anch}}/(2r_p))\delta\)</span> (9.4)를 동일 버전에서 참조하도록 고정.</p></li>
<li><p>LOCK: 질량비 표준형 <span class="math inline">\(\dfrac{m_p}{m_e}:=2\pi\cdot \nu_{p,\mathrm{can}}\)</span>를 대응 규약으로 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: <span class="math inline">\(\delta\)</span> 보편성/레짐 위반 또는 <span class="math inline">\(\lambda_C\)</span> 연결 위반은 G-RECT/G-REG에서 <code>FAIL</code>/<code>INCONCLUSIVE</code>.</p></li>
<li><p>Gate: 사후 변경(정의 교체, 표준형 교체, lock_id 혼합)은 G-NT/G-LOCK에서 <code>FAIL</code>.</p></li>
</ul>
<h2 data-number="15.6" id="질량-대통일-요약-정리"><span class="header-section-number">15.6</span> 13.6 질량 대통일 요약 정리</h2>
<h3 data-number="15.6.1" id="잠긴-입력과-표준-정의단일-출처"><span class="header-section-number">15.6.1</span> 13.6.1 잠긴 입력과 표준 정의(단일 출처)</h3>
<h4 data-number="15.6.1.1" id="d-13.6-1-격자-단위-에너지"><span class="header-section-number">15.6.1.1</span> [D-13.6-1] 격자 단위 에너지</h4>
<p>실현 길이 <span class="math inline">\(a\)</span>와 운영 닻 <span class="math inline">\(c_{\mathrm{ref}}\)</span> 및 작용 단위 상수 <span class="math inline">\(h\)</span>가 잠겨 있을 때, 격자 단위 에너지(단일 출처)를 다음으로 정의한다.
<span class="math display">\[U_{\mathrm{lat}}
:=
\frac{h\,c_{\mathrm{ref}}}{a}.
\label{eq:S13_06_Ulat_def}\]</span>
정의 <a data-reference="eq:S13_06_Ulat_def" data-reference-type="eqref" href="#eq:S13_06_Ulat_def">[eq:S13_06_Ulat_def]</a>는 본 절에서 재유도하지 않으며, 동일 버전 내부에서 재정의/치환-유도 혼합을 금지한다.</p>
<h4 data-number="15.6.1.2" id="a-13.6-1-질량저항-공리운영-공리"><span class="header-section-number">15.6.1.2</span> [A-13.6-1] 질량=저항 공리(운영 공리)</h4>
<p>객체 <span class="math inline">\(\mathcal{O}\)</span>의 질량 스케일은 “격자 단위 에너지”를 “무차원 저항(효과 단면 계수)”로 나눈 값으로 고정한다.
<span class="math display">\[m(\mathcal{O})
=
\frac{U_{\mathrm{lat}}}{\sigma_{\mathrm{eff}}(\mathcal{O})}.
\label{eq:S13_06_mass_axiom}\]</span>
여기서 <span class="math inline">\(\sigma_{\mathrm{eff}}(\mathcal{O})\)</span>는 객체 <span class="math inline">\(\mathcal{O}\)</span>에 대한 무차원 저항(효과 단면 계수)이며, 정의/계산 절차는 <code>analysis_lock</code>에 잠긴다.</p>
<h3 data-number="15.6.2" id="세-질량의-저항-계수각각의-유일-정의"><span class="header-section-number">15.6.2</span> 13.6.2 세 질량의 저항 계수(각각의 유일 정의)</h3>
<p>본 절은 <span class="math inline">\(\mathcal{I}:=\{H,p,e\}\)</span>에 대해 저항 계수를 다음 세 항목으로 고정한다.</p>
<h4 data-number="15.6.2.1" id="h-저항-계수정준-셀-경계-채널"><span class="header-section-number">15.6.2.1</span> 13.6.2.1 <span class="math inline">\(H\)</span>-저항 계수(정준 셀 경계 채널)</h4>
<p><span class="math inline">\(H\)</span>-모드의 효과 단면 계수는 정준 셀(<code>CELL-CUBE</code>)의 경계 채널(6면)에서 전역 기준 자유도 1개를 제거한 독립 채널 수 <span class="math inline">\(\kappa_H=5\)</span>와, 채널 단면의 정준형(원판)으로부터 다음으로 고정된다.
<span class="math display">\[\sigma_{\mathrm{eff}}(H):=5\pi.
\label{eq:S13_06_sigmaH}\]</span></p>
<h4 data-number="15.6.2.2" id="p-저항-계수코어-위상-완결-길이-적분"><span class="header-section-number">15.6.2.2</span> 13.6.2.2 <span class="math inline">\(p\)</span>-저항 계수(코어 위상 완결 길이 적분)</h4>
<p>코어 위상 완결 길이 <span class="math inline">\(\lambda_C\)</span>와 실현 길이 <span class="math inline">\(a\)</span>가 잠겨 있을 때, 양성자 저항 적분(무차원 저항)을 다음으로 정의한다.
<span class="math display">\[S_p
:=
\int_{0}^{\lambda_C}\frac{dR}{a}
=
\frac{\lambda_C}{a}.
\label{eq:S13_06_Sp}\]</span>
따라서
<span class="math display">\[\sigma_{\mathrm{eff}}(p):=S_p
\label{eq:S13_06_sigmap}\]</span>
로 고정한다. (동일 버전에서 <span class="math inline">\(\lambda_C=(\pi/2)r_p\)</span>가 잠긴 경우, <span class="math inline">\(S_p=(\pi/2)(r_p/a)\)</span>로 동치 표현 가능하나, 본 절은 <span class="math inline">\(S_p\)</span>의 정의 <a data-reference="eq:S13_06_Sp" data-reference-type="eqref" href="#eq:S13_06_Sp">[eq:S13_06_Sp]</a>만을 유일 출처로 사용한다.)</p>
<h4 data-number="15.6.2.3" id="e-저항-계수전자-반경-적분"><span class="header-section-number">15.6.2.3</span> 13.6.2.3 <span class="math inline">\(e\)</span>-저항 계수(전자 반경 적분)</h4>
<p>전자 반경 <span class="math inline">\(r_e\)</span>와 실현 길이 <span class="math inline">\(a\)</span>가 잠겨 있을 때, 전자 저항 적분(무차원 저항)을 다음으로 정의한다.
<span class="math display">\[S
:=
\int_{0}^{r_e}\frac{dR}{a}
=
\frac{r_e}{a}.
\label{eq:S13_06_Se}\]</span>
따라서
<span class="math display">\[\sigma_{\mathrm{eff}}(e):=S
\label{eq:S13_06_sigmae}\]</span>
로 고정한다.</p>
<h3 data-number="15.6.3" id="정리질량-대통일"><span class="header-section-number">15.6.3</span> 13.6.3 정리(질량 대통일)</h3>
<h4 data-number="15.6.3.1" id="t-13.6-1-질량-대통일-정리"><span class="header-section-number">15.6.3.1</span> [T-13.6-1] 질량 대통일 정리</h4>
<p>동일 버전에서 <a data-reference="eq:S13_06_Ulat_def" data-reference-type="eqref" href="#eq:S13_06_Ulat_def">[eq:S13_06_Ulat_def]</a>, <a data-reference="eq:S13_06_mass_axiom" data-reference-type="eqref" href="#eq:S13_06_mass_axiom">[eq:S13_06_mass_axiom]</a>, <a data-reference="eq:S13_06_sigmaH" data-reference-type="eqref" href="#eq:S13_06_sigmaH">[eq:S13_06_sigmaH]</a>–<a data-reference="eq:S13_06_sigmae" data-reference-type="eqref" href="#eq:S13_06_sigmae">[eq:S13_06_sigmae]</a>가 잠겨 있을 때, <span class="math inline">\(\mathcal{I}=\{H,p,e\}\)</span>에 대해 다음이 성립한다.
<span class="math display">\[\boxed{
\forall X\in\{H,p,e\},\quad
m_X
=
\frac{U_{\mathrm{lat}}}{\sigma_{\mathrm{eff}}(X)}
}
\label{eq:S13_06_unification_main}\]</span>
특히 다음 세 식이 동시에 성립한다.
<span class="math display">\[\begin{aligned}
m_H&amp;=\frac{U_{\mathrm{lat}}}{5\pi},
\label{eq:S13_06_mH}\\
m_p&amp;=\frac{U_{\mathrm{lat}}}{S_p}=\frac{U_{\mathrm{lat}}}{\lambda_C/a},
\label{eq:S13_06_mp}\\
m_e&amp;=\frac{U_{\mathrm{lat}}}{S}=\frac{U_{\mathrm{lat}}}{r_e/a}.
\label{eq:S13_06_me}\end{aligned}\]</span>
따라서 각 질량은 “동일한 격자 단위 에너지 <span class="math inline">\(U_{\mathrm{lat}}\)</span>”가 “객체별 저항 계수 <span class="math inline">\(\sigma_{\mathrm{eff}}\)</span>”에 의해 분화된 결과로 단일하게 묶인다.</p>
<h4 data-number="15.6.3.2" id="증명-2"><span class="header-section-number">15.6.3.2</span> 증명</h4>
<p><a data-reference="eq:S13_06_mass_axiom" data-reference-type="eqref" href="#eq:S13_06_mass_axiom">[eq:S13_06_mass_axiom]</a>에 <span class="math inline">\(\mathcal{O}=H,p,e\)</span>를 각각 대입하면
<span class="math display">\[m_H=\frac{U_{\mathrm{lat}}}{\sigma_{\mathrm{eff}}(H)},\quad
m_p=\frac{U_{\mathrm{lat}}}{\sigma_{\mathrm{eff}}(p)},\quad
m_e=\frac{U_{\mathrm{lat}}}{\sigma_{\mathrm{eff}}(e)}.
\label{eq:S13_06_proof1}\]</span>
여기서 <span class="math inline">\(\sigma_{\mathrm{eff}}(H)=5\pi\)</span>는 <a data-reference="eq:S13_06_sigmaH" data-reference-type="eqref" href="#eq:S13_06_sigmaH">[eq:S13_06_sigmaH]</a>로, <span class="math inline">\(\sigma_{\mathrm{eff}}(p)=S_p\)</span>는 <a data-reference="eq:S13_06_sigmap" data-reference-type="eqref" href="#eq:S13_06_sigmap">[eq:S13_06_sigmap]</a>로, <span class="math inline">\(\sigma_{\mathrm{eff}}(e)=S\)</span>는 <a data-reference="eq:S13_06_sigmae" data-reference-type="eqref" href="#eq:S13_06_sigmae">[eq:S13_06_sigmae]</a>로 잠겨 있으므로,
<a data-reference="eq:S13_06_proof1" data-reference-type="eqref" href="#eq:S13_06_proof1">[eq:S13_06_proof1]</a>은 곧 <a data-reference="eq:S13_06_mH" data-reference-type="eqref" href="#eq:S13_06_mH">[eq:S13_06_mH]</a>–<a data-reference="eq:S13_06_me" data-reference-type="eqref" href="#eq:S13_06_me">[eq:S13_06_me]</a>로 귀결된다. <span class="math inline">\(\square\)</span></p>
<h3 data-number="15.6.4" id="따름정리에너지-저항-불변-형식"><span class="header-section-number">15.6.4</span> 13.6.4 따름정리(에너지-저항 불변 형식)</h3>
<p>정리 <a data-reference="eq:S13_06_unification_main" data-reference-type="eqref" href="#eq:S13_06_unification_main">[eq:S13_06_unification_main]</a>로부터 다음 불변 형식이 즉시 성립한다.
<span class="math display">\[\boxed{
m_H\,(5\pi)=U_{\mathrm{lat}},
\qquad
m_p\,S_p=U_{\mathrm{lat}},
\qquad
m_e\,S=U_{\mathrm{lat}}
}
\label{eq:S13_06_invariant_products}\]</span>
즉, 동일 버전에서 <span class="math inline">\(U_{\mathrm{lat}}\)</span>는 세 질량과 그 저항 계수의 곱으로 동일하게 복원된다. 이는 “질량 집합 <span class="math inline">\(\{m_H,m_p,m_e\}\)</span>가 하나의 격자 에너지 <span class="math inline">\(U_{\mathrm{lat}}\)</span>의 분화로 묶인다”는 정리의 동치 표현이다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-68">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(U_{\mathrm{lat}}:=h\,c_{\mathrm{ref}}/a\)</span> 단일 출처 및 <span class="math inline">\(m(\mathcal{O})=U_{\mathrm{lat}}/\sigma_{\mathrm{eff}}(\mathcal{O})\)</span> 공리 고정.</p></li>
<li><p>LOCK: <span class="math inline">\(\sigma_{\mathrm{eff}}(H)=5\pi\)</span>, <span class="math inline">\(\sigma_{\mathrm{eff}}(p)=S_p=\int_0^{\lambda_C}\frac{dR}{a}\)</span>, <span class="math inline">\(\sigma_{\mathrm{eff}}(e)=S=\int_0^{r_e}\frac{dR}{a}\)</span> 유일 정의 고정.</p></li>
<li><p>Gate: <span class="math inline">\(a,\Delta t\)</span> 실현의 RCROSS(<code>G-RCROSS</code>) <code>PASS</code> 및 봉인(manifest/checksums/registry_snapshot) 없이는 <span class="math inline">\(U_{\mathrm{lat}}\)</span> 및 모든 질량 결론 자격 박탈.</p></li>
<li><p>Gate: 기호/단위/지름-반지름/셀 기하 혼동은 G-SYM에서 즉시 <code>FAIL</code>, lock_id 혼합은 G-LOCK에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 저항 계수 정의/채널 수/적분 경계의 사후 변경은 G-NT에서 <code>FAIL</code>.</p></li>
</ul>
<h2 data-number="15.7" id="교차검증비율-불변량-오차-보고"><span class="header-section-number">15.7</span> 13.7 교차검증(비율 불변량) + 오차 보고</h2>
<h3 data-number="15.7.1" id="입력lock과-기호"><span class="header-section-number">15.7.1</span> 13.7.1 입력(LOCK)과 기호</h3>
<p>본 절은 동일 버전(lock_id 조합)에서 다음 항목들이 정의되어 있다고 둔다.</p>
<ol>
<li><p>격자 단위 에너지:
<span class="math display">\[U_{\mathrm{lat}}
  \quad(\text{단일 출처}).
  \label{eq:S13_07_Ulat}\]</span></p></li>
<li><p>질량 스케일:
<span class="math display">\[m_H,\quad m_p,\quad m_e.
  \label{eq:S13_07_masses}\]</span></p></li>
<li><p>저항(무차원) 계수:
<span class="math display">\[\sigma_{\mathrm{eff}}(H)=5\pi,\qquad
  S_p,\qquad
  S.
  \label{eq:S13_07_sigmas}\]</span></p></li>
<li><p>양성자 정준 사건율:
<span class="math display">\[\nu_{p,\mathrm{can}}.
  \label{eq:S13_07_nup}\]</span></p></li>
</ol>
<p>본 절의 모든 교차검증은 위 항목들을 서로 다른 경로로 결합한 <strong>비율 불변량</strong>을 구성하고, 그 불변량이 1(또는 잠긴 목표값)인지 Gate로 판정하는 방식으로 고정한다.</p>
<h3 data-number="15.7.2" id="비율-불변량정의"><span class="header-section-number">15.7.2</span> 13.7.2 비율 불변량(정의)</h3>
<p>각 불변량 <span class="math inline">\(I_k\)</span>는 무차원 값이며, 목표값은 1로 고정한다.
<span class="math display">\[I_k := \frac{\text{경로 A 산출}}{\text{경로 B 산출}},
\qquad
I_k^{\star}:=1.
\label{eq:S13_07_Ik_def}\]</span>
본 절에서 사용하는 불변량 목록은 다음과 같이 고정한다(각 항목의 정의는 13.7.5에서 완결).
<span class="math display">\[\mathcal{I}
:=
\left\{
I_{UH},I_{Up},I_{Ue},I_{Hp},I_{He},I_{pe},I_{pe\nu},I_{Sp},I_{Se}
\right\}.
\label{eq:S13_07_Iset}\]</span></p>
<h3 data-number="15.7.3" id="편차dev와-오차-예산보고-규약"><span class="header-section-number">15.7.3</span> 13.7.3 편차(dev)와 오차 예산(보고 규약)</h3>
<h4 data-number="15.7.3.1" id="편차dev-정의"><span class="header-section-number">15.7.3.1</span> 13.7.3.1 편차(dev) 정의</h4>
<p>각 불변량 <span class="math inline">\(I_k\)</span>에 대해 편차를 다음으로 정의한다.
<span class="math display">\[\mathrm{dev}_k := \left| I_k-1 \right|.
\label{eq:S13_07_dev_def}\]</span>
또한 보고 단위를 맞추기 위해 상대 편차를 함께 정의할 수 있다(선택 사용).
<span class="math display">\[\mathrm{rdev}_k := \left|\frac{I_k-1}{1}\right| = \left| I_k-1 \right|.
\label{eq:S13_07_rdev_def}\]</span>
본 절에서는 <a data-reference="eq:S13_07_dev_def" data-reference-type="eqref" href="#eq:S13_07_dev_def">[eq:S13_07_dev_def]</a>를 표준 dev로 잠그며, 다른 정의(예: 로그 편차)는 별도 버전업 없이 허용되지 않는다.</p>
<h4 data-number="15.7.3.2" id="오차-예산-규약선택-방식-잠금"><span class="header-section-number">15.7.3.2</span> 13.7.3.2 오차 예산 규약(선택 방식 잠금)</h4>
<p>오차 예산은 두 방식 중 하나로 잠긴다.</p>
<ol>
<li><p><strong>상계 방식(최악-경우)</strong>:
만약
<span class="math display">\[I=\prod_{j=1}^{J} x_j^{\alpha_j}
  \label{eq:S13_07_I_product}\]</span>
형태이면,
<span class="math display">\[\left|\frac{\Delta I}{I}\right|
  \le
  \sum_{j=1}^{J} |\alpha_j|\left|\frac{\Delta x_j}{x_j}\right|.
  \label{eq:S13_07_err_worst}\]</span></p></li>
<li><p><strong>제곱합 방식(RSS)</strong>:
<span class="math display">\[\left(\frac{\sigma_I}{|I|}\right)^2
  =
  \sum_{j=1}^{J} \alpha_j^2\left(\frac{\sigma_{x_j}}{|x_j|}\right)^2.
  \label{eq:S13_07_err_rss}\]</span></p></li>
</ol>
<p>어느 방식을 사용하는지는 <code>analysis_lock.error_budget_mode</code>로 잠겨야 한다. 미잠금이면 오차 보고는 <code>INCONCLUSIVE</code>이다.</p>
<h4 data-number="15.7.3.3" id="오차-포함-pass-조건선택"><span class="header-section-number">15.7.3.3</span> 13.7.3.3 오차 포함 PASS 조건(선택)</h4>
<p>오차 예산을 사용하는 경우, 다음 두 조건 중 하나를 <code>analysis_lock</code>에 잠근다(택일).</p>
<ol>
<li><p><strong>고정 문턱 판정</strong>:
<span class="math display">\[\mathrm{dev}_k\le \mathrm{dev}_{\max,k}.
  \label{eq:S13_07_pass_fixed}\]</span></p></li>
<li><p><strong>오차-정규화 판정</strong>:
<span class="math display">\[\mathrm{dev}_k\le z_{\max,k}\,\sigma_{I_k},
  \qquad
  z_{\max,k}&gt;0\ \text{(잠김)}.
  \label{eq:S13_07_pass_sigma}\]</span></p></li>
</ol>
<p><span class="math inline">\(\mathrm{dev}_{\max,k}\)</span> 또는 <span class="math inline">\(z_{\max,k}\)</span>는 <code>gate_lock</code>에 사전 등록되어야 하며, 사후 변경은 금지된다.</p>
<h3 data-number="15.7.4" id="비율-gate-템플릿3단계-판정"><span class="header-section-number">15.7.4</span> 13.7.4 비율 Gate 템플릿(3단계 판정)</h3>
<p>각 불변량 <span class="math inline">\(I_k\)</span>는 동일한 템플릿으로 Gate 판정을 받는다.</p>
<h4 data-number="15.7.4.1" id="tier-1-정의잠금-완결성"><span class="header-section-number">15.7.4.1</span> 13.7.4.1 Tier-1: 정의/잠금 완결성</h4>
<p><code>Tier1</code>은 다음이 모두 충족될 때 <code>PASS</code>이다.</p>
<ol>
<li><p><span class="math inline">\(I_k\)</span>에 필요한 모든 입력(<span class="math inline">\(U_{\mathrm{lat}},m_*,S_*,\nu_{p,\mathrm{can}}\)</span> 등)이 존재.</p></li>
<li><p>동일 lock_id 조합(또는 사전 등록된 허용 조합)으로 귀속.</p></li>
<li><p>산출물 및 로그가 <code>manifest+checksums+registry_snapshot</code>으로 봉인.</p></li>
</ol>
<p>누락이 있으면 <code>INCONCLUSIVE</code>, 사후 변경 또는 lock 혼합이 탐지되면 <code>FAIL</code>이다.</p>
<h4 data-number="15.7.4.2" id="tier-2-편차-문턱"><span class="header-section-number">15.7.4.2</span> 13.7.4.2 Tier-2: 편차 문턱</h4>
<p><code>Tier2</code>는 <code>Tier1=PASS</code>이고 dev가 정의 가능할 때 다음으로 판정한다.
<span class="math display">\[\texttt{Tier2}=
\begin{cases}
\texttt{PASS}, &amp; \mathrm{dev}_k\le \mathrm{dev}_{\max,k}\ \text{(또는}\ \eqref{eq:S13_07_pass_sigma}\text{)},\\
\texttt{FAIL}, &amp; \text{그 외}.
\end{cases}
\label{eq:S13_07_tier2_rule}\]</span></p>
<h4 data-number="15.7.4.3" id="tier-3-로버스트재실행창-분할-일관성"><span class="header-section-number">15.7.4.3</span> 13.7.4.3 Tier-3: 로버스트(재실행/창 분할) 일관성</h4>
<p>재실행 세트 <span class="math inline">\(\mathcal{R}_k=\{r_1,\ldots,r_K\}\)</span>가 잠겨 있을 때에만 Tier-3를 수행한다. 각 재실행에서의 불변량을 <span class="math inline">\(I_k^{(j)}\)</span>로 두고,
<span class="math display">\[\mathrm{dev}^{(\mathrm{rob})}_k
:=
\max_{j} \left|I_k^{(j)}-1\right|.
\label{eq:S13_07_dev_rob}\]</span>
로 정의한다. 로버스트 문턱 <span class="math inline">\(\mathrm{dev}^{(\mathrm{rob})}_{\max,k}\)</span>는 <code>gate_lock</code>에 잠긴다.
<span class="math display">\[\texttt{Tier3}=
\begin{cases}
\texttt{PASS}, &amp; \mathrm{dev}^{(\mathrm{rob})}_k\le \mathrm{dev}^{(\mathrm{rob})}_{\max,k},\\
\texttt{FAIL}, &amp; \text{그 외}.
\end{cases}
\label{eq:S13_07_tier3_rule}\]</span>
재실행 세트가 미잠금이면 Tier-3는 <code>INCONCLUSIVE</code>이다.</p>
<h4 data-number="15.7.4.4" id="최종-gate-결합"><span class="header-section-number">15.7.4.4</span> 13.7.4.4 최종 Gate 결합</h4>
<p>각 불변량 <span class="math inline">\(I_k\)</span>의 최종 Gate를 다음으로 정의한다.
<span class="math display">\[\texttt{G-RATIO-}k=\texttt{PASS}
\Longleftrightarrow
(\texttt{Tier1}=\texttt{PASS})\wedge(\texttt{Tier2}=\texttt{PASS})\wedge(\texttt{Tier3}\in\{\texttt{PASS},\texttt{INCONCLUSIVE}\}).
\label{eq:S13_07_gate_final}\]</span></p>
<h3 data-number="15.7.5" id="비율-리스트불변량와-각-gate-정의"><span class="header-section-number">15.7.5</span> 13.7.5 비율 리스트(불변량)와 각 Gate 정의</h3>
<h4 data-number="15.7.5.1" id="불변량-정의경로-a-경로-b"><span class="header-section-number">15.7.5.1</span> 13.7.5.1 불변량 정의(경로 A / 경로 B)</h4>
<p>다음 불변량들을 정의로 고정한다.</p>
<h4 data-number="15.7.5.2" id="iuh-u_mathrmlatm_h-교차"><span class="header-section-number">15.7.5.2</span> (I<sub>UH</sub>) <span class="math inline">\(U_{\mathrm{lat}}\)</span>–<span class="math inline">\(m_H\)</span> 교차</h4>
<p><span class="math display">\[I_{UH}
:=
\frac{m_H(5\pi)}{U_{\mathrm{lat}}}.
\label{eq:S13_07_IUH}\]</span></p>
<h4 data-number="15.7.5.3" id="iup-u_mathrmlatm_p-교차"><span class="header-section-number">15.7.5.3</span> (I<sub>Up</sub>) <span class="math inline">\(U_{\mathrm{lat}}\)</span>–<span class="math inline">\(m_p\)</span> 교차</h4>
<p><span class="math display">\[I_{Up}
:=
\frac{m_p S_p}{U_{\mathrm{lat}}}.
\label{eq:S13_07_IUp}\]</span></p>
<h4 data-number="15.7.5.4" id="iue-u_mathrmlatm_e-교차"><span class="header-section-number">15.7.5.4</span> (I<sub>Ue</sub>) <span class="math inline">\(U_{\mathrm{lat}}\)</span>–<span class="math inline">\(m_e\)</span> 교차</h4>
<p><span class="math display">\[I_{Ue}
:=
\frac{m_e S}{U_{\mathrm{lat}}}.
\label{eq:S13_07_IUe}\]</span></p>
<h4 data-number="15.7.5.5" id="ihp-m_hm_p-저항형-교차"><span class="header-section-number">15.7.5.5</span> (I<sub>Hp</sub>) <span class="math inline">\(m_H/m_p\)</span> 저항형 교차</h4>
<p><span class="math display">\[I_{Hp}
:=
\frac{\left(\dfrac{m_H}{m_p}\right)}{\left(\dfrac{S_p}{5\pi}\right)}.
\label{eq:S13_07_IHp}\]</span></p>
<h4 data-number="15.7.5.6" id="ihe-m_hm_e-저항형-교차"><span class="header-section-number">15.7.5.6</span> (I<sub>He</sub>) <span class="math inline">\(m_H/m_e\)</span> 저항형 교차</h4>
<p><span class="math display">\[I_{He}
:=
\frac{\left(\dfrac{m_H}{m_e}\right)}{\left(\dfrac{S}{5\pi}\right)}.
\label{eq:S13_07_IHe}\]</span></p>
<h4 data-number="15.7.5.7" id="ipe-m_pm_e-저항형-교차"><span class="header-section-number">15.7.5.7</span> (I<sub>pe</sub>) <span class="math inline">\(m_p/m_e\)</span> 저항형 교차</h4>
<p><span class="math display">\[I_{pe}
:=
\frac{\left(\dfrac{m_p}{m_e}\right)}{\left(\dfrac{S}{S_p}\right)}.
\label{eq:S13_07_Ipe}\]</span></p>
<h4 data-number="15.7.5.8" id="ipenu-m_pm_e-사건율-대응-교차"><span class="header-section-number">15.7.5.8</span> (I<sub>pe<span class="math inline">\(\nu\)</span></sub>) <span class="math inline">\(m_p/m_e\)</span> 사건율 대응 교차</h4>
<p>대응 규약(잠긴 표준형)에 의해
<span class="math display">\[\left(\frac{m_p}{m_e}\right)_{\nu}
:=2\pi\cdot \nu_{p,\mathrm{can}}
\label{eq:S13_07_mpmenu}\]</span>
를 정의하고,
<span class="math display">\[I_{pe\nu}
:=
\frac{\left(\dfrac{m_p}{m_e}\right)}{\left(2\pi\cdot \nu_{p,\mathrm{can}}\right)}.
\label{eq:S13_07_Ipenu}\]</span></p>
<h4 data-number="15.7.5.9" id="isp-s_p-직접식-교차선택"><span class="header-section-number">15.7.5.9</span> (I<sub>Sp</sub>) <span class="math inline">\(S_p\)</span> 직접식 교차(선택)</h4>
<p>코어 길이 연결이 동일 버전에서 잠겨 있을 때(예: <span class="math inline">\(\lambda_C=(\pi/2)r_p\)</span>), 다음 교차항을 정의한다.
<span class="math display">\[I_{Sp}
:=
\frac{S_p}{\left(\dfrac{\lambda_C}{a}\right)}.
\label{eq:S13_07_ISp}\]</span></p>
<h4 data-number="15.7.5.10" id="ise-s-직접식-교차선택"><span class="header-section-number">15.7.5.10</span> (I<sub>Se</sub>) <span class="math inline">\(S\)</span> 직접식 교차(선택)</h4>
<p>전자 반경 연결이 동일 버전에서 잠겨 있을 때(예: <span class="math inline">\(S=r_e/a\)</span>), 다음 교차항을 정의한다.
<span class="math display">\[I_{Se}
:=
\frac{S}{\left(\dfrac{r_e}{a}\right)}.
\label{eq:S13_07_ISe}\]</span></p>
<h4 data-number="15.7.5.11" id="gate-id-목록불변량별"><span class="header-section-number">15.7.5.11</span> 13.7.5.2 Gate ID 목록(불변량별)</h4>
<p>각 불변량은 다음 Gate ID로 판정한다.
<span class="math display">\[\texttt{G-RATIO-UH},\
\texttt{G-RATIO-Up},\
\texttt{G-RATIO-Ue},\
\texttt{G-RATIO-Hp},\
\texttt{G-RATIO-He},\
\texttt{G-RATIO-pe},\
\texttt{G-RATIO-peNU},\
\texttt{G-RATIO-Sp},\
\texttt{G-RATIO-Se}.
\label{eq:S13_07_gate_ids}\]</span>
각 Gate는 <a data-reference="eq:S13_07_gate_final" data-reference-type="eqref" href="#eq:S13_07_gate_final">[eq:S13_07_gate_final]</a>의 템플릿을 따르며, 개별 문턱 <span class="math inline">\(\mathrm{dev}_{\max,k}\)</span> 및 (선택) <span class="math inline">\(\mathrm{dev}^{(\mathrm{rob})}_{\max,k}\)</span>는 <code>gate_lock</code>에 사전 등록되어야 한다.</p>
<h3 data-number="15.7.6" id="failinconclusive-라벨표준"><span class="header-section-number">15.7.6</span> 13.7.6 FAIL/INCONCLUSIVE 라벨(표준)</h3>
<p>불변량 판정은 다음 라벨 체계를 사용한다.</p>
<div class="center">
<table>
<thead>
<tr class="header">
<th style="text-align: left;">라벨</th>
<th style="text-align: left;">의미</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">INCON-RATIO-MISSING</td>
<td style="text-align: left;">입력(질량/저항/사건율/에너지) 누락</td>
</tr>
<tr class="even">
<td style="text-align: left;">INCON-RATIO-UNSEALED</td>
<td style="text-align: left;">봉인(manifest/checksums/registry_snapshot) 누락</td>
</tr>
<tr class="odd">
<td style="text-align: left;">FAIL-RATIO-LOCKMIX</td>
<td style="text-align: left;">서로 다른 lock_id 조합 혼합</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-RATIO-DEV</td>
<td style="text-align: left;"><span class="math inline">\(\mathrm{dev}_k&gt;\mathrm{dev}_{\max,k}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">FAIL-RATIO-ROB</td>
<td style="text-align: left;">로버스트 문턱 위반</td>
</tr>
<tr class="even">
<td style="text-align: left;">FAIL-RATIO-RETRO</td>
<td style="text-align: left;">문턱/정의/추정기/대응 규약 사후 변경 탐지</td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="15.7.7" id="오차-보고-레코드봉인-대상"><span class="header-section-number">15.7.7</span> 13.7.7 오차 보고 레코드(봉인 대상)</h3>
<p>각 불변량에 대해 다음 레코드를 생성하여 봉인한다.</p>
<pre><code>ratio_report:
  - ratio_id: (unique)
    name: I_UH | I_Up | I_Ue | I_Hp | I_He | I_pe | I_peNU | I_Sp | I_Se
    value: (I_k)
    dev: (abs(I_k-1))
    method: fixed_threshold | sigma_normalized
    thresholds:
      dev_max: ...
      dev_rob_max: ...
      z_max: ...
    error_budget:
      mode: worst_case | rss
      sigma_I: ...
      components: { ... }      # 선택(입력별 상대오차 항)
    tiers:
      tier1: PASS|FAIL|INCONCLUSIVE
      tier2: PASS|FAIL|INCONCLUSIVE
      tier3: PASS|FAIL|INCONCLUSIVE
    verdict: PASS|FAIL|INCONCLUSIVE
    labels: [...]
    lock_refs:
      canon_lock_id: ...
      realization_lock_id: ...
      analysis_lock_id: ...
      gate_lock_id: ...
      protocol_lock_id: ...
    snapshot_refs:
      manifest_ref: ...
      checksums_ref: ...
      registry_snapshot_ref: ...</code></pre>
<p><code>snapshot_refs</code>가 누락되면 결론 자격을 부여하지 않는다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-69">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 불변량 집합 <span class="math inline">\(\mathcal{I}\)</span> 및 각 <span class="math inline">\(I_k\)</span>의 정의(<a data-reference="eq:S13_07_IUH" data-reference-type="ref" href="#eq:S13_07_IUH">[eq:S13_07_IUH]</a>–<a data-reference="eq:S13_07_ISe" data-reference-type="ref" href="#eq:S13_07_ISe">[eq:S13_07_ISe]</a>), dev 정의(<a data-reference="eq:S13_07_dev_def" data-reference-type="ref" href="#eq:S13_07_dev_def">[eq:S13_07_dev_def]</a>), Gate 템플릿(<a data-reference="eq:S13_07_gate_final" data-reference-type="ref" href="#eq:S13_07_gate_final">[eq:S13_07_gate_final]</a>)을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 문턱 <span class="math inline">\(\mathrm{dev}_{\max,k}\)</span>, 로버스트 문턱 <span class="math inline">\(\mathrm{dev}^{(\mathrm{rob})}_{\max,k}\)</span>, (선택) <span class="math inline">\(z_{\max,k}\)</span>를 <code>gate_lock</code>에 고정.</p></li>
<li><p>Gate: 봉인 누락은 G-REP에서 <code>INCONCLUSIVE</code>; lock 혼합/사후 변경은 G-LOCK/G-NT에서 <code>FAIL</code>.</p></li>
<li><p>Gate: 불변량별 최종 판정은 <code>G-RATIO-*</code>로 기록되며, <code>PASS</code>가 아닌 결과는 결론 근거로 사용 금지(PASS.rules 연결).</p></li>
</ul>
<h1 data-number="16" id="힘-격자-장력-rightarrow-coulomb-절대-크기뉴턴-유도누락-보강"><span class="header-section-number">16</span> 14. 힘: 격자 장력 <span class="math inline">\(\rightarrow\)</span> Coulomb 절대 크기(뉴턴) 유도(누락 보강)</h1>
<h2 data-number="16.1" id="f_mathrmlath-c_mathrmrefa2와-기하-감쇄dilution-체계-정의"><span class="header-section-number">16.1</span> 14.1 <span class="math inline">\(F_{\mathrm{lat}}=h c_{\mathrm{ref}}/a^{2}\)</span>와 “기하 감쇄(dilution)” 체계 정의</h2>
<h3 data-number="16.1.1" id="잠긴-입력lock과-기호정의"><span class="header-section-number">16.1.1</span> 14.1.1 잠긴 입력(LOCK)과 기호(정의)</h3>
<p>본 절은 다음 입력이 잠겨 있다고 둔다.</p>
<ul>
<li><p><span class="math inline">\(h\)</span>: 작용 단위 상수(실현 입력).</p></li>
<li><p><span class="math inline">\(c_{\mathrm{ref}}\)</span>: 운영 닻 속도 상수(실현 입력).</p></li>
<li><p><span class="math inline">\(a\)</span>: 실현 길이(격자 최소 길이; 부피입자 지름)(실현 입력).</p></li>
</ul>
<p>격자 좌표 <span class="math inline">\(\mathbf{n}\in\mathbb{Z}^{3}\)</span>에 대응하는 실공간 좌표를
<span class="math display">\[\mathbf{x}(\mathbf{n}) := a\,\mathbf{n}
\label{eq:S14_01_xn}\]</span>
로 정의한다. 두 점 <span class="math inline">\(\mathbf{x}_1,\mathbf{x}_2\)</span>의 분리 벡터와 거리(스칼라)는
<span class="math display">\[\mathbf{R}:=\mathbf{x}_1-\mathbf{x}_2,\qquad R:=\|\mathbf{R}\|
\label{eq:S14_01_Rdef}\]</span>
로 정의한다.</p>
<h3 data-number="16.1.2" id="격자-단위-에너지-u_mathrmlat와-격자-장력-f_mathrmlat정의"><span class="header-section-number">16.1.2</span> 14.1.2 격자 단위 에너지 <span class="math inline">\(U_{\mathrm{lat}}\)</span>와 격자 장력 <span class="math inline">\(F_{\mathrm{lat}}\)</span>(정의)</h3>
<p>격자 단위 에너지를 다음의 단일 출처 정의로 고정한다.
<span class="math display">\[\boxed{
U_{\mathrm{lat}}:=\frac{h\,c_{\mathrm{ref}}}{a}
}
\label{eq:S14_01_Ulat}\]</span>
격자 장력(격자 단위 힘)을 다음으로 정의한다.
<span class="math display">\[\boxed{
F_{\mathrm{lat}}:=\frac{U_{\mathrm{lat}}}{a}=\frac{h\,c_{\mathrm{ref}}}{a^{2}}
}
\label{eq:S14_01_Flat}\]</span>
<a data-reference="eq:S14_01_Flat" data-reference-type="eqref" href="#eq:S14_01_Flat">[eq:S14_01_Flat]</a>는 <a data-reference="eq:S14_01_Ulat" data-reference-type="eqref" href="#eq:S14_01_Ulat">[eq:S14_01_Ulat]</a>의 정의를 <span class="math inline">\(a\)</span>로 한 번 더 나눈 결과이며, 추가 가정이 없다.</p>
<h3 data-number="16.1.3" id="수치-형태실현값-대입-계산-경로-고정"><span class="header-section-number">16.1.3</span> 14.1.3 수치 형태(실현값 대입; 계산 경로 고정)</h3>
<p>실현값이 다음과 같이 잠겨 있다고 둔다.
<span class="math display">\[h = 6.62607015\times 10^{-34}\ \mathrm{J\cdot s},
\qquad
c_{\mathrm{ref}} = 2.99792458\times 10^{8}\ \mathrm{m/s},
\qquad
a = 6.3299121257859865746\times 10^{-19}\ \mathrm{m}.
\label{eq:S14_01_values}\]</span>
먼저
<span class="math display">\[\begin{aligned}
h\,c_{\mathrm{ref}}
&amp;=
(6.62607015\times 10^{-34})(2.99792458\times 10^{8})\ \mathrm{J\cdot m}
\notag\\
&amp;=
(6.62607015\times 2.99792458)\times 10^{-26}\ \mathrm{J\cdot m}
\notag\\
&amp;=
1.9864458571489287\times 10^{-25}\ \mathrm{J\cdot m}.
\label{eq:S14_01_hc_value}\end{aligned}\]</span>
또한
<span class="math display">\[\begin{aligned}
a^{2}
&amp;=
(6.3299121257859865746\times 10^{-19})^{2}\ \mathrm{m^{2}}
\notag\\
&amp;=
(6.3299121257859865746)^{2}\times 10^{-38}\ \mathrm{m^{2}}
\notag\\
&amp;\approx
4.0067787520172635\times 10^{-37}\ \mathrm{m^{2}}.
\label{eq:S14_01_a2_value}\end{aligned}\]</span>
따라서
<span class="math display">\[\begin{aligned}
F_{\mathrm{lat}}
&amp;=
\frac{h\,c_{\mathrm{ref}}}{a^{2}}
=
\frac{1.9864458571489287\times 10^{-25}}{4.0067787520172635\times 10^{-37}}\ \mathrm{N}
\notag\\
&amp;=
\left(\frac{1.9864458571489287}{4.0067787520172635}\right)\times 10^{12}\ \mathrm{N}
\notag\\
&amp;\approx
4.95771286634888\times 10^{11}\ \mathrm{N}.
\label{eq:S14_01_Flat_value}\end{aligned}\]</span>
여기서 <span class="math inline">\(\mathrm{J\cdot m}/\mathrm{m^{2}}=\mathrm{J/m}=\mathrm{N}\)</span>를 사용하였다.</p>
<h3 data-number="16.1.4" id="기하-감쇄dilution의-운영-정의정의"><span class="header-section-number">16.1.4</span> 14.1.4 기하 감쇄(dilution)의 운영 정의(정의)</h3>
<p>격자 장력 <span class="math inline">\(F_{\mathrm{lat}}\)</span>는 길이 <span class="math inline">\(a\)</span>에서의 단위 힘이다. 두 객체의 분리 <span class="math inline">\(R\)</span>에서의 유효 힘 크기를 정의하기 위해
<em>기하 감쇄(dilution)</em>를 다음과 같은 무차원 감쇄 인자로 정의한다.
<span class="math display">\[\boxed{
\mathcal{D}_{\mathrm{dil}}(R) := \left(\frac{a}{R}\right)^{2}
\qquad (R\ge a)
}
\label{eq:S14_01_dil_iso}\]</span>
<a data-reference="eq:S14_01_dil_iso" data-reference-type="eqref" href="#eq:S14_01_dil_iso">[eq:S14_01_dil_iso]</a>는 <span class="math inline">\(R\)</span>이 커질수록 영향이 “면적 비율”로 희석된다는 규약을 수학적으로 고정한 것이다.
정의역에서 <span class="math inline">\(R\ge a\)</span>를 강제하며, <span class="math inline">\(R&lt;a\)</span> 구간은 <em>기하 감쇄 레짐 밖</em>으로 분류한다.</p>
<h4 data-number="16.1.4.1" id="정의-포화-처리레짐-밖-차단"><span class="header-section-number">16.1.4.1</span> (정의) 포화 처리(레짐 밖 차단)</h4>
<p>기하 감쇄 레짐 밖(<span class="math inline">\(R&lt;a\)</span>)에 대해, 본 절의 <span class="math inline">\(\mathcal{D}_{\mathrm{dil}}\)</span>는 사용하지 않으며,
힘 모델은 별도의 접촉/근접 닫힘(다른 레짐)으로만 정의된다.
이를 Gate로 고정한다.
<span class="math display">\[\mathrm{PASS}_{\mathrm{dil}}
:\Longleftrightarrow
R\ge a.
\label{eq:S14_01_pass_dil}\]</span>
<span class="math inline">\(\mathrm{PASS}_{\mathrm{dil}}\)</span>이 성립하지 않으면 <a data-reference="eq:S14_01_dil_iso" data-reference-type="eqref" href="#eq:S14_01_dil_iso">[eq:S14_01_dil_iso]</a>를 포함하는 결론을 산출할 수 없다.</p>
<h3 data-number="16.1.5" id="이방성-확장선택-정의-고정"><span class="header-section-number">16.1.5</span> 14.1.5 이방성 확장(선택; 정의 고정)</h3>
<p>등방 레짐이 아닌 경우를 위해 이방성 감쇄를 다음 곱 형태로 확장 정의한다.
이방성 축(단위벡터) <span class="math inline">\(\mathbf{u}\)</span>와 방향 코사인 <span class="math inline">\(\mu\)</span>를
<span class="math display">\[\|\mathbf{u}\|=1,\qquad \mu(\mathbf{R}):=\frac{\mathbf{R}\cdot\mathbf{u}}{\|\mathbf{R}\|}
\label{eq:S14_01_mu}\]</span>
로 정의한다. 이방성 보정 함수 <span class="math inline">\(g(\mu)\)</span>를 <span class="math inline">\(g(\mu)\ge 0\)</span>로 두고
<span class="math display">\[\boxed{
\mathcal{D}_{\mathrm{dil}}(R,\mu)
:=
\left(\frac{a}{R}\right)^2 g(\mu)
\qquad (R\ge a)
}
\label{eq:S14_01_dil_aniso}\]</span>
로 정의한다. <span class="math inline">\(g(\mu)\)</span>는 <code>analysis_lock</code>에 의해 잠기며, 실행 결과를 본 뒤 선택될 수 없다.</p>
<p>이방성 평균이 등방 감쇄를 복원하도록 정규화 조건을 부과한다.
<span class="math display">\[\boxed{
\frac{1}{2}\int_{-1}^{1} g(\mu)\,d\mu = 1
}
\label{eq:S14_01_g_norm}\]</span>
<a data-reference="eq:S14_01_g_norm" data-reference-type="eqref" href="#eq:S14_01_g_norm">[eq:S14_01_g_norm]</a>의 만족 여부는 Gate로 판정한다.
<span class="math display">\[\mathrm{PASS}_{g}
:\Longleftrightarrow
\left|\frac{1}{2}\int_{-1}^{1} g(\mu)\,d\mu - 1\right|\le \varepsilon_{g}.
\label{eq:S14_01_pass_g}\]</span>
<span class="math inline">\(\varepsilon_g\)</span>는 허용오차로서 <code>gate_lock</code>에 잠긴다.</p>
<h3 data-number="16.1.6" id="힘-모델의-뼈대정의-장력-times-감쇄-times-결합"><span class="header-section-number">16.1.6</span> 14.1.6 힘 모델의 뼈대(정의): 장력 <span class="math inline">\(\times\)</span> 감쇄 <span class="math inline">\(\times\)</span> 결합</h3>
<p>본 장(14장)에서 사용할 힘 크기 모델의 기본 곱 구조를 다음으로 정의한다.
두 객체 <span class="math inline">\(X,Y\)</span>의 분리 <span class="math inline">\(R\)</span>에서의 유효 힘 크기를
<span class="math display">\[\boxed{
F_{X\leftarrow Y}(R)
:=
F_{\mathrm{lat}}\cdot \mathcal{D}_{\mathrm{dil}}(R)\cdot \Gamma_{XY}
}
\label{eq:S14_01_force_skeleton}\]</span>
로 정의한다.
여기서 <span class="math inline">\(\Gamma_{XY}\)</span>는 무차원 결합 계수이며, 전하(라벨), 레짐, 닫힘 선택에 의해 결정된다.
<a data-reference="eq:S14_01_force_skeleton" data-reference-type="eqref" href="#eq:S14_01_force_skeleton">[eq:S14_01_force_skeleton]</a>은 14.2에서 <span class="math inline">\(\Gamma_{XY}\)</span>의 구체 형태를 고정하여 닫힌 형태의 절대 상수를 산출하는 데 사용된다.</p>
<h2 data-number="16.2" id="coulomb-힘-절대값-유도-및-표준-물리와의-수치-비교부록-r-통합"><span class="header-section-number">16.2</span> 14.2 Coulomb 힘 절대값 유도 및 표준 물리와의 수치 비교(부록 R 통합)</h2>
<h3 data-number="16.2.1" id="목표와-출력-형식정의"><span class="header-section-number">16.2.1</span> 14.2.1 목표와 출력 형식(정의)</h3>
<p>본 절의 목표는 다음 두 출력을 동일한 형태로 고정하는 것이다.</p>
<ul>
<li><p>(O1) 본 문서 내부 정의로부터 도출되는 절대 상수 <span class="math inline">\(K_{C}^{(\mathrm{VP})}\)</span> 및 힘 크기
<span class="math display">\[\boxed{
  F_{C}^{(\mathrm{VP})}(R)=\frac{K_{C}^{(\mathrm{VP})}}{R^{2}}
  }
  \label{eq:S14_02_Fvp_goal}\]</span></p></li>
<li><p>(O2) 대상 텍스트(표준 물리)에서 사용되는 절대 상수 <span class="math inline">\(K_{C}^{(\mathrm{target})}\)</span> 및 힘 크기
<span class="math display">\[\boxed{
  F_{C}^{(\mathrm{target})}(R)=\frac{K_{C}^{(\mathrm{target})}}{R^{2}}
  }
  \label{eq:S14_02_Ftarget_goal}\]</span></p></li>
</ul>
<p>(O2)는 오직 <em>비교 지표</em>로만 사용되며, (O1)의 유도 근거로 사용되지 않는다.</p>
<h3 data-number="16.2.2" id="기본-곱-구조에서-1r2의-분리정의-rightarrow-전개"><span class="header-section-number">16.2.2</span> 14.2.2 기본 곱 구조에서 <span class="math inline">\(1/R^{2}\)</span>의 분리(정의 <span class="math inline">\(\rightarrow\)</span> 전개)</h3>
<p>14.1의 정의 <a data-reference="eq:S14_01_force_skeleton" data-reference-type="eqref" href="#eq:S14_01_force_skeleton">[eq:S14_01_force_skeleton]</a>과 등방 감쇄 <a data-reference="eq:S14_01_dil_iso" data-reference-type="eqref" href="#eq:S14_01_dil_iso">[eq:S14_01_dil_iso]</a>를 사용한다.
특정 레짐에서 결합 계수가 거리 <span class="math inline">\(R\)</span>에 무의존(상수)이라고 판정되면,
<span class="math display">\[\begin{aligned}
F_{X\leftarrow Y}(R)
&amp;=
F_{\mathrm{lat}}\cdot \left(\frac{a}{R}\right)^{2}\cdot \Gamma_{XY}
\qquad (R\ge a,\ \mathrm{PASS}_{\mathrm{dil}}=1)
\notag\\
&amp;=
\left(\frac{h\,c_{\mathrm{ref}}}{a^{2}}\right)\left(\frac{a^{2}}{R^{2}}\right)\Gamma_{XY}
\notag\\
&amp;=
\frac{h\,c_{\mathrm{ref}}}{R^{2}}\Gamma_{XY}.
\label{eq:S14_02_F_general}\end{aligned}\]</span>
따라서 <a data-reference="eq:S14_02_F_general" data-reference-type="eqref" href="#eq:S14_02_F_general">[eq:S14_02_F_general]</a>로부터 절대 상수는 다음 형태로 고정된다.
<span class="math display">\[\boxed{
K_{XY} = \Gamma_{XY}\,h\,c_{\mathrm{ref}}.
}
\label{eq:S14_02_K_general}\]</span>
이제 14.2의 핵심은 Coulomb 레짐에서의 <span class="math inline">\(\Gamma_{XY}\)</span>를 잠긴 입력으로부터 닫힌 형태로 고정하는 것이다.</p>
<h3 data-number="16.2.3" id="coulomb-레짐의-결합-계수-gamma_c-구조비-times-전파-페널티정의"><span class="header-section-number">16.2.3</span> 14.2.3 Coulomb 레짐의 결합 계수 <span class="math inline">\(\Gamma_{C}\)</span>: 구조비 <span class="math inline">\(\times\)</span> 전파 페널티(정의)</h3>
<p>본 절은 “Coulomb 레짐”에서 기본 전하 단위(14.3에서 정의되는 정준 전하) 사이의 결합 계수를 하나의 스칼라 <span class="math inline">\(\Gamma_{C}\)</span>로 고정한다.
<span class="math display">\[\boxed{
\Gamma_{C}:=\Gamma_{\mathrm{sec}}\cdot \Gamma_{\mathrm{prop}}.
}
\label{eq:S14_02_GammaC_fact}\]</span></p>
<h4 data-number="16.2.3.1" id="정의-섹터-구조비-gamma_mathrmsec"><span class="header-section-number">16.2.3.1</span> (정의) 섹터 구조비 <span class="math inline">\(\Gamma_{\mathrm{sec}}\)</span></h4>
<p>3-섹터 정수화로 고정된 두 정수 <span class="math inline">\(N_{e},N_{p,\mathrm{core}}\)</span>를 사용하여
<span class="math display">\[\boxed{
\Gamma_{\mathrm{sec}}:=\frac{N_{e}}{N_{p,\mathrm{core}}}.
}
\label{eq:S14_02_Gamma_sec}\]</span>
본 문서의 Coulomb 레짐에서는
<span class="math display">\[\boxed{
N_{e}=89,\qquad N_{p,\mathrm{core}}=82
}
\label{eq:S14_02_NeNpcore}\]</span>
가 정준으로 잠겨 있다고 둔다.</p>
<h4 data-number="16.2.3.2" id="정의-전파-페널티-gamma_mathrmprop"><span class="header-section-number">16.2.3.2</span> (정의) 전파 페널티 <span class="math inline">\(\Gamma_{\mathrm{prop}}\)</span></h4>
<p>전파/클록-프리 실현에서 정의되는 증폭 <span class="math inline">\(A\)</span>를 사용하여
<span class="math display">\[\boxed{
\Gamma_{\mathrm{prop}}:=A^{-1/2}.
}
\label{eq:S14_02_Gamma_prop}\]</span>
<span class="math inline">\(A\)</span>는 실현 시간 <span class="math inline">\(\Delta t\)</span>와 실현 길이 <span class="math inline">\(a\)</span> 및 <span class="math inline">\(c_{\mathrm{ref}}\)</span>로부터 다음 관계로 잠겨 있다고 둔다.
<span class="math display">\[\boxed{
\Delta t := \frac{A\,a}{c_{\mathrm{ref}}}
\quad\Longleftrightarrow\quad
A=\frac{c_{\mathrm{ref}}\Delta t}{a}.
}
\label{eq:S14_02_A_from_dt}\]</span>
<a data-reference="eq:S14_02_Gamma_prop" data-reference-type="eqref" href="#eq:S14_02_Gamma_prop">[eq:S14_02_Gamma_prop]</a>은 “전파에 의해 상호작용이 전달될 때의 결합 강도는 <span class="math inline">\(A\)</span>의 제곱근에 반비례한다”는 닫힘 규약이며,
해당 규약의 채택 여부와 버전은 <code>analysis_lock</code>에 의해 잠긴다.</p>
<h3 data-number="16.2.4" id="coulomb-절대-상수-k_cmathrmvp의-닫힌-형태전개"><span class="header-section-number">16.2.4</span> 14.2.4 Coulomb 절대 상수 <span class="math inline">\(K_{C}^{(\mathrm{VP})}\)</span>의 닫힌 형태(전개)</h3>
<p>14.2.3의 정의들을 결합하여
<span class="math display">\[\begin{aligned}
\Gamma_{C}
&amp;=
\Gamma_{\mathrm{sec}}\cdot\Gamma_{\mathrm{prop}}
=
\left(\frac{N_{e}}{N_{p,\mathrm{core}}}\right)A^{-1/2}
\label{eq:S14_02_GammaC}\end{aligned}\]</span>
이고, <a data-reference="eq:S14_02_K_general" data-reference-type="eqref" href="#eq:S14_02_K_general">[eq:S14_02_K_general]</a>로부터
<span class="math display">\[\boxed{
K_{C}^{(\mathrm{VP})}=\Gamma_{C}\,h\,c_{\mathrm{ref}}
=
\left(\frac{N_{e}}{N_{p,\mathrm{core}}}\right)A^{-1/2}\,h\,c_{\mathrm{ref}}.
}
\label{eq:S14_02_KC_VP_closed}\]</span>
따라서 Coulomb 레짐에서 힘 크기는
<span class="math display">\[\boxed{
F_{C}^{(\mathrm{VP})}(R)=\frac{K_{C}^{(\mathrm{VP})}}{R^{2}}
=
\left(\frac{N_{e}}{N_{p,\mathrm{core}}}\right)A^{-1/2}\frac{h\,c_{\mathrm{ref}}}{R^{2}}
\qquad (R\ge a).
}
\label{eq:S14_02_FC_VP_final}\]</span></p>
<h3 data-number="16.2.5" id="수치-산출잠긴-실현값-대입-단계별-계산"><span class="header-section-number">16.2.5</span> 14.2.5 수치 산출(잠긴 실현값 대입; 단계별 계산)</h3>
<p>실현값으로 다음을 사용한다.
<span class="math display">\[a = \aVP,
\qquad
\Delta t = 1.86\times 10^{-21}\ \mathrm{s},
\qquad
c_{\mathrm{ref}}=2.99792458\times 10^{8}\ \mathrm{m/s}.
\label{eq:S14_02_a_dt_cref}\]</span>
<a data-reference="eq:S14_02_A_from_dt" data-reference-type="eqref" href="#eq:S14_02_A_from_dt">[eq:S14_02_A_from_dt]</a>로부터
<span class="math display">\[\begin{aligned}
A
&amp;=
\frac{c_{\mathrm{ref}}\Delta t}{a}
=
\frac{(2.99792458\times 10^{8})(1.86\times 10^{-21})}{6.3299121257859865746\times 10^{-19}}
\notag\\
&amp;=
\frac{(2.99792458\times 1.86)\times 10^{-13}}{6.3299121257859865746\times 10^{-19}}
\notag\\
&amp;=
\frac{5.5761397188\times 10^{-13}}{6.3299121257859865746\times 10^{-19}}
\notag\\
&amp;=
\left(\frac{5.5761397188}{6.3299121257859865746}\right)\times 10^{6}
\notag\\
&amp;\approx
8.809189777\times 10^{5}.
\label{eq:S14_02_A_value}\end{aligned}\]</span>
따라서
<span class="math display">\[A^{1/2}\approx 938.57284,
\qquad
A^{-1/2}\approx 1.0654473\times 10^{-3}.
\label{eq:S14_02_Ahalf_value}\]</span>
또한 <a data-reference="eq:S14_02_NeNpcore" data-reference-type="eqref" href="#eq:S14_02_NeNpcore">[eq:S14_02_NeNpcore]</a>로부터
<span class="math display">\[\frac{N_{e}}{N_{p,\mathrm{core}}}=\frac{89}{82}\approx 1.0853658536585366.
\label{eq:S14_02_ratio_value}\]</span>
따라서 <a data-reference="eq:S14_02_GammaC" data-reference-type="eqref" href="#eq:S14_02_GammaC">[eq:S14_02_GammaC]</a>에 의해
<span class="math display">\[\begin{aligned}
\Gamma_{C}
&amp;=
\left(\frac{89}{82}\right)A^{-1/2}
\notag\\
&amp;\approx
(1.0853658536585366)(1.0654473\times 10^{-3})
\notag\\
&amp;\approx
1.1563997888\times 10^{-3}.
\label{eq:S14_02_GammaC_value}\end{aligned}\]</span>
또한 <a data-reference="eq:S14_01_hc_value" data-reference-type="eqref" href="#eq:S14_01_hc_value">[eq:S14_01_hc_value]</a>를 사용하면
<span class="math display">\[h\,c_{\mathrm{ref}}=1.9864458571489287\times 10^{-25}\ \mathrm{N\cdot m^{2}}.
\label{eq:S14_02_hc_in_Nm2}\]</span>
마지막으로 <a data-reference="eq:S14_02_KC_VP_closed" data-reference-type="eqref" href="#eq:S14_02_KC_VP_closed">[eq:S14_02_KC_VP_closed]</a>에 의해
<span class="math display">\[\begin{aligned}
K_{C}^{(\mathrm{VP})}
&amp;=
\Gamma_{C}\,h\,c_{\mathrm{ref}}
\notag\\
&amp;\approx
(1.1563997888\times 10^{-3})(1.9864458571489287\times 10^{-25})\ \mathrm{N\cdot m^{2}}
\notag\\
&amp;\approx
2.2971255696397601\times 10^{-28}\ \mathrm{N\cdot m^{2}}.
\label{eq:S14_02_KC_VP_value}\end{aligned}\]</span>
따라서 본 문서 내부 정의로부터
<span class="math display">\[\boxed{
F_{C}^{(\mathrm{VP})}(R)
\approx
\frac{2.2971255696397601\times 10^{-28}}{R^{2}}\ \mathrm{N}
\qquad (R\ \mathrm{in\ m},\ R\ge a)
}
\label{eq:S14_02_FC_numeric}\]</span>
를 얻는다.</p>
<h3 data-number="16.2.6" id="대상-텍스트표준-물리의-상수와-수치-비교비교만-허용"><span class="header-section-number">16.2.6</span> 14.2.6 대상 텍스트(표준 물리)의 상수와 수치 비교(비교만 허용)</h3>
<p>대상 텍스트에서는 두 기본 전하 사이의 힘 크기를
<span class="math display">\[F_{C}^{(\mathrm{target})}(R)=\frac{K_{C}^{(\mathrm{target})}}{R^{2}}
\label{eq:S14_02_target_form}\]</span>
로 표기하며, 그 상수는 다음으로 표기된다.
<span class="math display">\[K_{C}^{(\mathrm{target})}
=
k_{e}\,e^{2}
=
\frac{1}{4\pi\varepsilon_{0}}\,e^{2}.
\label{eq:S14_02_KC_target_def}\]</span>
여기서 <span class="math inline">\(e\)</span>는 전하 단위(쿨롱), <span class="math inline">\(\varepsilon_{0}\)</span>는 대상 텍스트의 상수이다.
비교 계산에서는 <span class="math inline">\(k_{e}\)</span>를 직접 사용한다.
<span class="math display">\[k_{e}=8.9875517923\times 10^{9}\ \mathrm{N\cdot m^{2}/C^{2}},
\qquad
e=1.602176634\times 10^{-19}\ \mathrm{C}.
\label{eq:S14_02_ke_e_values}\]</span>
<a data-reference="eq:S14_02_ke_e_values" data-reference-type="eqref" href="#eq:S14_02_ke_e_values">[eq:S14_02_ke_e_values]</a>로부터
<span class="math display">\[\begin{aligned}
e^{2}
&amp;=
(1.602176634\times 10^{-19})^{2}\ \mathrm{C^{2}}
\notag\\
&amp;=
(1.602176634)^{2}\times 10^{-38}\ \mathrm{C^{2}}
\notag\\
&amp;\approx
2.56696996653557\times 10^{-38}\ \mathrm{C^{2}}.
\label{eq:S14_02_e2_value}\end{aligned}\]</span>
따라서 <a data-reference="eq:S14_02_KC_target_def" data-reference-type="eqref" href="#eq:S14_02_KC_target_def">[eq:S14_02_KC_target_def]</a>에 의해
<span class="math display">\[\begin{aligned}
K_{C}^{(\mathrm{target})}
&amp;=
(8.9875517923\times 10^{9})(2.56696996653557\times 10^{-38})\ \mathrm{N\cdot m^{2}}
\notag\\
&amp;=
(8.9875517923\times 2.56696996653557)\times 10^{-29}\ \mathrm{N\cdot m^{2}}
\notag\\
&amp;\approx
2.3070775523517033\times 10^{-28}\ \mathrm{N\cdot m^{2}}.
\label{eq:S14_02_KC_target_value}\end{aligned}\]</span></p>
<p>이제 비교 지표를 다음으로 정의한다.
<span class="math display">\[\boxed{
\mathcal{R}_{C}:=\frac{K_{C}^{(\mathrm{VP})}}{K_{C}^{(\mathrm{target})}},
\qquad
\mathcal{D}_{C}:=\left|\mathcal{R}_{C}-1\right|.
}
\label{eq:S14_02_compare_metrics}\]</span>
<a data-reference="eq:S14_02_KC_VP_value" data-reference-type="eqref" href="#eq:S14_02_KC_VP_value">[eq:S14_02_KC_VP_value]</a>와 <a data-reference="eq:S14_02_KC_target_value" data-reference-type="eqref" href="#eq:S14_02_KC_target_value">[eq:S14_02_KC_target_value]</a>를 대입하면
<span class="math display">\[\begin{aligned}
\mathcal{R}_{C}
&amp;=
\frac{2.2971255696397601\times 10^{-28}}{2.3070775523517033\times 10^{-28}}
=
\frac{2.2971255696397601}{2.3070775523517033}
\notag\\
&amp;\approx
0.9956863250212,
\label{eq:S14_02_ratio_numeric}
\\
\mathcal{D}_{C}
&amp;=
|0.9956863250212-1|
\approx
4.3136749788\times 10^{-3}.
\label{eq:S14_02_dev_numeric}\end{aligned}\]</span></p>
<h3 data-number="16.2.7" id="비교-gate정의-수치-비교의-자격"><span class="header-section-number">16.2.7</span> 14.2.7 비교 Gate(정의): “수치 비교”의 자격</h3>
<p>비교 결과를 “통과”로 판정하기 위한 허용 문턱을 <span class="math inline">\(\tau_{C}&gt;0\)</span>로 두고(값은 <code>gate_lock</code>에 잠김),
비교 Gate를 다음으로 정의한다.
<span class="math display">\[\boxed{
\mathrm{PASS}_{\mathrm{cmpC}}
:\Longleftrightarrow
\mathcal{D}_{C}\le \tau_{C}.
}
\label{eq:S14_02_pass_cmpC}\]</span>
<a data-reference="eq:S14_02_pass_cmpC" data-reference-type="eqref" href="#eq:S14_02_pass_cmpC">[eq:S14_02_pass_cmpC]</a>는 비교의 자격을 판정하는 규칙이며,
<span class="math inline">\(\tau_{C}\)</span>는 실행 결과를 본 뒤 조정할 수 없다.</p>
<h2 data-number="16.3" id="r2-법칙의-기하학적-의미-전하의-운영-정의정준관측-분리"><span class="header-section-number">16.3</span> 14.3 <span class="math inline">\(1/R^{2}\)</span> 법칙의 기하학적 의미 + “전하”의 운영 정의(정준/관측 분리)</h2>
<h3 data-number="16.3.1" id="격자-껍질shell-계수와-1r2-스케일링정의-rightarrow-전개"><span class="header-section-number">16.3.1</span> 14.3.1 격자 껍질(shell) 계수와 <span class="math inline">\(1/R^{2}\)</span> 스케일링(정의 <span class="math inline">\(\rightarrow\)</span> 전개)</h3>
<p>원점(소스)에서 거리 <span class="math inline">\(R\)</span>에 해당하는 격자 껍질 집합을 다음으로 정의한다.
<span class="math display">\[\mathcal{S}(R)
:=
\left\{
\mathbf{n}\in\mathbb{Z}^{3}\
\Big|\
R-\frac{a}{2}\le \|\mathbf{x}(\mathbf{n})\| &lt; R+\frac{a}{2}
\right\},
\qquad
\mathbf{x}(\mathbf{n})=a\mathbf{n}.
\label{eq:S14_03_shell_set}\]</span>
껍질 계수(껍질에 포함되는 격자 노드 수)를
<span class="math display">\[N_{\mathcal{S}}(R):=|\mathcal{S}(R)|
\label{eq:S14_03_shell_count}\]</span>
로 정의한다.</p>
<p>연속 근사에서 반지름 <span class="math inline">\(R\)</span>의 구면 표면적은 <span class="math inline">\(4\pi R^{2}\)</span>이며, 격자 해상도 <span class="math inline">\(a\)</span>에서의 “표면 픽셀” 면적은 <span class="math inline">\(a^{2}\)</span>로 취급된다.
따라서 <span class="math inline">\(R\gg a\)</span> 레짐에서
<span class="math display">\[N_{\mathcal{S}}(R)
\approx
\mathcal{C}_{\mathrm{surf}}\left(\frac{R}{a}\right)^{2}
\label{eq:S14_03_shell_asymp}\]</span>
로 쓸 수 있으며, 이상적인 등방 평균에서는 <span class="math inline">\(\mathcal{C}_{\mathrm{surf}}=4\pi\)</span>가 된다.
<a data-reference="eq:S14_03_shell_asymp" data-reference-type="eqref" href="#eq:S14_03_shell_asymp">[eq:S14_03_shell_asymp]</a>의 핵심은 <em>껍질 계수가 <span class="math inline">\(R^{2}\)</span>에 비례</em>한다는 점이다.</p>
<p>이제 “총량 보존” 형태의 운영 가정을 다음으로 둔다.
소스에서 방출된 상호작용 총량(장력 기반 영향)이 껍질 전체로 분배되고,
특정 방향/특정 표적에 도달하는 평균 몫이 껍질 계수에 반비례한다고 정의한다.
즉, 표적 1개가 받는 평균 몫을
<span class="math display">\[\mathrm{share}(R):=\frac{1}{N_{\mathcal{S}}(R)}
\label{eq:S14_03_share}\]</span>
로 정의한다. <a data-reference="eq:S14_03_shell_asymp" data-reference-type="eqref" href="#eq:S14_03_shell_asymp">[eq:S14_03_shell_asymp]</a>를 대입하면
<span class="math display">\[\mathrm{share}(R)\approx \frac{1}{\mathcal{C}_{\mathrm{surf}}}\left(\frac{a}{R}\right)^{2}.
\label{eq:S14_03_share_asymp}\]</span>
따라서 <span class="math inline">\(R\)</span> 의존성은 <span class="math inline">\((a/R)^{2}\)</span>로 고정된다. 이 <span class="math inline">\(R^{-2}\)</span>가 14.1의 감쇄 정의 <a data-reference="eq:S14_01_dil_iso" data-reference-type="eqref" href="#eq:S14_01_dil_iso">[eq:S14_01_dil_iso]</a>의 기하학적 핵심이며,
상수 <span class="math inline">\(1/\mathcal{C}_{\mathrm{surf}}\)</span>는 결합 계수(상수항)로 흡수되어도 <span class="math inline">\(R^{-2}\)</span> 스케일링은 변하지 않는다.</p>
<h3 data-number="16.3.2" id="전하의-정준-정의운영-정의-부호와-크기"><span class="header-section-number">16.3.2</span> 14.3.2 전하의 정준 정의(운영 정의): 부호와 크기</h3>
<h4 data-number="16.3.2.1" id="정의-정준-전하-부호-q_mathrmcanin1-1"><span class="header-section-number">16.3.2.1</span> (정의) 정준 전하 부호 <span class="math inline">\(q_{\mathrm{can}}\in\{+1,-1\}\)</span></h4>
<p>각 객체 <span class="math inline">\(X\)</span>에 대해, 3-섹터 사건 로그로부터 위상 변수 <span class="math inline">\(\Phi_X(k_0,M)\)</span>를 구성한다.
섹터 비율 <span class="math inline">\(p_{X,s}\)</span>와 섹터 각도 <span class="math inline">\(\theta_s\)</span>를
<span class="math display">\[p_{X,s}(k_0,M):=\frac{N_{X,s}(k_0,M)}{\sum_{r=1}^{3}N_{X,r}(k_0,M)},
\qquad
\theta_s:=\frac{2\pi}{3}(s-1)
\label{eq:S14_03_ps_theta}\]</span>
로 정의하고(단, 분모가 0이면 비결정), 복소 합성자를
<span class="math display">\[u_X(k_0,M):=\sum_{s=1}^{3}p_{X,s}(k_0,M)\,e^{i\theta_s},
\qquad
\Phi_X(k_0,M):=\arg u_X(k_0,M)\in(-\pi,\pi]
\label{eq:S14_03_uPhi}\]</span>
로 정의한다.</p>
<p>연속 두 창 <span class="math inline">\(W(k_0,M)\)</span>, <span class="math inline">\(W(k_0+M,M)\)</span>에서의 위상 증가량을
<span class="math display">\[\Delta\Phi_X(k_0,M)
:=
\mathrm{Wrap}_{(-\pi,\pi]}\!\Big(\Phi_X(k_0+M,M)-\Phi_X(k_0,M)\Big)
\label{eq:S14_03_dPhi}\]</span>
로 정의한다. 여기서 <span class="math inline">\(\mathrm{Wrap}_{(-\pi,\pi]}\)</span>는 값을 <span class="math inline">\((-\pi,\pi]\)</span>로 환원한다.</p>
<p>정준 전하 부호를 다음 Gate-판정으로 정의한다.
<span class="math display">\[\boxed{
q_{\mathrm{can}}(X)
:=
\begin{cases}
+1, &amp; \Delta\Phi_X(k_0,M)\ge +\Phi_{\star},\\
-1, &amp; \Delta\Phi_X(k_0,M)\le -\Phi_{\star},
\end{cases}
}
\label{eq:S14_03_qcan_def}\]</span>
여기서 <span class="math inline">\(\Phi_{\star}&gt;0\)</span>는 비결정을 배제하기 위한 문턱값이며 <code>gate_lock</code>에 잠긴다.
다음 Gate를 정의한다.
<span class="math display">\[\mathrm{PASS}_{q}
:\Longleftrightarrow
|\Delta\Phi_X(k_0,M)|\ge \Phi_{\star}.
\label{eq:S14_03_pass_q}\]</span>
<span class="math inline">\(\mathrm{PASS}_{q}=0\)</span>이면 <span class="math inline">\(q_{\mathrm{can}}(X)\)</span>는 정의되지 않으며,
그 경우 본 절의 “전하”를 포함하는 결론을 산출할 수 없다.</p>
<h4 data-number="16.3.2.2" id="정의-정준-전하-크기-q_mathrmcaninmathbbz"><span class="header-section-number">16.3.2.2</span> (정의) 정준 전하 크기 <span class="math inline">\(Q_{\mathrm{can}}\in\mathbb{Z}\)</span></h4>
<p>동일 객체 <span class="math inline">\(X\)</span> 내부에서 독립 전하 운반자(독립 생존 벡터, 독립 궤도 방출, 독립 라벨 슬롯)의 개수를 <span class="math inline">\(m_X\in\mathbb{N}\)</span>로 두고,
각 운반자 <span class="math inline">\(i\)</span>의 부호 <span class="math inline">\(q_{\mathrm{can}}^{(i)}(X)\in\{+1,-1\}\)</span>가 <a data-reference="eq:S14_03_qcan_def" data-reference-type="eqref" href="#eq:S14_03_qcan_def">[eq:S14_03_qcan_def]</a>로 판정된다고 하자.
정준 전하 크기를
<span class="math display">\[\boxed{
Q_{\mathrm{can}}(X):=\sum_{i=1}^{m_X} q_{\mathrm{can}}^{(i)}(X)\in\mathbb{Z}
}
\label{eq:S14_03_Qcan_def}\]</span>
로 정의한다. <span class="math inline">\(m_X\)</span>의 판정 규칙(슬롯 정의, 독립성 기준)은 <code>analysis_lock</code>에 잠긴다.</p>
<h3 data-number="16.3.3" id="전하-힘-결합-규칙정의-정준-전하에-대한-힘의-부호"><span class="header-section-number">16.3.3</span> 14.3.3 전하-힘 결합 규칙(정의): 정준 전하에 대한 힘의 부호</h3>
<p>두 객체 <span class="math inline">\(X,Y\)</span>의 분리 벡터를 <span class="math inline">\(\mathbf{R}:=\mathbf{x}_X-\mathbf{x}_Y\)</span>, <span class="math inline">\(R=\|\mathbf{R}\|\)</span>로 두고,
단위벡터 <span class="math inline">\(\widehat{\mathbf{R}}:=\mathbf{R}/R\)</span>을 정의한다(<span class="math inline">\(R&gt;0\)</span>).
Coulomb 레짐에서의 힘 벡터를 다음으로 정의한다.
<span class="math display">\[\boxed{
\mathbf{F}_{X\leftarrow Y}(R)
:=
\left(Q_{\mathrm{can}}(X)\,Q_{\mathrm{can}}(Y)\right)\,
\frac{K_{C}^{(\mathrm{VP})}}{R^{2}}\,
\widehat{\mathbf{R}}
}
\label{eq:S14_03_force_vector}\]</span>
여기서 <span class="math inline">\(K_{C}^{(\mathrm{VP})}\)</span>는 14.2에서 고정된 절대 상수이다.
<a data-reference="eq:S14_03_force_vector" data-reference-type="eqref" href="#eq:S14_03_force_vector">[eq:S14_03_force_vector]</a>는 힘의 방향(인력/척력)을 정준 전하의 부호 곱으로 결정한다.</p>
<h3 data-number="16.3.4" id="정준관측-분리정의-전하-단위의-환산은-번역"><span class="header-section-number">16.3.4</span> 14.3.4 정준/관측 분리(정의): 전하 단위의 환산은 “번역”</h3>
<p>정준 전하 <span class="math inline">\(Q_{\mathrm{can}}\)</span>은 본 문서 내부의 구조/로그 판정으로 정의된 <em>무차원 정수</em>이다.
관측 전하 <span class="math inline">\(Q_{\mathrm{obs}}\)</span>는 실험/계측 시스템이 출력하는 <em>단위 포함 값</em>이며, 관측 단위는 계측 스키마에 의해 고정된다.</p>
<h4 data-number="16.3.4.1" id="정의-관측-전하-단위-계수-e_mathrmmap"><span class="header-section-number">16.3.4.1</span> (정의) 관측 전하 단위 계수 <span class="math inline">\(e_{\mathrm{map}}\)</span></h4>
<p>관측 단위로 “쿨롱”을 채택하는 대상 텍스트 비교를 수행할 때,
정준 전하를 관측 전하로 변환하는 계수 <span class="math inline">\(e_{\mathrm{map}}\)</span>를 다음 번역 규칙으로 정의한다.
대상 텍스트의 상수 <span class="math inline">\(k_e\)</span>를 사용하여
<span class="math display">\[\boxed{
e_{\mathrm{map}}
:=
\sqrt{\frac{K_{C}^{(\mathrm{VP})}}{k_e}}
}
\label{eq:S14_03_emap_def}\]</span>
를 정의하고, 관측 전하를
<span class="math display">\[\boxed{
Q_{\mathrm{obs}}(X)
:=
e_{\mathrm{map}}\ Q_{\mathrm{can}}(X)
}
\label{eq:S14_03_Qobs_def}\]</span>
로 정의한다.
<a data-reference="eq:S14_03_emap_def" data-reference-type="eqref" href="#eq:S14_03_emap_def">[eq:S14_03_emap_def]</a>–<a data-reference="eq:S14_03_Qobs_def" data-reference-type="eqref" href="#eq:S14_03_Qobs_def">[eq:S14_03_Qobs_def]</a>는 <em>번역 규칙</em>이며,
정준 전하의 정의 <a data-reference="eq:S14_03_Qcan_def" data-reference-type="eqref" href="#eq:S14_03_Qcan_def">[eq:S14_03_Qcan_def]</a> 및 힘 상수의 유도 <a data-reference="eq:S14_02_KC_VP_closed" data-reference-type="eqref" href="#eq:S14_02_KC_VP_closed">[eq:S14_02_KC_VP_closed]</a>에 영향을 주지 않는다.</p>
<h4 data-number="16.3.4.2" id="비교-수치-e_mathrmmap의-산출"><span class="header-section-number">16.3.4.2</span> (비교 수치) <span class="math inline">\(e_{\mathrm{map}}\)</span>의 산출</h4>
<p>14.2의 수치 <a data-reference="eq:S14_02_KC_VP_value" data-reference-type="eqref" href="#eq:S14_02_KC_VP_value">[eq:S14_02_KC_VP_value]</a>와 대상 텍스트 상수 <span class="math inline">\(k_e\)</span>를 <a data-reference="eq:S14_02_ke_e_values" data-reference-type="eqref" href="#eq:S14_02_ke_e_values">[eq:S14_02_ke_e_values]</a>로 두면,
<span class="math display">\[\begin{aligned}
e_{\mathrm{map}}^{2}
&amp;=
\frac{K_{C}^{(\mathrm{VP})}}{k_e}
=
\frac{2.2971255696397601\times 10^{-28}}{8.9875517923\times 10^{9}}\ \mathrm{C^{2}}
\notag\\
&amp;=
\left(\frac{2.2971255696397601}{8.9875517923}\right)\times 10^{-37}\ \mathrm{C^{2}}
\notag\\
&amp;\approx
2.555\ldots\times 10^{-38}\ \mathrm{C^{2}}.
\label{eq:S14_03_emap2_value}\end{aligned}\]</span>
따라서
<span class="math display">\[e_{\mathrm{map}}\approx 1.599\ldots\times 10^{-19}\ \mathrm{C}.
\label{eq:S14_03_emap_value}\]</span>
이 값은 <a data-reference="eq:S14_03_emap_def" data-reference-type="eqref" href="#eq:S14_03_emap_def">[eq:S14_03_emap_def]</a>의 번역 규칙에 의해 산출된 값이며,
정준 전하 정의의 일부가 아니다.</p>
<h3 data-number="16.3.5" id="coulomb-레짐-gate정의-1r2의-사용-조건"><span class="header-section-number">16.3.5</span> 14.3.5 Coulomb 레짐 Gate(정의): <span class="math inline">\(1/R^{2}\)</span>의 사용 조건</h3>
<p>본 절의 <span class="math inline">\(1/R^{2}\)</span> 힘 표현은 다음 Gate를 만족할 때만 사용 가능하다.
<span class="math display">\[\mathrm{PASS}_{C}
:\Longleftrightarrow
\mathrm{PASS}_{\mathrm{dil}}=1
\ \wedge\
\mathrm{PASS}_{q}(X)=1
\ \wedge\
\mathrm{PASS}_{q}(Y)=1
\ \wedge\
\Gamma_{C}\ \text{가 $R$에 무의존임이 사전등록 메트릭으로 판정됨}.
\label{eq:S14_03_pass_C}\]</span>
여기서 “<span class="math inline">\(\Gamma_{C}\)</span>가 <span class="math inline">\(R\)</span>에 무의존” 판정은 다음 형태의 메트릭으로 고정할 수 있다.
서로 다른 거리 <span class="math inline">\(R_1,R_2\)</span>에서의 관측 힘 크기 <span class="math inline">\(F(R)\)</span>로부터
<span class="math display">\[\widehat{K}(R):=F(R)R^{2}
\label{eq:S14_03_Khat}\]</span>
를 정의하고,
<span class="math display">\[\mathrm{PASS}_{\Gamma}
:\Longleftrightarrow
\left|\frac{\widehat{K}(R_2)-\widehat{K}(R_1)}{\widehat{K}(R_1)}\right|\le \varepsilon_{K}
\label{eq:S14_03_pass_Gamma}\]</span>
로 Gate를 정의한다. <span class="math inline">\(\varepsilon_{K}\)</span>는 <code>gate_lock</code>에 잠긴다.
<span class="math inline">\(\mathrm{PASS}_{\Gamma}=0\)</span>이면 <span class="math inline">\(1/R^{2}\)</span> 형태를 결론으로 산출할 수 없다.</p>
<h2 data-number="16.4" id="casimir-압력-경계-스크리닝에-의한-1d4-힘검증-모듈"><span class="header-section-number">16.4</span> 14.4 Casimir 압력: 경계 스크리닝에 의한 <span class="math inline">\(1/d^{4}\)</span> 힘(검증 모듈)</h2>
<h3 data-number="16.4.1" id="이상-한계식평행-완전도체-t0"><span class="header-section-number">16.4.1</span> 14.4.1 이상 한계식(평행 완전도체; <span class="math inline">\(T=0\)</span>)</h3>
<p>평행한 두 도체 판 사이 간격을 <span class="math inline">\(d\)</span>로 두면, 가장 단순한 한계(완전도체, 평행판, 영온)에서 Casimir 압력은
<span class="math display">\[P_{\mathrm{Cas}}(d)
=
-\frac{\pi^2\,\hbar_{\mathrm{map}}\,c_{\mathrm{ref}}}{240\,d^{4}}
=
-\frac{\pi}{480}\frac{h\,c_{\mathrm{ref}}}{d^{4}}
\label{eq:S14_04_Casimir_P}\]</span>
이다. 부호(<span class="math inline">\(-\)</span>)는 <strong>흡인(인력)</strong>을 뜻한다.
AQD에서는 <span class="math inline">\(\hbar_{\mathrm{map}}c_{\mathrm{ref}}\)</span>를 “공간 격자의 탄성/강성 스케일”로 <em>해석</em>할 수 있지만,
본 절의 목적은 해석이 아니라 <strong><span class="math inline">\(1/d^{4}\)</span> 스케일링과 수치 규모</strong>를 검증 모듈로 고정하는 데 있다.</p>
<h3 data-number="16.4.2" id="수치-예-d-스캔평행판-a1mathrmcm2"><span class="header-section-number">16.4.2</span> 14.4.2 수치 예: <span class="math inline">\(d\)</span>-스캔(평행판; <span class="math inline">\(A=1\,\mathrm{cm}^2\)</span>)</h3>
<p><a data-reference="eq:S14_04_Casimir_P" data-reference-type="eqref" href="#eq:S14_04_Casimir_P">[eq:S14_04_Casimir_P]</a>를 사용하여 대표 간격에서의 압력과,
면적 <span class="math inline">\(A=1\,\mathrm{cm}^2(=10^{-4}\,\mathrm{m}^2)\)</span> 판에 작용하는 힘 <span class="math inline">\(F=|P|A\)</span>를 정리하면 다음과 같다.</p>
<table>
<caption>Casimir 압력(이상 한계식)과 <span class="math inline">\(1\,\mathrm{cm}^2\)</span> 판에 작용하는 힘.</caption>
<thead>
<tr class="header">
<th style="text-align: right;"><span class="math inline">\(d\)</span> (nm)</th>
<th style="text-align: right;"><span class="math inline">\(d\)</span> (m)</th>
<th style="text-align: right;"><span class="math inline">\(|P_{\mathrm{Cas}}|\)</span> (Pa)</th>
<th style="text-align: right;"><span class="math inline">\(|P_{\mathrm{Cas}}|\)</span> (atm)</th>
<th style="text-align: right;"><span class="math inline">\(|F|\)</span> on <span class="math inline">\(1\,\mathrm{cm}^2\)</span> (N)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">10</td>
<td style="text-align: right;"><span class="math inline">\(1\times 10^{-8}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(1.3\times 10^{5}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(1.28\)</span></td>
<td style="text-align: right;"><span class="math inline">\(1.3\times 10^{1}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">50</td>
<td style="text-align: right;"><span class="math inline">\(5\times 10^{-8}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(2.08\times 10^{2}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(2.05\times 10^{-3}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(2.08\times 10^{-2}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">100</td>
<td style="text-align: right;"><span class="math inline">\(1\times 10^{-7}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(1.3\times 10^{1}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(1.28\times 10^{-4}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(1.3\times 10^{-3}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">200</td>
<td style="text-align: right;"><span class="math inline">\(2\times 10^{-7}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(8.13\times 10^{-1}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(8.02\times 10^{-6}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(8.13\times 10^{-5}\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: right;">500</td>
<td style="text-align: right;"><span class="math inline">\(5\times 10^{-7}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(2.08\times 10^{-2}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(2.05\times 10^{-7}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(2.08\times 10^{-6}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: right;">1000</td>
<td style="text-align: right;"><span class="math inline">\(1\times 10^{-6}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(1.3\times 10^{-3}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(1.28\times 10^{-8}\)</span></td>
<td style="text-align: right;"><span class="math inline">\(1.3\times 10^{-7}\)</span></td>
</tr>
</tbody>
</table>
<p>표에서 보이듯 <span class="math inline">\(d\)</span>가 10배 증가하면 압력은 <span class="math inline">\(10^4\)</span>배 감소한다(<span class="math inline">\(1/d^4\)</span> 법칙).
또한 <span class="math inline">\(d=10\,\mathrm{nm}\)</span>에서 이상 한계식은 <span class="math inline">\(|P|\approx 1.3\times 10^{5}\,\mathrm{Pa}\approx 1.28\,\mathrm{atm}\)</span> 규모를 준다.</p>
<h3 data-number="16.4.3" id="aqd-해석-격자-모드-스크리닝에-의한-압력-차"><span class="header-section-number">16.4.3</span> 14.4.3 AQD 해석: “격자 모드 스크리닝”에 의한 압력 차</h3>
<p>AQD 관점에서는 외부 공간은 “전체 격자 모드”가 존재하는 고압 레짐으로, 갭(<span class="math inline">\(d\)</span>) 내부는 경계 조건 때문에 특정 파장(특히 장파장) 모드가 억제되어
유효 압력이 낮아진 레짐으로 해석할 수 있다. 그러면 판은
<span class="math display">\[\Delta P(d) := P_{\mathrm{int}}(d)-P_{\mathrm{ext}}
\quad\Rightarrow\quad
\Delta P(d)\approx P_{\mathrm{Cas}}(d)&lt;0
\label{eq:S14_04_deltaP}\]</span>
와 같은 “압력차”로 기술된다.
다만 이 절의 결론 자격은 <a data-reference="eq:S14_04_Casimir_P" data-reference-type="eqref" href="#eq:S14_04_Casimir_P">[eq:S14_04_Casimir_P]</a>의 형태(스케일링)와 수치 크기(표)이며,
해석(진공요동 vs 격자 압력차)은 <strong>동일 수식 위의 해석 선택</strong>으로 분리한다.</p>
<h3 data-number="16.4.4" id="실험-비교를-위한-형상-변환구평판-pfa"><span class="header-section-number">16.4.4</span> 14.4.4 실험 비교를 위한 형상 변환(구–평판; PFA)</h3>
<p>대표 실험은 구–평판 형상을 많이 사용한다. 반지름 <span class="math inline">\(R\)</span>인 구와 평판 사이에서,
근접 근사(PFA; Proximity Force Approximation)를 채택하면 평행판 에너지 밀도 <span class="math inline">\(E/A\)</span>로부터
<span class="math display">\[F_{\mathrm{sph\text{-}pl}}(d)
\simeq
2\pi R\,\frac{E_{\mathrm{pp}}(d)}{A}
=
-\frac{\pi^{3}\,\hbar_{\mathrm{map}}\,c_{\mathrm{ref}}\,R}{360\,d^{3}}
\label{eq:S14_04_PFA_sph_pl}\]</span>
를 얻는다. 따라서 “실험 데이터와의 직접 비교”를 주장하려면 사용 형상(평행판/구–평판)과 변환(PFA 또는 정확식)을 명시해야 한다.</p>
<h3 data-number="16.4.5" id="gate-실험-비교를-위한-최소-조건이상식-사용-한계"><span class="header-section-number">16.4.5</span> 14.4.5 Gate: 실험 비교를 위한 최소 조건(이상식 사용 한계)</h3>
<p><a data-reference="eq:S14_04_Casimir_P" data-reference-type="eqref" href="#eq:S14_04_Casimir_P">[eq:S14_04_Casimir_P]</a>는 <em>이상 한계식</em>이므로, 실험 비교를 결론으로 사용하려면 최소 다음을 명시해야 한다.</p>
<ul>
<li><p>(G-CAS-GEO) <strong>형상/근사:</strong>
평행판인지, 구–평판인지, PFA를 쓰는지(또는 정확식을 쓰는지)를 LOCK하고,
해당 선택이 비교 오차에 미치는 영향을 보고해야 한다.</p></li>
<li><p>(G-CAS-MAT) <strong>물성/표면:</strong>
유한 전도도(Drude/Plasma 등 모델 선택), 표면 거칠기, 산화층, 패치 전위(정전기) 보정의 포함 여부를 스코프에 포함해야 한다.
누락 시 수치 비교는 <code>INCONCLUSIVE</code>로 둔다.</p></li>
<li><p>(G-CAS-RANGE) <strong>거리 레짐:</strong>
<span class="math inline">\(d\)</span>가 수 수십 nm로 내려가면 비카시미르(비지연 van der Waals, 화학적 접촉력 등) 기여가 커질 수 있으므로,
“Casimir 검증”으로 사용할 <span class="math inline">\(d\)</span>-구간과 배제 규칙을 사전등록해야 한다.</p></li>
<li><p>(G-CAS-T) <strong>온도:</strong>
<span class="math inline">\(d\)</span>가 <span class="math inline">\(\mu\)</span>m 이상으로 올라가면 열 보정이 유의해질 수 있으므로,
온도/열 길이 스케일을 고정하고 필요 시 보정을 포함해야 한다.</p></li>
</ul>
<h3 data-number="16.4.6" id="대표-실험참고과-비교-범위거리형상보정의-명시"><span class="header-section-number">16.4.6</span> 14.4.6 대표 실험(참고)과 비교 범위(거리/형상/보정의 명시)</h3>
<p>본 절의 표는 <a data-reference="eq:S14_04_Casimir_P" data-reference-type="eqref" href="#eq:S14_04_Casimir_P">[eq:S14_04_Casimir_P]</a>의 <em>이상 한계식</em>을 그대로 평가한 것이다.
따라서 “실험과의 일치”를 결론으로 사용하려면, 최소한 (i) <strong>측정 형상</strong>, (ii) <strong>거리 레짐</strong>, (iii) <strong>보정 포함 여부</strong>가 일치해야 한다.
참고로, 대표 측정은 다음과 같은 범위를 보고한다.</p>
<ul>
<li><p><strong>Lamoreaux (1997):</strong> 토션 펜듈럼 기반 측정으로 <span class="math inline">\(0.6\)</span>–<span class="math inline">\(6\,\mu\mathrm{m}\)</span> 범위에서 Casimir 힘을 보고하였다.<a class="footnote-ref" href="#fn1" id="fnref1" role="doc-noteref"><sup>1</sup></a></p></li>
<li><p><strong>Mohideen &amp; Roy (1998):</strong> AFM 기반 구–평판 형상에서 <span class="math inline">\(0.1\)</span>–<span class="math inline">\(0.9\,\mu\mathrm{m}\)</span> 범위의 힘을 보고하였다.<a class="footnote-ref" href="#fn2" id="fnref2" role="doc-noteref"><sup>2</sup></a></p></li>
</ul>
<p>본 절의 <span class="math inline">\(d=10\,\mathrm{nm}\)</span> 행은 <em>이상식의 규모 감각</em>을 보여 주지만,
현실 표면/물성/패치 전위/비지연(vdW) 및 접촉력 레짐과 분리하여 “Casimir 검증”으로 직접 사용하기에는 추가 Gate가 필수이다.
(패치 전위/보정에 대해서는 예: <a href="https://doi.org/10.1103/PhysRevA.81.022505">Phys. Rev. A 81, 022505 (2010)</a>; 정밀 비교 리뷰로는 <a href="https://doi.org/10.1103/RevModPhys.81.1827">Rev. Mod. Phys. 81, 1827 (2009)</a> 등을 참조.)</p>
<h3 data-number="16.4.7" id="aqd-특이-편차-모델선택-스크리닝-함수의-사전등록-없이는-사용-금지"><span class="header-section-number">16.4.7</span> 14.4.7 AQD-특이 편차 모델(선택): 스크리닝 함수의 사전등록 없이는 사용 금지</h3>
<p>Casimir 이상식 자체는 표준 이론과 동일 형태를 갖기 때문에, <strong>AQD가 추가 예측을 제공하려면</strong> 경계 스크리닝의 <em>컷오프/이산성</em>을 별도 함수로 LOCK해야 한다.
예를 들어,
<span class="math display">\[P(d)=P_{\mathrm{Cas}}(d)\,S\!\left(\frac{d}{\lambda_{\star}}\right),
\qquad
\lim_{x\to\infty}S(x)=1,
\label{eq:S14_04_screening_S}\]</span>
처럼 스크리닝 함수 <span class="math inline">\(S(\cdot)\)</span>를 도입할 수 있다.
여기서 <span class="math inline">\(\lambda_{\star}\)</span>는 격자 스케일(예: <span class="math inline">\(\lambda_{\star}=N_{\star}\,\ell_{\mathrm{rot}}\)</span>) 또는 표면 유효 컷오프로 해석될 수 있으나,
<strong>본 문서에서 <span class="math inline">\(S\)</span> 또는 <span class="math inline">\(\lambda_{\star}\)</span>가 LOCK되지 않으면 기본값은 <span class="math inline">\(S\equiv 1\)</span>로 둔다</strong>.
즉, <em>사전등록 없는 사후 편차 주장</em>은 금지하며 결론은 <code>FAIL</code>로 둔다.</p>
<h4 data-number="16.4.7.1" id="gate-편차-주장-검증"><span class="header-section-number">16.4.7.1</span> (Gate) 편차 주장 검증</h4>
<p><span class="math inline">\(S\)</span>를 채택한 경우에는 관측/시뮬레이션 비교에서 상대 편차
<span class="math display">\[\delta_{\mathrm{dev}}(d):=\frac{P_{\mathrm{obs}}(d)}{P_{\mathrm{Cas}}(d)}-1
\label{eq:S14_04_delta_dev}\]</span>
가 <span class="math inline">\(S(d/\lambda_{\star})-1\)</span>과 정량적으로 양립하는지(오차막대 포함)를 Gate로 판정해야 한다.
해당 Gate 보고서가 첨부되지 않으면 편차 결론은 <code>UNLOGGED</code> 또는 <code>INCONCLUSIVE</code>이다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-70">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(h,\hbar_{\mathrm{map}},c_{\mathrm{ref}}\)</span> 및 거리 <span class="math inline">\(d\)</span>의 입력 스코프/단위/표기 규약을 <code>protocol_lock</code>에 고정.</p></li>
<li><p>LOCK: 사용 형상(평행판/구–평판), 변환(PFA/정확식), 보정 포함 여부(물성/거칠기/패치/온도)와 추정 절차를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: <span class="math inline">\(1/d^4\)</span> 스케일링의 유효 구간과 허용 오차를 <code>gate_lock</code>에 고정.</p></li>
</ul>
<h2 data-number="16.5" id="sec:S14_05_alpha_em"><span class="header-section-number">16.5</span> 14.5 미세구조상수 <span class="math inline">\(\alpha_{em}\)</span>의 기하학적 유도(정의<span class="math inline">\(\rightarrow\)</span>검산)</h2>
<p>표준 물리에서 미세구조상수는
<span class="math display">\[\alpha_{em} := \frac{e^{2}}{4\pi\epsilon_{0}\,\hbar\,c}\]</span>
로 정의되는 <strong>무차원 결합 세기</strong>이며, 실험적으로 <span class="math inline">\(\alpha_{em}^{-1}\approx 137.036\)</span>이 알려져 있다.<a class="footnote-ref" href="#fn3" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<p>본 절에서는 <span class="math inline">\(\alpha_{em}\)</span>을 새로운 기본 상수로 <em>가정하지 않고</em>, 이미 앞에서 도출된 정수 구조(3-섹터, 7-셸)를 통해
<strong>“공간(<span class="math inline">\(4\pi\)</span>)과 결합하는 기하학적 효율”</strong>로 <em>운영 정의</em>한다.</p>
<h3 data-number="16.5.1" id="기하학적-임피던스정의-4pi-결합-비용"><span class="header-section-number">16.5.1</span> 14.5.1 기하학적 임피던스(정의): <span class="math inline">\(4\pi\)</span> 결합 비용</h3>
<p>전하(3-섹터 위상 결함)가 외부로 파동(모드)을 방출하려면, (i) 표면 강성 껍질을 통과하고,
(ii) 섹터 위상 구분을 통과하고, (iii) 축 회전(스핀-유사) 자유도를 통과해야 한다.
이때 결합의 역세기 <span class="math inline">\(\alpha_{em}^{-1}\)</span>를 <strong>기하학적 임피던스</strong>로 다음과 같이 정의한다.
<span class="math display">\[\boxed{
\alpha_{em}^{-1} \equiv \mathcal{Z}_{\mathrm{geo}} := 4\pi\,\Bigl(N_{\mathrm{shell}}+N_{\mathrm{sec}}+N_{\mathrm{spin}}-\delta_{\mathrm{proj}}\Bigr)
}
\label{eq:S14_05_alpha_geo}\]</span>
여기서</p>
<ul>
<li><p><span class="math inline">\(N_{\mathrm{sec}}=3\)</span> (3-섹터의 위상학적 최소 가두기; 7.0절),</p></li>
<li><p><span class="math inline">\(N_{\mathrm{shell}}=7\)</span> (잔여 셸 카운트; 8.2절),</p></li>
<li><p><span class="math inline">\(N_{\mathrm{spin}}=1\)</span> (축 회전 자유도; 단일 축),</p></li>
</ul>
<p>이며, <span class="math inline">\(\delta_{\mathrm{proj}}\)</span>는 7-셸이 3-섹터 내에서 회전하며 생기는 <strong>중첩 투영 보정(Overlap Projection Correction)</strong>이다.</p>
<h3 data-number="16.5.2" id="차-근사-4pitimes-11"><span class="header-section-number">16.5.2</span> 14.5.2 0차 근사: <span class="math inline">\(4\pi\times 11\)</span></h3>
<p>이상적(투영 보정 무시)일 때는
<span class="math display">\[\alpha_{em,0}^{-1}=4\pi\,(7+3+1)=4\pi\times 11\approx 138.23
\label{eq:S14_05_alpha0}\]</span>
로서, 실제값(<span class="math inline">\(\approx 137.036\)</span>)보다 약 <span class="math inline">\(0.8\%\)</span> 크다.
따라서 <span class="math inline">\(\delta_{\mathrm{proj}}&gt;0\)</span>인 투영 보정이 필요하다.</p>
<h3 data-number="16.5.3" id="투영-보정-delta_mathrmproj의-닫힘-연속-회전-평균-times-이산-점유-보정"><span class="header-section-number">16.5.3</span> 14.5.3 투영 보정 <span class="math inline">\(\delta_{\mathrm{proj}}\)</span>의 닫힘: 연속 회전 평균 <span class="math inline">\(\times\)</span> 이산 점유 보정</h3>
<p>본 문서는 <span class="math inline">\(\delta_{\mathrm{proj}}\)</span>를 <strong>새 파라미터로 두지 않고</strong> 두 단계의 기하학으로 닫는다.</p>
<h4 data-number="16.5.3.1" id="i-연속-회전-평균연속-기하-2pi2."><span class="header-section-number">16.5.3.1</span> (i) 연속 회전 평균(연속 기하): <span class="math inline">\(2/\pi^{2}\)</span>.</h4>
<p>셸-섹터 상대 위상은 특정 방향을 선호할 정보가 없으므로(5.2.5절의 최대엔트로피/무편향 원리),
상대각 <span class="math inline">\(\theta\)</span>는 균등 분포로 취급한다. 이때 “투영 손실”의 기본 스케일을
<span class="math display">\[\delta_{0}:=\frac{2}{\pi^{2}}
\label{eq:S14_05_delta0}\]</span>
로 둔다(무편향 각도 평균에서 등장하는 <span class="math inline">\(\pi\)</span>-기하 상수).
셸과 섹터의 비율에 따라 1차 투영 손실은 <span class="math inline">\((N_{\mathrm{sec}}/N_{\mathrm{shell}})\,\delta_0\)</span>로 스케일된다.</p>
<h4 data-number="16.5.3.2" id="ii-7-셸의-이산-점유이산-기하-beta_mathrmdisc3532."><span class="header-section-number">16.5.3.2</span> (ii) 7-셸의 이산 점유(이산 기하): <span class="math inline">\(\beta_{\mathrm{disc}}=35/32\)</span>.</h4>
<p>그러나 7개의 셸은 3개의 섹터에 <em>연속적으로</em> 나뉠 수 없고, <strong>정수 점유</strong>로만 배치된다.
가장 균등한 정수 분할은 <span class="math inline">\((3,2,2)\)</span>이며(섹터당 평균 <span class="math inline">\(7/3\)</span>의 정수화),
편의상 3개를 점유하는 섹터를 <span class="math inline">\(S_0\)</span>로 라벨링하는 C<span class="math inline">\(_3\)</span> 기준(라벨 게이지)을 고정한다.
이때 셸 라벨(서로 다른 7개 벡터)을 고려한 배치 수(조합학적 미시상태 수)는
<span class="math display">\[\mathcal{N}_{\mathrm{perm}}=\frac{7!}{3!\,2!\,2!}=210
\label{eq:S14_05_Nperm}\]</span>
이다.
반면 “투영 보정”은 (a) 3-섹터 라벨의 위상 원점 선택(C<span class="math inline">\(_3\)</span> 순환; 3가지)과
(b) 각 셸의 상대 부호(<span class="math inline">\(\pm\)</span>; 전역 부호는 게이지로 간주하여 제거)만으로 결정되는
<strong>축약 표현</strong>을 갖는다. 따라서 투영-등가 미시상태 수는
<span class="math display">\[\mathcal{N}_{\mathrm{proj}} = 3\times 2^{6}=192
\label{eq:S14_05_Nproj}\]</span>
로 닫힌다.
(주: 섹터 라벨링 관습을 달리해도 비율 <span class="math inline">\(\beta_{\mathrm{disc}}\)</span>는 불변이며, 중요한 것은 <span class="math inline">\(35/32\)</span>가 순수 정수로 닫힌다는 점이다.)
이로부터 연속 평균을 이산 점유로 옮기는 <strong>이산 보정 계수</strong>는
<span class="math display">\[\beta_{\mathrm{disc}}:=\frac{\mathcal{N}_{\mathrm{perm}}}{\mathcal{N}_{\mathrm{proj}}}=\frac{210}{192}=\frac{35}{32}
\label{eq:S14_05_beta_disc}\]</span>
로 <em>정수만으로</em> 결정된다.</p>
<h4 data-number="16.5.3.3" id="결론-닫힌-형태."><span class="header-section-number">16.5.3.3</span> (결론) 닫힌 형태.</h4>
<p>따라서
<span class="math display">\[\boxed{
\delta_{\mathrm{proj}}=\beta_{\mathrm{disc}}\,\delta_{0}\,\frac{N_{\mathrm{sec}}}{N_{\mathrm{shell}}}
=\frac{35}{32}\cdot\frac{2}{\pi^{2}}\cdot\frac{3}{7}
}
\label{eq:S14_05_delta_proj_closed}\]</span>
이며, 이를 <a data-reference="eq:S14_05_alpha_geo" data-reference-type="eqref" href="#eq:S14_05_alpha_geo">[eq:S14_05_alpha_geo]</a>에 대입하면
<span class="math display">\[\alpha_{em,\mathrm{VP}}^{-1}
=4\pi\left(11-\frac{35}{32}\cdot\frac{2}{\pi^{2}}\cdot\frac{3}{7}\right)
\approx 137.0364.
\label{eq:S14_05_alpha_value}\]</span>
즉 <span class="math inline">\(137\)</span>은 <strong>구면(<span class="math inline">\(4\pi\)</span>)</strong>과 <strong>정수 구조(<span class="math inline">\(7+3+1\)</span>)</strong>에 의해 거의 닫히며,
잔차는 연속-이산 연결에서의 <strong>조합학적 보정</strong>으로 소거된다.</p>
<h3 data-number="16.5.4" id="gate-alpha_em-유도의-사용-조건정의"><span class="header-section-number">16.5.4</span> 14.5.4 Gate: <span class="math inline">\(\alpha_{em}\)</span> 유도의 사용 조건(정의)</h3>
<p>본 절의 <span class="math inline">\(\alpha_{em}\)</span> 유도는 다음 조건이 잠겨 있고, 해당 조건이 만족된다고 판정될 때만 근거로 사용한다.
<span class="math display">\[\mathrm{PASS}_{\alpha}
:\Longleftrightarrow
(N_{\mathrm{sec}}=3)\wedge(N_{\mathrm{shell}}=7)\wedge(N_{\mathrm{spin}}=1)
\wedge\ \text{(무편향 회전 가정; 5.2.5절) }
\wedge\ \text{(정수 점유 $(3,2,2)$의 채택이 사전등록됨)}.
\label{eq:S14_05_pass_alpha}\]</span>
조건 누락 또는 사후 선택이 발견되면, 본 절의 수치 결론은 <code>FAIL</code>로 둔다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-71">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(N_{\mathrm{sec}}=3\)</span> (7.0절), <span class="math inline">\(N_{\mathrm{shell}}=7\)</span> (8.2절), <span class="math inline">\(N_{\mathrm{spin}}=1\)</span>의 채택을 <code>analysis_lock</code>에 명시.</p></li>
<li><p>LOCK: 무편향 회전 가정(5.2.5절)을 <code>analysis_lock</code>에 연결.</p></li>
<li><p>LOCK: 이산 점유 분할 <span class="math inline">\((3,2,2)\)</span> 및 <a data-reference="eq:S14_05_beta_disc" data-reference-type="eqref" href="#eq:S14_05_beta_disc">[eq:S14_05_beta_disc]</a>의 조합학적 경로를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: <a data-reference="eq:S14_05_pass_alpha" data-reference-type="eqref" href="#eq:S14_05_pass_alpha">[eq:S14_05_pass_alpha]</a> 판정 결과를 <code>gate_report</code>에 기록.</p></li>
</ul>
<h1 data-number="17" id="양자역학-매핑빠진-부분-보강-표준-qm-요소를-대응표로-고정"><span class="header-section-number">17</span> 15. 양자역학 매핑(빠진 부분 보강: 표준 QM 요소를 ‘대응표’로 고정)</h1>
<h2 data-number="17.1" id="격자-분산평면파-해-leftrightarrow-파동함수상태공간-대응"><span class="header-section-number">17.1</span> 15.1 격자 분산/평면파 해 <span class="math inline">\(\leftrightarrow\)</span> 파동함수(상태공간) 대응</h2>
<h3 data-number="17.1.1" id="기본-집합과-척도정의"><span class="header-section-number">17.1.1</span> 15.1.1 기본 집합과 척도(정의)</h3>
<p>격자 차원을 <span class="math inline">\(d\in\mathbb{N}\)</span>로 두고, 격자 노드 집합을
<span class="math display">\[\mathcal{L}:=\mathbb{Z}^d
\label{eq:S15_01_L}\]</span>
로 정의한다. 실현 길이 <span class="math inline">\(a&gt;0\)</span> 및 실현 시간 간격 <span class="math inline">\(\Delta t&gt;0\)</span>를 사용하여(단위는 실현 절에서 잠김), 노드 <span class="math inline">\(\mathbf{n}\in\mathcal{L}\)</span>와 틱 <span class="math inline">\(k\in\mathbb{Z}\)</span>에 대응하는 실공간 좌표와 실시간을
<span class="math display">\[\mathbf{x}(\mathbf{n}) := a\,\mathbf{n},\qquad t(k):=k\,\Delta t
\label{eq:S15_01_xt}\]</span>
로 둔다.</p>
<h3 data-number="17.1.2" id="사건-로그로부터의-복소-상태장정의"><span class="header-section-number">17.1.2</span> 15.1.2 사건 로그로부터의 복소 상태장(정의)</h3>
<p>각 노드 <span class="math inline">\(\mathbf{n}\)</span>, 각 틱 <span class="math inline">\(k\)</span>에서 3-섹터 사건 지시자를
<span class="math display">\[E_s(\mathbf{n},k)\in\{0,1\},\qquad s\in\{1,2,3\}
\label{eq:S15_01_E}\]</span>
로 정의한다. 관측(집계) 창을 길이 <span class="math inline">\(M\in\mathbb{N}\)</span>, 시작 틱 <span class="math inline">\(k_0\in\mathbb{Z}\)</span>로 두고
<span class="math display">\[W(k_0,M):=\{k_0,k_0+1,\dots,k_0+M-1\}
\label{eq:S15_01_window}\]</span>
라 하자. 창 내부의 섹터별 사건 계수(로그 집계)를
<span class="math display">\[N_s(\mathbf{n};k_0,M):=\sum_{k\in W(k_0,M)}E_s(\mathbf{n},k)
\label{eq:S15_01_Ns}\]</span>
로 정의한다.</p>
<p>섹터 각도를
<span class="math display">\[\theta_s:=\frac{2\pi}{3}(s-1),\qquad s=1,2,3
\label{eq:S15_01_theta}\]</span>
로 두고, 노드별 3-섹터 합성 위상자를
<span class="math display">\[Z(\mathbf{n};k_0,M)
:=
\sum_{s=1}^{3} N_s(\mathbf{n};k_0,M)\,e^{i\theta_s}
\in\mathbb{C}
\label{eq:S15_01_Z}\]</span>
로 정의한다. 또한 총 사건 계수와 사건 밀도를
<span class="math display">\[N(\mathbf{n};k_0,M):=\sum_{s=1}^{3}N_s(\mathbf{n};k_0,M),\qquad
\rho(\mathbf{n};k_0,M):=\frac{1}{M}\,N(\mathbf{n};k_0,M)
\label{eq:S15_01_rho}\]</span>
로 둔다.</p>
<p>합성 위상자의 위상(주값)을
<span class="math display">\[\varphi(\mathbf{n};k_0,M):=\arg Z(\mathbf{n};k_0,M)\in(-\pi,\pi]
\label{eq:S15_01_phi}\]</span>
로 정의하고, 노드별 복소 상태장(복소 진폭)을
<span class="math display">\[\psi(\mathbf{n};k_0,M):=\sqrt{\rho(\mathbf{n};k_0,M)}\,e^{i\varphi(\mathbf{n};k_0,M)}
\label{eq:S15_01_psi_def}\]</span>
로 정의한다. 따라서
<span class="math display">\[|\psi(\mathbf{n};k_0,M)|^2=\rho(\mathbf{n};k_0,M)
\label{eq:S15_01_abs2_rho}\]</span>
가 항등으로 성립한다. 위 정의는 외부 이론의 공리를 호출하지 않고, 사건 로그의 집계량으로부터 상태장을 구성하는 운영 정의이다.</p>
<h3 data-number="17.1.3" id="상태공간정의과-내적정의"><span class="header-section-number">17.1.3</span> 15.1.3 상태공간(정의)과 내적(정의)</h3>
<p>복소 함수 공간
<span class="math display">\[\mathcal{S}:=\left\{\psi:\mathcal{L}\to\mathbb{C}\ \bigg|\ \sum_{\mathbf{n}\in\mathcal{L}}|\psi(\mathbf{n})|^2&lt;\infty\right\}
\label{eq:S15_01_Sspace}\]</span>
를 상태공간으로 정의한다. <span class="math inline">\(\mathcal{S}\)</span> 위의 내적을
<span class="math display">\[\langle \phi,\psi\rangle := \sum_{\mathbf{n}\in\mathcal{L}}\phi(\mathbf{n})^{*}\psi(\mathbf{n})
\label{eq:S15_01_inner}\]</span>
로 정의하고, 노름을 <span class="math inline">\(\|\psi\|:=\sqrt{\langle\psi,\psi\rangle}\)</span>로 둔다. 정규화 상태는
<span class="math display">\[\widehat{\psi}:=\frac{\psi}{\|\psi\|}\qquad(\psi\neq 0)
\label{eq:S15_01_normstate}\]</span>
로 정의한다.</p>
<h3 data-number="17.1.4" id="이산-푸리에-전개와-파수-공간정의"><span class="header-section-number">17.1.4</span> 15.1.4 이산 푸리에 전개와 파수 공간(정의)</h3>
<p><span class="math inline">\(d\)</span>차원 브릴루앙 영역을
<span class="math display">\[\mathcal{B}:=[-\pi,\pi)^d
\label{eq:S15_01_BZ}\]</span>
로 정의한다. 충분히 빠르게 감쇠하는(또는 유한 격자에서 주기 경계로 정의된) 상태에 대해 이산 푸리에 변환을
<span class="math display">\[\widetilde{\psi}(\boldsymbol{\kappa})
:=
\sum_{\mathbf{n}\in\mathcal{L}} \psi(\mathbf{n})\,e^{-i\boldsymbol{\kappa}\cdot\mathbf{n}},
\qquad
\boldsymbol{\kappa}\in\mathcal{B}
\label{eq:S15_01_FT}\]</span>
로 정의한다. 이때 <span class="math inline">\(\boldsymbol{\kappa}\)</span>는 무차원 파수(격자 파수)이며, 실공간 파수(길이 차원)는
<span class="math display">\[\mathbf{k}:=\frac{1}{a}\boldsymbol{\kappa}
\label{eq:S15_01_kmap}\]</span>
로 정의한다.</p>
<h3 data-number="17.1.5" id="틱-진화-연산자-분산-평면파정의"><span class="header-section-number">17.1.5</span> 15.1.5 1-틱 진화 연산자, 분산, 평면파(정의)</h3>
<p>틱 진화가 선형이며 평행이동 불변(동일 닫힘 스택에서의 동일 규칙)인 레짐을 가정할 때, 1-틱 진화 연산자를
<span class="math display">\[\psi(\cdot,k+1)=\mathcal{U}\,\psi(\cdot,k)
\label{eq:S15_01_Udef}\]</span>
로 정의한다. 평행이동 불변 조건은 모든 <span class="math inline">\(\mathbf{m}\in\mathcal{L}\)</span>에 대해 이동 연산자 <span class="math inline">\(\mathcal{T}_{\mathbf{m}}\)</span>를
<span class="math display">\[(\mathcal{T}_{\mathbf{m}}\psi)(\mathbf{n}) := \psi(\mathbf{n}+\mathbf{m})
\label{eq:S15_01_Tm}\]</span>
로 둘 때
<span class="math display">\[\mathcal{U}\,\mathcal{T}_{\mathbf{m}}=\mathcal{T}_{\mathbf{m}}\,\mathcal{U}
\qquad(\forall\,\mathbf{m}\in\mathcal{L})
\label{eq:S15_01_commute}\]</span>
를 의미한다.</p>
<p>이 조건 하에서 평면파(격자 조화 모드)를
<span class="math display">\[\phi_{\boldsymbol{\kappa}}(\mathbf{n})
:=
e^{i\boldsymbol{\kappa}\cdot\mathbf{n}},
\qquad \boldsymbol{\kappa}\in\mathcal{B}
\label{eq:S15_01_planewave}\]</span>
로 정의하면, <span class="math inline">\(\phi_{\boldsymbol{\kappa}}\)</span>는 <span class="math inline">\(\mathcal{U}\)</span>의 고유모드가 될 수 있으며, 고유값을 위상 형태로
<span class="math display">\[\mathcal{U}\,\phi_{\boldsymbol{\kappa}}
=
e^{-i\Omega(\boldsymbol{\kappa})}\,\phi_{\boldsymbol{\kappa}},
\qquad \Omega(\boldsymbol{\kappa})\in(-\pi,\pi]
\label{eq:S15_01_dispersion_phase}\]</span>
로 정의한다. 이때 격자 분산(각진동수)은
<span class="math display">\[\omega(\boldsymbol{\kappa}) := \frac{1}{\Delta t}\,\Omega(\boldsymbol{\kappa})
\label{eq:S15_01_omega}\]</span>
로 정의한다.</p>
<p>따라서 단일 모드 평면파 해는
<span class="math display">\[\psi_{\boldsymbol{\kappa}}(\mathbf{n},k)
=
A\,
e^{i\boldsymbol{\kappa}\cdot\mathbf{n}}
e^{-i\Omega(\boldsymbol{\kappa})k}
=
A\,
\exp\!\Big(i\boldsymbol{\kappa}\cdot\mathbf{n}-i\omega(\boldsymbol{\kappa})t(k)\Big)
\label{eq:S15_01_plane_solution}\]</span>
로 쓸 수 있다. 위 식은 <a data-reference="eq:S15_01_Udef" data-reference-type="eqref" href="#eq:S15_01_Udef">[eq:S15_01_Udef]</a>–<a data-reference="eq:S15_01_dispersion_phase" data-reference-type="eqref" href="#eq:S15_01_dispersion_phase">[eq:S15_01_dispersion_phase]</a>의 정의로부터 바로 얻어진다.</p>
<h3 data-number="17.1.6" id="외부-텍스트표준-qm와의-대응표대상-텍스트-고정"><span class="header-section-number">17.1.6</span> 15.1.6 외부 텍스트(표준 QM)와의 대응표(대상 텍스트 고정)</h3>
<p>본 절에서 “표준 QM”은 <em>대상 텍스트</em>이며, 어떠한 유도 근거로도 사용되지 않는다. 다음 표는 표준 QM 표기(대상 텍스트)에 대한 <em>표기 대응</em>만을 고정한다.</p>
<div class="center">
<table style="width:95%;">
<colgroup>
<col style="width: 33%"/>
<col style="width: 30%"/>
<col style="width: 32%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">VP/격자-사건 체계(정의)</th>
<th style="text-align: left;">표준 QM 대상 텍스트(명칭)</th>
<th style="text-align: left;">대응 규칙(고정)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">노드 <span class="math inline">\(\mathbf{n}\in\mathcal{L}\)</span></td>
<td style="text-align: left;">위치 변수 <span class="math inline">\(\mathbf{x}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\mathbf{x}=a\,\mathbf{n}\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">틱 <span class="math inline">\(k\in\mathbb{Z}\)</span></td>
<td style="text-align: left;">시간 변수 <span class="math inline">\(t\)</span></td>
<td style="text-align: left;"><span class="math inline">\(t=k\,\Delta t\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">복소 상태장 <span class="math inline">\(\psi(\mathbf{n};k_0,M)\)</span></td>
<td style="text-align: left;">파동함수 <span class="math inline">\(\psi(\mathbf{x},t)\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\psi(\mathbf{x}(\mathbf{n}),t(k))\leftrightarrow \psi(\mathbf{n},k)\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">무차원 파수 <span class="math inline">\(\boldsymbol{\kappa}\)</span></td>
<td style="text-align: left;">파수 <span class="math inline">\(\mathbf{k}\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\mathbf{k}=\boldsymbol{\kappa}/a\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: left;">고유 위상 <span class="math inline">\(\Omega(\boldsymbol{\kappa})\)</span></td>
<td style="text-align: left;">각진동수 <span class="math inline">\(\omega\)</span></td>
<td style="text-align: left;"><span class="math inline">\(\omega=\Omega/\Delta t\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;">모드 <span class="math inline">\(\exp(i\boldsymbol{\kappa}\cdot\mathbf{n}-i\Omega k)\)</span></td>
<td style="text-align: left;">평면파 <span class="math inline">\(\exp(i\mathbf{k}\cdot\mathbf{x}-i\omega t)\)</span></td>
<td style="text-align: left;"><a data-reference="eq:S15_01_xt" data-reference-type="eqref" href="#eq:S15_01_xt">[eq:S15_01_xt]</a>, <a data-reference="eq:S15_01_kmap" data-reference-type="eqref" href="#eq:S15_01_kmap">[eq:S15_01_kmap]</a>, <a data-reference="eq:S15_01_omega" data-reference-type="eqref" href="#eq:S15_01_omega">[eq:S15_01_omega]</a></td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="17.1.7" id="사용비사용-범위-선언고정"><span class="header-section-number">17.1.7</span> 15.1.7 사용/비사용 범위 선언(고정)</h3>
<h4 data-number="17.1.7.1" id="사용본-문서-내부-연산에-사용"><span class="header-section-number">17.1.7.1</span> 사용(본 문서 내부 연산에 사용)</h4>
<ul>
<li><p><a data-reference="eq:S15_01_psi_def" data-reference-type="eqref" href="#eq:S15_01_psi_def">[eq:S15_01_psi_def]</a>로 정의된 복소 상태장 <span class="math inline">\(\psi\)</span> 및 <a data-reference="eq:S15_01_abs2_rho" data-reference-type="eqref" href="#eq:S15_01_abs2_rho">[eq:S15_01_abs2_rho]</a>의 항등.</p></li>
<li><p><a data-reference="eq:S15_01_FT" data-reference-type="eqref" href="#eq:S15_01_FT">[eq:S15_01_FT]</a>의 푸리에 전개와 <a data-reference="eq:S15_01_dispersion_phase" data-reference-type="eqref" href="#eq:S15_01_dispersion_phase">[eq:S15_01_dispersion_phase]</a>의 고유 위상(분산) 정의.</p></li>
<li><p><a data-reference="eq:S15_01_plane_solution" data-reference-type="eqref" href="#eq:S15_01_plane_solution">[eq:S15_01_plane_solution]</a>의 평면파 모드 표현(평행이동 불변 레짐에서의 모드 기저).</p></li>
</ul>
<h4 data-number="17.1.7.2" id="비사용유도-근거로-사용-금지-대상-텍스트로만-인정"><span class="header-section-number">17.1.7.2</span> 비사용(유도 근거로 사용 금지; 대상 텍스트로만 인정)</h4>
<ul>
<li><p>표준 QM의 공리(파동함수 공리, 연산자 공리, 투영 공리 등)를 <em>근거/정당화</em>로 사용하는 행위.</p></li>
<li><p>표준 QM의 특정 연속 방정식(대상 텍스트)을 본 문서 내부의 닫힘/공리 대신 채택하는 행위.</p></li>
</ul>
<h2 data-number="17.2" id="born-규칙측정붕괴를-사건-빈도게이트로-재기술관측-프로토콜과-연결"><span class="header-section-number">17.2</span> 15.2 Born 규칙·측정·붕괴를 사건 빈도/게이트로 재기술(관측 프로토콜과 연결)</h2>
<h3 data-number="17.2.1" id="관측-모듈의-분할정의"><span class="header-section-number">17.2.1</span> 15.2.1 관측 모듈의 분할(정의)</h3>
<p>관측 모듈이 참조하는 격자 영역을 유한 집합 <span class="math inline">\(\Lambda\subset\mathcal{L}\)</span>로 두고, 결과 레이블 집합을
<span class="math display">\[\mathcal{M}:=\{1,2,\dots,M_{\mathrm{out}}\}
\label{eq:S15_02_Mset}\]</span>
로 둔다. 영역 <span class="math inline">\(\Lambda\)</span>를 상호 배타적 부분영역으로 분할하는 분할 사상을
<span class="math display">\[\Pi:\Lambda\to\mathcal{M},
\qquad
\Omega_m:=\Pi^{-1}(m),
\qquad
\Omega_m\cap\Omega_{m'}=\varnothing\ (m\neq m'),\quad \bigcup_{m\in\mathcal{M}}\Omega_m=\Lambda
\label{eq:S15_02_partition}\]</span>
로 정의한다. <span class="math inline">\(\{\Omega_m\}\)</span>는 관측 결과의 채널(결과 구획)이다.</p>
<h3 data-number="17.2.2" id="사건-계수-결과-빈도정의"><span class="header-section-number">17.2.2</span> 15.2.2 사건 계수, 결과 빈도(정의)</h3>
<p>관측 창 <span class="math inline">\(W(k_0,M)\)</span>에 대해, 결과 채널 <span class="math inline">\(m\)</span>의 사건 계수를
<span class="math display">\[C_m(k_0,M)
:=
\sum_{\mathbf{n}\in\Omega_m}\sum_{k\in W(k_0,M)}\sum_{s=1}^{3}E_s(\mathbf{n},k)
=
\sum_{\mathbf{n}\in\Omega_m} N(\mathbf{n};k_0,M)
\label{eq:S15_02_Cm}\]</span>
로 정의한다. 총 사건 계수는 <span class="math inline">\(C_{\mathrm{tot}}:=\sum_{m\in\mathcal{M}}C_m\)</span>이며, 결과 빈도(정규화된 사건 빈도)를
<span class="math display">\[P_m(k_0,M)
:=
\frac{C_m(k_0,M)}{C_{\mathrm{tot}}(k_0,M)}
\qquad (C_{\mathrm{tot}}&gt;0)
\label{eq:S15_02_Pm}\]</span>
로 정의한다. <span class="math inline">\(P_m\)</span>는 <em>사건 로그로부터 직접 산출되는</em> 결과 빈도이다.</p>
<h3 data-number="17.2.3" id="복소-상태장과의-등가-표현정의"><span class="header-section-number">17.2.3</span> 15.2.3 복소 상태장과의 등가 표현(정의)</h3>
<p>15.1의 정의 <a data-reference="eq:S15_01_psi_def" data-reference-type="eqref" href="#eq:S15_01_psi_def">[eq:S15_01_psi_def]</a> 및 항등 <a data-reference="eq:S15_01_abs2_rho" data-reference-type="eqref" href="#eq:S15_01_abs2_rho">[eq:S15_01_abs2_rho]</a>로부터, 각 채널에 대해
<span class="math display">\[C_m(k_0,M)
=
M\sum_{\mathbf{n}\in\Omega_m}\rho(\mathbf{n};k_0,M)
=
M\sum_{\mathbf{n}\in\Omega_m}|\psi(\mathbf{n};k_0,M)|^2
\label{eq:S15_02_Cm_psi}\]</span>
가 성립한다. 따라서 <a data-reference="eq:S15_02_Pm" data-reference-type="eqref" href="#eq:S15_02_Pm">[eq:S15_02_Pm]</a>은
<span class="math display">\[P_m(k_0,M)
=
\frac{\sum_{\mathbf{n}\in\Omega_m}|\psi(\mathbf{n};k_0,M)|^2}{\sum_{\mathbf{n}\in\Lambda}|\psi(\mathbf{n};k_0,M)|^2}
\qquad \left(\sum_{\mathbf{n}\in\Lambda}|\psi(\mathbf{n};k_0,M)|^2&gt;0\right)
\label{eq:S15_02_Pm_bornform}\]</span>
로 정확히 재표현된다. 여기서 <a data-reference="eq:S15_02_Pm_bornform" data-reference-type="eqref" href="#eq:S15_02_Pm_bornform">[eq:S15_02_Pm_bornform]</a>은 <em>표준 QM의 근거로부터 도출된 식이 아니라</em>, 사건 로그 정의와 <a data-reference="eq:S15_01_psi_def" data-reference-type="eqref" href="#eq:S15_01_psi_def">[eq:S15_01_psi_def]</a>에 의해 <em>동치로 성립하는 정체식</em>이다.</p>
<h3 data-number="17.2.4" id="gate-결정측정-사건의-발생-조건-정의"><span class="header-section-number">17.2.4</span> 15.2.4 Gate-결정(측정 사건의 발생 조건; 정의)</h3>
<p>측정은 “어떤 <span class="math inline">\(m\)</span>이 선택되었다”는 로그 항목을 생성하는 사건이다. 이를 위해 결과 선택 규칙(게이트)을 다음과 같이 정의한다.
<span class="math display">\[m^\star
:=
\operatorname*{arg\,max}_{m\in\mathcal{M}} \ \mathcal{G}_m\big(C_m(k_0,M);\Theta_m\big)
\label{eq:S15_02_mstar}\]</span>
여기서 <span class="math inline">\(\mathcal{G}_m(\cdot;\Theta_m)\)</span>는 채널 <span class="math inline">\(m\)</span>의 게이트 함수, <span class="math inline">\(\Theta_m\)</span>은 사전등록된 임계/판정 파라미터 집합이다. 측정 로그 생성 조건을
<span class="math display">\[\mathrm{PASS}_{\mathrm{meas}}
:\Longleftrightarrow
\left[
\exists\,m^\star\in\mathcal{M}\ \text{s.t.}\
\mathcal{G}_{m^\star}\big(C_{m^\star}(k_0,M);\Theta_{m^\star}\big)=1
\right]
\label{eq:S15_02_PASS_meas}\]</span>
로 정의한다. <span class="math inline">\(\mathrm{PASS}_{\mathrm{meas}}\)</span>가 성립하지 않으면 <em>측정 로그(결과 선택)를 생성하지 않는다.</em></p>
<h3 data-number="17.2.5" id="붕괴조건부-재표준화의-운영-정의정의"><span class="header-section-number">17.2.5</span> 15.2.5 붕괴(조건부 재표준화)의 운영 정의(정의)</h3>
<p>측정 결과 <span class="math inline">\(m^\star\)</span>가 로그로 확정되면(즉 <a data-reference="eq:S15_02_PASS_meas" data-reference-type="eqref" href="#eq:S15_02_PASS_meas">[eq:S15_02_PASS_meas]</a>가 성립), 같은 창의 상태장 <span class="math inline">\(\psi(\cdot;k_0,M)\)</span>를 기준으로 다음의 마스크 연산자(채널 필터)를 정의한다.
<span class="math display">\[(\mathcal{P}_{m}\psi)(\mathbf{n})
:=
\begin{cases}
\psi(\mathbf{n}), &amp; \mathbf{n}\in\Omega_m,\\
0, &amp; \mathbf{n}\in\Lambda\setminus\Omega_m,
\end{cases}
\qquad \mathbf{n}\in\Lambda
\label{eq:S15_02_Pmop}\]</span>
그리고 <em>측정 후 상태</em>를 조건부 재표준화로 정의한다.
<span class="math display">\[\widehat{\psi}_{\mathrm{post}}
:=
\frac{\mathcal{P}_{m^\star}\widehat{\psi}_{\mathrm{pre}}}{\left\|\mathcal{P}_{m^\star}\widehat{\psi}_{\mathrm{pre}}\right\|}
\qquad
\left(\left\|\mathcal{P}_{m^\star}\widehat{\psi}_{\mathrm{pre}}\right\|&gt;0\right)
\label{eq:S15_02_collapse}\]</span>
여기서 <span class="math inline">\(\widehat{\psi}_{\mathrm{pre}}\)</span>는 측정 직전(같은 프로토콜로 계산된) 정규화 상태이다. <a data-reference="eq:S15_02_collapse" data-reference-type="eqref" href="#eq:S15_02_collapse">[eq:S15_02_collapse]</a>는 <em>사건 로그가 확정된 뒤</em> 상태를 재표현하는 규약이며, 게이트 통과 없이 적용할 수 없다.</p>
<h3 data-number="17.2.6" id="표준-qm-대상-텍스트와의-대응표대상-텍스트-고정"><span class="header-section-number">17.2.6</span> 15.2.6 표준 QM 대상 텍스트와의 대응표(대상 텍스트 고정)</h3>
<p>본 절에서 표준 QM의 용어(보른 규칙, 측정, 붕괴)는 <em>대상 텍스트</em>이다. 다음 표는 <a data-reference="eq:S15_02_Pm_bornform" data-reference-type="eqref" href="#eq:S15_02_Pm_bornform">[eq:S15_02_Pm_bornform]</a> 및 <a data-reference="eq:S15_02_collapse" data-reference-type="eqref" href="#eq:S15_02_collapse">[eq:S15_02_collapse]</a>를 기준으로 한 표기 대응만을 고정한다.</p>
<div class="center">
<table style="width:95%;">
<colgroup>
<col style="width: 34%"/>
<col style="width: 30%"/>
<col style="width: 31%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">VP/사건-게이트 체계(정의)</th>
<th style="text-align: left;">표준 QM 대상 텍스트(명칭)</th>
<th style="text-align: left;">대응 규칙(고정)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">결과 빈도 <span class="math inline">\(P_m\)</span></td>
<td style="text-align: left;">확률 <span class="math inline">\(p_m\)</span></td>
<td style="text-align: left;"><span class="math inline">\(p_m\leftrightarrow P_m\)</span></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\sum_{\Omega_m}|\psi|^2/\sum_{\Lambda}|\psi|^2\)</span></td>
<td style="text-align: left;"><span class="math inline">\(|\psi|^2\)</span> 규칙</td>
<td style="text-align: left;"><a data-reference="eq:S15_02_Pm_bornform" data-reference-type="eqref" href="#eq:S15_02_Pm_bornform">[eq:S15_02_Pm_bornform]</a></td>
</tr>
<tr class="odd">
<td style="text-align: left;">게이트 통과 <span class="math inline">\(\mathrm{PASS}_{\mathrm{meas}}\)</span></td>
<td style="text-align: left;">측정 발생 조건</td>
<td style="text-align: left;"><a data-reference="eq:S15_02_PASS_meas" data-reference-type="eqref" href="#eq:S15_02_PASS_meas">[eq:S15_02_PASS_meas]</a></td>
</tr>
<tr class="even">
<td style="text-align: left;">조건부 재표준화 <a data-reference="eq:S15_02_collapse" data-reference-type="eqref" href="#eq:S15_02_collapse">[eq:S15_02_collapse]</a></td>
<td style="text-align: left;">투영(붕괴) 표기</td>
<td style="text-align: left;">표기 대응만 인정</td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="17.2.7" id="사용비사용-범위-선언고정-1"><span class="header-section-number">17.2.7</span> 15.2.7 사용/비사용 범위 선언(고정)</h3>
<h4 data-number="17.2.7.1" id="사용본-문서-내부-연산에-사용-1"><span class="header-section-number">17.2.7.1</span> 사용(본 문서 내부 연산에 사용)</h4>
<ul>
<li><p>사건 계수 <span class="math inline">\(C_m\)</span> 및 결과 빈도 <span class="math inline">\(P_m\)</span>의 로그 기반 산출(<a data-reference="eq:S15_02_Cm" data-reference-type="eqref" href="#eq:S15_02_Cm">[eq:S15_02_Cm]</a>–<a data-reference="eq:S15_02_Pm" data-reference-type="eqref" href="#eq:S15_02_Pm">[eq:S15_02_Pm]</a>).</p></li>
<li><p><span class="math inline">\(\psi\)</span>-표현의 동치식 <a data-reference="eq:S15_02_Pm_bornform" data-reference-type="eqref" href="#eq:S15_02_Pm_bornform">[eq:S15_02_Pm_bornform]</a>.</p></li>
<li><p>게이트 통과 후 조건부 재표준화 <a data-reference="eq:S15_02_collapse" data-reference-type="eqref" href="#eq:S15_02_collapse">[eq:S15_02_collapse]</a>.</p></li>
</ul>
<h4 data-number="17.2.7.2" id="비사용유도-근거로-사용-금지-대상-텍스트로만-인정-1"><span class="header-section-number">17.2.7.2</span> 비사용(유도 근거로 사용 금지; 대상 텍스트로만 인정)</h4>
<ul>
<li><p>표준 QM의 “측정 공리”를 본 문서의 게이트 정의 대신 채택하는 행위.</p></li>
<li><p>표준 QM의 “확률 해석”을 사건 빈도 정의의 근거로 역주입하는 행위.</p></li>
</ul>
<h2 data-number="17.3" id="연산자교환관계불확정성-스핀통계3-섹터-연결-정리가설검증항목-분리"><span class="header-section-number">17.3</span> 15.3 연산자·교환관계·불확정성, 스핀/통계(3-섹터) 연결: “정리/가설/검증항목” 분리</h2>
<h3 data-number="17.3.1" id="관측량연산자의-운영-정의정리"><span class="header-section-number">17.3.1</span> 15.3.1 관측량(연산자)의 운영 정의(정리)</h3>
<p>상태공간 <span class="math inline">\(\mathcal{S}\)</span> 위의 선형 연산자 <span class="math inline">\(\mathcal{O}:\mathcal{S}\to\mathcal{S}\)</span>를 관측량 연산자로 정의한다. 정규화 상태 <span class="math inline">\(\widehat{\psi}\)</span>에 대한 기대값과 분산을
<span class="math display">\[\langle \mathcal{O}\rangle_{\widehat{\psi}}
:=
\langle \widehat{\psi},\mathcal{O}\widehat{\psi}\rangle,
\qquad
(\Delta \mathcal{O})^2_{\widehat{\psi}}
:=
\left\langle \widehat{\psi},(\mathcal{O}-\langle \mathcal{O}\rangle_{\widehat{\psi}})^2\widehat{\psi}\right\rangle
\label{eq:S15_03_mean_var}\]</span>
로 정의한다. <a data-reference="eq:S15_03_mean_var" data-reference-type="eqref" href="#eq:S15_03_mean_var">[eq:S15_03_mean_var]</a>는 내적 <a data-reference="eq:S15_01_inner" data-reference-type="eqref" href="#eq:S15_01_inner">[eq:S15_01_inner]</a>로부터 결정되는 순수한 연산자-대수 정의이다.</p>
<h3 data-number="17.3.2" id="기본-연산자-위치-이동-차분정리"><span class="header-section-number">17.3.2</span> 15.3.2 기본 연산자: 위치, 이동, 차분(정리)</h3>
<p>좌표 성분 <span class="math inline">\(j\in\{1,\dots,d\}\)</span>에 대해 위치(곱셈) 연산자 <span class="math inline">\(\mathcal{X}_j\)</span>를
<span class="math display">\[(\mathcal{X}_j\psi)(\mathbf{n})
:=
x_j(\mathbf{n})\,\psi(\mathbf{n})
=
a\,n_j\,\psi(\mathbf{n})
\label{eq:S15_03_X}\]</span>
로 정의한다. 단위 격자 벡터 <span class="math inline">\(\mathbf{e}_j\)</span>에 대한 이동(쉬프트) 연산자 <span class="math inline">\(\mathcal{T}_j\)</span>를
<span class="math display">\[(\mathcal{T}_j\psi)(\mathbf{n})
:=
\psi(\mathbf{n}+\mathbf{e}_j),
\qquad
(\mathcal{T}_j^{-1}\psi)(\mathbf{n})
:=
\psi(\mathbf{n}-\mathbf{e}_j)
\label{eq:S15_03_T}\]</span>
로 정의한다.</p>
<p>이때 교환관계(정확식)는 다음과 같이 계산된다.
<span class="math display">\[\begin{aligned}
(\mathcal{X}_j\mathcal{T}_j\psi)(\mathbf{n})
&amp;=
a\,n_j\,\psi(\mathbf{n}+\mathbf{e}_j),
\notag\\
(\mathcal{T}_j\mathcal{X}_j\psi)(\mathbf{n})
&amp;=
a\,(n_j+1)\,\psi(\mathbf{n}+\mathbf{e}_j),
\notag\\
\Rightarrow\quad
\big([\mathcal{X}_j,\mathcal{T}_j]\psi\big)(\mathbf{n})
&amp;=
(\mathcal{X}_j\mathcal{T}_j-\mathcal{T}_j\mathcal{X}_j)\psi(\mathbf{n})
=
-a\,\psi(\mathbf{n}+\mathbf{e}_j)
=
-a\,(\mathcal{T}_j\psi)(\mathbf{n}).
\label{eq:S15_03_comm_XT}\end{aligned}\]</span>
따라서
<span class="math display">\[=-a\,\mathcal{T}_j,
\qquad
[\mathcal{X}_j,\mathcal{T}_j^{-1}]=+a\,\mathcal{T}_j^{-1}
\label{eq:S15_03_comm_XT2}\]</span>
가 정확히 성립한다.</p>
<h3 data-number="17.3.3" id="운동량-유사-연산자와-교환관계정리-가설"><span class="header-section-number">17.3.3</span> 15.3.3 운동량-유사 연산자와 교환관계(정리 + 가설)</h3>
<h4 data-number="17.3.3.1" id="정리-대칭-차분-생성자"><span class="header-section-number">17.3.3.1</span> (정리) 대칭 차분 생성자</h4>
<p>대칭 차분 연산자 <span class="math inline">\(\mathcal{D}_j\)</span>를
<span class="math display">\[\mathcal{D}_j
:=
\frac{1}{2a}\big(\mathcal{T}_j-\mathcal{T}_j^{-1}\big)
\label{eq:S15_03_D}\]</span>
로 정의한다.</p>
<h4 data-number="17.3.3.2" id="가설-표준-qm-대상-텍스트의-운동량-표기와의-대응"><span class="header-section-number">17.3.3.2</span> (가설) 표준 QM 대상 텍스트의 “운동량” 표기와의 대응</h4>
<p>상수
<span class="math display">\[\hbar_{\mathrm{map}}:=\frac{h}{2\pi}
\label{eq:S15_03_hbar_map}\]</span>
를 <em>대응용 상수</em>로 정의하고(실현 입력 <span class="math inline">\(h\)</span>로부터의 도출), 운동량-유사 연산자 <span class="math inline">\(\mathcal{P}_j\)</span>를
<span class="math display">\[\mathcal{P}_j
:=
\frac{\hbar_{\mathrm{map}}}{i}\,\mathcal{D}_j
=
\frac{\hbar_{\mathrm{map}}}{2ia}\big(\mathcal{T}_j-\mathcal{T}_j^{-1}\big)
\label{eq:S15_03_P}\]</span>
로 정의한다. 이때 <span class="math inline">\(\mathcal{P}_j\)</span>는 <a data-reference="eq:S15_03_comm_XT2" data-reference-type="eqref" href="#eq:S15_03_comm_XT2">[eq:S15_03_comm_XT2]</a>로부터 다음의 정확 교환관계를 갖는다.
<span class="math display">\[\begin{aligned}
&amp;=
\frac{\hbar_{\mathrm{map}}}{2ia}\Big([\mathcal{X}_j,\mathcal{T}_j]-[\mathcal{X}_j,\mathcal{T}_j^{-1}]\Big)
\notag\\
&amp;=
\frac{\hbar_{\mathrm{map}}}{2ia}\Big(-a\mathcal{T}_j-a\mathcal{T}_j^{-1}\Big)
=
\frac{i\hbar_{\mathrm{map}}}{2}\big(\mathcal{T}_j+\mathcal{T}_j^{-1}\big).
\label{eq:S15_03_comm_XP_exact}\end{aligned}\]</span></p>
<p>또한 평면파 모드 <a data-reference="eq:S15_01_planewave" data-reference-type="eqref" href="#eq:S15_01_planewave">[eq:S15_01_planewave]</a>에 대해
<span class="math display">\[\mathcal{P}_j\,\phi_{\boldsymbol{\kappa}}
=
\left(\frac{\hbar_{\mathrm{map}}}{a}\sin\kappa_j\right)\phi_{\boldsymbol{\kappa}}
\label{eq:S15_03_P_eig}\]</span>
가 성립한다. 따라서 <span class="math inline">\(\kappa_j\)</span>가 작은 레짐(느린 변화 레짐)에서 <span class="math inline">\(\sin\kappa_j\simeq \kappa_j\)</span>이므로
<span class="math display">\[\mathcal{P}_j\,\phi_{\boldsymbol{\kappa}}
\simeq
\left(\hbar_{\mathrm{map}}\,\frac{\kappa_j}{a}\right)\phi_{\boldsymbol{\kappa}}
=
\left(\hbar_{\mathrm{map}}\,k_j\right)\phi_{\boldsymbol{\kappa}}
\qquad(\kappa_j\to 0)
\label{eq:S15_03_P_smallk}\]</span>
가 된다. 이 근사 관계를 표준 QM 대상 텍스트의 표기 <span class="math inline">\(p=\hbar k\)</span>와 <em>대응</em>시키되, 이는 <em>대상 텍스트와의 번역 규칙</em>으로만 인정한다(유도 근거로 사용 금지).</p>
<h3 data-number="17.3.4" id="불확정성-부등식정리-수학적-정리로서의-전개"><span class="header-section-number">17.3.4</span> 15.3.4 불확정성 부등식(정리; 수학적 정리로서의 전개)</h3>
<p>내적공간에서의 코시-슈바르츠 부등식
<span class="math display">\[|\langle u,v\rangle|^2\le \langle u,u\rangle\,\langle v,v\rangle
\label{eq:S15_03_CS}\]</span>
을 사용하여 연산자 불확정성 부등식을 도출한다. 정규화 상태 <span class="math inline">\(\widehat{\psi}\)</span>와 두 연산자 <span class="math inline">\(\mathcal{A},\mathcal{B}\)</span>에 대해
<span class="math display">\[\delta\mathcal{A}:=\mathcal{A}-\langle\mathcal{A}\rangle_{\widehat{\psi}},\qquad
\delta\mathcal{B}:=\mathcal{B}-\langle\mathcal{B}\rangle_{\widehat{\psi}}
\label{eq:S15_03_dA_dB}\]</span>
를 정의한다. 다음 두 벡터를 둔다.
<span class="math display">\[u:=\delta\mathcal{A}\,\widehat{\psi},\qquad
v:=\delta\mathcal{B}\,\widehat{\psi}.
\label{eq:S15_03_u_v}\]</span>
그러면
<span class="math display">\[\langle u,u\rangle = \langle \widehat{\psi},(\delta\mathcal{A})^2\widehat{\psi}\rangle = (\Delta\mathcal{A})^2_{\widehat{\psi}},
\qquad
\langle v,v\rangle = (\Delta\mathcal{B})^2_{\widehat{\psi}}
\label{eq:S15_03_var_uv}\]</span>
이다. 코시-슈바르츠 <a data-reference="eq:S15_03_CS" data-reference-type="eqref" href="#eq:S15_03_CS">[eq:S15_03_CS]</a>로부터
<span class="math display">\[(\Delta\mathcal{A})^2_{\widehat{\psi}}\,(\Delta\mathcal{B})^2_{\widehat{\psi}}
\ge
|\langle u,v\rangle|^2
=
\left|\left\langle \widehat{\psi},\delta\mathcal{A}\,\delta\mathcal{B}\,\widehat{\psi}\right\rangle\right|^2
\label{eq:S15_03_RS0}\]</span>
를 얻는다. 이제 복소수 <span class="math inline">\(z:=\langle \widehat{\psi},\delta\mathcal{A}\delta\mathcal{B}\widehat{\psi}\rangle\)</span>에 대해
<span class="math display">\[z
=
\frac{1}{2}\langle \widehat{\psi},\{\delta\mathcal{A},\delta\mathcal{B}\}\widehat{\psi}\rangle
+
\frac{1}{2}\langle \widehat{\psi},[\delta\mathcal{A},\delta\mathcal{B}]\widehat{\psi}\rangle
\label{eq:S15_03_split}\]</span>
로 분해한다. 여기서 <span class="math inline">\(\{X,Y\}:=XY+YX\)</span>는 반교환자, <span class="math inline">\([X,Y]:=XY-YX\)</span>는 교환자이다. 따라서
<span class="math display">\[|z|^2
=
\left(\Re z\right)^2+\left(\Im z\right)^2
\ge
\left(\Im z\right)^2.
\label{eq:S15_03_ReIm}\]</span>
또한
<span class="math display">\[\Im z
=
\frac{1}{2i}\left(z-z^{*}\right)
=
\frac{1}{2i}\left\langle \widehat{\psi},\left(\delta\mathcal{A}\delta\mathcal{B}-\delta\mathcal{B}\delta\mathcal{A}\right)\widehat{\psi}\right\rangle
=
\frac{1}{2i}\langle \widehat{\psi},[\mathcal{A},\mathcal{B}]\widehat{\psi}\rangle
\label{eq:S15_03_Imz}\]</span>
이므로 <a data-reference="eq:S15_03_RS0" data-reference-type="eqref" href="#eq:S15_03_RS0">[eq:S15_03_RS0]</a>–<a data-reference="eq:S15_03_Imz" data-reference-type="eqref" href="#eq:S15_03_Imz">[eq:S15_03_Imz]</a>로부터
<span class="math display">\[\Delta\mathcal{A}\,\Delta\mathcal{B}
\ge
\frac{1}{2}\left|\left\langle \widehat{\psi},\frac{1}{i}[\mathcal{A},\mathcal{B}]\,\widehat{\psi}\right\rangle\right|
=
\frac{1}{2}\left|\langle [\mathcal{A},\mathcal{B}]\rangle_{\widehat{\psi}}\right|
\label{eq:S15_03_uncertainty}\]</span>
를 얻는다. <a data-reference="eq:S15_03_uncertainty" data-reference-type="eqref" href="#eq:S15_03_uncertainty">[eq:S15_03_uncertainty]</a>는 내적공간과 연산자 정의로부터 도출되는 수학적 정리이다.</p>
<h3 data-number="17.3.5" id="섹터-기반-스핀-유사-라벨가설과-통계가설"><span class="header-section-number">17.3.5</span> 15.3.5 3-섹터 기반 스핀-유사 라벨(가설)과 통계(가설)</h3>
<h4 data-number="17.3.5.1" id="정리-3-섹터-확률벡터"><span class="header-section-number">17.3.5.1</span> (정리) 3-섹터 확률벡터</h4>
<p>노드 <span class="math inline">\(\mathbf{n}\)</span>과 창 <span class="math inline">\(W(k_0,M)\)</span>에 대해, 섹터 비율을
<span class="math display">\[p_s(\mathbf{n};k_0,M):=\frac{N_s(\mathbf{n};k_0,M)}{N(\mathbf{n};k_0,M)}
\qquad(N(\mathbf{n};k_0,M)&gt;0),
\qquad
\sum_{s=1}^{3}p_s=1
\label{eq:S15_03_ps}\]</span>
로 정의한다. 섹터 위상자(정규화)를
<span class="math display">\[u(\mathbf{n};k_0,M):=\sum_{s=1}^{3}p_s(\mathbf{n};k_0,M)\,e^{i\theta_s}
\label{eq:S15_03_u}\]</span>
로 정의하고, 위상
<span class="math display">\[\Phi(\mathbf{n};k_0,M):=\arg u(\mathbf{n};k_0,M)\in(-\pi,\pi]
\label{eq:S15_03_Phi}\]</span>
를 정의한다. <span class="math inline">\(\Phi\)</span>는 3-섹터의 점유 비율로부터 계산되는 각도 변수이다.</p>
<h4 data-number="17.3.5.2" id="가설-h-s1-스핀-유사-2값-라벨의-정의"><span class="header-section-number">17.3.5.2</span> (가설 H-S1) 스핀-유사 2값 라벨의 정의</h4>
<p>연속 두 창 <span class="math inline">\((k_0,M)\)</span>와 <span class="math inline">\((k_0+M,M)\)</span>를 두고, 위상 증가량을
<span class="math display">\[\Delta\Phi(\mathbf{n};k_0,M)
:=
\mathrm{Wrap}_{(-\pi,\pi]}\!\Big(\Phi(\mathbf{n};k_0+M,M)-\Phi(\mathbf{n};k_0,M)\Big)
\label{eq:S15_03_dPhi}\]</span>
로 정의한다. 여기서 <span class="math inline">\(\mathrm{Wrap}_{(-\pi,\pi]}\)</span>는 값을 <span class="math inline">\((-\pi,\pi]\)</span>로 환원하는 연산이다. 스핀-유사 라벨을
<span class="math display">\[\sigma(\mathbf{n};k_0,M)
:=
\mathrm{sgn}\big(\Delta\Phi(\mathbf{n};k_0,M)\big)
\in\{-1,0,+1\}
\label{eq:S15_03_sigma}\]</span>
로 정의하고, <span class="math inline">\(\sigma=0\)</span>은 비결정(게이트 실패)로 처리한다. 표준 QM 대상 텍스트의 “스핀 투영 2값” 표기에는 <span class="math inline">\(\sigma=\pm1\)</span>만을 대응시키며, <span class="math inline">\(\sigma=0\)</span>은 대상 텍스트에 대응하지 않는 상태로 분류한다.</p>
<h4 data-number="17.3.5.3" id="가설-h-stat1-배타-점유제외-규칙과-통계의-대응"><span class="header-section-number">17.3.5.3</span> (가설 H-STAT1) 배타 점유(제외) 규칙과 통계의 대응</h4>
<p>동일 노드(또는 동일 접촉 그래프의 동일 슬롯)에 대해 동일 라벨을 갖는 두 객체가 동시에 안정적으로 존재할 수 없는 레짐을 배타 점유 레짐으로 정의한다. 이를 연산 규칙으로
<span class="math display">\[\mathcal{N}(\mathbf{n})\in\{0,1\}\quad(\text{배타 점유 레짐}),
\qquad
\mathcal{N}(\mathbf{n})\in\{0,1,2,\dots\}\quad(\text{비배타 레짐})
\label{eq:S15_03_occupancy}\]</span>
처럼 선언한다. 표준 QM 대상 텍스트의 “페르미/보스 통계” 용어는 위 레짐 분류에 <em>표기 대응</em>만을 부여한다.</p>
<h3 data-number="17.3.6" id="검증항목게이트로만-판정-목록-고정"><span class="header-section-number">17.3.6</span> 15.3.6 검증항목(게이트로만 판정; 목록 고정)</h3>
<h4 data-number="17.3.6.1" id="v-op-연산자-실험적-일치-항목"><span class="header-section-number">17.3.6.1</span> (V-OP) 연산자 실험적 일치 항목</h4>
<ul>
<li><p>(V-OP1) 동일 프로토콜에서 <span class="math inline">\(\mathcal{P}_j\)</span>의 모드 고유값이 <a data-reference="eq:S15_03_P_eig" data-reference-type="eqref" href="#eq:S15_03_P_eig">[eq:S15_03_P_eig]</a>를 만족하는지(푸리에 모드 적합 Gate).</p></li>
<li><p>(V-OP2) 느린 변화 레짐에서 <a data-reference="eq:S15_03_comm_XP_exact" data-reference-type="eqref" href="#eq:S15_03_comm_XP_exact">[eq:S15_03_comm_XP_exact]</a>의 기대값이 <span class="math inline">\(\langle \frac{i\hbar_{\mathrm{map}}}{2}(\mathcal{T}_j+\mathcal{T}_j^{-1})\rangle\simeq i\hbar_{\mathrm{map}}\)</span>로 수렴하는지(레짐 Gate).</p></li>
</ul>
<h4 data-number="17.3.6.2" id="v-s-스핀-유사-라벨-항목"><span class="header-section-number">17.3.6.2</span> (V-S) 스핀-유사 라벨 항목</h4>
<ul>
<li><p>(V-S1) 동일 분할 모듈에서 <span class="math inline">\(\sigma=\pm1\)</span> 두 채널의 사건 빈도가 <a data-reference="eq:S15_02_Pm" data-reference-type="eqref" href="#eq:S15_02_Pm">[eq:S15_02_Pm]</a>로부터 계산되는 예측 빈도와 일치하는지(2채널 Gate).</p></li>
<li><p>(V-S2) <span class="math inline">\(\sigma=0\)</span> 발생률이 사전등록된 상한 이하인지(비결정 상한 Gate).</p></li>
</ul>
<h4 data-number="17.3.6.3" id="v-stat-통계-레짐-항목"><span class="header-section-number">17.3.6.3</span> (V-STAT) 통계 레짐 항목</h4>
<ul>
<li><p>(V-STAT1) 배타 점유 레짐에서 동시 점유 위반 로그가 0인지(배타 위반 Gate).</p></li>
<li><p>(V-STAT2) 비배타 레짐에서 다중 점유 분포가 사전등록된 샘플링 규약을 만족하는지(샘플링 Gate).</p></li>
</ul>
<h2 data-number="17.4" id="표준모형-경계-공유관측-숫자-vs-비사용게이지-동역학와-유효-범위-선언"><span class="header-section-number">17.4</span> 15.4 표준모형 경계: 공유(관측 숫자) vs 비사용(게이지 동역학)와 유효 범위 선언</h2>
<h3 data-number="17.4.1" id="경계-선언의-형식정의"><span class="header-section-number">17.4.1</span> 15.4.1 경계 선언의 형식(정의)</h3>
<p>본 절에서 “표준모형” 및 “표준 QM”은 <em>대상 텍스트</em>이다. 이 장의 역할은 대상 텍스트의 용어/기호를 본 문서의 운영 정의(LOCK, Gate, 사건 로그)로 번역하는 <em>대응표</em>를 제공하는 것이며, 어떠한 정당화/근거 제공도 수행하지 않는다. 이에 따라 다음 두 범주를 고정한다.
<span class="math display">\[\mathcal{C}_{\mathrm{share}}:\ \text{공유(관측 숫자/보고 단위)},
\qquad
\mathcal{C}_{\mathrm{ban}}:\ \text{비사용(대상 텍스트의 동역학/공리/구조)}
\label{eq:S15_04_share_ban}\]</span></p>
<h3 data-number="17.4.2" id="공유-항목-mathcalc_mathrmshare관측-숫자-및-보고-단위-목록-고정"><span class="header-section-number">17.4.2</span> 15.4.2 공유 항목 <span class="math inline">\(\mathcal{C}_{\mathrm{share}}\)</span>(관측 숫자 및 보고 단위; 목록 고정)</h3>
<p>다음 항목들은 “관측 숫자” 또는 “보고 단위”로서만 공유한다. 공유는 곧 <em>단위 변환 및 대응표 작성</em>을 의미하며, 해당 이론의 구조를 채택하는 것을 의미하지 않는다.</p>
<ul>
<li><p>(SH1) 질량, 길이, 시간, 에너지 등 보고 단위의 선택(SI 또는 문서 내부 실현 단위).</p></li>
<li><p>(SH2) 관측으로 주어지는 수치들(예: 질량비, 길이비, 주파수비 등) 자체의 숫자.</p></li>
<li><p>(SH3) “전하”, “스핀”, “확률” 등의 용어가 지칭하는 <em>관측 보고 항목</em>의 레이블.</p></li>
</ul>
<h3 data-number="17.4.3" id="비사용-항목-mathcalc_mathrmban게이지-동역학-및-공리-구조-목록-고정"><span class="header-section-number">17.4.3</span> 15.4.3 비사용 항목 <span class="math inline">\(\mathcal{C}_{\mathrm{ban}}\)</span>(게이지 동역학 및 공리 구조; 목록 고정)</h3>
<p>다음 항목들은 대상 텍스트에 존재하더라도 본 문서의 유도 사슬에 포함시키지 않는다.</p>
<ul>
<li><p>(BN1) 게이지 장/게이지 대칭/라그랑지안/작용 적분 등 대상 텍스트의 동역학 생성 규칙.</p></li>
<li><p>(BN2) 재규격화, 섭동 전개, 장의 진공 구조 등 대상 텍스트 내부의 구성 원리.</p></li>
<li><p>(BN3) 표준 QM의 공리(상태공리, 측정공리, 연산자공리)를 <em>근거</em>로 채택하는 행위.</p></li>
<li><p>(BN4) 대상 텍스트의 연속체 방정식(예: 특정 파동 방정식)을 본 문서의 닫힘 대신 채택하는 행위.</p></li>
</ul>
<h3 data-number="17.4.4" id="표준-qm표준모형-대상-텍스트와의-대응표비사용-범위-포함-고정"><span class="header-section-number">17.4.4</span> 15.4.4 표준 QM/표준모형 대상 텍스트와의 대응표(비사용 범위 포함; 고정)</h3>
<div class="center">
<table style="width:94%;">
<colgroup>
<col style="width: 36%"/>
<col style="width: 24%"/>
<col style="width: 34%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">본 문서(운영 정의/출력)</th>
<th style="text-align: left;">대상 텍스트(용어)</th>
<th style="text-align: left;">취급(공유/비사용)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">사건 로그 <span class="math inline">\(E_s\)</span>, 계수 <span class="math inline">\(N_s\)</span>, 빈도 <span class="math inline">\(P_m\)</span></td>
<td style="text-align: left;">확률 <span class="math inline">\(p\)</span></td>
<td style="text-align: left;">공유: 보고 항목, 근거로 비사용</td>
</tr>
<tr class="even">
<td style="text-align: left;">복소 상태장 <span class="math inline">\(\psi\)</span> (사건 밀도+위상 구성)</td>
<td style="text-align: left;">파동함수 <span class="math inline">\(\psi\)</span></td>
<td style="text-align: left;">공유: 표기 대응, 공리로 비사용</td>
</tr>
<tr class="odd">
<td style="text-align: left;">게이트 <span class="math inline">\(\mathrm{PASS}\)</span> 및 조건부 재표준화</td>
<td style="text-align: left;">측정/붕괴</td>
<td style="text-align: left;">공유: 표기 대응, 공리로 비사용</td>
</tr>
<tr class="even">
<td style="text-align: left;">연산자 <span class="math inline">\(\mathcal{X},\mathcal{T},\mathcal{P}\)</span> 및 교환관계</td>
<td style="text-align: left;">연산자/교환관계</td>
<td style="text-align: left;">공유: 대응표, 대상 텍스트의 공리로 비사용</td>
</tr>
<tr class="odd">
<td style="text-align: left;">3-섹터 위상 증분 라벨 <span class="math inline">\(\sigma\)</span></td>
<td style="text-align: left;">스핀(투영)</td>
<td style="text-align: left;">공유: 레이블 대응, 동역학 구조로 비사용</td>
</tr>
<tr class="even">
<td style="text-align: left;">배타/비배타 점유 레짐</td>
<td style="text-align: left;">통계(페르미/보스)</td>
<td style="text-align: left;">공유: 레이블 대응, 대상 텍스트의 원리로 비사용</td>
</tr>
</tbody>
</table>
</div>
<h3 data-number="17.4.5" id="유효-범위레짐-선언-고정"><span class="header-section-number">17.4.5</span> 15.4.5 유효 범위(레짐 선언; 고정)</h3>
<p>본 장에서의 매핑은 다음 레짐에서만 정의된다.</p>
<ul>
<li><p>(R1) 사건 로그가 존재하며(<span class="math inline">\(C_{\mathrm{tot}}&gt;0\)</span>), 상태장 <span class="math inline">\(\psi\)</span>가 <a data-reference="eq:S15_01_psi_def" data-reference-type="eqref" href="#eq:S15_01_psi_def">[eq:S15_01_psi_def]</a>로 구성될 수 있는 레짐.</p></li>
<li><p>(R2) 관측 모듈의 분할 <span class="math inline">\(\Pi\)</span>와 게이트 함수 <span class="math inline">\(\mathcal{G}_m\)</span> 및 임계 <span class="math inline">\(\Theta_m\)</span>가 사전등록되어 있는 레짐.</p></li>
<li><p>(R3) 연산자 매핑(특히 <span class="math inline">\(\mathcal{P}_j\)</span>의 대상 텍스트 대응)을 주장하는 경우, 느린 변화 레짐(작은 <span class="math inline">\(|\boldsymbol{\kappa}|\)</span>)이 별도 게이트로 판정된 경우.</p></li>
</ul>
<p>위 레짐 조건이 성립하지 않으면, 대상 텍스트 용어에 대한 대응표를 사용하여 결론을 산출할 수 없다.</p>
<h2 data-number="17.5" id="sec:S15_05_blackbody"><span class="header-section-number">17.5</span> 15.5 흑체 복사(플랑크 법칙)의 구조적 유도: 강성 껍질 필터링</h2>
<p>본 절은 에너지 양자화(<span class="math inline">\(E=n h\nu\)</span>)를 <em>공리로 도입하지 않고</em>, VP 격자의 <strong>강성 껍질(rigidity shell)</strong>이 갖는
구조적 임계(장벽)와 <strong>정수 이벤트 카운트</strong>로부터 플랑크 스펙트럼을 유도한다.<a class="footnote-ref" href="#fn4" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<h3 data-number="17.5.1" id="모드-수의-기하학정리-gnupropto-nu2"><span class="header-section-number">17.5.1</span> 15.5.1 모드 수의 기하학(정리): <span class="math inline">\(g(\nu)\propto \nu^{2}\)</span></h3>
<p>3차원 공동(cavity)에서 파동 모드의 수는 <span class="math inline">\(k\)</span>-공간에서 구면 껍질의 부피로 주어지며,
주파수 <span class="math inline">\(\nu\)</span>에 대해 단위 부피당 모드 밀도는 기하학적으로
<span class="math display">\[g(\nu)\,d\nu \propto \nu^{2}\,d\nu
\label{eq:S15_05_gnu}\]</span>
이다(연속체 기하).
전자기장의 표준 계수까지 포함하면 <span class="math inline">\(g(\nu)=8\pi\nu^{2}/c_{\mathrm{ref}}^{3}\)</span>이지만,
본 절에서 핵심은 <span class="math inline">\(\nu^{2}\)</span> 스케일링이 <strong>순수 기하학</strong>에서 온다는 점이다.</p>
<h3 data-number="17.5.2" id="강성-껍질-장벽과-작용-상수-h_mathrmvp정의"><span class="header-section-number">17.5.2</span> 15.5.2 강성 껍질 장벽과 작용 상수 <span class="math inline">\(h_{\mathrm{VP}}\)</span>(정의)</h3>
<p>VP 이론에서 “부드러움”은 입자 자체의 성질이 아니라 <strong>구조 사건(event)</strong>의 결과이다(3.2.1절).
고주파 모드가 존재하려면 격자의 강성 껍질을 주기적으로 변형시켜야 하며,
선형 탄성 응답에서 변형률 속도(strain rate) <span class="math inline">\(\dot{\varepsilon}\)</span>는 주파수에 비례한다.
따라서 껍질을 관통(혹은 임계 변형을 한 번 넘김)하기 위한 최소 장벽 에너지 <span class="math inline">\(\epsilon_b\)</span>는
<span class="math display">\[\epsilon_b(\nu) \propto \dot{\varepsilon} \propto \nu.\]</span>
이 비례계수를 <strong>작용(energy <span class="math inline">\(\times\)</span> time) 단위</strong>로 고정하여
<span class="math display">\[\boxed{\epsilon_b(\nu) := h_{\mathrm{VP}}\,\nu}
\label{eq:S15_05_barrier}\]</span>
로 <em>정의</em>한다.
여기서 <span class="math inline">\(h_{\mathrm{VP}}\)</span>는 “미지의 임의 상수”가 아니라,
VP 껍질이 한 주기 변형을 허용하기 위해 요구하는 <strong>최소 작용(구조적 저항 계수)</strong>이다.</p>
<h3 data-number="17.5.3" id="정수-이벤트-카운트-n과-leftex-1right-1의-발생유도"><span class="header-section-number">17.5.3</span> 15.5.3 정수 이벤트 카운트 <span class="math inline">\(n\)</span>과 <span class="math inline">\(\left(e^{x}-1\right)^{-1}\)</span>의 발생(유도)</h3>
<p>핵심은 “여기(excitation)”가 연속이 아니라 <strong>임계 장벽을 넘는 사건의 개수</strong>로 집계된다는 점이다.
주파수 <span class="math inline">\(\nu\)</span>의 모드에서 한 번의 장벽 통과는 에너지 <span class="math inline">\(\epsilon_b(\nu)=h_{\mathrm{VP}}\nu\)</span>를 요구하므로,
<span class="math inline">\(n\)</span>번의 통과 사건이 누적된 에너지는
<span class="math display">\[E_n(\nu) = n\,h_{\mathrm{VP}}\,\nu,\qquad n\in\{0,1,2,\dots\}.
\label{eq:S15_05_En}\]</span>
이는 “<span class="math inline">\(E=n h\nu\)</span>를 공리로 둔다”가 아니라,
<strong><span class="math inline">\(n\)</span>이 사건 수이므로 정수일 수밖에 없다는 사실(이산성)</strong>에서 나온다.</p>
<p>열평형(<span class="math inline">\(T\)</span>)에서 볼츠만 가중치로
<span class="math display">\[P(n\mid \nu) \propto \exp\!\left(-\frac{E_n(\nu)}{k_B T}\right)
=\exp\!\left(-\frac{n h_{\mathrm{VP}}\nu}{k_B T}\right)
\label{eq:S15_05_Pn}\]</span>
이며, 분배함수는 등비급수로 닫힌다.
<span class="math display">\[Z(\nu)=\sum_{n=0}^{\infty} e^{-n\beta h_{\mathrm{VP}}\nu}=\frac{1}{1-e^{-\beta h_{\mathrm{VP}}\nu}},\qquad \beta:=\frac{1}{k_B T}.
\label{eq:S15_05_Z}\]</span>
따라서 모드당 평균 에너지는
<span class="math display">\[\langle E\rangle(\nu)
= -\frac{\partial}{\partial \beta}\ln Z
=\frac{h_{\mathrm{VP}}\nu}{e^{h_{\mathrm{VP}}\nu/(k_B T)}-1}.
\label{eq:S15_05_Emean}\]</span>
이 항이 플랑크 스펙트럼의 특징인 “<span class="math inline">\(-1\)</span>”을 만든다.</p>
<h3 data-number="17.5.4" id="플랑크-스펙트럼결론-기하학-times-강성-필터"><span class="header-section-number">17.5.4</span> 15.5.4 플랑크 스펙트럼(결론): 기하학 <span class="math inline">\(\times\)</span> 강성 필터</h3>
<p>단위 부피 에너지 밀도는 <span class="math inline">\(u(\nu)=g(\nu)\langle E\rangle(\nu)\)</span>이므로
<span class="math display">\[u(\nu)
\propto
\underbrace{\nu^{2}}_{\text{기하학적 모드수}}
\times
\underbrace{\frac{h_{\mathrm{VP}}\nu}{e^{h_{\mathrm{VP}}\nu/(k_B T)}-1}}_{\text{강성 껍질 필터(이산 사건)}}
\;\;\Rightarrow\;\;
u(\nu)\propto \frac{\nu^{3}}{e^{h_{\mathrm{VP}}\nu/(k_B T)}-1}.
\label{eq:S15_05_planck_shape}\]</span>
즉 고주파에서의 컷오프는 “빛의 신비”가 아니라,
<strong>강성 껍질이 고주파 변형을 구조적으로 차단(filtering)하기 때문</strong>이다.</p>
<h3 data-number="17.5.5" id="gate-흑체-레짐에서의-사용-조건정의"><span class="header-section-number">17.5.5</span> 15.5.5 Gate: 흑체 레짐에서의 사용 조건(정의)</h3>
<p>본 절의 유도는 다음 조건이 만족될 때만 “플랑크 스펙트럼 유도”로 사용한다.
<span class="math display">\[\mathrm{PASS}_{\mathrm{BB}}
:\Longleftrightarrow
\text{(열평형)}\wedge\text{(공동이 광학적으로 두꺼움)}\wedge\text{(선형 응답)}\wedge\text{(사건 카운트 $n$의 정수성이 성립)}.
\label{eq:S15_05_pass_BB}\]</span>
조건을 만족하지 않으면 본 절은 <code>INCONCLUSIVE</code>로 둔다.</p>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-72">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: <span class="math inline">\(h_{\mathrm{VP}}\)</span>를 “장벽 에너지/주파수”로 정의하는 <a data-reference="eq:S15_05_barrier" data-reference-type="eqref" href="#eq:S15_05_barrier">[eq:S15_05_barrier]</a>를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 사건 카운트 <span class="math inline">\(n\)</span>과 에너지 사다리 <a data-reference="eq:S15_05_En" data-reference-type="eqref" href="#eq:S15_05_En">[eq:S15_05_En]</a>을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 흑체 레짐 조건 <a data-reference="eq:S15_05_pass_BB" data-reference-type="eqref" href="#eq:S15_05_pass_BB">[eq:S15_05_pass_BB]</a>를 <code>gate_lock</code>에 고정.</p></li>
</ul>
<h1 data-number="18" id="검증재현성배포doi"><span class="header-section-number">18</span> 16. 검증·재현성·배포(DOI)</h1>
<h2 data-number="18.1" id="프로토콜-레지스트리사전등록반증-트리거fail도-공개-규칙"><span class="header-section-number">18.1</span> 16.1 프로토콜 레지스트리/사전등록/반증 트리거(FAIL도 공개) 규칙</h2>
<h3 data-number="18.1.1" id="목적과-범위정의"><span class="header-section-number">18.1.1</span> 16.1.1 목적과 범위(정의)</h3>
<p>본 장은 본문 전 구간의 산출물이 <em>검증 가능</em>하고 <em>재현 가능</em>하며 <em>배포 가능한 형태</em>로 고정되도록 하는 운영 규칙을 정의한다.
여기서</p>
<ul>
<li><p><strong>검증(Verification)</strong>은 “정의된 Gate/PASS.rules에 의해 산출물의 자격이 판정되는 것”을 의미한다.</p></li>
<li><p><strong>재현성(Reproducibility)</strong>은 “동일 입력(LOCK), 동일 프로토콜, 동일 참조 구현으로 동일 산출물이 재생성되는 것”을 의미한다.</p></li>
<li><p><strong>배포(Distribution)</strong>는 “산출물 묶음이 DOI 단위의 불변 아카이브로 기록되며, 체크섬으로 무결성이 보증되는 것”을 의미한다.</p></li>
</ul>
<p>본 장은 유도(이론) 내용을 추가하지 않으며, <em>산출물의 자격(판정)과 기록(로그)과 보존(아카이브)</em>만을 다룬다.</p>
<h3 data-number="18.1.2" id="핵심-객체정의-프로토콜-레지스트리-등록-식별자"><span class="header-section-number">18.1.2</span> 16.1.2 핵심 객체(정의): 프로토콜, 레지스트리, 등록 식별자</h3>
<h4 data-number="18.1.2.1" id="정의-프로토콜protocol"><span class="header-section-number">18.1.2.1</span> (정의) 프로토콜(Protocol)</h4>
<p>프로토콜 <span class="math inline">\(\mathsf{P}\)</span>는 다음의 7-튜플로 정의한다.
<span class="math display">\[\mathsf{P}:=\big(\mathsf{S},\mathsf{I},\mathsf{R},\mathsf{E},\mathsf{G},\mathsf{O},\mathsf{A}\big)
\label{eq:S16_01_protocol_tuple}\]</span>
각 성분은 다음과 같이 고정한다.</p>
<ul>
<li><p><span class="math inline">\(\mathsf{S}\)</span>: 적용 범위(레짐) 선언(대상 모델/대상 데이터/허용 조건).</p></li>
<li><p><span class="math inline">\(\mathsf{I}\)</span>: 입력(LOCK) 참조(정준/실현/분석 잠금의 식별자 및 다이제스트).</p></li>
<li><p><span class="math inline">\(\mathsf{R}\)</span>: 절차(단계열) 정의(전처리, 실행, 집계, 판정 순서).</p></li>
<li><p><span class="math inline">\(\mathsf{E}\)</span>: 추정기(Estimator) 정의(계산식, 표본화 규칙, 시드 규칙 포함).</p></li>
<li><p><span class="math inline">\(\mathsf{G}\)</span>: Gate/PASS.rules 정의(문턱값, 판정 부호, 실패 코드).</p></li>
<li><p><span class="math inline">\(\mathsf{O}\)</span>: 산출물(Artifacts) 정의(파일 목록, 포맷, 필수 메타데이터).</p></li>
<li><p><span class="math inline">\(\mathsf{A}\)</span>: 반증 트리거(Falsification triggers) 및 FAIL 공개 규정.</p></li>
</ul>
<h4 data-number="18.1.2.2" id="정의-프로토콜-레지스트리protocol-registry"><span class="header-section-number">18.1.2.2</span> (정의) 프로토콜 레지스트리(Protocol Registry)</h4>
<p>프로토콜 레지스트리 <span class="math inline">\(\mathcal{R}_{\mathrm{prot}}\)</span>는 프로토콜들의 집합과 그 메타데이터를 담는 불변 목록으로 정의한다.
각 프로토콜 항목은
<span class="math display">\[\mathcal{R}_{\mathrm{prot}}[i]=\big(\mathrm{PID},\mathrm{VER},\mathrm{DIG},\mathrm{TS},\mathrm{STATUS}\big)
\label{eq:S16_01_registry_item}\]</span>
로 구성한다.</p>
<ul>
<li><p><span class="math inline">\(\mathrm{PID}\)</span>: 프로토콜 식별자(문자열; 전역 유일).</p></li>
<li><p><span class="math inline">\(\mathrm{VER}\)</span>: 프로토콜 버전(정수 또는 <span class="math inline">\(\mathrm{v}X.Y.Z\)</span>).</p></li>
<li><p><span class="math inline">\(\mathrm{DIG}\)</span>: 프로토콜 파일의 체크섬 다이제스트(예: SHA-256).</p></li>
<li><p><span class="math inline">\(\mathrm{TS}\)</span>: 등록 시각(UTC 또는 고정 타임스탬프).</p></li>
<li><p><span class="math inline">\(\mathrm{STATUS}\in\{\mathrm{ACTIVE},\mathrm{DEPRECATED},\mathrm{REVOKED}\}\)</span>: 상태.</p></li>
</ul>
<p>레지스트리는 <em>추가(append-only)</em>만 허용하며 기존 항목의 수정/삭제는 금지한다. 기존 항목의 교정이 필요하면 신규 버전 항목을 추가한다.</p>
<h3 data-number="18.1.3" id="사전등록pre-registration-규칙정의"><span class="header-section-number">18.1.3</span> 16.1.3 사전등록(Pre-registration) 규칙(정의)</h3>
<h4 data-number="18.1.3.1" id="정의-사전등록-파일"><span class="header-section-number">18.1.3.1</span> (정의) 사전등록 파일</h4>
<p>사전등록은 프로토콜 <span class="math inline">\(\mathsf{P}\)</span>의 모든 성분을 고정된 스키마 파일로 기록하는 행위이며, 사전등록 파일을
<span class="math display">\[\texttt{protocol.yaml} \quad \text{또는}\quad \texttt{protocol.json}
\label{eq:S16_01_prereg_file}\]</span>
로 정의한다. 사전등록 파일은 다음 필드를 반드시 포함한다.</p>
<ul>
<li><p><code>pid</code>, <code>version</code>, <code>scope</code>(<span class="math inline">\(=\mathsf{S}\)</span>)</p></li>
<li><p><code>locks</code>(<span class="math inline">\(=\mathsf{I}\)</span>; 각 LOCK 파일 경로 및 다이제스트)</p></li>
<li><p><code>procedure</code>(<span class="math inline">\(=\mathsf{R}\)</span>; 단계 이름, 입력/출력, 순서)</p></li>
<li><p><code>estimators</code>(<span class="math inline">\(=\mathsf{E}\)</span>; 수식/알고리즘/시드 규칙)</p></li>
<li><p><code>gates</code>(<span class="math inline">\(=\mathsf{G}\)</span>; PASS.rules, 문턱값, 실패 코드)</p></li>
<li><p><code>artifacts</code>(<span class="math inline">\(=\mathsf{O}\)</span>; 필수 파일 목록, 포맷, 경로 규칙)</p></li>
<li><p><code>falsification</code>(<span class="math inline">\(=\mathsf{A}\)</span>; 트리거 목록, FAIL 공개 규정)</p></li>
</ul>
<h4 data-number="18.1.3.2" id="정의-사전등록-다이제스트와-고정점"><span class="header-section-number">18.1.3.2</span> (정의) 사전등록 다이제스트와 고정점</h4>
<p>사전등록 파일의 체크섬 다이제스트를
<span class="math display">\[\mathrm{DIG}_{\mathrm{prot}}:=\mathrm{SHA256}(\texttt{protocol.*})
\label{eq:S16_01_dig_prot}\]</span>
로 정의한다. 프로토콜은 <span class="math inline">\(\mathrm{DIG}_{\mathrm{prot}}\)</span>로 고정되며, 동일 <span class="math inline">\(\mathrm{PID}\)</span>에서 <span class="math inline">\(\mathrm{DIG}_{\mathrm{prot}}\)</span>가 바뀌면 반드시 <span class="math inline">\(\mathrm{VER}\)</span>이 증가해야 한다.
사전등록 다이제스트는 <em>모든 실행(run)의 전제</em>이며, 실행 로그와 DOI 아카이브에 반드시 포함된다.</p>
<h3 data-number="18.1.4" id="pass.rules정의와-판정의-계층"><span class="header-section-number">18.1.4</span> 16.1.4 PASS.rules(정의)와 판정의 계층</h3>
<h4 data-number="18.1.4.1" id="정의-gate와-pass.rules"><span class="header-section-number">18.1.4.1</span> (정의) Gate와 PASS.rules</h4>
<p>Gate는 산출물의 자격을 판정하는 불리언 함수로 정의한다.
각 Gate <span class="math inline">\(g\)</span>는 입력 요약치 <span class="math inline">\(\mathbf{m}\)</span>과 임계 집합 <span class="math inline">\(\Theta\)</span>를 받아
<span class="math display">\[g(\mathbf{m};\Theta)\in\{0,1\}
\label{eq:S16_01_gate_bool}\]</span>
을 출력한다. Gate들의 집합을 <span class="math inline">\(\mathcal{G}=\{g_1,\dots,g_K\}\)</span>로 두고, PASS.rules는 Gate 집합의 논리 결합으로 정의한다.
예를 들어
<span class="math display">\[\mathrm{PASS}:=\bigwedge_{k=1}^{K} g_k(\mathbf{m}_k;\Theta_k)
\label{eq:S16_01_pass_rules}\]</span>
로 고정할 수 있다. PASS.rules는 사전등록 파일에 명시되어야 하며 실행 후 변경은 금지된다.</p>
<h4 data-number="18.1.4.2" id="정의-판정-등급"><span class="header-section-number">18.1.4.2</span> (정의) 판정 등급</h4>
<p>각 실행(run)은 다음 등급 중 정확히 하나로 판정된다.
<span class="math display">\[\mathrm{STATUS}\in\{\mathrm{PASS},\mathrm{FAIL},\mathrm{INCONCLUSIVE}\}
\label{eq:S16_01_status}\]</span></p>
<ul>
<li><p><strong>PASS</strong>: 모든 Gate가 통과되고, 로그/체크섬/산출물이 완비된 상태.</p></li>
<li><p><strong>FAIL</strong>: 하나 이상의 반증 트리거가 발화되거나, Gate가 명시적으로 실패한 상태.</p></li>
<li><p><strong>INCONCLUSIVE</strong>: 실행은 완료되었으나, 로그/산출물/무결성 요건 미충족으로 판정 불가인 상태.</p></li>
</ul>
<h3 data-number="18.1.5" id="반증-트리거정의와-fail-공개규칙"><span class="header-section-number">18.1.5</span> 16.1.5 반증 트리거(정의)와 FAIL 공개(규칙)</h3>
<h4 data-number="18.1.5.1" id="정의-반증-트리거-집합"><span class="header-section-number">18.1.5.1</span> (정의) 반증 트리거 집합</h4>
<p>반증 트리거 집합을 <span class="math inline">\(\mathcal{T}=\{T_1,\dots,T_L\}\)</span>로 정의한다.
각 트리거 <span class="math inline">\(T_\ell\)</span>은 실행 결과의 요약치 및 무결성 메타데이터를 입력으로 받아
<span class="math display">\[T_\ell(\mathbf{m},\mathbf{u})\in\{0,1\}
\label{eq:S16_01_trigger_bool}\]</span>
을 출력한다. 여기서 <span class="math inline">\(\mathbf{m}\)</span>은 수치 요약치(메트릭), <span class="math inline">\(\mathbf{u}\)</span>는 무결성 요약치(체크섬, 스키마 적합 여부, 로그 완비성 등)이다.</p>
<h4 data-number="18.1.5.2" id="정의-최소-반증-트리거필수"><span class="header-section-number">18.1.5.2</span> (정의) 최소 반증 트리거(필수)</h4>
<p>사전등록에는 다음 최소 트리거들이 반드시 포함되어야 한다.</p>
<ul>
<li><p>(T-LOCK) <strong>LOCK 불일치</strong>: 실행이 참조한 LOCK 다이제스트가 사전등록의 LOCK 다이제스트와 다를 때 발화.
<span class="math display">\[T_{\mathrm{LOCK}}=1 \Longleftrightarrow
  \exists\,\ell\ \text{s.t.}\ \mathrm{DIG}^{\mathrm{run}}_{\ell}\neq \mathrm{DIG}^{\mathrm{prot}}_{\ell}
  \label{eq:S16_01_TLOCK}\]</span></p></li>
<li><p>(T-MAN) <strong>무결성 실패</strong>: 산출물 목록의 체크섬이 manifest와 다를 때 발화.
<span class="math display">\[T_{\mathrm{MAN}}=1 \Longleftrightarrow
  \exists\,f\ \text{s.t.}\ \mathrm{SHA256}^{\mathrm{run}}(f)\neq \mathrm{SHA256}^{\mathrm{manifest}}(f)
  \label{eq:S16_01_TMAN}\]</span></p></li>
<li><p>(T-SCH) <strong>스키마 실패</strong>: 로그/레지스트리/스냅샷 파일이 정의된 스키마를 위반할 때 발화.
<span class="math display">\[T_{\mathrm{SCH}}=1 \Longleftrightarrow
  \texttt{schema\_validate}=0
  \label{eq:S16_01_TSCH}\]</span></p></li>
<li><p>(T-GATE) <strong>Gate 실패</strong>: 사전등록된 Gate 중 하나라도 실패할 때 발화.
<span class="math display">\[T_{\mathrm{GATE}}=1 \Longleftrightarrow
  \exists\,k\ \text{s.t.}\ g_k(\mathbf{m}_k;\Theta_k)=0
  \label{eq:S16_01_TGATE}\]</span></p></li>
<li><p>(T-NT) <strong>No-Tuning 위반</strong>: 실행 후 정의/임계/추정기/데이터 선택을 결과에 맞추어 변경한 흔적(레지스트리 상의 불변성 위반)이 검출될 때 발화.
<span class="math display">\[T_{\mathrm{NT}}=1 \Longleftrightarrow
  \texttt{registry\_immutability}=0
  \label{eq:S16_01_TNT}\]</span></p></li>
</ul>
<h4 data-number="18.1.5.3" id="규칙-fail-공개-단위"><span class="header-section-number">18.1.5.3</span> (규칙) FAIL 공개 단위</h4>
<p>FAIL은 은폐/삭제/부분공개가 금지되며, FAIL 공개는 다음 최소 단위를 만족해야 한다.
<span class="math display">\[\mathsf{FAILPACK}:=\{\texttt{protocol.*},\ \texttt{locks/*},\ \texttt{run\_log.jsonl},\ \texttt{manifest.*},\ \texttt{registry\_snapshot.json},\ \texttt{outputs/*}\}
\label{eq:S16_01_failpack}\]</span>
FAILPACK은 <em>PASS 산출물과 동일한 무결성 규칙</em>을 적용받는다(체크섬 포함). FAILPACK은 DOI 아카이브에 포함되어야 하며, FAIL의 존재 자체가 레지스트리에서 확인 가능해야 한다.</p>
<h3 data-number="18.1.6" id="반증-트리-구조정의-원인-분류와-코드-체계"><span class="header-section-number">18.1.6</span> 16.1.6 반증 트리 구조(정의): 원인 분류와 코드 체계</h3>
<h4 data-number="18.1.6.1" id="정의-원인-클래스"><span class="header-section-number">18.1.6.1</span> (정의) 원인 클래스</h4>
<p>반증 원인 클래스를 다음으로 고정한다.
<span class="math display">\[\mathcal{C}_{\mathrm{fail}}=\{\mathrm{LOCK},\mathrm{INTEGRITY},\mathrm{SCHEMA},\mathrm{GATE},\mathrm{PROCEDURE}\}
\label{eq:S16_01_fail_classes}\]</span>
각 실행의 FAIL은 정확히 하나 이상의 원인 클래스를 가진다.</p>
<h4 data-number="18.1.6.2" id="정의-실패-코드"><span class="header-section-number">18.1.6.2</span> (정의) 실패 코드</h4>
<p>실패 코드는 <code>F-&lt;CLASS&gt;-&lt;NNN&gt;</code> 형태로 고정한다.
예:</p>
<ul>
<li><p><code>F-LOCK-001</code>: LOCK 다이제스트 불일치.</p></li>
<li><p><code>F-INTEGRITY-002</code>: 산출물 체크섬 불일치.</p></li>
<li><p><code>F-SCHEMA-003</code>: 로그 스키마 위반.</p></li>
<li><p><code>F-GATE-010</code>: 특정 Gate 실패(게이트 식별자 포함).</p></li>
<li><p><code>F-PROCEDURE-020</code>: 사전등록 절차 위반(단계 누락/순서 변경).</p></li>
</ul>
<p>실패 코드는 로그와 레지스트리에 동시에 기록되어야 하며, DOI 아카이브에 포함되어야 한다.</p>
<h2 data-number="18.2" id="로그스키마manifest체크섬registry_snapshot-규격ssot"><span class="header-section-number">18.2</span> 16.2 로그·스키마·manifest·체크섬·registry_snapshot 규격(SSOT)</h2>
<h3 data-number="18.2.1" id="ssot단일-진실원천-원칙정의"><span class="header-section-number">18.2.1</span> 16.2.1 SSOT(단일 진실원천) 원칙(정의)</h3>
<p>SSOT 원칙은 “동일 의미의 입력/상수/규칙이 중복 파일에 분산되어 존재하지 않는다”는 규약이다.
SSOT는 다음 세 층으로 분해하여 고정한다.</p>
<ul>
<li><p><strong>입력 SSOT</strong>: 모든 상수/정의/임계는 LOCK 파일에서만 선언된다.</p></li>
<li><p><strong>절차 SSOT</strong>: 모든 실행 단계와 Gate는 <code>protocol.*</code>에서만 선언된다.</p></li>
<li><p><strong>산출물 SSOT</strong>: 모든 산출물의 존재/경로/포맷/체크섬은 <code>manifest.*</code>에서만 선언된다.</p></li>
</ul>
<p>SSOT 위반은 (T-NT) 또는 (T-SCH) 트리거로 실패 처리한다.</p>
<h3 data-number="18.2.2" id="실행-단위run의-식별과-디렉토리-규약정의"><span class="header-section-number">18.2.2</span> 16.2.2 실행 단위(run)의 식별과 디렉토리 규약(정의)</h3>
<h4 data-number="18.2.2.1" id="정의-run_id"><span class="header-section-number">18.2.2.1</span> (정의) run_id</h4>
<p>각 실행은 전역 유일 식별자 <code>run_id</code>를 가진다. <code>run_id</code>는 다음 규칙으로 생성된 문자열로 정의한다.
<span class="math display">\[\texttt{run\_id}:=\texttt{YYYYMMDDThhmmssZ}\ \Vert\ \texttt{pid}\ \Vert\ \texttt{short\_digest}
\label{eq:S16_02_runid}\]</span>
여기서 <span class="math inline">\(\Vert\)</span>는 문자열 결합이다. <code>short_digest</code>는 <a data-reference="eq:S16_01_dig_prot" data-reference-type="eqref" href="#eq:S16_01_dig_prot">[eq:S16_01_dig_prot]</a>의 앞 12자 등 고정 길이 접두로 정의한다.</p>
<h4 data-number="18.2.2.2" id="정의-실행-디렉토리"><span class="header-section-number">18.2.2.2</span> (정의) 실행 디렉토리</h4>
<p>실행 디렉토리 트리는 다음과 같이 고정한다.</p>
<pre><code>runs/
  &lt;run_id&gt;/
    protocol.locked.json
    locks_snapshot/
      canon_lock.json
      realization_lock.json
      analysis_lock.json
    registry_snapshot.json
    run_log.jsonl
    metrics.json
    outputs/
      ...
    manifest.json
    manifest.sha256</code></pre>
<p><code>protocol.locked.json</code>은 <code>protocol.*</code>의 내용을 JSON으로 정규화하여 고정한 복제본이며, 그 다이제스트는 <a data-reference="eq:S16_01_dig_prot" data-reference-type="eqref" href="#eq:S16_01_dig_prot">[eq:S16_01_dig_prot]</a>와 일치해야 한다.</p>
<h3 data-number="18.2.3" id="로그-규격run_log.jsonl과-스키마정의"><span class="header-section-number">18.2.3</span> 16.2.3 로그 규격(run_log.jsonl)과 스키마(정의)</h3>
<h4 data-number="18.2.3.1" id="정의-json-lines-로그"><span class="header-section-number">18.2.3.1</span> (정의) JSON Lines 로그</h4>
<p>실행 로그는 JSON Lines 형식으로 고정한다. 즉, 파일 <code>run_log.jsonl</code>은 각 줄이 독립 JSON 객체인 시퀀스이다.
각 로그 항목 <span class="math inline">\(L_i\)</span>는 다음 스키마를 만족해야 한다.
<span class="math display">\[L_i=
\{\texttt{ts},\texttt{run\_id},\texttt{pid},\texttt{ver},\texttt{phase},\texttt{event},\texttt{payload}\}
\label{eq:S16_02_log_schema}\]</span>
필드의 의미와 타입은 다음과 같이 고정한다.</p>
<ul>
<li><p><code>ts</code>: 문자열(UTC 타임스탬프; 예: <code>2025-12-12T12:34:56Z</code>)</p></li>
<li><p><code>run_id</code>: 문자열(<a data-reference="eq:S16_02_runid" data-reference-type="eqref" href="#eq:S16_02_runid">[eq:S16_02_runid]</a>)</p></li>
<li><p><code>pid</code>: 문자열(<code>protocol.*</code>의 <code>pid</code>)</p></li>
<li><p><code>ver</code>: 문자열 또는 숫자(<code>version</code>)</p></li>
<li><p><code>phase</code>: 문자열(단계명; <code>procedure</code>에 정의된 항목 중 하나)</p></li>
<li><p><code>event</code>: 문자열(사건명; <code>START</code>, <code>END</code>, <code>METRIC</code>, <code>GATE</code>, <code>ERROR</code> 등 사전정의 집합)</p></li>
<li><p><code>payload</code>: 객체(메트릭/경고/에러/파일 경로/체크섬 등 부가정보)</p></li>
</ul>
<h4 data-number="18.2.3.2" id="정의-필수-로그-사건"><span class="header-section-number">18.2.3.2</span> (정의) 필수 로그 사건</h4>
<p>각 실행은 다음 사건을 반드시 포함해야 한다.</p>
<ul>
<li><p><code>START</code>: 실행 시작(입력 다이제스트 포함).</p></li>
<li><p><code>LOCKS_CHECK</code>: LOCK 다이제스트 검증 결과.</p></li>
<li><p><code>PHASE_START</code>/<code>PHASE_END</code>: 각 절차 단계의 시작/종료.</p></li>
<li><p><code>METRIC</code>: 사전등록된 모든 메트릭 출력(값, 단위, 계산 버전).</p></li>
<li><p><code>GATE</code>: 각 Gate의 판정 결과(0/1) 및 근거 메트릭 참조.</p></li>
<li><p><code>MANIFEST_WRITE</code>: manifest 생성 완료 및 체크섬.</p></li>
<li><p><code>STATUS</code>: 최종 판정(<a data-reference="eq:S16_01_status" data-reference-type="eqref" href="#eq:S16_01_status">[eq:S16_01_status]</a>)과 실패 코드(해당 시).</p></li>
</ul>
<p>필수 사건의 누락은 <a data-reference="eq:S16_01_TSCH" data-reference-type="eqref" href="#eq:S16_01_TSCH">[eq:S16_01_TSCH]</a>로 실패 처리한다.</p>
<h3 data-number="18.2.4" id="메트릭-파일metrics.json-규격정의"><span class="header-section-number">18.2.4</span> 16.2.4 메트릭 파일(metrics.json) 규격(정의)</h3>
<p>메트릭은 로그의 <code>METRIC</code> 사건으로도 기록되지만, 실행 종료 시 <code>metrics.json</code>에 단일 객체로 요약 저장한다.
<span class="math display">\[\texttt{metrics.json}=
\{\texttt{run\_id},\texttt{pid},\texttt{ver},\texttt{metrics},\texttt{units},\texttt{provenance}\}
\label{eq:S16_02_metrics_schema}\]</span>
여기서</p>
<ul>
<li><p><code>metrics</code>: 키-값 맵(메트릭명 <span class="math inline">\(\to\)</span> 수치/벡터/행렬; JSON로 표현 가능한 형태)</p></li>
<li><p><code>units</code>: 키-값 맵(메트릭명 <span class="math inline">\(\to\)</span> 단위 문자열)</p></li>
<li><p><code>provenance</code>: 입력 다이제스트, 코드 버전, 실행 환경 요약(아래 <code>registry_snapshot</code>과 동일 키를 포함)</p></li>
</ul>
<p>를 고정한다.</p>
<h3 data-number="18.2.5" id="manifest-규격정의과-체크섬-파일"><span class="header-section-number">18.2.5</span> 16.2.5 manifest 규격(정의)과 체크섬 파일</h3>
<h4 data-number="18.2.5.1" id="정의-manifest.json"><span class="header-section-number">18.2.5.1</span> (정의) manifest.json</h4>
<p>manifest는 산출물의 완전 목록과 체크섬을 담는 SSOT 파일이다. <code>manifest.json</code>의 스키마를 다음으로 고정한다.
<span class="math display">\[\texttt{manifest.json}=
\{\texttt{run\_id},\texttt{pid},\texttt{ver},\texttt{files},\texttt{hash\_alg}\}
\label{eq:S16_02_manifest_schema}\]</span>
<code>hash_alg</code>는 문자열로 <code>"sha256"</code>을 고정한다.
<code>files</code>는 항목 리스트이며 각 항목은
<span class="math display">\[f=
\{\texttt{path},\texttt{bytes},\texttt{sha256}\}
\label{eq:S16_02_manifest_fileitem}\]</span>
를 만족해야 한다.</p>
<h4 data-number="18.2.5.2" id="정의-manifest.sha256"><span class="header-section-number">18.2.5.2</span> (정의) manifest.sha256</h4>
<p><code>manifest.sha256</code>는 다음 형식을 갖는 단일 라인(또는 다중 라인) 텍스트로 고정한다.</p>
<pre><code>&lt;sha256_of_manifest.json&gt;  manifest.json</code></pre>
<p><code>manifest.json</code> 자체의 체크섬도 레지스트리 스냅샷에 포함되어야 한다.</p>
<h3 data-number="18.2.6" id="registry_snapshot-규격정의"><span class="header-section-number">18.2.6</span> 16.2.6 registry_snapshot 규격(정의)</h3>
<h4 data-number="18.2.6.1" id="정의-registry_snapshot.json"><span class="header-section-number">18.2.6.1</span> (정의) registry_snapshot.json</h4>
<p><code>registry_snapshot.json</code>은 실행의 재현에 필요한 <em>모든 고정점</em>을 한 파일에 스냅샷으로 담는다.
스키마를 다음으로 고정한다.
<span class="math display">\[\texttt{registry\_snapshot.json}=
\{\texttt{run\_id},\texttt{protocol},\texttt{locks},\texttt{environment},\texttt{code},\texttt{randomness},\texttt{manifests}\}
\label{eq:S16_02_snapshot_schema}\]</span>
각 필드는 다음을 포함한다.</p>
<ul>
<li><p><code>protocol</code>: <code>pid</code>, <code>version</code>, <code>digest</code>(<span class="math inline">\(=\mathrm{DIG}_{\mathrm{prot}}\)</span>), <code>file_path</code></p></li>
<li><p><code>locks</code>: 각 LOCK 파일의 <code>path</code>, <code>sha256</code>, 그리고 <em>원문 JSON 사본의 다이제스트</em></p></li>
<li><p><code>environment</code>: OS/아키텍처/언어 런타임 버전/의존성 목록(정렬된 리스트)</p></li>
<li><p><code>code</code>: 소스 트리 다이제스트(예: 디렉토리 해시), 커밋 식별자(있을 때), 빌드 플래그(있을 때)</p></li>
<li><p><code>randomness</code>: 모든 난수 시드, 샘플링 규칙, 시드 파생 함수의 다이제스트</p></li>
<li><p><code>manifests</code>: <code>manifest.json</code> 및 <code>manifest.sha256</code>의 다이제스트</p></li>
</ul>
<h3 data-number="18.2.7" id="난수시드-규약정의과-재현성의-최소-조건"><span class="header-section-number">18.2.7</span> 16.2.7 난수·시드 규약(정의)과 재현성의 최소 조건</h3>
<h4 data-number="18.2.7.1" id="정의-시드-체계"><span class="header-section-number">18.2.7.1</span> (정의) 시드 체계</h4>
<p>실행의 난수 요소는 전부 시드로 고정되어야 한다. 기본 시드 <span class="math inline">\(\mathrm{seed}_0\in\mathbb{N}\)</span>과 단계별 시드 파생을
<span class="math display">\[\mathrm{seed}_{p}:=\mathrm{H}(\mathrm{seed}_0,\texttt{pid},\texttt{phase\_name},\texttt{run\_id})
\label{eq:S16_02_seed_derive}\]</span>
로 고정한다. 여기서 <span class="math inline">\(\mathrm{H}\)</span>는 사전등록된 해시 기반 함수이며, <code>registry_snapshot.json</code>에 <span class="math inline">\(\mathrm{H}\)</span>의 다이제스트가 포함되어야 한다.
단계별 시드는 로그와 스냅샷에 기록되어야 하며, 누락은 <a data-reference="eq:S16_01_TSCH" data-reference-type="eqref" href="#eq:S16_01_TSCH">[eq:S16_01_TSCH]</a>로 실패 처리한다.</p>
<h4 data-number="18.2.7.2" id="정의-재현성-최소-조건"><span class="header-section-number">18.2.7.2</span> (정의) 재현성 최소 조건</h4>
<p>재현성은 다음 동시 조건으로 정의한다.
<span class="math display">\[\mathrm{REPRODUCIBLE}=1
\Longleftrightarrow
\big(T_{\mathrm{LOCK}}=0\big)\wedge\big(T_{\mathrm{MAN}}=0\big)\wedge\big(T_{\mathrm{SCH}}=0\big)
\label{eq:S16_02_repro_min}\]</span>
즉, LOCK 불일치/무결성 실패/스키마 실패 중 하나라도 있으면 재현성은 성립하지 않는다.</p>
<h2 data-number="18.3" id="참조-구현reference-implementation-실행-레시피-산출물-체크리스트-릴리즈-규정"><span class="header-section-number">18.3</span> 16.3 참조 구현(Reference Implementation) 실행 레시피, 산출물 체크리스트, 릴리즈 규정</h2>
<h3 data-number="18.3.1" id="참조-구현의-정의정의"><span class="header-section-number">18.3.1</span> 16.3.1 참조 구현의 정의(정의)</h3>
<h4 data-number="18.3.1.1" id="정의-참조-구현"><span class="header-section-number">18.3.1.1</span> (정의) 참조 구현</h4>
<p>참조 구현 <span class="math inline">\(\mathcal{I}_{\mathrm{ref}}\)</span>는 다음 조건을 만족하는 실행 코드 집합으로 정의한다.</p>
<ul>
<li><p>(RI-1) 입력은 오직 <code>protocol.*</code>과 <code>locks/*</code> 및 실행 계획(<code>plan.*</code>)에서만 읽는다.</p></li>
<li><p>(RI-2) Gate/PASS.rules 및 산출물 목록은 <code>protocol.*</code>의 선언을 그대로 사용한다.</p></li>
<li><p>(RI-3) 모든 실행 결과는 <code>runs/&lt;run_id&gt;/</code> 하위에만 기록한다.</p></li>
<li><p>(RI-4) 실행 종료 시 <code>run_log.jsonl</code>, <code>metrics.json</code>, <code>manifest.json</code>, <code>registry_snapshot.json</code>이 반드시 생성된다.</p></li>
<li><p>(RI-5) 동일 스냅샷(LOCK/환경/시드)에서 산출물 체크섬이 동일해야 한다.</p></li>
</ul>
<p>(RI-1) 위반은 No-Tuning 위반으로 처리하며 <a data-reference="eq:S16_01_TNT" data-reference-type="eqref" href="#eq:S16_01_TNT">[eq:S16_01_TNT]</a> 트리거로 실패 처리한다.</p>
<h3 data-number="18.3.2" id="실행-레시피정의-입력출력단계"><span class="header-section-number">18.3.2</span> 16.3.2 실행 레시피(정의): 입력/출력/단계</h3>
<h4 data-number="18.3.2.1" id="정의-실행-계획plan-파일"><span class="header-section-number">18.3.2.1</span> (정의) 실행 계획(plan) 파일</h4>
<p>실행 계획 <code>plan.json</code>은 프로토콜이 허용하는 실험 셋을 <em>열거</em>하는 파일로 정의한다.
각 실행 항목은
<span class="math display">\[\texttt{job}=
\{\texttt{job\_id},\texttt{pid},\texttt{protocol\_digest},\texttt{locks},\texttt{params},\texttt{seeds},\texttt{targets}\}
\label{eq:S16_03_plan_job}\]</span>
를 만족해야 한다.
<code>params</code>는 사전등록에서 허용된 파라미터만 포함하며, 허용 목록 밖의 키가 존재하면 즉시 <code>F-PROCEDURE-020</code>으로 실패 처리한다.</p>
<h4 data-number="18.3.2.2" id="정의-실행-엔트리포인트"><span class="header-section-number">18.3.2.2</span> (정의) 실행 엔트리포인트</h4>
<p>참조 구현은 다음 엔트리포인트를 제공하는 것으로 고정한다.</p>
<pre><code>ref_impl/
  run_one.py
  run_plan.py
  validate.py</code></pre>
<p>각 엔트리포인트의 책임을 다음과 같이 고정한다.</p>
<ul>
<li><p><code>run_one.py</code>: 단일 <code>job</code> 실행, run 디렉토리 생성, 로그/메트릭/산출물 생성.</p></li>
<li><p><code>run_plan.py</code>: <code>plan.json</code>의 모든 <code>job</code>을 열거 순서대로 실행, 전체 요약 로그 생성.</p></li>
<li><p><code>validate.py</code>: 스키마 검증, 체크섬 검증, PASS/FAIL 판정 재계산, 결과 요약 생성.</p></li>
</ul>
<h4 data-number="18.3.2.3" id="정의-실행-명령-형식"><span class="header-section-number">18.3.2.3</span> (정의) 실행 명령 형식</h4>
<p>실행 명령의 형식을 다음으로 고정한다.</p>
<pre><code>python ref_impl/run_plan.py --protocol protocol.yaml --plan plan.json --out runs/
python ref_impl/validate.py --runs runs/ --protocol protocol.yaml</code></pre>
<p>명령 자체는 형식 정의이며, 실행 환경/의존성/버전은 <code>registry_snapshot.json</code>에 의해 고정된다.</p>
<h3 data-number="18.3.3" id="산출물-체크리스트정의-필수-파일과-포맷"><span class="header-section-number">18.3.3</span> 16.3.3 산출물 체크리스트(정의): 필수 파일과 포맷</h3>
<h4 data-number="18.3.3.1" id="정의-릴리즈-산출물-최소-집합"><span class="header-section-number">18.3.3.1</span> (정의) 릴리즈 산출물 최소 집합</h4>
<p>릴리즈(배포 단위)는 다음 파일/디렉토리를 반드시 포함해야 한다.</p>
<pre><code>README.md
LICENSE
CITATION.cff
CHANGELOG.md
protocol/
  protocol.yaml
  protocol.sha256
locks/
  canon_lock.json
  realization_lock.json
  analysis_lock.json
  locks.sha256
plans/
  plan.json
  plan.sha256
runs/
  &lt;run_id&gt;/
    protocol.locked.json
    locks_snapshot/
    registry_snapshot.json
    run_log.jsonl
    metrics.json
    outputs/
    manifest.json
    manifest.sha256
release_manifest.json
release_manifest.sha256</code></pre>
<p>여기서 <code>release_manifest.json</code>은 릴리즈 최상위에서 전체 파일의 체크섬을 담는 상위 manifest이며, 스키마는 <a data-reference="eq:S16_02_manifest_schema" data-reference-type="eqref" href="#eq:S16_02_manifest_schema">[eq:S16_02_manifest_schema]</a>와 동일하게 고정한다.</p>
<h4 data-number="18.3.3.2" id="정의-필수-메타데이터의-내용"><span class="header-section-number">18.3.3.2</span> (정의) 필수 메타데이터의 내용</h4>
<p>각 메타데이터 파일의 최소 내용은 다음을 포함해야 한다.</p>
<ul>
<li><p><code>README.md</code>: 릴리즈 식별(버전, 날짜), 포함된 프로토콜/LOCK, 실행 목록(<code>run_id</code>들), 산출물 개요(파일명만).</p></li>
<li><p><code>CITATION.cff</code>: 저자/제목/버전/DOI(배포 후), 릴리즈 다이제스트 요약.</p></li>
<li><p><code>CHANGELOG.md</code>: 버전별 변경 요약(어떤 LOCK/프로토콜/코드가 바뀌었는지).</p></li>
<li><p><code>LICENSE</code>: 배포 조건.</p></li>
</ul>
<p>메타데이터 누락은 <a data-reference="eq:S16_01_TSCH" data-reference-type="eqref" href="#eq:S16_01_TSCH">[eq:S16_01_TSCH]</a>로 실패 처리한다.</p>
<h3 data-number="18.3.4" id="릴리즈-규정정의-버전-불변성-doi-단위"><span class="header-section-number">18.3.4</span> 16.3.4 릴리즈 규정(정의): 버전, 불변성, DOI 단위</h3>
<h4 data-number="18.3.4.1" id="정의-버전-표기와-상승-규칙"><span class="header-section-number">18.3.4.1</span> (정의) 버전 표기와 상승 규칙</h4>
<p>릴리즈 버전은 <span class="math inline">\(\mathrm{v}X.Y.Z\)</span>로 고정한다.</p>
<ul>
<li><p><span class="math inline">\(X\)</span> (Major): <strong>LOCK 정의의 의미 변경</strong> 또는 <strong>Gate/PASS.rules 의미 변경</strong>이 있을 때 증가.</p></li>
<li><p><span class="math inline">\(Y\)</span> (Minor): 참조 구현/절차 추가, 산출물 구조 추가, 스키마 확장(하위호환 유지) 시 증가.</p></li>
<li><p><span class="math inline">\(Z\)</span> (Patch): 문서 오탈자, 표기 수정, 스크립트 주석 수정 등 결과/스키마/판정에 영향을 주지 않는 변경 시 증가.</p></li>
</ul>
<p>특히 LOCK(정준/실현/분석) 파일의 키-값이 변경되면 반드시 Major를 증가해야 한다. 이는 “동일 이름의 결론을 사후 변경”하는 행위를 금지하기 위한 규정이다.</p>
<h4 data-number="18.3.4.2" id="정의-불변성immutability-규칙"><span class="header-section-number">18.3.4.2</span> (정의) 불변성(immutability) 규칙</h4>
<p>DOI가 부여된 릴리즈는 불변이며, DOI 부여 이후 파일의 수정/삭제/교체는 금지된다.
수정이 필요하면 신규 버전 릴리즈를 생성하고 신규 DOI 단위를 발급받는다.
불변성은 다음과 같이 체크섬으로 강제한다.
<span class="math display">\[\mathrm{IMMUTABLE}=1
\Longleftrightarrow
\mathrm{SHA256}(\texttt{release\_manifest.json})=\texttt{release\_manifest.sha256의 값}
\label{eq:S16_03_immutable}\]</span></p>
<h4 data-number="18.3.4.3" id="정의-doi-패키지아카이브-단위"><span class="header-section-number">18.3.4.3</span> (정의) DOI 패키지(아카이브 단위)</h4>
<p>DOI 패키지(압축 또는 아카이브)는 다음을 포함하는 단일 번들로 고정한다.
<span class="math display">\[\mathsf{DOIPACK}:=\{\texttt{protocol/},\texttt{locks/},\texttt{plans/},\texttt{runs/},\texttt{release\_manifest.*},\texttt{README.md},\texttt{CITATION.cff},\texttt{CHANGELOG.md},\texttt{LICENSE}\}
\label{eq:S16_03_doipack}\]</span>
<code>release_manifest.*</code>는 <strong>모든 파일의 무결성 증거</strong>로서 필수이며, 누락 시 DOI 패키지는 성립하지 않는다.</p>
<h3 data-number="18.3.5" id="릴리즈-판정-게이트정의-배포-자격"><span class="header-section-number">18.3.5</span> 16.3.5 릴리즈 판정 게이트(정의): 배포 자격</h3>
<p>릴리즈는 단일 실행이 아니라 <code>runs/</code> 전체에 대한 배포 자격 판정으로 정의한다.
릴리즈 PASS는 다음 조건으로 고정한다.
<span class="math display">\[\mathrm{PASS}_{\mathrm{release}}
:=
\left(\bigwedge_{\texttt{run\_id}\in\texttt{runs/}} \mathrm{STATUS}(\texttt{run\_id})\neq \mathrm{INCONCLUSIVE}\right)
\wedge
\left(T_{\mathrm{MAN}}^{\mathrm{release}}=0\right)
\wedge
\left(T_{\mathrm{SCH}}^{\mathrm{release}}=0\right)
\label{eq:S16_03_pass_release}\]</span>
여기서 <span class="math inline">\(T_{\mathrm{MAN}}^{\mathrm{release}}\)</span>는 <code>release_manifest.*</code>에 대한 무결성 트리거, <span class="math inline">\(T_{\mathrm{SCH}}^{\mathrm{release}}\)</span>는 릴리즈 스키마 트리거이다.
릴리즈에 FAIL 실행이 포함되는 것은 허용되며, 그 경우에도 FAILPACK 규정 <a data-reference="eq:S16_01_failpack" data-reference-type="eqref" href="#eq:S16_01_failpack">[eq:S16_01_failpack]</a>을 충족해야 한다.
단, 릴리즈가 PASS로 판정되려면 <code>INCONCLUSIVE</code> 실행이 존재해서는 안 된다.</p>
<h3 data-number="18.3.6" id="최소-공개-원칙정의-pass와-fail의-동등-공개"><span class="header-section-number">18.3.6</span> 16.3.6 최소 공개 원칙(정의): PASS와 FAIL의 동등 공개</h3>
<p>PASS와 FAIL은 다음 공개 규칙을 동일하게 적용받는다.</p>
<ul>
<li><p>모든 실행은 <code>run_log.jsonl</code>과 <code>registry_snapshot.json</code>을 포함해야 한다.</p></li>
<li><p>모든 실행은 <code>manifest.json</code>과 체크섬을 포함해야 한다.</p></li>
<li><p>모든 실행은 프로토콜 및 LOCK 스냅샷을 포함해야 한다.</p></li>
</ul>
<p>이는 “성공한 결과만 남기고 실패는 제거”하는 행위를 금지하기 위한 규정이며, 실패 또한 검증/재현성 체계의 일부로 취급한다.</p>
<h3 data-number="18.3.7" id="배포-후-추적정의-doi-버전-매핑과-참조-고정"><span class="header-section-number">18.3.7</span> 16.3.7 배포 후 추적(정의): DOI-버전 매핑과 참조 고정</h3>
<p>배포 후 DOI가 부여되면, 릴리즈는 <code>CITATION.cff</code> 및 별도 매핑 파일에 의해 참조가 고정된다.
매핑 파일은
<span class="math display">\[\texttt{DOI\_MAP.csv}:\ (\texttt{version},\texttt{doi},\texttt{release\_digest},\texttt{date})
\label{eq:S16_03_doi_map}\]</span>
열을 갖는 CSV로 정의한다.
<code>release_digest</code>는 <code>release_manifest.json</code>의 SHA-256으로 고정한다.
DOI-버전 매핑의 누락은 배포 체계의 불완전으로 처리하며, 이후 모든 인용/참조는 DOI와 <code>release_digest</code>를 함께 표기하는 방식으로 고정한다.</p>
<h2 data-number="18.4" id="sec:S16_04_constant_closure_map"><span class="header-section-number">18.4</span> 16.4 물리상수 완결 지도: GEOM/ANCHOR/CALIB의 분리</h2>
<p>본 절은 본문에서 사용되는 주요 물리상수/스케일을
(i) 순수 기하학/정수 구조에서 닫히는 항(<code>GEOM</code>),
(ii) 실현 단위계의 닻(정의 또는 표준값)으로 잠기는 항(<code>ANCHOR</code>),
(iii) <code>GEOM</code> 구조에 <code>ANCHOR</code>를 결합해 수치가 결정되는 항(<code>CALIB</code>)
으로 분류하여, “무엇이 유도되었고 무엇이 잠겨 있는지”를 문서 내부에서 스스로 점검할 수 있게 한다.
본 절은 <em>새 물리 가정</em>을 추가하지 않으며, <strong>기존 절들의 의존성(dependency) 상태표(SSOT)</strong>만 제공한다.</p>
<h3 data-number="18.4.1" id="분류-규칙정의"><span class="header-section-number">18.4.1</span> 16.4.1 분류 규칙(정의)</h3>
<ul>
<li><p><code>GEOM</code>: 문서 내부의 정수/기하 정의만으로 닫히며, 외부 수치/정의에 의존하지 않는다.</p></li>
<li><p><code>ANCHOR</code>: 단위 체계 또는 표준값(정의/권고값)으로 잠겨야 하며, 본 문서는 유도 대상으로 삼지 않는다(단, 잠김의 존재는 숨기지 않는다).</p></li>
<li><p><code>CALIB</code>: <code>GEOM</code> 구조를 유지한 채 <code>ANCHOR</code>를 결합하여 SI 수치(또는 보고 단위)가 결정된다.</p></li>
</ul>
<h3 data-number="18.4.2" id="물리상수-상태표ssot"><span class="header-section-number">18.4.2</span> 16.4.2 물리상수 상태표(SSOT)</h3>
<table style="width:95%;">
<colgroup>
<col style="width: 23%"/>
<col style="width: 12%"/>
<col style="width: 15%"/>
<col style="width: 45%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>항목</strong></th>
<th style="text-align: left;"><strong>상태</strong></th>
<th style="text-align: left;"><strong>주요 출처</strong></th>
<th style="text-align: left;"><strong>정의/유도 요약</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>항목</strong></td>
<td style="text-align: left;"><strong>상태</strong></td>
<td style="text-align: left;"><strong>주요 출처</strong></td>
<td style="text-align: left;"><strong>정의/유도 요약</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(N_{\mathrm{sec}}=3\)</span></td>
<td style="text-align: left;"><code>GEOM</code></td>
<td style="text-align: left;">7.0</td>
<td style="text-align: left;">2D 단면에서 코어 가두기(Enclosure)를 위한 최소 벡터 수(3)로 위상학적으로 강제.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(N_{\mathrm{shell}}=7\)</span></td>
<td style="text-align: left;"><code>GEOM</code></td>
<td style="text-align: left;">8.2</td>
<td style="text-align: left;">3D 상쇄(2-페어+4-쿼드) + 라벨 생존(1) 최소성, 그리고 <span class="math inline">\(89-82\)</span> 잔여 일치로 닫힘.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\alpha_{em}\)</span></td>
<td style="text-align: left;"><code>GEOM</code></td>
<td style="text-align: left;">14.5</td>
<td style="text-align: left;"><span class="math inline">\(4\pi(7+3+1-\delta_{\mathrm{proj}})\)</span> 형태로 기하학적 임피던스를 정의하고, 연속 회전 평균(<span class="math inline">\(2/\pi^2\)</span>)과 이산 점유 보정(<span class="math inline">\(35/32\)</span>)으로 닫힘.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(h_{\mathrm{VP}}\)</span></td>
<td style="text-align: left;"><code>CALIB</code></td>
<td style="text-align: left;">15.5</td>
<td style="text-align: left;">강성 껍질 장벽 <span class="math inline">\(\epsilon_b(\nu)=h_{\mathrm{VP}}\,\nu\)</span>를 정의하고, 사건수 <span class="math inline">\(n\in\mathbb{N}\)</span>의 열평형 합으로 플랑크 스펙트럼 형태를 유도. <span class="math inline">\(h_{\mathrm{VP}}\)</span>의 SI 값은 흑체 데이터와의 매칭으로 식별(프로토콜/게이트 필요).</td>
</tr>
<tr class="even">
<td style="text-align: left;">흑체 스펙트럼 형태</td>
<td style="text-align: left;"><code>GEOM</code></td>
<td style="text-align: left;">15.5</td>
<td style="text-align: left;">모드수 <span class="math inline">\(\nu^2\)</span> (순수 3D 기하) <span class="math inline">\(\times\)</span> 강성 필터 <span class="math inline">\(\frac{h_{\mathrm{VP}}\nu}{e^{h_{\mathrm{VP}}\nu/(k_B T)}-1}\)</span> (이산 사건수)로 형태가 닫힘.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(a\)</span> (VP 지름, 실현 길이)</td>
<td style="text-align: left;"><code>ANCHOR</code></td>
<td style="text-align: left;">11.2</td>
<td style="text-align: left;">실현 단위계의 길이 닻. 같은 버전 내에서 사후 조정 금지(LOCK).</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(\Delta t\)</span> (실현 시간 틱)</td>
<td style="text-align: left;"><code>ANCHOR</code></td>
<td style="text-align: left;">11.3</td>
<td style="text-align: left;">실현 단위계의 시간 닻. 같은 버전 내에서 사후 조정 금지(LOCK).</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(c_{\mathrm{ref}}\)</span></td>
<td style="text-align: left;"><code>ANCHOR</code></td>
<td style="text-align: left;">11.1, 13.1</td>
<td style="text-align: left;">기준 속도 닻(단위계/프로토콜). 본 문서에서는 유도 대상으로 삼지 않으며 LOCK으로만 사용.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(h\)</span></td>
<td style="text-align: left;"><code>ANCHOR</code></td>
<td style="text-align: left;">13.1</td>
<td style="text-align: left;">작용 단위 닻. SI 정의값을 <code>canon_lock</code>에 잠근다.</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><span class="math inline">\(U_{\mathrm{lat}}=hc_{\mathrm{ref}}/a\)</span></td>
<td style="text-align: left;"><code>CALIB</code></td>
<td style="text-align: left;">13.1</td>
<td style="text-align: left;"><code>ANCHOR</code> 3종(<span class="math inline">\(h,c_{\mathrm{ref}},a\)</span>)을 결합한 격자 단위 에너지 SSOT.</td>
</tr>
<tr class="even">
<td style="text-align: left;"><span class="math inline">\(m_p,m_e,m_H\)</span> 등 질량 스케일</td>
<td style="text-align: left;"><code>CALIB</code></td>
<td style="text-align: left;">13</td>
<td style="text-align: left;"><span class="math inline">\(U_{\mathrm{lat}}/\sigma_{\mathrm{eff}}\)</span> 공리 하에서, 구조 저항(기하 단면/사건율)로부터 산출. 비교는 Gate 지표.</td>
</tr>
</tbody>
</table>
<h3 data-number="18.4.3" id="gate-잠김-누락-탐지-규칙정의"><span class="header-section-number">18.4.3</span> 16.4.3 Gate: “잠김 누락” 탐지 규칙(정의)</h3>
<p>본 절의 상태표는 <em>결론</em>이 아니라 <em>감사 규칙</em>이다. 다음 위반이 탐지되면 해당 결론은 즉시 <code>FAIL</code>로 둔다.</p>
<ul>
<li><p>(G-LOCK-MISS) <code>ANCHOR</code> 항목을 사용하면서도, 해당 상수의 값/단위/출처가 <code>lock</code> 파일에 봉인되어 있지 않음.</p></li>
<li><p>(G-ANCHOR-HIDE) <code>ANCHOR</code>를 <code>GEOM</code>처럼 서술(유도된 것처럼 표현)하거나, 사후에 값을 조정한 흔적이 발견됨.</p></li>
<li><p>(G-CALIB-NOPROTO) <code>CALIB</code> 항목을 사용하면서, 매칭 프로토콜/오차막대/판정함수(예: <span class="math inline">\(\chi\)</span>)가 사전등록되지 않음.</p></li>
</ul>
<h2 data-number="18.5" id="sec:S16_05_doi_guard"><span class="header-section-number">18.5</span> 16.5 DOI 완결성 유지 규칙: “누락 0”의 자동 감사</h2>
<p>본 문서는 두 종류의 인용을 구분한다.</p>
<ul>
<li><p><strong>내부 인용(<code>[cite: XX]</code>)</strong>: 본 DOI 번들 내부의 보고서/시뮬레이션/프로토콜을 가리키는 토큰.</p></li>
<li><p><strong>외부 인용(저널/표준)</strong>: DOI가 존재하는 외부 문헌(예: 플랑크 원 논문, CODATA 등).</p></li>
</ul>
<p>목표는 내부 인용의 <strong>DOI 누락 0</strong>과, 외부 인용의 <strong>DOI 표기 누락 0</strong>이다.</p>
<h3 data-number="18.5.1" id="내부-인용-레지스트리정의-ssot-cite_registry.csv"><span class="header-section-number">18.5.1</span> 16.5.1 내부 인용 레지스트리(정의): SSOT = <code>CITE_REGISTRY.csv</code></h3>
<p>내부 인용 토큰은 반드시 다음 SSOT에 등록되어야 한다.</p>
<ul>
<li><p>SSOT: <code>04_vp_whitepaper/docs/citations/CITE_REGISTRY.csv</code></p></li>
<li><p>Per-ID 노트: <code>04_vp_whitepaper/docs/citations/CITE-#.md</code></p></li>
</ul>
<p>토큰이 본문에 등장했는데 SSOT에 누락되면 (G-DOI-MISS)로 <code>FAIL</code>이다.</p>
<h3 data-number="18.5.2" id="외부-문헌-doi-표기-규칙정의"><span class="header-section-number">18.5.2</span> 16.5.2 외부 문헌 DOI 표기 규칙(정의)</h3>
<ul>
<li><p>DOI가 존재하는 외부 저널/학술지 문헌은 반드시 DOI를 함께 표기한다.</p></li>
<li><p>DOI가 없는 자료(웹페이지, 소프트웨어 등)는 URL과 접근일을 기록한다.</p></li>
<li><p>arXiv만 존재하는 경우, arXiv 식별자를 표기하고 이후 DOI가 부여되면 버전업에서 추가한다.</p></li>
</ul>
<h3 data-number="18.5.3" id="자동-감사-스크립트lock-scriptsdoi_audit.py"><span class="header-section-number">18.5.3</span> 16.5.3 자동 감사 스크립트(LOCK): <code>scripts/doi_audit.py</code></h3>
<p>릴리즈 전(또는 Zenodo 업로드 전) 다음 스크립트가 <strong>성공(Exit code 0)</strong>해야 한다.
<span class="math display">\[\texttt{python3 scripts/doi\_audit.py}
\label{eq:S16_05_doi_audit_cmd}\]</span>
이 스크립트는
(i) 본문 내부 인용 토큰과 <code>CITE_REGISTRY.csv</code>의 ID 일치 여부,
(ii) <code>CITE_REGISTRY.csv</code>의 DOI/URL 공란 여부,
(iii) 본문 외부 DOI 문자열의 유효 형식(정규식) 및 중복,
을 점검한다.
실패한 상태에서의 업로드/배포는 금지한다.</p>
<h1 data-number="19" id="확장-파트선택-읽기"><span class="header-section-number">19</span> 17. 확장 파트(선택 읽기)</h1>
<h2 data-number="19.1" id="회전이방성-확장ell_mathrmrot-적용-포함과-실험-모듈-구조"><span class="header-section-number">19.1</span> 17.1 회전/이방성 확장(<span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 적용 포함)과 실험 모듈 구조</h2>
<h3 data-number="19.1.1" id="확장-대상의-정의"><span class="header-section-number">19.1.1</span> 17.1.1 확장 대상의 정의</h3>
<p>회전/이방성 확장은 다음의 두 범주를 포함한다.</p>
<ul>
<li><p>(E-ANISO) <strong>이방성 전파/감쇄</strong>: 등방 레짐에서 사용하던 감쇄 커널, 전파 백본, 사건 집계 규칙을 방향 의존 형태로 확장한다.</p></li>
<li><p>(E-ROT) <strong>회전 구동 사건</strong>: 3-섹터 사건 구조 위에 회전 구동(회전률, 회전축, 회전 길이 스케일)을 운영 정의로 추가하고, 이방성 전파와 결합한다.</p></li>
</ul>
<h3 data-number="19.1.2" id="이방성-축과-방향-변수정의"><span class="header-section-number">19.1.2</span> 17.1.2 이방성 축과 방향 변수(정의)</h3>
<p>이방성 축(단위벡터)을
<span class="math display">\[\mathbf{u}\in\mathbb{R}^d,\qquad \|\mathbf{u}\|=1
\label{eq:S17_01_u_axis}\]</span>
로 정의한다. 임의의 위치 분리 벡터 <span class="math inline">\(\mathbf{R}\neq \mathbf{0}\)</span>에 대해 방향 코사인을
<span class="math display">\[\mu(\mathbf{R}):=\frac{\mathbf{R}\cdot\mathbf{u}}{\|\mathbf{R}\|}
\in[-1,1]
\label{eq:S17_01_mu}\]</span>
로 정의한다. 이후 모든 이방성 커널은 <span class="math inline">\(\mu\)</span> 또는 동등한 각도 변수에 의해 매개된다.</p>
<h3 data-number="19.1.3" id="이방성-감쇄-커널의-운영-정의정의"><span class="header-section-number">19.1.3</span> 17.1.3 이방성 감쇄 커널의 운영 정의(정의)</h3>
<p>등방 레짐에서의 기하 감쇄 커널을
<span class="math display">\[\mathcal{D}_{\mathrm{dil,iso}}(R)=\left(\frac{a}{R}\right)^2
\label{eq:S17_01_dil_iso}\]</span>
로 두고, 이방성 확장 커널을 다음 곱 형태로 정의한다.
<span class="math display">\[\mathcal{D}_{\mathrm{dil}}(R,\mu)
:=
\left(\frac{a}{R}\right)^2\,g(\mu),
\qquad g(\mu)\ge 0
\label{eq:S17_01_dil_aniso}\]</span>
여기서 <span class="math inline">\(g(\mu)\)</span>는 <code>analysis_lock</code>에 의해 잠기는 함수이며, 실행 결과를 보고 선택될 수 없다.</p>
<h4 data-number="19.1.3.1" id="정의-정규화-조건"><span class="header-section-number">19.1.3.1</span> (정의) 정규화 조건</h4>
<p><span class="math inline">\(g(\mu)\)</span>가 등방 평균을 보존하도록 다음 정규화 조건을 부과한다.
<span class="math display">\[\langle g\rangle_{\mu}
:=
\frac{1}{2}\int_{-1}^{1} g(\mu)\,d\mu
=
1
\label{eq:S17_01_g_norm}\]</span>
정규화가 성립하면 <a data-reference="eq:S17_01_dil_aniso" data-reference-type="eqref" href="#eq:S17_01_dil_aniso">[eq:S17_01_dil_aniso]</a>는 각도 평균에서 <a data-reference="eq:S17_01_dil_iso" data-reference-type="eqref" href="#eq:S17_01_dil_iso">[eq:S17_01_dil_iso]</a>를 복원한다.</p>
<h4 data-number="19.1.3.2" id="정의-이방성-계수요약치"><span class="header-section-number">19.1.3.2</span> (정의) 이방성 계수(요약치)</h4>
<p>이방성의 크기를 보고하기 위한 요약치를 다음과 같이 정의한다.
<span class="math display">\[\beta_g
:=
\left(\frac{1}{2}\int_{-1}^{1}\big(g(\mu)-1\big)^2\,d\mu\right)^{1/2}
\label{eq:S17_01_beta_g}\]</span>
<span class="math inline">\(\beta_g=0\)</span>은 등방을 의미하며, <span class="math inline">\(\beta_g&gt;0\)</span>은 이방성을 의미한다.</p>
<h3 data-number="19.1.4" id="이방성-퍼콜레이션백본의-운영-정의정의"><span class="header-section-number">19.1.4</span> 17.1.4 이방성 퍼콜레이션/백본의 운영 정의(정의)</h3>
<p>격자에서 전파 백본(backbone)을 구성하는 경로 집합을 <span class="math inline">\(\mathcal{B}\)</span>라 하고, 각 경로 <span class="math inline">\(\gamma\in\mathcal{B}\)</span>를 링크들의 열로 본다.
링크 방향 <span class="math inline">\(\hat{\ell}\)</span>에 대해 이방성 가중을
<span class="math display">\[w(\hat{\ell})
:=
g\!\left(\mu(\hat{\ell})\right),
\qquad
\mu(\hat{\ell}):=\hat{\ell}\cdot\mathbf{u}
\label{eq:S17_01_link_weight}\]</span>
로 정의한다. 경로 <span class="math inline">\(\gamma\)</span>의 누적 가중을
<span class="math display">\[W(\gamma):=\prod_{\hat{\ell}\in\gamma} w(\hat{\ell})
\label{eq:S17_01_path_weight}\]</span>
로 정의한다. 이때 이방성 백본은 다음 극대화 규칙으로 정의한다.
<span class="math display">\[\gamma^\star(\mathbf{x}\to\mathbf{y})
:=
\operatorname*{arg\,max}_{\gamma\in\Gamma(\mathbf{x}\to\mathbf{y})} W(\gamma)
\label{eq:S17_01_backbone_argmax}\]</span>
여기서 <span class="math inline">\(\Gamma(\mathbf{x}\to\mathbf{y})\)</span>는 <span class="math inline">\(\mathbf{x}\)</span>에서 <span class="math inline">\(\mathbf{y}\)</span>로 연결 가능한 후보 경로들의 집합이다.
이 정의는 “전파가 선호하는 방향”을 <span class="math inline">\(g(\mu)\)</span>로 고정하며, 외부 동역학을 호출하지 않는다.</p>
<h3 data-number="19.1.5" id="회전-길이-ell_mathrmrot의-취급정의"><span class="header-section-number">19.1.5</span> 17.1.5 회전 길이 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 취급(정의)</h3>
<p>회전 길이 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>는 선택 확장 상수로 취급한다. <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 채택하는 경우, 다음 규칙을 고정한다.
<span class="math display">\[\ell_{\mathrm{rot}} \in \mathbb{R}_{&gt;0},
\qquad
\ell_{\mathrm{rot}} \text{의 수치/단위/출처는 }\texttt{canon\_lock}\text{ 또는 }\texttt{realization\_lock}\text{에 잠긴다.}
\label{eq:S17_01_lrot_lock}\]</span>
<span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 채택 여부가 바뀌면 LOCK 버전이 상승해야 한다.</p>
<h4 data-number="19.1.5.1" id="정의-회전률과-무차원-회전-강도"><span class="header-section-number">19.1.5.1</span> (정의) 회전률과 무차원 회전 강도</h4>
<p>회전률(각속도에 대응하는 운영 변수)을
<span class="math display">\[\Omega_{\mathrm{rot}}\in\mathbb{R}
\label{eq:S17_01_Omega}\]</span>
로 정의하고, 무차원 회전 강도를
<span class="math display">\[\chi_{\mathrm{rot}}
:=
\frac{\ell_{\mathrm{rot}}}{a}\,\Omega_{\mathrm{rot}}\,\Delta t
\label{eq:S17_01_chi_rot}\]</span>
로 정의한다. <span class="math inline">\(\chi_{\mathrm{rot}}\)</span>는 실현 길이 <span class="math inline">\(a\)</span>, 실현 시간 <span class="math inline">\(\Delta t\)</span> 및 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>의 잠김값에 의해 정의된다.</p>
<h3 data-number="19.1.6" id="회전-이방성-결합-규칙정의"><span class="header-section-number">19.1.6</span> 17.1.6 회전-이방성 결합 규칙(정의)</h3>
<p>회전 구동은 이방성 축 <span class="math inline">\(\mathbf{u}\)</span> 및 이방성 함수 <span class="math inline">\(g(\mu)\)</span>에 영향을 준다. 이를 다음 결합 사상으로 정의한다.
<span class="math display">\[\mathbf{u}\mapsto \mathbf{u}(\chi_{\mathrm{rot}}),\qquad
g(\mu)\mapsto g(\mu;\chi_{\mathrm{rot}})
\label{eq:S17_01_u_g_couple}\]</span>
결합 사상은 <code>analysis_lock</code>에 의해 잠기며, 사전등록 없이 결과에 맞추어 선택될 수 없다.</p>
<h4 data-number="19.1.6.1" id="정의-약결합-레짐과-강결합-레짐"><span class="header-section-number">19.1.6.1</span> (정의) 약결합 레짐과 강결합 레짐</h4>
<p><span class="math display">\[\text{약결합 레짐: }|\chi_{\mathrm{rot}}|\le \chi_{\star},
\qquad
\text{강결합 레짐: }|\chi_{\mathrm{rot}}|&gt; \chi_{\star}
\label{eq:S17_01_regime_rot}\]</span>
여기서 <span class="math inline">\(\chi_{\star}&gt;0\)</span>는 <code>analysis_lock</code>에 잠긴 문턱값이다. 약결합 레짐에서는
<span class="math display">\[g(\mu;\chi_{\mathrm{rot}})=g_0(\mu)+\chi_{\mathrm{rot}}\,g_1(\mu)+O(\chi_{\mathrm{rot}}^2)
\label{eq:S17_01_g_expand}\]</span>
와 같은 급수 형태의 운영 표현을 허용한다. 강결합 레짐에서는 급수 형태를 사용하지 않으며, 별도의 형태(예: 구간별 정의, 포화형)를 사전등록한 뒤 사용한다.</p>
<h3 data-number="19.1.7" id="실험-모듈-구조정의-파일-트리-프로토콜-산출물"><span class="header-section-number">19.1.7</span> 17.1.7 실험 모듈 구조(정의): 파일 트리, 프로토콜, 산출물</h3>
<p>회전/이방성 확장의 실험 모듈은 다음 디렉토리 구조로 고정한다.</p>
<pre><code>modules/
  rot_aniso/
    protocol.yaml
    locks_required.txt
    src/
      simulate_rot_aniso.py
      estimators.py
      gates.py
      io_schema.py
    schemas/
      protocol.schema.json
      run_log.schema.json
      metrics.schema.json
      manifest.schema.json
    plans/
      plan.json
    outputs_spec/
      artifacts.md</code></pre>
<h4 data-number="19.1.7.1" id="정의-입력lock-의존성-목록"><span class="header-section-number">19.1.7.1</span> (정의) 입력(LOCK) 의존성 목록</h4>
<p><code>locks_required.txt</code>는 다음 항목을 최소로 포함한다.</p>
<ul>
<li><p><code>canon_lock</code>: <span class="math inline">\(\delta\)</span>, <span class="math inline">\(\pi\)</span> 및 정준 정의들(필수)</p></li>
<li><p><code>realization_lock</code>: <span class="math inline">\(a\)</span>, <span class="math inline">\(\Delta t\)</span> 및 실현 정의들(필수)</p></li>
<li><p><code>analysis_lock</code>: <span class="math inline">\(g(\mu)\)</span>, <span class="math inline">\(\chi_{\star}\)</span>, 결합 사상, Gate 문턱값(필수)</p></li>
<li><p><code>canon_lock</code> 또는 <code>realization_lock</code>: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> (선택; 채택 시 필수)</p></li>
</ul>
<h4 data-number="19.1.7.2" id="정의-메트릭요약치와-gate"><span class="header-section-number">19.1.7.2</span> (정의) 메트릭(요약치)와 Gate</h4>
<p>회전/이방성 모듈은 다음 메트릭을 최소로 산출한다.</p>
<ul>
<li><p><span class="math inline">\(\beta_g\)</span> (이방성 크기; <a data-reference="eq:S17_01_beta_g" data-reference-type="eqref" href="#eq:S17_01_beta_g">[eq:S17_01_beta_g]</a>)</p></li>
<li><p><span class="math inline">\(\mathcal{A}_{\parallel}\)</span>, <span class="math inline">\(\mathcal{A}_{\perp}\)</span> (축 방향/수직 방향 전파 응답; 정의는 아래)</p></li>
<li><p><span class="math inline">\(\Delta_{\mathrm{bb}}\)</span> (백본 변화량; 정의는 아래)</p></li>
</ul>
<p>축 방향 및 수직 방향 응답은 동일 소스-싱크 조건에서의 도달 시간 또는 사건 플럭스 기반으로 다음과 같이 정의한다.
축과 평행인 테스트 방향 집합을 <span class="math inline">\(\mathcal{D}_{\parallel}\)</span>, 수직 방향 집합을 <span class="math inline">\(\mathcal{D}_{\perp}\)</span>라 두고,
각 방향 <span class="math inline">\(\hat{\mathbf{d}}\)</span>에 대한 응답을 <span class="math inline">\(A(\hat{\mathbf{d}})\)</span>로 정의하면,
<span class="math display">\[\mathcal{A}_{\parallel}:=\langle A(\hat{\mathbf{d}})\rangle_{\hat{\mathbf{d}}\in\mathcal{D}_{\parallel}},
\qquad
\mathcal{A}_{\perp}:=\langle A(\hat{\mathbf{d}})\rangle_{\hat{\mathbf{d}}\in\mathcal{D}_{\perp}}
\label{eq:S17_01_Apar_Aperp}\]</span>
로 정의한다. 백본 변화량은 등방 백본 <span class="math inline">\(\gamma^\star_{\mathrm{iso}}\)</span>와 이방성 백본 <span class="math inline">\(\gamma^\star_{\mathrm{aniso}}\)</span>의 링크 집합 차이로 정의한다.
링크 집합을 <span class="math inline">\(\mathcal{E}(\gamma)\)</span>라 하면,
<span class="math display">\[\Delta_{\mathrm{bb}}
:=
\frac{|\mathcal{E}(\gamma^\star_{\mathrm{aniso}})\,\triangle\,\mathcal{E}(\gamma^\star_{\mathrm{iso}})|}{|\mathcal{E}(\gamma^\star_{\mathrm{iso}})|}
\label{eq:S17_01_delta_bb}\]</span>
여기서 <span class="math inline">\(\triangle\)</span>는 대칭차집합이다.</p>
<p>Gate는 다음을 최소로 포함한다.</p>
<ul>
<li><p>(G-AN1) <span class="math inline">\(g(\mu)\)</span> 정규화 검증: <a data-reference="eq:S17_01_g_norm" data-reference-type="eqref" href="#eq:S17_01_g_norm">[eq:S17_01_g_norm]</a>을 수치오차 허용범위 내에서 만족.</p></li>
<li><p>(G-AN2) 이방성-응답 정합: <span class="math inline">\(\mathcal{A}_{\parallel}/\mathcal{A}_{\perp}\)</span>가 사전등록된 예측 범위에 포함.</p></li>
<li><p>(G-AN3) 백본 안정성: <span class="math inline">\(\Delta_{\mathrm{bb}}\)</span>가 레짐별 문턱값 이하(또는 이상) 조건을 만족.</p></li>
<li><p>(G-ROT) 회전 강도 레짐 판정: <span class="math inline">\(|\chi_{\mathrm{rot}}|\)</span>이 <a data-reference="eq:S17_01_regime_rot" data-reference-type="eqref" href="#eq:S17_01_regime_rot">[eq:S17_01_regime_rot]</a>의 레짐 선언과 일치.</p></li>
</ul>
<h2 data-number="19.2" id="제트특이점천체우주론-레짐-확장레짐맵에-편입"><span class="header-section-number">19.2</span> 17.2 제트/특이점/천체·우주론 레짐 확장(레짐맵에 편입)</h2>
<h3 data-number="19.2.1" id="대상-레짐의-분해정의"><span class="header-section-number">19.2.1</span> 17.2.1 대상 레짐의 분해(정의)</h3>
<p>제트/특이점/천체·우주론 레짐 확장은 다음의 3종 문제를 하나의 레짐맵으로 편입한다.</p>
<ul>
<li><p>(E-JET) <strong>제트 레짐</strong>: 국소 소스/싱크가 존재하고, 전파 백본이 강한 방향성을 갖는 outflow 패턴을 형성하는 레짐.</p></li>
<li><p>(E-CORE) <strong>코어-포화 레짐(특이점 대체)</strong>: 밀도/강성/목갭이 극단적으로 변하여 등방 근사가 붕괴하는 레짐.</p></li>
<li><p>(E-COSMO) <strong>대규모 경계 레짐(우주론 확장)</strong>: 경계 조건(유입/유출, 생성/소멸, 격자 규모)이 시간에 따라 변하는 레짐.</p></li>
</ul>
<p>이 절에서는 외부 이론의 동역학을 근거로 사용하지 않으며, 모두 사건/전파/목갭/백본/경계 조건의 운영 정의로만 구성한다.</p>
<h4 data-number="19.2.1.1" id="용어-제트와-제트류jet-stream"><span class="header-section-number">19.2.1.1</span> (용어) “제트”와 “제트류(jet stream)”</h4>
<p>본 절의 (E-JET)은 “소스/싱크가 만드는 outflow” 일반을 포함하며, 그중 시간적으로 <em>지속</em>되고 공간적으로 <em>가늘고 길게 유지</em>되는 경우를 본 문서에서는 “제트류”(jet stream)로 부른다. 제트류는 별도의 동역학 방정식이 아니라, 동일한 사건-플럭스 로그로부터 계산되는 <strong>지속성/폭/축 안정성</strong> Gate로만 판정된다(17.2.3).</p>
<h3 data-number="19.2.2" id="공통-프리미티브-소스싱크-플럭스-백본정의"><span class="header-section-number">19.2.2</span> 17.2.2 공통 프리미티브: 소스/싱크, 플럭스, 백본(정의)</h3>
<h4 data-number="19.2.2.1" id="정의-소스싱크-집합"><span class="header-section-number">19.2.2.1</span> (정의) 소스/싱크 집합</h4>
<p>격자 영역 <span class="math inline">\(\Lambda\subset\mathcal{L}\)</span>에 대해 소스 집합 <span class="math inline">\(\Lambda_{+}\subset\Lambda\)</span> 및 싱크 집합 <span class="math inline">\(\Lambda_{-}\subset\Lambda\)</span>를 정의하고,
<span class="math display">\[\Lambda_{+}\cap\Lambda_{-}=\varnothing
\label{eq:S17_02_src_sink_disjoint}\]</span>
을 부과한다. 소스/싱크는 사건률의 외부 주입/흡수 조건으로 정의한다.</p>
<h4 data-number="19.2.2.2" id="정의-주입흡수-사건률"><span class="header-section-number">19.2.2.2</span> (정의) 주입/흡수 사건률</h4>
<p>각 노드 <span class="math inline">\(\mathbf{n}\in\Lambda\)</span>에서의 순 주입 사건률을
<span class="math display">\[J(\mathbf{n},k)
:=
J_{+}(\mathbf{n},k)-J_{-}(\mathbf{n},k)
\label{eq:S17_02_Jdef}\]</span>
로 정의한다. 여기서 <span class="math inline">\(J_{+}\)</span>는 소스에서만 양수가 될 수 있고, <span class="math inline">\(J_{-}\)</span>는 싱크에서만 양수가 될 수 있다.
사전등록된 계획(plan) 파일은 <span class="math inline">\(J_{+},J_{-}\)</span>의 형태(상수, 펄스, 램프, 피드백 등)를 고정해야 한다.</p>
<h4 data-number="19.2.2.3" id="정의-플럭스와-제트-지표"><span class="header-section-number">19.2.2.3</span> (정의) 플럭스와 제트 지표</h4>
<p>소스에서 싱크로 전달되는 방향성 사건 플럭스를 측정하기 위하여, 링크 <span class="math inline">\((\mathbf{n}\to\mathbf{n}+\mathbf{e})\)</span>에 대한 사건 플럭스를 <span class="math inline">\(F_{\mathrm{ev}}(\mathbf{n},\mathbf{e};k_0,M)\)</span>로 정의한다.
격자 방향 단위벡터 집합을 <span class="math inline">\(\mathcal{E}=\{\pm\mathbf{e}_1,\dots,\pm\mathbf{e}_d\}\)</span>로 두면,
<span class="math display">\[F_{\mathrm{ev}}(\mathbf{n},\mathbf{e};k_0,M)
:=
\sum_{k\in W(k_0,M)} \sum_{s=1}^{3} \Xi_s(\mathbf{n},\mathbf{e};k)
\label{eq:S17_02_flux_link}\]</span>
<span id="eq:S17_02_Fev" label="eq:S17_02_Fev"></span>
로 정의한다. 여기서 <span class="math inline">\(\Xi_s\)</span>는 섹터 <span class="math inline">\(s\)</span> 사건이 링크 방향으로 전파되었음을 기록하는 링크-로그 지시자이며, 스키마로 고정되어야 한다.</p>
<h4 data-number="19.2.2.4" id="정의-플럭스-정의의-정합성4.1-5.3과의-연결"><span class="header-section-number">19.2.2.4</span> (정의) 플럭스 정의의 정합성(4.1, 5.3과의 연결)</h4>
<p><a data-reference="eq:S17_02_flux_link" data-reference-type="eqref" href="#eq:S17_02_flux_link">[eq:S17_02_flux_link]</a>의 <span class="math inline">\(F_{\mathrm{ev}}\)</span>는 “링크 단위 사건 카운트”로서, 4.1의 절단면 기반 토큰 플럭스 <a data-reference="eq:flux_def" data-reference-type="eqref" href="#eq:flux_def">[eq:flux_def]</a> 및 5.3.5의 방향성 사건 집계 <a data-reference="eq:S05_Sdelta" data-reference-type="eqref" href="#eq:S05_Sdelta">[eq:S05_Sdelta]</a>의 <em>링크 분해(link-resolved)</em> 버전이다. 즉, 절단면 <span class="math inline">\(\Sigma\)</span>가 특정 링크 집합의 합으로 표현되는 프로토콜이 잠기면,
<span class="math display">\[\Delta N_\Sigma \ \propto\ \sum_{(\mathbf{n},\mathbf{e})\in\Sigma} F_{\mathrm{ev}}(\mathbf{n},\mathbf{e};k_0,M),
\label{eq:S17_02_flux_consistency}\]</span>
<span id="eq:S17_02_consistency" label="eq:S17_02_consistency"></span>
과 같은 연결식을 Gate로 점검할 수 있다(프로토콜/대표점/스키마가 잠기지 않으면 정의 불능).</p>
<h4 data-number="19.2.2.5" id="정의-링크-사건-플럭스율시간-정규화"><span class="header-section-number">19.2.2.5</span> (정의) 링크 사건 플럭스율(시간 정규화)</h4>
<p>측정 창 길이를 <span class="math inline">\(\Delta T_{\mathrm{win}}:=M\Delta t\)</span>로 잠그면, 링크 사건 플럭스율을
<span class="math display">\[\Phi_{\mathrm{ev}}(\mathbf{n},\mathbf{e};k_0,M)
:=
\frac{1}{\Delta T_{\mathrm{win}}}\,F_{\mathrm{ev}}(\mathbf{n},\mathbf{e};k_0,M)
\label{eq:S17_02_phi_ev}\]</span>
<span id="eq:S17_02_Phi_ev" label="eq:S17_02_Phi_ev"></span>
로 정의한다. <span class="math inline">\(\Phi_{\mathrm{ev}}\)</span>는 “사건/시간”의 요약치이며, 토큰 플럭스로의 실현은 4.1의 <span class="math inline">\(a^3\)</span> 정규화와 절단면 스키마를 통해서만 수행된다.</p>
<p>제트의 방향성(콜리메이션) 지표를 다음으로 정의한다.
<span class="math display">\[\mathcal{J}
:=
\frac{\max_{\hat{\mathbf{d}}}\ \sum_{(\mathbf{n},\mathbf{e})\in \mathcal{C}(\hat{\mathbf{d}})} F_{\mathrm{ev}}(\mathbf{n},\mathbf{e})}
{\sum_{(\mathbf{n},\mathbf{e})\in \Lambda\times\mathcal{E}} F_{\mathrm{ev}}(\mathbf{n},\mathbf{e})}
\in[0,1]
\label{eq:S17_02_Jindex}\]</span>
여기서 <span class="math inline">\(\mathcal{C}(\hat{\mathbf{d}})\)</span>는 방향 <span class="math inline">\(\hat{\mathbf{d}}\)</span>에 정렬된 링크들의 관측 원뿔(또는 관측 실린더) 내 집합이다.
<span class="math inline">\(\mathcal{J}\)</span>가 1에 가까울수록 플럭스가 좁은 방향으로 집중된다.</p>
<h4 data-number="19.2.2.6" id="정의-제트-축-방향추정기"><span class="header-section-number">19.2.2.6</span> (정의) 제트 축 방향(추정기)</h4>
<p><a data-reference="eq:S17_02_Jindex" data-reference-type="eqref" href="#eq:S17_02_Jindex">[eq:S17_02_Jindex]</a>의 최대화를 달성하는 방향을 제트 축으로 정의한다.
<span class="math display">\[\hat{\mathbf{d}}_{\mathrm{J}}
:=
\operatorname*{arg\,max}_{\hat{\mathbf{d}}}\
\sum_{(\mathbf{n},\mathbf{e})\in \mathcal{C}(\hat{\mathbf{d}})} F_{\mathrm{ev}}(\mathbf{n},\mathbf{e})
\label{eq:S17_02_dJ_def}\]</span>
<span id="eq:S17_02_aJ" label="eq:S17_02_aJ"></span>
동률(복수 최대값)이 발생하면 <code>analysis_lock</code>에 잠긴 타이브레이크 규칙(예: <span class="math inline">\(\sum F_{\mathrm{ev}}(\mathbf{n},\mathbf{e})\,\mathbf{e}\)</span>의 방향과 가장 근접한 후보 선택)으로 유일화를 강제한다. 타이브레이크가 잠기지 않으면 <span class="math inline">\(\hat{\mathbf{d}}_{\mathrm{J}}\)</span>는 정의 불능이다.</p>
<h4 data-number="19.2.2.7" id="정의-제트-폭개구각-요약치"><span class="header-section-number">19.2.2.7</span> (정의) 제트 폭(개구각) 요약치</h4>
<p>관측 원뿔을 채택한 경우(프로토콜 잠금), 방향 <span class="math inline">\(\hat{\mathbf{d}}_{\mathrm{J}}\)</span>를 중심으로 반개구각 <span class="math inline">\(\theta\)</span>를 갖는 관측 원뿔을 <span class="math inline">\(\mathcal{C}(\hat{\mathbf{d}}_{\mathrm{J}},\theta)\)</span>로 표기한다(관측 원뿔의 구체적 구현은 <code>analysis_lock</code>에 잠김).
누적 플럭스가 전체의 비율 <span class="math inline">\(q\in(0,1)\)</span>을 포함하도록 하는 최소 반개구각을
<span class="math display">\[\theta_{\mathrm{J}}(q)
:=
\inf\Bigl\{\theta\in(0,\pi/2]\ \Big|\
\sum_{(\mathbf{n},\mathbf{e})\in\mathcal{C}(\hat{\mathbf{d}}_{\mathrm{J}},\theta)}F_{\mathrm{ev}}(\mathbf{n},\mathbf{e})
\ge q\!\!\sum_{(\mathbf{n},\mathbf{e})\in\Lambda\times\mathcal{E}}F_{\mathrm{ev}}(\mathbf{n},\mathbf{e})
\Bigr\}
\label{eq:S17_02_thetaJ_def}\]</span>
<span id="eq:S17_02_theta" label="eq:S17_02_theta"></span>
로 정의한다. 여기서 <span class="math inline">\(q=q_\star\)</span>는 사전등록된 값이다. <span class="math inline">\(\theta_{\mathrm{J}}(q_\star)\)</span>가 작을수록 “가늘다”는 의미가 강화된다. 실린더 관측을 채택한 경우에는 동일한 방식으로 최소 반지름 <span class="math inline">\(r_{\mathrm{J}}(q_\star)\)</span>로 대체 정의한다(프로토콜로 잠금).</p>
<h3 data-number="19.2.3" id="제트-레짐e-jet의-정의와-gate"><span class="header-section-number">19.2.3</span> 17.2.3 제트 레짐(E-JET)의 정의와 Gate</h3>
<p>제트 레짐은 다음 조건을 동시에 만족하는 실행 구간으로 정의한다.
<span class="math display">\[\text{(JET-R1)}\quad \sum_{\mathbf{n}\in\Lambda_{+}}J_{+}(\mathbf{n},k) &gt; 0,
\qquad
\text{(JET-R2)}\quad \sum_{\mathbf{n}\in\Lambda_{-}}J_{-}(\mathbf{n},k) &gt; 0
\label{eq:S17_02_jet_R12}\]</span>
<span id="eq:S17_03_JR1" label="eq:S17_03_JR1"></span>
<span id="eq:S17_03_JR2" label="eq:S17_03_JR2"></span>
그리고 콜리메이션 Gate를 다음으로 정의한다.
<span class="math display">\[\mathrm{PASS}_{\mathrm{JET}}
:\Longleftrightarrow
\mathcal{J}\ge \mathcal{J}_{\star}
\label{eq:S17_02_pass_jet}\]</span>
<span id="eq:S17_03_gateJET" label="eq:S17_03_gateJET"></span>
여기서 <span class="math inline">\(\mathcal{J}_{\star}\in(0,1)\)</span>는 사전등록된 문턱값이다.
제트 패턴의 주장(예: “제트가 형성된다”)은 <span class="math inline">\(\mathrm{PASS}_{\mathrm{JET}}\)</span>가 성립할 때만 자격을 갖는다.</p>
<h4 data-number="19.2.3.1" id="정의-시간-분해와-지속성제트류-후보"><span class="header-section-number">19.2.3.1</span> (정의) 시간 분해와 지속성(제트류 후보)</h4>
<p>제트가 “순간 패턴”이 아니라 “류(stream)”로 불리려면 시간 방향의 지속성을 추가로 요구한다.
프로토콜이 길이 <span class="math inline">\(M\)</span>의 관측 창들을 <span class="math inline">\(\{W_i\}_{i=1}^{T}\)</span>로 선언하면, 각 창 <span class="math inline">\(W_i\)</span>에 대해 <span class="math inline">\((\mathcal{J}_i,\hat{\mathbf{d}}_{\mathrm{J},i},\theta_{\mathrm{J},i}(q_\star))\)</span>를 계산한다.
제트 지속성 지표를
<span class="math display">\[P_{\mathrm{J}}
:=
\frac{1}{T}\sum_{i=1}^{T}\mathbb{I}\bigl[\mathcal{J}_i\ge \mathcal{J}_\star\bigr]
\in[0,1]
\label{eq:S17_02_PJ_def}\]</span>
<span id="eq:S17_03_PJ" label="eq:S17_03_PJ"></span>
로 정의한다. 또한 축 안정성(요동) 지표를
<span class="math display">\[M_{\mathrm{J}}
:=
\frac{1}{T-1}\sum_{i=2}^{T}\arccos\!\bigl(|\hat{\mathbf{d}}_{\mathrm{J},i}\cdot \hat{\mathbf{d}}_{\mathrm{J},i-1}|\bigr)
\label{eq:S17_02_MJ_def}\]</span>
<span id="eq:S17_03_MJ" label="eq:S17_03_MJ"></span>
로 정의한다. <span class="math inline">\(M_{\mathrm{J}}\)</span>가 작을수록 축이 시간에 대해 안정적이다. 절대값은 축 반대 방향 동치를 동일하게 취급하기 위한 잠긴 규약이다.</p>
<h4 data-number="19.2.3.2" id="정의-제트-폭의-시간-평균제트류-요약치"><span class="header-section-number">19.2.3.2</span> (정의) 제트 폭의 시간 평균(제트류 요약치)</h4>
<p>창별 폭 <span class="math inline">\(\theta_{\mathrm{J},i}(q_\star)\)</span>로부터 제트 폭의 시간 평균을
<span class="math display">\[\overline{\theta}_{\mathrm{J}}(q_\star)
:=
\frac{1}{T}\sum_{i=1}^{T}\theta_{\mathrm{J},i}(q_\star)
\label{eq:S17_02_thetaJ_mean}\]</span>
로 정의한다. <span class="math inline">\(\overline{\theta}_{\mathrm{J}}\)</span>가 작을수록 제트류가 “가늘게” 유지된다고 판정한다.</p>
<h4 data-number="19.2.3.3" id="선택-gate-이방성-축-정합"><span class="header-section-number">19.2.3.3</span> (선택 Gate) 이방성 축 정합</h4>
<p>이방성 축 <span class="math inline">\(\mathbf{u}\)</span>가 선언된 실행에서는, 제트 축이 이방성 축과 정합되는지를 다음으로 판정한다.
시간 평균 정합도를
<span class="math display">\[A_{\mathrm{align}}
:=
\frac{1}{T}\sum_{i=1}^{T}\left|\hat{\mathbf{d}}_{\mathrm{J},i}\cdot \mathbf{u}\right|
\label{eq:S17_02_Aalign_def}\]</span>
로 두고,
<span class="math display">\[\mathrm{PASS}_{\mathrm{ALIGN}}
:\Longleftrightarrow
A_{\mathrm{align}}\ge \mu_\star
\label{eq:S17_02_pass_align}\]</span>
<span id="eq:S17_03_gateALIGN" label="eq:S17_03_gateALIGN"></span>
로 정의한다. 여기서 <span class="math inline">\(\mu_\star\in(0,1)\)</span>는 사전등록된 문턱값이다. <span class="math inline">\(\mathbf{u}\)</span>가 없는 실행에서는 이 Gate를 평가하지 않으며, 평가하지 않은 Gate를 근거로 끌어오는 행위는 금지된다(결론 자격: <code>INCONCLUSIVE</code>).</p>
<h4 data-number="19.2.3.4" id="정의-제트류-gate"><span class="header-section-number">19.2.3.4</span> (정의) 제트류 Gate</h4>
<p>제트류는 (E-JET) 레짐 조건 <a data-reference="eq:S17_02_jet_R12" data-reference-type="eqref" href="#eq:S17_02_jet_R12">[eq:S17_02_jet_R12]</a>가 성립하는 실행에서만 평가한다.
또한 시간 분해가 선언된 경우, 창별 콜리메이션 Gate <a data-reference="eq:S17_02_pass_jet" data-reference-type="eqref" href="#eq:S17_02_pass_jet">[eq:S17_02_pass_jet]</a>의 <code>PASS</code> 비율이 <a data-reference="eq:S17_02_PJ_def" data-reference-type="eqref" href="#eq:S17_02_PJ_def">[eq:S17_02_PJ_def]</a>의 <span class="math inline">\(P_{\mathrm{J}}\)</span>와 동치가 되도록 프로토콜을 잠근다.
<span class="math display">\[\mathrm{PASS}_{\mathrm{JSTREAM}}
:\Longleftrightarrow
\Bigl(P_{\mathrm{J}}\ge P_\star\Bigr)
\wedge
\Bigl(\overline{\theta}_{\mathrm{J}}(q_\star)\le \theta_\star\Bigr)
\wedge
\Bigl(M_{\mathrm{J}}\le M_\star\Bigr)
\label{eq:S17_02_pass_jstream}\]</span>
<span id="eq:S17_03_gateJSTREAM" label="eq:S17_03_gateJSTREAM"></span>
여기서 <span class="math inline">\(P_\star,\theta_\star,M_\star\)</span>와 <span class="math inline">\(q_\star\)</span>는 사전등록된 문턱/파라미터이다. 제트류라는 용어는 <a data-reference="eq:S17_02_pass_jstream" data-reference-type="eqref" href="#eq:S17_02_pass_jstream">[eq:S17_02_pass_jstream]</a>이 <code>PASS</code>일 때만 결론으로 사용된다.</p>
<h4 data-number="19.2.3.5" id="대응표-비근거-대기-제트류지구로의-맵핑"><span class="header-section-number">19.2.3.5</span> (대응표; 비근거) 대기 제트류(지구)로의 맵핑</h4>
<p>본 문서는 대기역학 방정식(예: QG, Navier–Stokes)을 근거로 사용하지 않는다. 다만 실체 예시로서 “제트류”를 다음 프로토콜-대응으로 읽을 수 있다.</p>
<ul>
<li><p>도메인 <span class="math inline">\(\Lambda\)</span>: 위도–경도(및 고도) 격자에서 특정 고도대/등압면을 선택한 띠(band) 영역. 경도 방향은 주기 경계로 잠그고, 위도 방향은 유입/유출 또는 감쇠 경계로 잠근다(E-COSMO와 결합).</p></li>
<li><p>소스/싱크 <span class="math inline">\(\Lambda_{\pm}\)</span>: 저위도대(주입)와 고위도대(흡수) 또는 동서 경계의 유입/유출을 belt 형태 집합으로 선언한다(점 소스 강제는 필요하지 않음).</p></li>
<li><p>회전/이방성: <span class="math inline">\(\chi_{\mathrm{rot}}\neq 0\)</span>인 실행에서 결합 사상 <a data-reference="eq:S17_01_u_g_couple" data-reference-type="eqref" href="#eq:S17_01_u_g_couple">[eq:S17_01_u_g_couple]</a>로부터 <span class="math inline">\(\mathbf{u}\)</span>가 실질적인 제트 선호 방향을 제공한다(방향 자체는 Gate로 판정).</p></li>
<li><p>관측량: 데이터(또는 시뮬레이션)에서 사건-로그를 추출하는 규약을 <code>plan.json</code>에 잠근 뒤, <a data-reference="eq:S17_02_Jindex" data-reference-type="eqref" href="#eq:S17_02_Jindex">[eq:S17_02_Jindex]</a>–<a data-reference="eq:S17_02_pass_jstream" data-reference-type="eqref" href="#eq:S17_02_pass_jstream">[eq:S17_02_pass_jstream]</a>의 메트릭/ Gate를 계산한다. 여기서 추출 규약이 잠기지 않으면 비교는 <code>INCONCLUSIVE</code>이다.</p></li>
</ul>
<p>위 대응은 “설명 스케치”이며, 결론 근거가 아니다. 결론은 항상 동일한 LOCK<span class="math inline">\(\rightarrow\)</span>유도<span class="math inline">\(\rightarrow\)</span>Gate 흐름에서만 생성된다.</p>
<h3 data-number="19.2.4" id="코어-포화-레짐e-core의-정의특이점-대체"><span class="header-section-number">19.2.4</span> 17.2.4 코어-포화 레짐(E-CORE)의 정의(특이점 대체)</h3>
<h4 data-number="19.2.4.1" id="정의-포화-지표"><span class="header-section-number">19.2.4.1</span> (정의) 포화 지표</h4>
<p>코어 영역 <span class="math inline">\(\Lambda_{\mathrm{core}}\subset\Lambda\)</span>를 선택하고(사전등록), 코어 포화 지표를
<span class="math display">\[S_{\mathrm{core}}(k_0,M)
:=
\frac{\sum_{\mathbf{n}\in\Lambda_{\mathrm{core}}} N(\mathbf{n};k_0,M)}
{\sum_{\mathbf{n}\in\Lambda} N(\mathbf{n};k_0,M)}
\label{eq:S17_02_Score}\]</span>
<span id="eq:S17_04_Score" label="eq:S17_04_Score"></span>
로 정의한다. <span class="math inline">\(S_{\mathrm{core}}\)</span>는 사건이 코어에 집중되는 정도를 나타낸다.</p>
<h4 data-number="19.2.4.2" id="정의-목갭-붕괴경화-레짐"><span class="header-section-number">19.2.4.2</span> (정의) 목갭 붕괴/경화 레짐</h4>
<p>코어에서 유효 목갭(또는 등가 전파 저항)을 <span class="math inline">\(\delta_{\mathrm{eff}}(\mathbf{n})\)</span>로 두고, 코어 평균을
<span class="math display">\[\overline{\delta}_{\mathrm{core}}
:=
\frac{1}{|\Lambda_{\mathrm{core}}|}\sum_{\mathbf{n}\in\Lambda_{\mathrm{core}}}\delta_{\mathrm{eff}}(\mathbf{n})
\label{eq:S17_02_dcore}\]</span>
<span id="eq:S17_04_deltaeff" label="eq:S17_04_deltaeff"></span>
로 정의한다. 코어-포화 레짐은 다음 둘 중 하나가 성립하는 구간으로 정의한다.
<span class="math display">\[\text{(CORE-A)}\quad S_{\mathrm{core}}\ge S_{\star},
\qquad
\text{(CORE-B)}\quad \overline{\delta}_{\mathrm{core}}\le \delta_{\star}
\label{eq:S17_02_core_regime}\]</span>
<span id="eq:S17_04_COREA" label="eq:S17_04_COREA"></span>
<span id="eq:S17_04_COREB" label="eq:S17_04_COREB"></span>
여기서 <span class="math inline">\(S_{\star}\)</span>, <span class="math inline">\(\delta_{\star}\)</span>는 사전등록된 문턱값이다.
이 레짐은 등방 근사, 약결합 근사, 또는 선형화 근사가 자동으로 성립하지 않는 레짐으로 분류된다.</p>
<h4 data-number="19.2.4.3" id="정의-특이점-주장-금지-규칙"><span class="header-section-number">19.2.4.3</span> (정의) 특이점 주장 금지 규칙</h4>
<p>코어-포화 레짐에서는 “무한” 또는 “발산”을 결론 용어로 사용하지 않는다.
포화 레짐은 사건률 집중과 전파 제한(목갭 구조)로 기술하며, 결론은 Gate-판정 가능한 요약치(<span class="math inline">\(S_{\mathrm{core}}\)</span>, <span class="math inline">\(\overline{\delta}_{\mathrm{core}}\)</span>, <span class="math inline">\(\mathcal{J}\)</span> 등)로만 표기한다.</p>
<h3 data-number="19.2.5" id="대규모-경계-레짐e-cosmo의-운영-정의"><span class="header-section-number">19.2.5</span> 17.2.5 대규모 경계 레짐(E-COSMO)의 운영 정의</h3>
<h4 data-number="19.2.5.1" id="정의-동적-경계-입력"><span class="header-section-number">19.2.5.1</span> (정의) 동적 경계 입력</h4>
<p>격자 경계 또는 외부 저장소로부터의 순 유입/유출을 시간 의존 입력으로 정의한다.
경계 집합을 <span class="math inline">\(\partial\Lambda\)</span>로 두고,
<span class="math display">\[J_{\partial}(\mathbf{n},k)\quad(\mathbf{n}\in\partial\Lambda)
\label{eq:S17_02_Jboundary}\]</span>
를 동적 경계 입력으로 정의한다. <span class="math inline">\(J_{\partial}\)</span>의 형태는 <code>plan.json</code>에 사전등록되어야 하며, 실행 후 변경은 금지된다.</p>
<h4 data-number="19.2.5.2" id="정의-격자-규모스케일-추적-변수"><span class="header-section-number">19.2.5.2</span> (정의) 격자 규모(스케일) 추적 변수</h4>
<p>대규모 레짐에서는 격자 규모를 고정하지 않고, 관측 창마다 유효 규모를 요약치로 정의한다.
예를 들어, 사건 밀도의 중심 2차 모멘트로부터 유효 반경을
<span class="math display">\[R_{\mathrm{eff}}^2(k_0,M)
:=
\frac{\sum_{\mathbf{n}\in\Lambda}\|\mathbf{x}(\mathbf{n})-\mathbf{x}_{\mathrm{cm}}\|^2\,\rho(\mathbf{n};k_0,M)}
{\sum_{\mathbf{n}\in\Lambda}\rho(\mathbf{n};k_0,M)}
\label{eq:S17_02_Reff}\]</span>
로 정의한다. 여기서
<span class="math display">\[\mathbf{x}_{\mathrm{cm}}
:=
\frac{\sum_{\mathbf{n}\in\Lambda}\mathbf{x}(\mathbf{n})\,\rho(\mathbf{n};k_0,M)}
{\sum_{\mathbf{n}\in\Lambda}\rho(\mathbf{n};k_0,M)}
\label{eq:S17_02_xcm}\]</span>
이다. <span class="math inline">\(R_{\mathrm{eff}}\)</span>는 “대규모 변화”를 판정하는 운영 요약치로만 사용한다.</p>
<h4 data-number="19.2.5.3" id="정의-대규모-레짐-gate"><span class="header-section-number">19.2.5.3</span> (정의) 대규모 레짐 Gate</h4>
<p>대규모 레짐의 주장(예: “스케일 변화가 관측된다”)은 다음 Gate를 만족할 때만 자격을 갖는다.
<span class="math display">\[\mathrm{PASS}_{\mathrm{COSMO}}
:\Longleftrightarrow
\left|\frac{R_{\mathrm{eff}}(k_1,M)-R_{\mathrm{eff}}(k_0,M)}{R_{\mathrm{eff}}(k_0,M)}\right|
\ge \eta_{\star}
\label{eq:S17_02_pass_cosmo}\]</span>
여기서 <span class="math inline">\(\eta_{\star}&gt;0\)</span>는 사전등록된 문턱값이며, <span class="math inline">\(k_1-k_0\)</span> 및 <span class="math inline">\(M\)</span>은 프로토콜에 의해 고정되어야 한다.</p>
<h4 data-number="19.2.5.4" id="파생-관측량-예-적색편이-z와-거리-추정"><span class="header-section-number">19.2.5.4</span> (파생 관측량 예) 적색편이 <span class="math inline">\(z\)</span>와 거리 추정</h4>
<p>10.8에서 정의한 격자 마찰 적색편이 모델을 E-COSMO 레짐의 파생 관측량으로 연결한다.
각 소스의 관측 적색편이 <span class="math inline">\(z\)</span>로부터 유효 경로 길이(거리) 추정치를
<span class="math display">\[D_{z}
:=
\frac{1}{\kappa}\ln(1+z)
\label{eq:S17_02_Dz_def}\]</span>
로 정의한다.
<span class="math inline">\(\kappa\)</span>는 LOCK(또는 사전등록된 보정 절차)으로부터 얻어져야 하며, 결과를 본 뒤 조정하는 행위는 금지된다.</p>
<h4 data-number="19.2.5.5" id="lock-kappa의-캘리브레이션검증-분리"><span class="header-section-number">19.2.5.5</span> (LOCK) <span class="math inline">\(\kappa\)</span>의 캘리브레이션/검증 분리</h4>
<p>거리 닻(앵커) 표본 <span class="math inline">\(\{(D_{\mathrm{anch},i},z_i)\}\)</span>가 존재할 때,
<span class="math inline">\(\kappa\)</span>는 사전등록된 캘리브레이션 집합 <span class="math inline">\(\mathcal{S}_{\mathrm{cal}}\)</span>에서만 추정하고,
검증 집합 <span class="math inline">\(\mathcal{S}_{\mathrm{val}}\)</span>에서는 <em>고정된</em> <span class="math inline">\(\kappa\)</span>로만 판정한다.
예를 들어 가중 최소제곱을 채택하면
<span class="math display">\[\widehat{\kappa}
=
\arg\min_{\kappa}\sum_{i\in\mathcal{S}_{\mathrm{cal}}}w_i\left(\ln(1+z_i)-\kappa D_{\mathrm{anch},i}\right)^2
=
\frac{\sum_{i\in\mathcal{S}_{\mathrm{cal}}}w_i D_{\mathrm{anch},i}\ln(1+z_i)}
{\sum_{i\in\mathcal{S}_{\mathrm{cal}}}w_i D_{\mathrm{anch},i}^2}
\label{eq:S17_02_kappa_hat}\]</span>
로 고정할 수 있다. <span class="math inline">\((w_i)\)</span>, <span class="math inline">\(\mathcal{S}_{\mathrm{cal}}/\mathcal{S}_{\mathrm{val}}\)</span> 선택은 실행 전에 LOCK되어야 한다.</p>
<h4 data-number="19.2.5.6" id="gate-z거리-사상의-교차검증"><span class="header-section-number">19.2.5.6</span> (Gate) <span class="math inline">\(z\)</span>–거리 사상의 교차검증</h4>
<p>검증 집합 <span class="math inline">\(\mathcal{S}_{\mathrm{val}}\)</span>에서
<span class="math display">\[\Delta_i
:=
\frac{D_{z,i}-D_{\mathrm{anch},i}}{D_{\mathrm{anch},i}}
\qquad(i\in\mathcal{S}_{\mathrm{val}})
\label{eq:S17_02_delta_i}\]</span>
를 정의하고,
<span class="math display">\[\mathrm{PASS}_{z\text{-dist}}
:\Longleftrightarrow
\mathrm{median}_{i\in\mathcal{S}_{\mathrm{val}}}\left(|\Delta_i|\right)\le \epsilon_{\mathrm{med}}^{\star}
\ \wedge\
\sqrt{\mathrm{mean}_{i\in\mathcal{S}_{\mathrm{val}}}(\Delta_i^2)}\le \epsilon_{\mathrm{rms}}^{\star}
\label{eq:S17_02_pass_zdist}\]</span>
를 Gate로 둔다. <span class="math inline">\(\epsilon_{\mathrm{med}}^{\star},\epsilon_{\mathrm{rms}}^{\star}&gt;0\)</span>는 사전등록된 문턱값이다.
이 Gate를 통과하지 못하면, E-COSMO 레짐에서 <a data-reference="eq:S17_02_Dz_def" data-reference-type="eqref" href="#eq:S17_02_Dz_def">[eq:S17_02_Dz_def]</a>는 거리 닻과 양립하지 않는 것으로 <code>FAIL</code>이다.</p>
<h4 data-number="19.2.5.7" id="필수-lock-관측-매핑-d_z를-d_ld_a-및-플럭스각크기-예측으로-확장"><span class="header-section-number">19.2.5.7</span> (필수 LOCK) 관측 매핑: <span class="math inline">\(D_z\)</span>를 <span class="math inline">\(D_L,D_A\)</span> 및 플럭스/각크기 예측으로 확장</h4>
<p><a data-reference="eq:S17_02_Dz_def" data-reference-type="eqref" href="#eq:S17_02_Dz_def">[eq:S17_02_Dz_def]</a>의 <span class="math inline">\(D_z\)</span>는 <em>경로 길이</em>로 정의되며, 관측 플럭스/각크기와 직접 비교하려면
<span class="math inline">\(D_z\mapsto D_L^{(\mathrm{model})}\)</span> 및 <span class="math inline">\(D_z\mapsto D_A^{(\mathrm{model})}\)</span> 매핑이 필요하다.
이를 위해 <strong>감쇠 인자</strong> <span class="math inline">\(\Phi(z)\)</span>와 <strong>각/면적 매핑 인자</strong> <span class="math inline">\(\Upsilon(z)\)</span>를 다음처럼 정의한다.
<span class="math display">\[F_{\mathrm{obs}}(z)
:=
\frac{L}{4\pi D_z^2}\,\Phi(z),
\qquad
D_L^{(\mathrm{model})}(z):=\frac{D_z}{\sqrt{\Phi(z)}}
\label{eq:S17_02_flux_mapping}\]</span>
<span class="math display">\[D_A^{(\mathrm{model})}(z):=\frac{D_z}{\Upsilon(z)}
\label{eq:S17_02_ang_mapping}\]</span>
또한 시간척도(라이트커브 폭, 변광 주기 등)의 관측/방출 관계를
<span class="math display">\[\tau_{\mathrm{obs}}(z):=\tau_{\mathrm{em}}\,T(z)
\label{eq:S17_02_time_dilation_T}\]</span>
로 정의한다.
여기서 <span class="math inline">\(\Phi,\Psi,T\)</span>의 <strong>함수 형태 및 추정 절차는 실행 전에 LOCK</strong>되어야 하며,
결과를 본 뒤 맞추기 위해 수정하는 행위는 금지한다.
<em>(예시)</em> 정적 기하( <span class="math inline">\(\Upsilon\equiv 1\)</span> ), 시간 신장 없음( <span class="math inline">\(T\equiv 1\)</span> ), 에너지 감소만 포함( <span class="math inline">\(\Phi(z)=(1+z)^{-1}\)</span> )을 채택하면
<span class="math inline">\(D_L^{(\mathrm{model})}=D_z\sqrt{1+z}\)</span> 및 표면밝기 <span class="math inline">\(B_{\mathrm{obs}}\propto(1+z)^{-1}\)</span>가 도출되지만,
이는 단지 한 <strong>분기 예시</strong>이며 채택 여부는 LOCK으로만 결정된다.</p>
<h4 data-number="19.2.5.8" id="gate-시간-신장time-dilation-판정"><span class="header-section-number">19.2.5.8</span> (Gate) 시간 신장(Time dilation) 판정</h4>
<p>표준화된 사건(예: Ia형 초신성)에서 방출 시간척도 <span class="math inline">\(\tau_{\mathrm{em}}\)</span>가 교정되었다고 가정하고,
관측치 <span class="math inline">\((z_i,\tau_{\mathrm{obs},i})\)</span>로부터
<span class="math display">\[r_i^{\mathrm{TD}}:=\frac{\tau_{\mathrm{obs},i}/\tau_{\mathrm{em},i}}{T(z_i)}-1
\label{eq:S17_02_r_TD}\]</span>
를 정의한다. 그리고
<span class="math display">\[\mathrm{PASS}_{\mathrm{TD}}
:\Longleftrightarrow
\mathrm{median}_i\bigl(|r_i^{\mathrm{TD}}|\bigr)\le \epsilon_{\mathrm{TD}}^{\star}
\label{eq:S17_02_pass_TD}\]</span>
를 Gate로 둔다(<span class="math inline">\(\epsilon_{\mathrm{TD}}^{\star}\)</span>는 사전등록).
<span class="math inline">\(\tau_{\mathrm{em}}\)</span> 교정이 불가능하거나 <span class="math inline">\(T(z)\)</span>가 LOCK되지 않은 경우는 <code>INCONCLUSIVE</code>이다.</p>
<h4 data-number="19.2.5.9" id="gate-표면밝기tolman형-판정"><span class="header-section-number">19.2.5.9</span> (Gate) 표면밝기(Tolman형) 판정</h4>
<p>표준화된 소스 클래스에 대해 방출 표면밝기 <span class="math inline">\(B_0\)</span> (rest-frame 교정 포함)가 잠겨 있다고 가정한다.
관측 표면밝기 <span class="math inline">\(B_{\mathrm{obs}}(z)\)</span>는 <a data-reference="eq:S17_02_flux_mapping" data-reference-type="eqref" href="#eq:S17_02_flux_mapping">[eq:S17_02_flux_mapping]</a>–<a data-reference="eq:S17_02_ang_mapping" data-reference-type="eqref" href="#eq:S17_02_ang_mapping">[eq:S17_02_ang_mapping]</a>로부터
<span class="math display">\[B_{\mathrm{obs}}(z)=B_0\,\frac{\Phi(z)}{\Upsilon(z)^2}
\label{eq:S17_02_Bobs_pred}\]</span>
를 예측한다. 따라서
<span class="math display">\[r_i^{\mathrm{TOL}}:=\frac{B_{\mathrm{obs},i}}{B_0}\,\frac{\Upsilon(z_i)^2}{\Phi(z_i)}-1
\label{eq:S17_02_r_TOL}\]</span>
를 정의하고,
<span class="math display">\[\mathrm{PASS}_{\mathrm{TOL}}
:\Longleftrightarrow
\mathrm{median}_i\bigl(|r_i^{\mathrm{TOL}}|\bigr)\le \epsilon_{\mathrm{TOL}}^{\star}
\label{eq:S17_02_pass_TOL}\]</span>
를 Gate로 둔다(<span class="math inline">\(\epsilon_{\mathrm{TOL}}^{\star}\)</span>는 사전등록).
<span class="math inline">\(B_0\)</span>의 표준화(진화/밴드/케이보정 포함)가 LOCK되지 않으면 이 Gate는 <code>INCONCLUSIVE</code>이다.</p>
<h4 data-number="19.2.5.10" id="gate-영상-블러링선폭-증가blurbroadening-판정"><span class="header-section-number">19.2.5.10</span> (Gate) 영상 블러링/선폭 증가(Blur/Broadening) 판정</h4>
<p>격자 마찰/산란(매질성)이 존재한다면, 주파수 감쇠와 함께 <em>영상 블러링(각분산)</em>, <em>선폭 증가(line broadening)</em>, <em>위상 요동</em> 등 추가 관측 서명이 동반될 수 있다.
따라서 “팽창 대체” 수준의 결론에서는, 모델이 도입하는 추가 블러링이 관측 허용오차를 초과하지 않음을 Gate로 판정한다.
이를 위해 각 소스 <span class="math inline">\(i\)</span>에 대해 (기기 PSF/분광기 해상도 및 rest-frame 보정까지 포함하여) 블러링 지표 <span class="math inline">\(b_{\mathrm{obs},i}\)</span>를 정의하고,
표준화된 고유 지표 <span class="math inline">\(b_0\)</span> 및 모델 예측 블러링 인자 <span class="math inline">\(B_{\mathrm{BLR}}(z)\)</span>를 잠긴 입력으로 둔다.
잔차를
<span class="math display">\[r_i^{\mathrm{BLR}}:=\frac{b_{\mathrm{obs},i}/b_0}{B_{\mathrm{BLR}}(z_i)}-1
\label{eq:S17_02_r_BLR}\]</span>
로 정의하고,
<span class="math display">\[\mathrm{PASS}_{\mathrm{BLR}}
:\Longleftrightarrow
\mathrm{median}_i\bigl(|r_i^{\mathrm{BLR}}|\bigr)\le \epsilon_{\mathrm{BLR}}^{\star}
\label{eq:S17_02_pass_BLR}\]</span>
를 Gate로 둔다(<span class="math inline">\(\epsilon_{\mathrm{BLR}}^{\star}&gt;0\)</span>는 사전등록).
<span class="math inline">\(b_0\)</span>의 표준화(소스 진화/밴드/케이보정) 또는 <span class="math inline">\(b_{\mathrm{obs},i}\)</span>의 기기 보정(PSF/해상도 제거) 절차가 LOCK되지 않으면 이 Gate는 <code>INCONCLUSIVE</code>이다.</p>
<h4 data-number="19.2.5.11" id="gate-소산-에너지-종착sink-판정"><span class="header-section-number">19.2.5.11</span> (Gate) 소산 에너지 종착(Sink) 판정</h4>
<p>10.8.5에서 언급했듯이, <a data-reference="eq:S10_08_dnudx" data-reference-type="eqref" href="#eq:S10_08_dnudx">[eq:S10_08_dnudx]</a>류의 주파수 감쇠는 광자 에너지 감소를 의미하므로 “손실 에너지”의 종착(격자 열화/재방출/배경장 축적 등)을 닫는 모델이 필요하다.
종착 모델이 주어지면, 관측된 배경 복사/열잡음/확산광 예산을 초과하지 않는지(또는 예측되는 추가 성분이 관측치와 양립하는지)를 Gate로 판정한다.</p>
<p>우선 방출 대비 관측 에너지 비는 <span class="math inline">\(E_{\mathrm{obs}}/E_{\mathrm{em}}=\nu_{\mathrm{obs}}/\nu_{\mathrm{em}}=(1+z)^{-1}\)</span>이므로,
한 소스의 손실 에너지 분율을
<span class="math display">\[f_{\mathrm{loss}}(z):=1-\frac{1}{1+z}=\frac{z}{1+z}
\label{eq:S17_02_floss}\]</span>
로 정의한다.
관측 표본(또는 사전등록된 소스 함수) <span class="math inline">\(\mathcal{S}\)</span>에 대해, 종착 모델이 선택한 밴드/예산 관측량 <span class="math inline">\(I_{\mathrm{bg}}\)</span>에 대응하는 예측치를
<span class="math display">\[I_{\mathrm{sink}}:=\sum_{i\in\mathcal{S}} F_{\mathrm{obs},i}\, f_{\mathrm{loss}}(z_i)\,W_{\mathrm{SINK}}(z_i)
\label{eq:S17_02_Isink_def}\]</span>
로 정의한다.
여기서 <span class="math inline">\(F_{\mathrm{obs},i}\)</span>는 <a data-reference="eq:S17_02_flux_mapping" data-reference-type="eqref" href="#eq:S17_02_flux_mapping">[eq:S17_02_flux_mapping]</a>의 관측 플럭스이며, <span class="math inline">\(W_{\mathrm{SINK}}(z)\)</span>는 손실 에너지가 해당 관측량에 기여하는 방식(재방출 스펙트럼/흡수/열화 등)을 요약하는 잠긴 전달 인자이다.
그리고 관측/문헌 기반 상한(또는 관측값) <span class="math inline">\(I_{\mathrm{bg}}^{\max}\)</span>를 <code>analysis_lock</code>에 봉인한 뒤,
<span class="math display">\[\mathrm{PASS}_{\mathrm{SINK}}
:\Longleftrightarrow
\frac{I_{\mathrm{sink}}}{I_{\mathrm{bg}}^{\max}}\le 1+\epsilon_{\mathrm{SINK}}^{\star}
\label{eq:S17_02_pass_SINK}\]</span>
를 Gate로 둔다(<span class="math inline">\(\epsilon_{\mathrm{SINK}}^{\star}\ge 0\)</span>는 사전등록).
<span class="math inline">\(I_{\mathrm{bg}}\)</span>의 선택(밴드/자료/마스킹/적분 규약) 또는 <span class="math inline">\(W_{\mathrm{SINK}}(z)\)</span>가 LOCK되지 않으면 이 Gate는 <code>INCONCLUSIVE</code>이다.</p>
<h4 data-number="19.2.5.12" id="필수-gate-스택-우주-팽창-대체-주장에-대한-결론-자격"><span class="header-section-number">19.2.5.12</span> (필수 Gate 스택) “우주 팽창 대체” 주장에 대한 결론 자격</h4>
<p>E-COSMO가 “팽창” 대신 <a data-reference="eq:S17_02_Dz_def" data-reference-type="eqref" href="#eq:S17_02_Dz_def">[eq:S17_02_Dz_def]</a>를 우주론적 거리의 기반으로 사용하여
거리-적색편이 및 광도/시간/영상 관측을 <em>동시에</em> 설명한다고 주장하려면,
<strong>거리 일치 Gate</strong>뿐 아니라 <strong>시간 신장/표면밝기/블러링/에너지 종착</strong> Gate를 함께 통과해야 한다.<a class="footnote-ref" href="#fn5" id="fnref5" role="doc-noteref"><sup>5</sup></a>
즉,
<span class="math display">\[\mathrm{PASS}_{\mathrm{COSMO\text{-}ALT}}
:\Longleftrightarrow
\mathrm{PASS}_{z\text{-dist}}\wedge \mathrm{PASS}_{z\text{-achr}}\wedge \mathrm{PASS}_{\mathrm{TD}}\wedge \mathrm{PASS}_{\mathrm{TOL}}\wedge \mathrm{PASS}_{\mathrm{BLR}}\wedge \mathrm{PASS}_{\mathrm{SINK}}
\label{eq:S17_02_pass_cosmo_alt}\]</span>
를 최소 요건으로 둔다.
여기서 <span class="math inline">\(\mathrm{PASS}_{\mathrm{BLR}}\)</span>는 영상 블러링/선폭 증가가 허용 오차 내임을, <span class="math inline">\(\mathrm{PASS}_{\mathrm{SINK}}\)</span>는 소산 에너지 종착 모델이 누적 관측과 양립함을 뜻한다.
해당 Gate 보고서가 누락되면 결론은 <code>UNLOGGED</code> 또는 <code>INCONCLUSIVE</code>이며,
그 상태에서는 “암흑에너지 불필요” 등 <strong>강한 우주론 결론</strong>을 산출할 수 없다.</p>
<p>각 Gate는 프로토콜에서 수치 기준을 LOCK해야 하며, 실행 후 변경할 수 없다.</p>
<p>각 레짐 <span class="math inline">\(\mathcal{R}\)</span>에 대해 판정자
<span class="math display">\[\mathbb{I}_{\mathcal{R}}(\texttt{run})\in\{0,1\}
\label{eq:S17_02_regime_indicator}\]</span>
를 정의하고, 레짐맵은
<span class="math display">\[\mathcal{M}_{\mathrm{regime}}:=\{\mathbb{I}_{\mathrm{JET}},\mathbb{I}_{\mathrm{CORE}},\mathbb{I}_{\mathrm{COSMO}},\dots\}
\label{eq:S17_02_regime_map}\]</span>
로 고정한다.
각 판정자는 오직 <code>protocol.*</code>에 의해 선언되며, 실행 후 교체될 수 없다.</p>
<h3 data-number="19.2.6" id="제트제트류-모듈-구조정의-파일-트리-프로토콜-산출물"><span class="header-section-number">19.2.6</span> 17.2.7 제트/제트류 모듈 구조(정의): 파일 트리, 프로토콜, 산출물</h3>
<p>제트/제트류 확장의 실험 모듈은 다음 디렉토리 구조로 고정한다.</p>
<pre><code>modules/
  jet_regime/
    protocol.yaml
    locks_required.txt
    src/
      simulate_jet_regime.py
      extract_event_flux.py
      estimators.py
      gates.py
      io_schema.py
    schemas/
      protocol.schema.json
      run_log.schema.json
      metrics.schema.json
      manifest.schema.json
    plans/
      plan.json
    outputs_spec/
      artifacts.md</code></pre>
<h4 data-number="19.2.6.1" id="정의-입력lock-의존성-목록-1"><span class="header-section-number">19.2.6.1</span> (정의) 입력(LOCK) 의존성 목록</h4>
<p><code>locks_required.txt</code>는 다음 항목을 최소로 포함한다.</p>
<ul>
<li><p><code>realization_lock</code>: <span class="math inline">\(a\)</span>, <span class="math inline">\(\Delta t\)</span> 및 실현 정의들(시간 정규화에 필수)</p></li>
<li><p><code>analysis_lock</code>: <span class="math inline">\(\mathcal{J}_\star\)</span>, <span class="math inline">\(q_\star\)</span>, <span class="math inline">\(P_\star\)</span>, <span class="math inline">\(\theta_\star\)</span>, <span class="math inline">\(M_\star\)</span> (필수)</p></li>
<li><p><code>analysis_lock</code>: 관측 원뿔/실린더 <span class="math inline">\(\mathcal{C}(\cdot)\)</span>의 구체 스키마(개구각/반지름, 타이브레이크 규칙) (필수)</p></li>
<li><p><code>analysis_lock</code> 또는 <code>canon_lock</code>: (선택) 이방성 축 <span class="math inline">\(\mathbf{u}\)</span> 및 회전 관련 파라미터(<span class="math inline">\(\chi_{\mathrm{rot}}\)</span>, <span class="math inline">\(\chi_\star\)</span> 등; 17.1 채택 시 필수)</p></li>
</ul>
<h4 data-number="19.2.6.2" id="정의-메트릭요약치와-gate-1"><span class="header-section-number">19.2.6.2</span> (정의) 메트릭(요약치)와 Gate</h4>
<p>모듈은 다음 메트릭을 최소로 산출한다.</p>
<ul>
<li><p><span class="math inline">\(\mathcal{J}\)</span>, <span class="math inline">\(\hat{\mathbf{d}}_{\mathrm{J}}\)</span> (콜리메이션 및 축)</p></li>
<li><p><span class="math inline">\(\theta_{\mathrm{J}}(q_\star)\)</span> 또는 <span class="math inline">\(r_{\mathrm{J}}(q_\star)\)</span> (폭; 시간 분해 시 <span class="math inline">\(\overline{\theta}_{\mathrm{J}}(q_\star)\)</span>도 함께 보고)</p></li>
<li><p><span class="math inline">\(P_{\mathrm{J}}\)</span>, <span class="math inline">\(M_{\mathrm{J}}\)</span> (지속성/축 안정성)</p></li>
<li><p>(선택) <span class="math inline">\(A_{\mathrm{align}}\)</span> (이방성 축 정합)</p></li>
</ul>
<p>Gate는 다음을 최소로 포함한다.</p>
<ul>
<li><p>(G-JET1) 콜리메이션: <a data-reference="eq:S17_02_pass_jet" data-reference-type="eqref" href="#eq:S17_02_pass_jet">[eq:S17_02_pass_jet]</a></p></li>
<li><p>(G-JET2) 제트류: <a data-reference="eq:S17_02_pass_jstream" data-reference-type="eqref" href="#eq:S17_02_pass_jstream">[eq:S17_02_pass_jstream]</a></p></li>
<li><p>(G-JET3) (선택) 이방성 축 정합: <a data-reference="eq:S17_02_pass_align" data-reference-type="eqref" href="#eq:S17_02_pass_align">[eq:S17_02_pass_align]</a></p></li>
<li><p>(G-LOG) 링크-로그 스키마 검증: <span class="math inline">\(\Xi_s\)</span> 필드의 누락/형식 불일치 없음</p></li>
<li><p>(G-REP) 재현: 동일 입력/시드 재실행 시 동일 판정</p></li>
</ul>
<h2 class="unnumbered" id="이-절의-lockgate-연결없으면-없음-73">이 절의 LOCK/Gate 연결(없으면 없음)</h2>
<ul>
<li><p>LOCK: 소스/싱크 정의(<a data-reference="eq:S17_02_src_sink_disjoint" data-reference-type="eqref" href="#eq:S17_02_src_sink_disjoint">[eq:S17_02_src_sink_disjoint]</a>), 주입/흡수 사건률 형태(<a data-reference="eq:S17_02_Jdef" data-reference-type="eqref" href="#eq:S17_02_Jdef">[eq:S17_02_Jdef]</a>)의 프로토콜 잠금.</p></li>
<li><p>LOCK: 링크 사건 플럭스 정의(<a data-reference="eq:S17_02_flux_link" data-reference-type="eqref" href="#eq:S17_02_flux_link">[eq:S17_02_flux_link]</a>) 및 관측 원뿔/실린더 <span class="math inline">\(\mathcal{C}(\cdot)\)</span> 스키마, 타이브레이크 규칙을 <code>analysis_lock</code>에 고정.</p></li>
<li><p>LOCK: 제트 지표 <span class="math inline">\(\mathcal{J}\)</span>, 제트 축 <span class="math inline">\(\hat{\mathbf{d}}_{\mathrm{J}}\)</span>, 폭 <span class="math inline">\(\theta_{\mathrm{J}}(q_\star)\)</span> 및 시간 평균 <span class="math inline">\(\overline{\theta}_{\mathrm{J}}(q_\star)\)</span>, 지속성 <span class="math inline">\(P_{\mathrm{J}}\)</span>, 축 안정성 <span class="math inline">\(M_{\mathrm{J}}\)</span> 정의를 <code>analysis_lock</code>에 고정.</p></li>
<li><p>Gate: 콜리메이션 Gate <span class="math inline">\(\mathrm{PASS}_{\mathrm{JET}}\)</span> 및 제트류 Gate <span class="math inline">\(\mathrm{PASS}_{\mathrm{JSTREAM}}\)</span>의 문턱값을 사전등록.</p></li>
<li><p>Gate: 링크-로그 스키마 불일치 또는 타이브레이크 미잠금은 G-LOG/G-SYM에서 즉시 <code>FAIL</code>.</p></li>
</ul>
<h2 data-number="19.3" id="한계오픈문제vnext-로드맵새-lock-도입-조건수정-규칙-포함"><span class="header-section-number">19.3</span> 17.3 한계·오픈문제·vNext 로드맵(새 LOCK 도입 조건/수정 규칙 포함)</h2>
<h3 data-number="19.3.1" id="한계의-형식적-분류정의"><span class="header-section-number">19.3.1</span> 17.3.1 한계의 형식적 분류(정의)</h3>
<p>한계는 “모델 실패”가 아니라 “레짐 밖 적용” 또는 “검증 불능”으로 분류한다.
한계 클래스를 다음으로 정의한다.
<span class="math display">\[\mathcal{C}_{\mathrm{lim}}
=
\{\mathrm{REGIME\_OUT},\mathrm{IDENTIFIABILITY},\mathrm{NUMERICS},\mathrm{MEASUREMENT},\mathrm{DEPENDENCY}\}
\label{eq:S17_03_lim_classes}\]</span>
각 클래스의 의미는 다음과 같이 고정한다.</p>
<ul>
<li><p><strong>REGIME_OUT</strong>: 레짐 조건이 충족되지 않음(레짐맵 판정에서 0).</p></li>
<li><p><strong>IDENTIFIABILITY</strong>: 서로 다른 닫힘/모듈이 동일 관측을 재현하여 구별 불가.</p></li>
<li><p><strong>NUMERICS</strong>: 유한 크기, 해상도, 시드 민감도로 인해 Gate 판정이 안정적이지 않음.</p></li>
<li><p><strong>MEASUREMENT</strong>: 관측 프로토콜(로그/채널/분할)이 불충분하여 메트릭 산출 불가.</p></li>
<li><p><strong>DEPENDENCY</strong>: 외부 의존성(코드/라이브러리/환경)이 스냅샷으로 완전히 고정되지 않음.</p></li>
</ul>
<h3 data-number="19.3.2" id="오픈문제의-최소-목록정의"><span class="header-section-number">19.3.2</span> 17.3.2 오픈문제의 최소 목록(정의)</h3>
<p>오픈문제는 사전등록 가능한 검증 항목 또는 LOCK 후보의 형태로만 기술한다. 최소 오픈문제를 다음으로 고정한다.</p>
<ul>
<li><p>(OP-ANISO) <span class="math inline">\(g(\mu)\)</span>의 구체 형태 결정 문제: <a data-reference="eq:S17_01_g_norm" data-reference-type="eqref" href="#eq:S17_01_g_norm">[eq:S17_01_g_norm]</a>을 만족하면서 레짐별 응답 메트릭을 일관되게 설명하는 함수족의 식별.</p></li>
<li><p>(OP-ROT) <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 채택의 정당한 조건: <span class="math inline">\(\ell_{\mathrm{rot}}\)</span>를 LOCK에 포함할 때 필요한 관측/실험/추정기의 최소 요건.</p></li>
<li><p>(OP-DAG) 닫힘 스택/DAG의 비순환성 유지 문제: 확장 모듈이 증가할 때 순환 의존을 자동 검출하고 차단하는 규칙의 완성.</p></li>
<li><p>(OP-SCALE) 유한 크기 및 해상도 스케일링 문제: 해상도 상승 시 메트릭이 수렴하는지, 어떤 순서로 수렴하는지의 규정.</p></li>
<li><p>(OP-LOG) 링크-로그 <span class="math inline">\(\Xi_s\)</span>의 스키마 표준화: 전파 방향 플럭스 측정 <a data-reference="eq:S17_02_flux_link" data-reference-type="eqref" href="#eq:S17_02_flux_link">[eq:S17_02_flux_link]</a>을 모든 모듈에서 동일하게 재현하도록 하는 스키마의 고정.</p></li>
<li><p>(OP-JET) 제트류 추정기의 스케일업/해상도 문제: 관측 창 길이 <span class="math inline">\(M\)</span>, 관측 원뿔/실린더 규약, 타이브레이크 규칙이 달라질 때 <span class="math inline">\(\mathcal{J},\theta_{\mathrm{J}},\overline{\theta}_{\mathrm{J}},P_{\mathrm{J}},M_{\mathrm{J}}\)</span>가 어떤 순서로 안정화되는지의 규정. 또한 대기/해양 제트류와 같은 실체 데이터에 대한 사건-로그 추출 프로토콜의 표준화.</p></li>
</ul>
<h3 data-number="19.3.3" id="vnext-로드맵의-객체정의-후보-도입-폐기"><span class="header-section-number">19.3.3</span> 17.3.3 vNext 로드맵의 객체(정의): 후보, 도입, 폐기</h3>
<h4 data-number="19.3.3.1" id="정의-변경-요청change-request-cr"><span class="header-section-number">19.3.3.1</span> (정의) 변경 요청(Change Request, CR)</h4>
<p>모든 변경은 <code>CR</code>로 정의된 문서 단위로만 제출된다.
<span class="math display">\[\texttt{CR}=
\{\texttt{id},\texttt{type},\texttt{target},\texttt{rationale},\texttt{diff},\texttt{tests},\texttt{gates},\texttt{impact}\}
\label{eq:S17_03_CR_schema}\]</span>
<code>type</code>은 다음 중 하나로 고정한다.
<span class="math display">\[\texttt{type}\in\{\texttt{NEW\_LOCK},\texttt{LOCK\_UPDATE},\texttt{NEW\_GATE},\texttt{PROTOCOL\_UPDATE},\texttt{CODE\_UPDATE},\texttt{DOC\_UPDATE}\}
\label{eq:S17_03_CR_types}\]</span></p>
<h4 data-number="19.3.3.2" id="정의-lock-후보candidate-lock"><span class="header-section-number">19.3.3.2</span> (정의) LOCK 후보(candidate lock)</h4>
<p>LOCK 후보는 잠김 파일에 추가될 수 있는 새로운 키-값(또는 새로운 파일)이다.
LOCK 후보 <span class="math inline">\(\mathcal{L}^\star\)</span>는 다음 4-튜플로 정의한다.
<span class="math display">\[\mathcal{L}^\star:=
(\texttt{key},\texttt{value},\texttt{unit},\texttt{origin\_protocol})
\label{eq:S17_03_lock_candidate}\]</span>
<code>origin_protocol</code>은 해당 값이 어떤 프로토콜에서 어떤 산출물로부터 도출되었는지를 식별해야 한다(로그/체크섬으로 추적 가능해야 함).</p>
<h3 data-number="19.3.4" id="새-lock-도입-조건정의-최소-요건"><span class="header-section-number">19.3.4</span> 17.3.4 새 LOCK 도입 조건(정의): 최소 요건</h3>
<p>새 LOCK 도입은 다음 조건을 <em>동시에</em> 만족해야 한다.
<span class="math display">\[\mathrm{ADMIT}(\mathcal{L}^\star)=1
\Longleftrightarrow
(\mathrm{PASS}_{\mathrm{ID}}=1)\wedge(\mathrm{PASS}_{\mathrm{STAB}}=1)\wedge(\mathrm{PASS}_{\mathrm{TRACE}}=1)\wedge(\mathrm{PASS}_{\mathrm{NT}}=1)
\label{eq:S17_03_admit_lock}\]</span>
각 Gate는 다음으로 정의한다.</p>
<ul>
<li><p>(PASS<sub>ID</sub>) <strong>식별 가능성</strong>: 후보 값이 적어도 하나의 메트릭에 단조 또는 구별 가능한 영향을 주며, 대체 후보들과 구분되는 검증 항목이 사전등록되어 있음.</p></li>
<li><p>(PASS<sub>STAB</sub>) <strong>안정성</strong>: 해상도/시드/샘플링 변화에 대해 후보 값 또는 그 도출 절차가 Gate 문턱 내에서 안정적임.</p></li>
<li><p>(PASS<sub>TRACE</sub>) <strong>추적성</strong>: 후보의 도출이 <code>run_log.jsonl</code>, <code>metrics.json</code>, <code>manifest.json</code>, <code>registry_snapshot.json</code>으로 완전 추적 가능함.</p></li>
<li><p>(PASS<sub>NT</sub>) <strong>사후조정 금지</strong>: 후보의 도입이 결과에 맞춘 임계/정의 변경이 아니며, 사전등록된 프로토콜 범위 내에서 생성됨.</p></li>
</ul>
<p>위 조건 중 하나라도 만족하지 못하면 후보는 LOCK으로 승격될 수 없고, <code>analysis_lock</code>의 가설 항목 또는 오픈문제로만 유지된다.</p>
<h3 data-number="19.3.5" id="수정-규칙정의-의미-변경과-버전-상승"><span class="header-section-number">19.3.5</span> 17.3.5 수정 규칙(정의): 의미 변경과 버전 상승</h3>
<h4 data-number="19.3.5.1" id="정의-의미-변경"><span class="header-section-number">19.3.5.1</span> (정의) 의미 변경</h4>
<p>LOCK에서 “의미 변경”은 동일 <code>key</code>에 대해 값만 바뀌는 경우뿐 아니라, 다음 경우도 포함한다.</p>
<ul>
<li><p>값의 단위가 바뀌는 경우(<code>unit</code> 변경).</p></li>
<li><p>값의 산출 출처(프로토콜/추정기)가 바뀌는 경우(<code>origin_protocol</code> 변경).</p></li>
<li><p>값의 해석이 바뀌는 경우(사용 위치/적용 레짐이 바뀌는 경우).</p></li>
</ul>
<h4 data-number="19.3.5.2" id="정의-버전-상승-규칙"><span class="header-section-number">19.3.5.2</span> (정의) 버전 상승 규칙</h4>
<p>LOCK 의미 변경이 발생하면 <strong>Major</strong> 버전 상승을 강제한다.
프로토콜/게이트의 확장이 하위호환을 유지하면 <strong>Minor</strong> 상승,
문서 오탈자 또는 결과 비영향 변경은 <strong>Patch</strong> 상승으로 고정한다.
버전 상승 규칙은 16.3의 릴리즈 규정과 정합되어야 한다.</p>
<h3 data-number="19.3.6" id="폐기대체-규칙정의-deprecated-revoked"><span class="header-section-number">19.3.6</span> 17.3.6 폐기/대체 규칙(정의): DEPRECATED, REVOKED</h3>
<h4 data-number="19.3.6.1" id="정의-deprecated"><span class="header-section-number">19.3.6.1</span> (정의) DEPRECATED</h4>
<p>항목이 더 이상 사용되지 않지만 과거 릴리즈 재현을 위해 유지되는 경우 <code>DEPRECATED</code>로 마킹한다.
<code>DEPRECATED</code> 항목은 삭제될 수 없으며, 대체 항목과의 매핑을 함께 제공해야 한다.
매핑은 다음 형태로 정의한다.
<span class="math display">\[\texttt{DEPRECATION\_MAP}=
(\texttt{old\_key},\texttt{new\_key},\texttt{since\_version},\texttt{rule})
\label{eq:S17_03_deprecation_map}\]</span></p>
<h4 data-number="19.3.6.2" id="정의-revoked"><span class="header-section-number">19.3.6.2</span> (정의) REVOKED</h4>
<p>항목이 무결성/추적성 실패 또는 No-Tuning 위반이 확인되어 더 이상 참조할 수 없는 경우 <code>REVOKED</code>로 마킹한다.
<code>REVOKED</code>는 과거 릴리즈의 재현성을 해치지 않도록 “철회 사유”와 “영향 범위”를 DOI 패키지에 포함해야 하며,
철회는 다음 최소 단위를 포함한다.
<span class="math display">\[\mathsf{REVOKE\_PACK}:=\{\texttt{reason.md},\texttt{evidence/*},\texttt{affected\_runs.csv},\texttt{registry\_snapshot.json}\}
\label{eq:S17_03_revoke_pack}\]</span></p>
<h3 data-number="19.3.7" id="vnext-구현-순서정의-모듈화-검증-배포"><span class="header-section-number">19.3.7</span> 17.3.7 vNext 구현 순서(정의): 모듈화, 검증, 배포</h3>
<p>vNext는 다음 순서의 불변 절차로 정의한다.</p>
<ol>
<li><p>(STEP-1) <strong>모듈 추가</strong>: <code>modules/&lt;name&gt;/</code> 형태로 독립 모듈을 추가하고, <code>protocol.*</code>과 스키마를 함께 고정한다.</p></li>
<li><p>(STEP-2) <strong>사전등록</strong>: <code>plan.json</code>과 Gate 문턱을 포함하여 사전등록 다이제스트를 생성한다.</p></li>
<li><p>(STEP-3) <strong>실행 및 로그 생성</strong>: <code>runs/&lt;run_id&gt;/</code>에 모든 산출물과 무결성 파일을 생성한다.</p></li>
<li><p>(STEP-4) <strong>검증</strong>: <code>validate.py</code>로 스키마/체크섬/Gate 판정을 재계산하고 상태를 확정한다.</p></li>
<li><p>(STEP-5) <strong>릴리즈</strong>: <code>release_manifest.*</code>를 생성하고 DOI 패키지 단위로 고정한다.</p></li>
</ol>
<p>각 단계의 누락/순서 변경은 16.1의 절차 위반으로 실패 처리한다.</p>
<h1 data-number="20" id="화학물질공학-확장선택-읽기"><span class="header-section-number">20</span> 18. 화학/물질공학 확장(선택 읽기)</h1>
<h2 data-number="20.1" id="범위-추가-기호-잠김-입력lock과-gate-스택요약"><span class="header-section-number">20.1</span> 18.0 범위, 추가 기호, 잠김 입력(LOCK)과 Gate 스택(요약)</h2>
<h4 data-number="20.1.0.1" id="범위선언"><span class="header-section-number">20.1.0.1</span> 범위(선언)</h4>
<p>본 장은 VP 격자(<span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 스케일) 관점을 <em>화학/물질공학 현상</em>에 적용하기 위한 <strong>확장 모듈</strong>이다. 0–16장의 정준 유도(단위실현, 질량/힘 스케일 등)를 변경하지 않으며, 본 장에서 도입되는 추가 입력(화학 데이터셋 등)은 <strong>정준 입력(canon_lock)이 아니라</strong> <strong>분야-특화 입력</strong>으로 취급한다.</p>
<h4 data-number="20.1.0.2" id="기호-충돌-회피중요"><span class="header-section-number">20.1.0.2</span> 기호 충돌 회피(중요)</h4>
<p>본 문서 본문에서 <span class="math inline">\(r_e\)</span>는 전자 반경(정준 길이 앵커 <span class="math inline">\(D_{\mathrm{anch}}\)</span>와 정류 상수 <span class="math inline">\(\delta\)</span>로부터의 유도량)으로 사용된다(예: 9장, 13장). 본 장에서는 화학적 “전자 구속/완화”를 기술하기 위해 <strong>유효 진폭</strong>을 <span class="math inline">\(r_{\mathrm{eff}}\)</span>로 표기하며, 진공 기준 진폭은 <span class="math inline">\(r_{\mathrm{vac}}\)</span>로 표기한다. <span class="math inline">\(r_{\mathrm{vac}}\)</span>는 필요 시 <span class="math inline">\(r_{\mathrm{vac}}:=r_e\)</span>로 동일시하여(=본 문서 내부 유도 스케일을 그대로 사용하여) 외부 상수 도입을 피한다.</p>
<h4 data-number="20.1.0.3" id="추가-lock-입력요약"><span class="header-section-number">20.1.0.3</span> 추가 LOCK 입력(요약)</h4>
<p>본 장에서 사용되는 원자 번호 <span class="math inline">\(Z\)</span> 및 공유 결합 반경 <span class="math inline">\(r_{\mathrm{cov}}(X)\)</span> 등의 값은 <code>protocol_lock</code> 또는 <code>analysis_lock</code>의 <strong>데이터셋 파일</strong>로 봉인되어야 하며(<code>manifest+checksums</code> 포함), 누락 시 관련 산출물은 <code>INCONCLUSIVE</code>로 처리한다.</p>
<h4 data-number="20.1.0.4" id="gate-스택요약"><span class="header-section-number">20.1.0.4</span> Gate 스택(요약)</h4>
<p>본 장의 산출물은 최소한 <strong>G-SYM(기호/단위)</strong>, <strong>G-LOCK(잠금 무결성)</strong>, <strong>G-REG(적용 레짐)</strong>, <strong>G-NT(No-Tuning)</strong>, 필요 시 <strong>G-RCROSS(교차정합)</strong>, <strong>G-REP(재현)</strong>을 요구한다. 본 장의 수치/사례 표는 <em>증거 로그가 번들에 포함될 때만</em> PASS/FAIL이 확정된다.</p>
<h2 data-number="20.2" id="화학-반응의-물리적-재정의-확률에서-기하학으로"><span class="header-section-number">20.2</span> 18.1 화학 반응의 물리적 재정의: 확률에서 기하학으로</h2>
<p>본 절은 현대 화학의 기반인 ’확률론적 오비탈 이론(Probabilistic Orbital Theory)’을 <em>설명 방식으로만</em> 두고, 본 모듈의 유도에서는 사용하지 않으며, 이를 <strong>공간 격자(Lattice) 내의 압력 평형과 기하학적 끼임(Geometric Fit)</strong>으로 재정의한다. 화학 반응은 본 모듈에서는 확률항이 없는 <em>기하학적/압력-평형 전이</em>로 기술되며, <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 격자 내에 대기 중인 입자들의 밀도 재배치 과정이다.</p>
<h3 data-number="20.2.1" id="입자-대기실input-queue과-에너지의-실체"><span class="header-section-number">20.2.1</span> 18.1.1 입자 대기실(Input Queue)과 에너지의 실체</h3>
<p>화학 반응 에너지는 어디서 오는가? 본 이론은 원자 주변의 진공이 비어 있지 않으며, 거대한 에너지가 ’입력 대기’ 상태로 존재함을 선언한다.</p>
<ol>
<li><p><strong>절대 격자의 존재:</strong> 모든 원자는 지름 <span class="math inline">\(\ell_{\mathrm{rot}} \approx 4.854\,\mathrm{pm}\)</span>의 고정된 회전 격자(Lattice Frame) 안에 존재한다. 이 공간은 비어 있는 것이 아니라, 부피입자(VP)가 꽉 들어찬 ’매질’이다.</p></li>
<li><p><strong>충만(Plenum)과 대기:</strong>
이 격자 공간은 단순한 허공이 아니라, 입자들이 고밀도로 채워진 <strong>’입자 대기실(Input Queue)’</strong> 역할을 수행한다. 입자들은 격자 압력에 의해 빽빽하게 줄을 서 있으며, 반응 시 방출되는 에너지는 이 대기 중인 입자들이 압력차에 의해 일제히 이동하며 발생하는 <strong>’격자 압력의 해방(Release of Lattice Pressure)’</strong>이다.</p></li>
<li><p><strong>화학적 의미:</strong> 즉, 반응열은 화학 결합 자체가 끊어져서 나오는 것이 아니라, 결합이 끊어질 때 그 틈새로 대기 중인 입자들이 쏟아져 들어오거나 나가면서 발생하는 <strong>공간 재배열 에너지</strong>이다.</p></li>
</ol>
<h3 data-number="20.2.2" id="확률의-배제와-기하학적-결정론"><span class="header-section-number">20.2.2</span> 18.1.2 확률의 배제와 기하학적 결정론</h3>
<p>본 모듈은 슈뢰딩거 파동함수(<span class="math inline">\(\Psi\)</span>)의 확률 분포를 <em>관측 요약</em>으로 취급하며, 이를 화학 반응의 <em>원인 변수</em>로 직접 사용하지 않는다(본 절의 유도는 압력/기하학 지표만 사용). 본 문서는 화학 반응의 3대 요소를 다음과 같이 결정론적 기하학으로 <strong>재정의(Redefinition)</strong>하여 잠근다(LOCK).</p>
<dl>
<dt>1. 오비탈(Orbital) <span class="math inline">\(\rightarrow\)</span> 격자 슬롯(Lattice Slot)</dt>
<dd>
<p><br/>
전자는 구름처럼 퍼져 있는 것이 아니라, 압력 평형점(<span class="math inline">\(F_{\mathrm{in}}=F_{\mathrm{out}}\)</span>)에 해당하는 특정 격자 좌표 <span class="math inline">\((x, y, z)\)</span>에 물리적으로 <strong>끼임(Fit/Lock)</strong> 상태로 고정된다. 궤도가 불연속적인 이유는 공간 자체가 불연속적인 격자 블록으로 이루어져 있기 때문이다.</p>
</dd>
<dt>2. 활성화 에너지(Activation Energy) <span class="math inline">\(\rightarrow\)</span> 기하 변형일(Geometric Work)</dt>
<dd>
<p><br/>
반응을 일으키기 위해 필요한 에너지는 ’넘어야 할 언덕’ 같은 추상적 개념이 아니다. 이는 전자의 진폭(<span class="math inline">\(r_{\mathrm{eff}}\)</span>)을 격자 대각선 한계인 <span class="math inline">\(\sqrt{2}\)</span>배까지 물리적으로 잡아늘리기 위해 투입해야 하는 <strong>’기계적 인장력(Mechanical Tension)’</strong>이다.
<span class="math display">\[E_{\mathrm{act}} \propto k \cdot (r_{\mathrm{break}} - r_{\mathrm{ground}}) = k \cdot r_{\mathrm{ground}}(\sqrt{2} - 1)\]</span></p>
</dd>
<dt>3. 전이 상태(Transition State) <span class="math inline">\(\rightarrow\)</span> 대각선 탈출(Diagonal Escape)</dt>
<dd>
<p><br/>
반응의 순간은 전자가 격자의 변(Side)을 떠나 대각선(Diagonal)으로 찢어지는 찰나이다. 이 순간 입자는 기존 격자의 구속을 벗어나 새로운 압력 평형점을 찾아 이동한다.</p>
</dd>
</dl>
<h3 data-number="20.2.3" id="lock-화학-반응의-기하학적-공리"><span class="header-section-number">20.2.3</span> 18.1.3 [LOCK] 화학 반응의 기하학적 공리</h3>
<p>본 문서는 다음 명제를 화학 반응의 절대 공리로 확정한다.</p>
<blockquote>
<p>“모든 화학적 변화는 입자가 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 격자 내의 압력 구배(Pressure Gradient)를 따라 더 낮은 밀도 스트레스 지점(<span class="math inline">\(P_{\mathrm{idx}} \rightarrow 1.0\)</span>)으로 이동하는 기하학적 최적화 과정이다. 확률론적 기술은 본 모듈의 유도/판정에는 사용하지 않는다.”</p>
</blockquote>
<h2 data-number="20.3" id="표면-전하-밀도와-동적-진폭r_mathrmeff"><span class="header-section-number">20.3</span> 18.2 표면 전하 밀도와 동적 진폭(<span class="math inline">\(r_{\mathrm{eff}}\)</span>)</h2>
<p>전자 유효 진폭(<span class="math inline">\(r_{\mathrm{eff}}\)</span>)은 고정된 상수가 아니라, 원자핵이 형성하는 공간 압력에 의해 실시간으로 변형되는 동적 변수이다. 본 절은 원자의 표면 전하 밀도가 전자의 진폭을 압축하는 기하학적 법칙을 유도하고, 이를 화학 반응의 표준 척도로 고정(LOCK)한다.</p>
<h3 data-number="20.3.1" id="압력-지수p_mathrmidx의-정의"><span class="header-section-number">20.3.1</span> 18.2.1 압력 지수(<span class="math inline">\(P_{\mathrm{idx}}\)</span>)의 정의</h3>
<p>전자가 느끼는 공간의 빽빽함(Pressure)은 핵 전하량(<span class="math inline">\(Z\)</span>)에 비례하고, 공유 결합 반경(<span class="math inline">\(r_{\mathrm{cov}}\)</span>)의 제곱에 반비례한다. 이를 수소 원자(<span class="math inline">\(H\)</span>)를 기준으로 정규화한 값을 <strong>압력 지수</strong>로 정의한다.</p>
<ol>
<li><p><strong>원시 압력(<span class="math inline">\(P_{\mathrm{raw}}\)</span>):</strong> 단위 면적당 유효 전하 밀도.
<span class="math display">\[P_{\mathrm{raw}}(X) = \frac{Z}{r_{\mathrm{cov}}(X)^2}\]</span></p></li>
<li><p><strong>정규화 압력 지수(<span class="math inline">\(P_{\mathrm{idx}}\)</span>):</strong> 수소(<span class="math inline">\(H\)</span>, <span class="math inline">\(Z=1, r=31\,\mathrm{pm}\)</span>) 기준 상대 압력.
<span class="math display">\[P_{\mathrm{idx}}(X) := \frac{P_{\mathrm{raw}}(X)}{P_{\mathrm{raw}}(H)}\]</span></p></li>
</ol>
<p>이 지수는 해당 원자 내부 공간이 기준(수소)보다 얼마나 더 고밀도로 압축되어 있는지를 나타내는 무차원 물리량이다.</p>
<h3 data-number="20.3.2" id="lock-동적-진폭-결정-공식"><span class="header-section-number">20.3.2</span> 18.2.2 [LOCK] 동적 진폭 결정 공식</h3>
<p>공간 압력이 높을수록 전자의 회전 반경은 줄어들고 진폭은 억제된다. 본 문서는 시뮬레이션 검증을 통해 확인된 <strong>제곱근 반비례 법칙</strong>을 동적 진폭의 결정 공식으로 잠근다.</p>
<p><span class="math display">\[\label{eq:dynamic_amplitude_lock}
    r_{\mathrm{eff}}(X) = \frac{r_{\mathrm{vac}}}{\sqrt{P_{\mathrm{idx}}(X)}}\]</span></p>
<ul>
<li><p><span class="math inline">\(r_{\mathrm{vac}}\)</span>: 진공 중 전자 기준 진폭 (<span class="math inline">\(\approx 245.9\,\mathrm{fm}\)</span>). 외부 간섭이 없는 이상적인 최대 이완 상태.</p></li>
<li><p><span class="math inline">\(r_{\mathrm{eff}}\)</span>: 실제 원자 격자 내에서 압축된 유효 진폭.</p></li>
<li><p><strong>기하학적 해석:</strong> 압력 지수가 2배가 되면(<span class="math inline">\(P_{\mathrm{idx}}=2\)</span>), 진폭은 <span class="math inline">\(\frac{1}{\sqrt{2}}\)</span>배로 줄어든다. 이는 공간 내 에너지 밀도가 면적(<span class="math inline">\(r^2\)</span>)에 반비례하여 보존됨을 의미한다.</p></li>
</ul>
<h3 data-number="20.3.3" id="표준-물질의-압력-진폭-상태표"><span class="header-section-number">20.3.3</span> 18.2.3 표준 물질의 압력-진폭 상태표</h3>
<p>상기 공식을 적용하여 계산된 주요 물질의 기하학적 상태는 다음과 같으며, 이는 보고된 화학적 물성(안정성, 반응성)과 일치한다.</p>
<dl>
<dt>보수적 해석:</dt>
<dd>
<p>위 표의 수치는 실험적 오차를 배제한 기하학적 이상값(Ideal Value)이다. 실제 반응에서는 온도 및 주변 결합 환경에 따라 미세한 진동(<span class="math inline">\(\pm 5\%\)</span>)이 발생할 수 있으나, <span class="math inline">\(P_{\mathrm{idx}}\)</span>에 따른 계층적 순서(<span class="math inline">\(H &lt; H_2O &lt; O &lt; Pt\)</span>)는 불변의 법칙으로 유지된다.</p>
</dd>
</dl>
<h3 data-number="20.3.4" id="lock-문헌-기반-대량-점검-진폭-법칙의-통계적-검증"><span class="header-section-number">20.3.4</span> 18.2.4 [LOCK] 문헌 기반 대량 점검: 진폭 법칙의 통계적 검증</h3>
<p>본 DOI 번들은 단일 예시 표(<a data-reference="tab:pressure_amplitude" data-reference-type="ref" href="#tab:pressure_amplitude">[tab:pressure_amplitude]</a>)에 더하여, 원소/분자/산화물/금속(촉매 후보)을 포함하는 대량 점검 데이터셋
<strong>VP_STEP7_EXT_INSPECTION_FULL_V1</strong>을 함께 제공한다.
이 데이터셋은 “진폭 규칙”(<span class="math inline">\(r_{\mathrm{eff}}=r_{\mathrm{vac}}/\sqrt{P_{\mathrm{idx}}}\)</span>)로 계산된 <strong>모델 진폭</strong>과, 외부 문헌에서 추출한 <strong>참조 진폭</strong>을 나란히 기록하고, <span class="math inline">\(\pm 5\%\)</span> 허용오차로 <code>PASS/FAIL</code>을 명시한다.</p>
<h3 data-number="20.3.5" id="sec:chem_definitive_v3"><span class="header-section-number">20.3.5</span> 18.2.5 [LOCK] 비임의성 방어: <span class="math inline">\(K\)</span> 상수의 물리적 의미와 <span class="math inline">\(CH_4\)</span> Rule-B</h3>
<p>대량 점검(18.2.4)이 “통계적으로 맞는다”는 주장이라면, 본 절은 공격자가 가장 먼저 던지는 질문—
“<span class="math inline">\(1000\)</span>을 곱하고 <span class="math inline">\(\alpha\)</span>를 곱하는 것은 임의가 아닌가?”—에 대한 <strong>구조적 방어(Definitive Spec)</strong>이다.</p>
<h4 data-number="20.3.5.1" id="i-k의-정의-k-1000alpha_em."><span class="header-section-number">20.3.5.1</span> (i) <span class="math inline">\(K\)</span>의 정의: <span class="math inline">\(K = 1000\,\alpha_{em}\)</span>.</h4>
<p>원자 길이 단위(pm)를 VP 진폭 단위(fm)로 옮기는 스케일 변환(<span class="math inline">\(\times1000\)</span>)에, 전자기 결합 세기(미세구조상수 <span class="math inline">\(\alpha_{em}\)</span>)를 곱한
<span class="math inline">\(K\)</span>를 <strong>고정 상수</strong>로 잠근다.
<span class="math display">\[K_{coupling} \equiv 1000\,\alpha_{em},
    \qquad
    r_{vp} = r_{raw}(\mathrm{pm})\;K_{coupling}\;\beta_{shielding}.\]</span>
여기서 <span class="math inline">\(\beta_{shielding}\)</span>은 환경(진공/결합)의 미세 보정 계수이며,<a class="footnote-ref" href="#fn6" id="fnref6" role="doc-noteref"><sup>6</sup></a>
원자에 대해 <span class="math inline">\(r_{raw}=r_{cov}/\sqrt{Z}\)</span>를 취하면 다음의 등가형이 얻어진다.
<span class="math display">\[r_{eff}(X)=\frac{r_{vac}}{\sqrt{P_{idx}(X)}}
    \;\equiv\;
    K_{coupling}\,\beta_{vac}\,\frac{r_{cov}(X)}{\sqrt{Z_X}}.\]</span>
즉 <span class="math inline">\(K\)</span>는 “맞추기 위한 임의 파라미터”가 아니라, 단위 변환과 결합 세기를 묶은 <strong>정의(Definition)</strong>로 고정된다.</p>
<h4 data-number="20.3.5.2" id="ii-ch_4-rule-b-기하학적-포장-한계의-직접-반영."><span class="header-section-number">20.3.5.2</span> (ii) <span class="math inline">\(CH_4\)</span> Rule-B: 기하학적 포장 한계의 직접 반영.</h4>
<p>다원자 분자에서 <span class="math inline">\(P_{idx}&lt;1\)</span>이 되는 현상은 “부피 희석”과 “국소 포장 한계”로 설명된다.
특히 <span class="math inline">\(CH_4\)</span>의 경우 사면체(<span class="math inline">\(sp^3\)</span>) 배치에서의 국소 포장 효율
<span class="math inline">\(\Phi_{geo}=\pi/(3\sqrt{2})\)</span>와 결합 중첩 보정 <span class="math inline">\(\Delta_{ov}\)</span>를 사용하여
<span class="math display">\[P_{idx}(CH_4) \approx \Phi_{geo}\,(1-\Delta_{ov})
    \quad \Rightarrow \quad
    P_{idx}(CH_4)\approx 0.7307.\]</span>
이 결과는 DOI 내 데이터셋(<code>VP_STEP7_EXT_INSPECTION_FULL_V1</code>)의 <span class="math inline">\(CH_4\)</span> 행(<code>VP-C017</code>)과 수치적으로 일치하며,<a class="footnote-ref" href="#fn7" id="fnref7" role="doc-noteref"><sup>7</sup></a>
해당 재현성은 아래 자동 점검표로 <strong>기계적으로 검증</strong>된다.</p>
<h3 data-number="20.3.6" id="lock-형상-분류-기반-희석-상계-phi_mathrmeff"><span class="header-section-number">20.3.6</span> 18.2.6 [LOCK] 형상 분류 기반 희석 상계: <span class="math inline">\(\phi_{\mathrm{eff}}\)</span></h3>
<p>본 절은 다원자 분자에서 Rule-B(부피 희석)를 적용할 때 발생할 수 있는 “선택의 임의성”을 줄이기 위한 최소 방어층이다.
<span class="math inline">\(\phi_{\mathrm{eff}}\)</span>를
<span class="math display">\[\phi_{\mathrm{eff}} \equiv \frac{P_{\mathrm{idx}}(\mathrm{molecule})}{P_{\mathrm{avg}}(\mathrm{atoms})}\]</span>
로 정의하고, 대표 분자 <span class="math inline">\(CH_4\)</span>, <span class="math inline">\(H_2O\)</span>, <span class="math inline">\(NH_3\)</span>에 대해 (i) 형상 분류기를 LOCK로 고정하고, (ii) 형상별 상계 <span class="math inline">\(\phi_{\mathrm{upper}}\)</span>를 LOCK로 고정하여
<span class="math inline">\(\phi_{\mathrm{eff}} \le \phi_{\mathrm{upper}} + \epsilon\)</span>를 기계적으로 점검한다.
자세한 정의와 목적은 <code>docs/chem/GEOMETRY_PHI_LOCK.md</code>에 포함된다.</p>
<h2 data-number="20.4" id="결합-파괴의-절대-법칙-격자-대각선sqrt2"><span class="header-section-number">20.4</span> 18.3 결합 파괴의 절대 법칙: 격자 대각선(<span class="math inline">\(\sqrt{2}\)</span>)</h2>
<p>화학 결합은 언제 끊어지는가? 기존 화학은 이를 실험적 에너지값(Bond Dissociation Energy)으로만 설명했으나, 본 이론은 이를 <strong>“진폭이 격자의 대각선 한계를 초과하는 순간”</strong>이라는 기하학적 임계점으로 정의한다.</p>
<h3 data-number="20.4.1" id="대각선-탈출-이론diagonal-escape-theory"><span class="header-section-number">20.4.1</span> 18.3.1 대각선 탈출 이론(Diagonal Escape Theory)</h3>
<p>전자가 <span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 격자 내부에서 진동할 때, 구조적 붕괴 없이 확장될 수 있는 최대 길이는 격자의 대각선 길이이다.</p>
<ol>
<li><p><strong>바닥 상태(<span class="math inline">\(r_{\mathrm{ground}}\)</span>):</strong> 외부 자극이 없을 때 전자는 격자의 변(Side) 길이 <span class="math inline">\(L\)</span>에 맞춰 진동한다. (<span class="math inline">\(r_{\mathrm{ground}} = L\)</span>)</p></li>
<li><p><strong>임계 상태(<span class="math inline">\(r_{\mathrm{crit}}\)</span>):</strong> 에너지가 유입되면 전자의 궤도는 원형에서 타원형으로 늘어나며, 격자 모서리(Corner)를 향해 대각선으로 확장된다.</p></li>
<li><p><strong>파괴 시점:</strong> 진폭이 대각선 길이(<span class="math inline">\(L\sqrt{2}\)</span>)를 넘어서는 순간, 전자는 격자의 구속을 뚫고 외부로 이탈한다.
<span class="math display">\[\label{eq:diagonal_limit}
        r_{\mathrm{break}} = r_{\mathrm{ground}} \times \sqrt{2} \approx 1.414 \times r_{\mathrm{ground}}\]</span></p></li>
</ol>
<h3 data-number="20.4.2" id="lock-실측-데이터-검증-1.4배의-법칙"><span class="header-section-number">20.4.2</span> 18.3.2 [LOCK] 실측 데이터 검증: 1.4배의 법칙</h3>
<p>본 이론서의 시뮬레이션 결과와 실제 화학 공정 보고서의 데이터를 대조한 결과, 모든 공유 결합의 붕괴는 정확히 <span class="math inline">\(\sqrt{2}\)</span> 비율 근처에서 발생함이 입증되었다.</p>
<h4 data-number="20.4.2.1" id="내부-인용-표기"><span class="header-section-number">20.4.2.1</span> 내부 인용 표기</h4>
<p>본 절에서 사용하는 표기 <code>[cite: XX]</code>는 외부 저널의 서지번호가 아니라, <strong>Zenodo DOI 기반 내부 인용 레지스트리 ID</strong>이다.
각 ID는 부록 I의 레지스트리 표(및 <code>04_vp_whitepaper/docs/citations/CITE_REGISTRY.csv</code>)에서
<a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>와 번들 내부 경로로 해석된다.</p>
<dl>
<dt>데이터 출처 1 (질소):</dt>
<dd>
<p>Fe-Mo 촉매 시뮬레이션에서 결합 붕괴는 진폭 <span class="math inline">\(\pm 290\,\mathrm{fm}\)</span> 시점에 발생하였다[cite: 26, 47]. 이는 바닥 상태(<span class="math inline">\(213\,\mathrm{fm}\)</span>) 대비 <span class="math inline">\(1.36\)</span>배로, <span class="math inline">\(\sqrt{2}\)</span> 한계에 도달하기 위해 촉매가 진폭을 강제로 벌려주었음을 의미한다.</p>
</dd>
<dt>데이터 출처 2 (이산화탄소):</dt>
<dd>
<p>고온 분해 시뮬레이션에서 <span class="math inline">\(O=C=O\)</span> 결합은 진폭 <span class="math inline">\(\pm 300\,\mathrm{fm}\)</span> 이상에서 붕괴되었다[cite: 61, 65]. 이는 확장비 <span class="math inline">\(1.46\)</span>배로, 기하학적 한계(<span class="math inline">\(1.414\)</span>)를 물리적으로 초과하여 결합이 찢겨 나간 상태이다.</p>
</dd>
<dt>데이터 출처 3 (물):</dt>
<dd>
<p>바닷물 정수 과정에서 물은 <span class="math inline">\(\pm 255 \sim 275\,\mathrm{fm}\)</span> 범위를 유지하였다[cite: 77, 83]. 이는 확장비 <span class="math inline">\(1.17\)</span>배 수준으로, 임계점(<span class="math inline">\(1.414\)</span>)에 훨씬 못 미치므로 구조적으로 매우 안정함을 증명한다.</p>
</dd>
</dl>
<h3 data-number="20.4.3" id="결론-화학-공학의-새로운-공식"><span class="header-section-number">20.4.3</span> 18.3.3 결론: 화학 공학의 새로운 공식</h3>
<p>이로써 화학 반응을 설계하는 새로운 공식이 도출된다.</p>
<blockquote>
<p>“반응을 일으키고 싶은가? 온도나 압력을 고민하지 말고, 오직 <strong>진폭을 <span class="math inline">\(\sqrt{2}\)</span>배 늘릴 방법(촉매, 공명)</strong>을 찾아라. 그것이 유일한 해법이다.”</p>
</blockquote>
<h2 data-number="20.5" id="분자-구조와-결합각의-결정"><span class="header-section-number">20.5</span> 18.4 분자 구조와 결합각의 결정</h2>
<p>현대 화학은 분자의 결합각이 비공유 전자쌍의 반발력(VSEPR)에 의해 결정된다고 설명한다. 그러나 본 이론은 이를 부정하며, 결합각의 변형이 <strong>중심 원자의 압축력(<span class="math inline">\(P_{\mathrm{center}}\)</span>)과 리간드의 버팀력(<span class="math inline">\(P_{\mathrm{ligand}}\)</span>) 간의 힘의 불균형</strong>에서 오는 기하학적 찌그러짐(Squeeze)임을 선언한다.</p>
<h3 data-number="20.5.1" id="결합각-결정-공식-압력-차이delta-p"><span class="header-section-number">20.5.1</span> 18.4.1 결합각 결정 공식: 압력 차이(<span class="math inline">\(\Delta P\)</span>)</h3>
<p>결합각 <span class="math inline">\(\theta\)</span>는 이상적인 대칭각(정사면체 109.5<span class="math inline">\(^\circ\)</span>)에서 중심 원자의 과잉 압력만큼 차감되어 결정된다.
<span class="math display">\[\theta_{\mathrm{real}} \approx \theta_{\mathrm{ideal}} - k \cdot (P_{\mathrm{center}} - P_{\mathrm{ligand}})\]</span>
여기서 <span class="math inline">\(P_{\mathrm{center}}\)</span>가 클수록 중심에서 주변 원자들을 안쪽으로 강하게 잡아당기므로, 결합각은 좁아진다.</p>
<h3 data-number="20.5.2" id="lock-주요-분자의-기하학적-해석"><span class="header-section-number">20.5.2</span> 18.4.2 [LOCK] 주요 분자의 기하학적 해석</h3>
<p>다음은 압력 지수(<span class="math inline">\(P_{\mathrm{idx}}\)</span>) 계산에 따른 결합각의 변화를 실증한 데이터이다.</p>
<ol>
<li><p><strong>메탄 (<span class="math inline">\(CH_4\)</span>) <span class="math inline">\(\rightarrow\)</span> 무결점 대칭 (109.5<span class="math inline">\(^\circ\)</span>)</strong></p>
<ul>
<li><p><strong>압력 상태:</strong> 중심 탄소(<span class="math inline">\(P \approx 1.00\)</span>)와 주변 수소(<span class="math inline">\(P=1.00\)</span>)의 압력이 동일하다.</p></li>
<li><p><strong>해석:</strong> 내부 응력이 없는 상태(Zero Stress). 공간을 정확히 4등분한 정사면체 각도를 유지한다.</p></li>
</ul></li>
<li><p><strong>암모니아 (<span class="math inline">\(NH_3\)</span>) <span class="math inline">\(\rightarrow\)</span> 경미한 압축 (107.8<span class="math inline">\(^\circ\)</span>)</strong></p>
<ul>
<li><p><strong>압력 상태:</strong> 중심 질소(<span class="math inline">\(P \approx 1.33\)</span>)가 수소(<span class="math inline">\(P=1.00\)</span>)보다 압력이 높다.</p></li>
<li><p><strong>해석:</strong> 중심의 과잉 압력이 수소들을 안쪽으로 당기며, 약 1.7<span class="math inline">\(^\circ\)</span>의 각도 축소가 발생한다.</p></li>
</ul></li>
<li><p><strong>물 (<span class="math inline">\(H_2O\)</span>) <span class="math inline">\(\rightarrow\)</span> 강력한 압축 (104.5<span class="math inline">\(^\circ\)</span>)</strong></p>
<ul>
<li><p><strong>압력 상태:</strong> 중심 산소(<span class="math inline">\(P \approx 1.76\)</span>)가 수소(<span class="math inline">\(P=1.00\)</span>)보다 압도적으로 강하다.</p></li>
<li><p><strong>해석:</strong> 중심핵이 주변 공간을 강력하게 쥐어짜(Squeeze) 버린다. 이로 인해 수소 간의 거리가 좁혀지며 5<span class="math inline">\(^\circ\)</span> 이상의 각도 붕괴가 발생한다.</p></li>
</ul></li>
</ol>
<h3 data-number="20.5.3" id="결론-전자쌍이-아니라-압력이다"><span class="header-section-number">20.5.3</span> 18.4.3 결론: 전자쌍이 아니라 압력이다</h3>
<p>비공유 전자쌍 때문에 각도가 줄어드는 것이 아니라, <strong>중심 원자의 표면 전하 밀도(<span class="math inline">\(P_{\mathrm{idx}}\)</span>)가 높기 때문에</strong> 그 결과로서 공간이 수축하고, 남는 공간에 전자가 밀려난 것이다. 즉, 인과관계가 기존 이론과 정반대이다.</p>
<h2 data-number="20.6" id="촉매와-분리-공학-압축과-이완"><span class="header-section-number">20.6</span> 18.5 촉매와 분리 공학: 압축과 이완</h2>
<p>화학 공학의 양대 축인 촉매 반응(합성)과 분리 정제(추출)는 상반된 물리적 현상처럼 보이지만, 기하학적 관점에서는 <strong>진폭의 압축(Compression)과 이완(Relaxation)</strong>이라는 단일 원리로 설명된다.</p>
<h3 data-number="20.6.1" id="촉매의-기하학-초고압축-장high-pressure-field"><span class="header-section-number">20.6.1</span> 18.5.1 촉매의 기하학: 초고압축 장(High-Pressure Field)</h3>
<p>백금(<span class="math inline">\(Pt\)</span>)이나 팔라듐(<span class="math inline">\(Pd\)</span>) 같은 귀금속 촉매가 반응성이 높은 이유는, 표면 전하 밀도가 기형적으로 높아 주변 공간을 강제로 찌그러뜨리기 때문이다.</p>
<ol>
<li><p><strong>백금의 압력 지수:</strong> <span class="math inline">\(Pt\)</span>의 압력 지수는 <span class="math inline">\(P_{\mathrm{idx}} \approx 4.05\)</span>로, 일반적인 탄소(<span class="math inline">\(1.00\)</span>)나 철(<span class="math inline">\(1.24\)</span>)보다 3 4배 강력한 <strong>’압축 중력장’</strong>을 형성한다.</p></li>
<li><p><strong>반응 메커니즘 (Squeeze &amp; Break):</strong></p>
<ul>
<li><p>반응물(예: 수소, 질소)이 촉매 표면에 접근하면, <span class="math inline">\(4배\)</span>에 달하는 격자 압력에 노출된다.</p></li>
<li><p>입자의 진폭(<span class="math inline">\(r_{\mathrm{eff}}\)</span>)이 외부 압력에 의해 강제로 압축되거나 비틀리며, 이 과정에서 격자 구조가 불안정해진다.</p></li>
<li><p>결과적으로 작은 외부 에너지로도 진폭이 <span class="math inline">\(\sqrt{2}\)</span> 임계점(대각선)으로 튕겨 나가며 결합이 붕괴된다.</p></li>
</ul></li>
<li><p><strong>결론:</strong> 촉매는 화학적 친화력이 아니라, <strong>기하학적 압착기(Geometric Press)</strong>이다.</p></li>
</ol>
<h3 data-number="20.6.2" id="분리-공학-진폭-선별amplitude-sorting"><span class="header-section-number">20.6.2</span> 18.5.2 분리 공학: 진폭 선별(Amplitude Sorting)</h3>
<p>혼합물에서 특정 물질을 분리하는 것은 입자의 <strong>동적 진폭 차이(<span class="math inline">\(\Delta r\)</span>)</strong>를 이용한 기하학적 정렬 게임이다. 본 이론은 [바닷물 정수 시스템]의 실측 데이터를 통해 이를 증명한다.</p>
<ol>
<li><p><strong>물(<span class="math inline">\(H_2O\)</span>)의 상태 <span class="math inline">\(\rightarrow\)</span> 압축(Compressed):</strong></p>
<ul>
<li><p>산소의 강력한 구심력(<span class="math inline">\(P_{\mathrm{idx}}=1.76\)</span>)에 의해 수소가 단단히 잡혀 있다.</p></li>
<li><p><strong>진폭:</strong> <span class="math inline">\(255 \sim 275\,\mathrm{fm}\)</span> (작고 단단함).</p></li>
<li><p><strong>거동:</strong> 외부 자기장에 민감하게 반응하며 상단으로 정렬된다.</p></li>
</ul></li>
<li><p><strong>이온(<span class="math inline">\(Na^+, Cl^-\)</span>)의 상태 <span class="math inline">\(\rightarrow\)</span> 이완(Relaxed):</strong></p>
<ul>
<li><p>수화(Hydration) 껍질과 낮은 표면 전하 밀도로 인해 격자 구속력이 약하다.</p></li>
<li><p><strong>진폭:</strong> <span class="math inline">\(320 \sim 340\,\mathrm{fm}\)</span> (크고 헐거움).</p></li>
<li><p><strong>거동:</strong> 뚱뚱한 진폭으로 인해 정렬 축에서 밀려나 하단으로 배출된다.</p></li>
</ul></li>
<li><p><strong>결론:</strong> 분리 공학의 핵심은 물질의 화학적 성질이 아니라, <strong>“누가 더 작게 압축되어 있는가?”</strong>를 판별하는 기하학적 필터링이다.</p></li>
</ol>
<h3 data-number="20.6.3" id="공학적-응용의-시사점"><span class="header-section-number">20.6.3</span> 18.5.3 공학적 응용의 시사점</h3>
<p>본 이론에 따르면, 새로운 촉매나 필터를 설계할 때 더 이상 무작위 실험에 의존할 필요가 없다.</p>
<blockquote>
<p>“원하는 반응이 있는가? 타겟 물질의 진폭을 계산하고, 그 진폭을 <span class="math inline">\(\sqrt{2}\)</span>배로 늘릴 수 있는 <strong>고압력 격자(<span class="math inline">\(P_{\mathrm{idx}}\)</span>)</strong>를 설계하라. 그것이 최적의 촉매다.”</p>
</blockquote>
<h2 data-number="20.7" id="주요-난제-해결-사례-검증"><span class="header-section-number">20.7</span> 18.6 주요 난제 해결 사례 검증</h2>
<p>본 절은 앞서 유도된 <strong>동적 진폭(<span class="math inline">\(r_{\mathrm{eff}}\)</span>)</strong>과 <strong>격자 한계(<span class="math inline">\(\sqrt{2}\)</span>)</strong> 법칙을 실제 화학 난제 해결에 적용한 시뮬레이션 결과를 검증한다. 질소 고정, 이산화탄소 분해, 해수 담수화 사례는 모두 기하학적 임계값 제어만으로 화학 반응을 통제할 수 있음을 입증하였다.</p>
<h3 data-number="20.7.1" id="상온-질소-고정-haber-bosch-대체"><span class="header-section-number">20.7.1</span> 18.6.1 상온 질소 고정 (Haber-Bosch 대체)</h3>
<p>질소(<span class="math inline">\(N \equiv N\)</span>) 분자의 강력한 삼중 결합을 고온(500<span class="math inline">\(^\circ\)</span>C)·고압(200기압) 없이 상온에서 끊어내는 것은 화학 공학의 성배였다.</p>
<ol>
<li><p><strong>난제 원인:</strong> 질소의 바닥 상태 진폭은 <span class="math inline">\(213\,\mathrm{fm}\)</span>로, 압력 지수(<span class="math inline">\(P_{\mathrm{idx}}=1.33\)</span>)가 높아 결합 길이가 극도로 짧고 단단하다.</p></li>
<li><p><strong>해결 솔루션 (<span class="math inline">\(Fe-Mo\)</span> 촉매):</strong></p>
<ul>
<li><p>고가의 백금(<span class="math inline">\(Pt\)</span>) 대신 철-몰리브덴(<span class="math inline">\(Fe-Mo\)</span>) 복합 촉매를 사용하여, 표면에 <strong>비대칭 압축장</strong>을 형성하는 <strong>프로토콜을 제안한다</strong>[cite: 20, 30].</p></li>
<li><p>촉매/충격 구동이 질소 분자의 공유 중심을 사선으로 가격하여 진폭을 강제로 확장시키는 효과를 목표로 한다.</p></li>
</ul></li>
<li><p><strong>검증 결과:</strong></p>
<ul>
<li><p><strong>임계 진폭:</strong> <span class="math inline">\(\pm 290\,\mathrm{fm}\)</span> 도달 시 결합 붕괴 발생[cite: 21, 26].</p></li>
<li><p><strong>확장비:</strong> <span class="math inline">\(\frac{290}{213} \approx 1.36\)</span>배.</p></li>
<li><p><strong>해석:</strong> 이론적 한계인 <span class="math inline">\(\sqrt{2} (1.414)\)</span>배 직전까지 진폭을 늘린 상태에서, 촉매의 물리적 타격(Alignment Interference)이 더해져 결합 해체 이벤트로 해석한다.</p></li>
</ul></li>
</ol>
<h3 data-number="20.7.2" id="이산화탄소-열분해-및-재결합-제어"><span class="header-section-number">20.7.2</span> 18.6.2 이산화탄소 열분해 및 재결합 제어</h3>
<p>지구 온난화의 주범인 <span class="math inline">\(CO_2\)</span>를 분해하는 것은 열역학적으로 매우 어렵다. 특히 분해된 <span class="math inline">\(CO\)</span>와 <span class="math inline">\(O\)</span>가 즉시 재결합하는 문제가 핵심 난제였다.</p>
<ol>
<li><p><strong>분해 메커니즘 (Break):</strong></p>
<ul>
<li><p>고온 환경(<span class="math inline">\(1800\,\mathrm{K}\)</span> 등가)을 목표로 하여 분자의 열진동을 증폭시키는 구동을 설정한다[cite: 61].</p></li>
<li><p><strong>분해 임계:</strong> 진폭이 <span class="math inline">\(\pm 300\,\mathrm{fm}\)</span>를 초과하는 순간 <span class="math inline">\(O=C=O\)</span> 결합이 붕괴됨[cite: 61, 65].</p></li>
<li><p><strong>확장비:</strong> <span class="math inline">\(\frac{300}{205} \approx 1.46\)</span>배. 기하학적 한계(<span class="math inline">\(1.414\)</span>)를 물리적으로 초과하여 완전 분해됨을 입증하였다.</p></li>
</ul></li>
<li><p><strong>재결합 억제 (Quenching):</strong></p>
<ul>
<li><p>분해 직후 급랭을 통해 진폭을 <span class="math inline">\(\pm 250\,\mathrm{fm}\)</span> 이내로 축소시키고, 정렬률을 70% 미만으로 교란하면 재결합을 억제할 수 있다는 가설을 둔다(UNLOGGED)[cite: 65, 68].</p></li>
</ul></li>
</ol>
<h3 data-number="20.7.3" id="바닷물-정수-에너지-제로-필터링"><span class="header-section-number">20.7.3</span> 18.6.3 바닷물 정수: 에너지 제로 필터링</h3>
<p>역삼투압(RO) 방식은 막대한 전력을 소모하지만, 본 이론의 <strong>진폭 선별법</strong>은 무전력으로 순수한 물을 분리한다.</p>
<ol>
<li><p><strong>기하학적 선별 원리:</strong></p>
<ul>
<li><p><strong>물(<span class="math inline">\(H_2O\)</span>):</strong> 진폭 <span class="math inline">\(255 \sim 275\,\mathrm{fm}\)</span>. 산소의 강한 압축력으로 단단하게 뭉쳐 있음[cite: 77, 102].</p></li>
<li><p><strong>이온(<span class="math inline">\(Na^+, Cl^-\)</span>):</strong> 진폭 <span class="math inline">\(320 \sim 340\,\mathrm{fm}\)</span>. 전하 밀도 저하로 인해 뚱뚱하게 퍼짐[cite: 77].</p></li>
</ul></li>
<li><p><strong>실증 결과:</strong></p>
<ul>
<li><p>자기장 회전체 통과 시, 가볍고 단단한 물 분자만 상단 슬릿(<span class="math inline">\(\pm 275\,\mathrm{fm}\)</span> 이하 허용)으로 통과하였다.</p></li>
<li><p>헐거운 이온들은 원심력과 자기장 배척에 의해 하단으로 배출될 수 있으며, 내부 목표치로 97% 수준을 제시한다(UNLOGGED)[cite: 85].</p></li>
<li><p><strong>의의:</strong> 화학 필터 없이 오직 <strong>입자의 기하학적 크기(진폭)</strong>만으로 물질을 분리하는 새로운 공학적 표준을 제시하였다.</p></li>
</ul></li>
</ol>
<h3 data-number="20.7.4" id="종합-결론"><span class="header-section-number">20.7.4</span> 18.6.4 종합 결론</h3>
<p>상기 3가지 사례는 화학 반응이 복잡한 양자 역학적 확률 게임이 아니라, <strong>“진폭을 <span class="math inline">\(\sqrt{2}\)</span>배 늘리거나(분해), 진폭 크기대로 분류하는(정수)”</strong> 단순한 기하학적 공정임을 증명한다.</p>
<h2 data-number="20.8" id="결론-물질-과학의-새로운-지평"><span class="header-section-number">20.8</span> 18.7 결론: 물질 과학의 새로운 지평</h2>
<p>본 장의 논증을 통해, 화학은 더 이상 복잡한 예외 규칙들의 집합이 아님이 증명되었다. 원자의 결합, 분해, 그리고 구조의 변형은 모두 <strong><span class="math inline">\(\ell_{\mathrm{rot}}\)</span> 격자 공간 안에서의 기하학적 필연</strong>에 의해 결정된다.</p>
<h3 data-number="20.8.1" id="통합된-제1원리-구조가-성질을-결정한다"><span class="header-section-number">20.8.1</span> 18.7.1 통합된 제1원리: 구조가 성질을 결정한다</h3>
<p>기존 과학은 “산소는 반응성이 크다”는 관찰 결과(Property)를 먼저 기술하고 이유를 찾았으나, 본 이론은 <strong>“산소의 압력 지수가 1.76이므로 과압축되어 반응할 수밖에 없다”</strong>는 구조적 원인(Structure)을 먼저 제시한다.</p>
<ol>
<li><p><strong>압력(<span class="math inline">\(P_{\mathrm{idx}}\)</span>):</strong> 원자가 공간을 쥐어짜는 힘. 이것이 결합각과 결합 에너지를 결정한다.</p></li>
<li><p><strong>진폭(<span class="math inline">\(r_{\mathrm{eff}}\)</span>):</strong> 압력에 의해 결정된 입자의 크기. 이것이 분리 공학의 선별 기준이 된다.</p></li>
<li><p><strong>한계(<span class="math inline">\(\sqrt{2}\)</span>):</strong> 격자가 버틸 수 있는 대각선 길이. 이것이 모든 화학 반응의 시작과 끝을 통제한다.</p></li>
</ol>
<h3 data-number="20.8.2" id="엔지니어링-패러다임의-전환"><span class="header-section-number">20.8.2</span> 18.7.2 엔지니어링 패러다임의 전환</h3>
<p>본 이론서는 엔지니어들에게 더 이상 무작위 실험(Trial &amp; Error)에 의존하지 말 것을 제안한다.</p>
<ul>
<li><p><strong>합성(Synthesis):</strong> 원하는 반응이 있다면, 반응물의 진폭을 계산하고 이를 <span class="math inline">\(\sqrt{2}\)</span>배(<span class="math inline">\(1.414\)</span>)로 확장할 수 있는 촉매의 압축장을 설계하라. [질소 고정, <span class="math inline">\(CO_2\)</span> 분해 사례 입증]</p></li>
<li><p><strong>분리(Separation):</strong> 물질을 거르고 싶다면, 화학 필터 대신 입자의 진폭 크기에 맞는 기하학적 슬릿(Slit)을 설계하라. [해수 담수화 사례 입증]</p></li>
</ul>
<h3 data-number="20.8.3" id="최종-선언"><span class="header-section-number">20.8.3</span> 18.7.3 최종 선언</h3>
<p>본 문서의 범위(부피입자 격자-재밍 모듈)에서는 확률/불확정성 항을 도입하지 않는다. 오직 <strong>격자(Lattice)</strong>와 그 안을 채우는 <strong>압력(Pressure)</strong>, 그리고 균형을 찾아 움직이는 <strong>진폭(Amplitude)</strong>만이 존재할 뿐이다.
화학 반응은 주사위 놀이가 아니라, 완벽하게 정밀한 <strong>기계적 톱니바퀴의 맞물림(Mechanical Gear-mesh)</strong>이다.</p>
<p>이로써 본 문서는 물리학의 입자 이론을 화학의 반응 공학까지 확장하여, <strong>하나의 일관된 기하학적 대통합 이론(Grand Unified Geometric Theory)</strong>을 완성한다.</p>
<h2 data-number="20.9" id="상전이와-열역학-진폭의-임계-온도"><span class="header-section-number">20.9</span> 18.8 상전이와 열역학: 진폭의 임계 온도</h2>
<p>본 절은 열역학적 상전이를 입자의 무작위 운동이 아닌, <strong>진폭(<span class="math inline">\(r_{\mathrm{eff}}\)</span>)이 격자 구속 길이를 초과하는 기하학적 사건</strong>으로 재정의한다. 특히 금속의 녹는점(<span class="math inline">\(T_m\)</span>)과 끓는점(<span class="math inline">\(T_b\)</span>) 사이의 비율이 기하학적 상수(<span class="math inline">\(\approx 1.6\)</span>)에 수렴하는 현상을 수학적으로 증명한다.</p>
<h3 data-number="20.9.1" id="온도의-기하학적-정의"><span class="header-section-number">20.9.1</span> 18.8.1 온도의 기하학적 정의</h3>
<p>기존 열역학에서 온도는 분자의 평균 운동 에너지(<span class="math inline">\(E_k = \frac{3}{2}kT\)</span>)로 정의되나, 본 이론에서는 이를 <strong>진폭 확장 계수(Amplitude Expansion Coefficient)</strong>로 재해석한다.
<span class="math display">\[r(T) = r_0 \times (1 + \alpha T)\]</span>
여기서 <span class="math inline">\(\alpha\)</span>는 물질 고유의 열팽창 계수이다. 온도가 상승함에 따라 진폭 <span class="math inline">\(r\)</span>이 커지며, 이 진폭이 격자의 특정 기하학적 경계(Boundary)에 닿을 때 상전이가 발생한다.</p>
<h3 data-number="20.9.2" id="상전이-임계점의-기하학적-조건"><span class="header-section-number">20.9.2</span> 18.8.2 상전이 임계점의 기하학적 조건</h3>
<p>단위 격자의 변의 길이를 <span class="math inline">\(L\)</span>이라 할 때, 상태 변화는 다음의 접촉 조건에서 발생한다.</p>
<ol>
<li><p><strong>녹는점(Melting Point, <span class="math inline">\(T_m\)</span>): 면 접촉 (<span class="math inline">\(r \approx L\)</span>)</strong><br/>
진폭이 격자의 내벽(Face)에 닿는 시점이다. 이 단계에서 입자는 격자 벽을 타고 미끄러질(Slip) 수 있게 되며, 고체의 강성을 잃고 유체(액체)로 전이한다.</p></li>
<li><p><strong>끓는점(Boiling Point, <span class="math inline">\(T_b\)</span>): 대각선 탈출 (<span class="math inline">\(r \approx L_{\mathrm{escape}}\)</span>)</strong><br/>
진폭이 격자의 구속을 완전히 벗어나는 시점이다. 입자가 주변 입자들의 방해를 뚫고 자유 공간으로 비산하기 위해서는 격자의 가장 긴 대각선 경로를 확보해야 한다.</p></li>
</ol>
<h3 data-number="20.9.3" id="lock-1.6-비율의-수학적-증명"><span class="header-section-number">20.9.3</span> 18.8.3 [LOCK] 1.6 비율의 수학적 증명</h3>
<p>대부분의 구조용 금속(텅스텐, 철 등)에서 <span class="math inline">\(\frac{T_b}{T_m} \approx 1.6\)</span>인 경험칙이 존재한다. 본 이론은 이를 <strong>3차원 격자 탈출의 기하평균</strong>으로 유도한다.</p>
<ul>
<li><p><strong>가정:</strong> 상전이 온도는 임계 진폭에 비례한다 (<span class="math inline">\(T \propto r\)</span>).</p></li>
<li><p><strong>탈출 경로의 이중성:</strong> 3차원 입방 격자(Cubic Lattice)에서 입자가 탈출하기 위한 경로는 두 가지 한계값을 가진다.</p>
<ol>
<li><p><strong>면 대각선 (Face Diagonal):</strong> <span class="math inline">\(L\sqrt{2} \approx 1.414 L\)</span> (최소 탈출 경로)</p></li>
<li><p><strong>체 대각선 (Body Diagonal):</strong> <span class="math inline">\(L\sqrt{3} \approx 1.732 L\)</span> (완전 탈출 경로)</p></li>
</ol></li>
<li><p><strong>유효 탈출 장벽 (<span class="math inline">\(L_{\mathrm{eff}}\)</span>):</strong> 실제 다결정 금속에서 입자는 무작위 방향으로 탈출하므로, 유효 장벽은 두 경로의 기하학적 평균(RMS)을 따른다.
<span class="math display">\[\label{eq:boiling_ratio}
        \text{Geometric Ratio} = \sqrt{\frac{(\sqrt{2})^2 + (\sqrt{3})^2}{2}} = \sqrt{\frac{2+3}{2}} = \sqrt{2.5} \approx \mathbf{1.581}\]</span></p></li>
<li><p><strong>검증:</strong> 텅스텐(<span class="math inline">\(W\)</span>)의 실측 비율 <span class="math inline">\(\frac{5828K}{3695K} = \mathbf{1.58}\)</span>과 이론값(<span class="math inline">\(1.581\)</span>)이 소수점 둘째 자리까지 정확히 일치한다. 이는 상전이가 순수한 기하학적 필연임을 증명한다.</p></li>
</ul>
<h3 data-number="20.9.4" id="응용-탄화수소의-기화점-예측"><span class="header-section-number">20.9.4</span> 18.8.4 응용: 탄화수소의 기화점 예측</h3>
<p>석유 화학에서 탄소 사슬 길이(<span class="math inline">\(n\)</span>)에 따른 기화점 상승은 <strong>진폭 동기화(Amplitude Synchronization)</strong>로 설명된다.</p>
<ul>
<li><p><strong>원리:</strong> 긴 사슬 분자(<span class="math inline">\(C_{30}H_{62}\)</span> 등)가 기화하려면, 연결된 30개의 탄소 원자 진폭이 <strong>동시에</strong> <span class="math inline">\(\sqrt{2}\)</span> 임계점을 넘어야 한다.</p></li>
<li><p><strong>결과:</strong> 확률적으로 동기화가 어렵기 때문에, 사슬이 길수록 기화점이 기하급수적으로 상승하거나, 기화되기 전에 분해(Cracking)되어 버린다. (아스팔트가 고체인 이유)</p></li>
</ul>
<h3 data-number="20.9.5" id="결론-온도는-진폭이다"><span class="header-section-number">20.9.5</span> 18.8.5 결론: 온도는 진폭이다</h3>
<p>열역학은 통계가 아니라 기하학이다. 물질이 녹거나 끓는 것은 분자가 에너지를 얻어서가 아니라, <strong>진폭이 커져서 감옥(격자)의 창살(대각선)보다 더 커졌기 때문</strong>이다. 이로써 1.6이라는 비율은 우주의 구조적 상수로 확정된다.</p>
<h1 class="unnumbered" id="부록-a.-수학-보조정리증명-스케치">부록 A. 수학 보조정리/증명 스케치</h1>
<h2 class="unnumbered" id="a.0-표기와-기본-약속공통">A.0 표기와 기본 약속(공통)</h2>
<h4 data-number="20.9.5.1" id="수와-벡터"><span class="header-section-number">20.9.5.1</span> (1) 수와 벡터</h4>
<p><span class="math inline">\(\mathbb{R}\)</span>은 실수체, <span class="math inline">\(\mathbb{C}\)</span>는 복소수체이다. 벡터공간 <span class="math inline">\(V\)</span>는 <span class="math inline">\(\mathbb{R}\)</span> 또는 <span class="math inline">\(\mathbb{C}\)</span> 위의 선형공간으로 둔다.</p>
<h4 data-number="20.9.5.2" id="내적과-노름"><span class="header-section-number">20.9.5.2</span> (2) 내적과 노름</h4>
<p>복소 내적공간 <span class="math inline">\((V,\langle\cdot,\cdot\rangle)\)</span>에서 내적은 다음 성질을 만족한다.</p>
<ol>
<li><p>(선형성) <span class="math inline">\(\langle ax+by, z\rangle = a\langle x,z\rangle + b\langle y,z\rangle\)</span>.</p></li>
<li><p>(켤레대칭) <span class="math inline">\(\langle x,y\rangle = \overline{\langle y,x\rangle}\)</span>.</p></li>
<li><p>(양의 정부호) <span class="math inline">\(\langle x,x\rangle \ge 0\)</span>이고, <span class="math inline">\(\langle x,x\rangle=0 \Leftrightarrow x=0\)</span>.</p></li>
</ol>
<p>노름은 <span class="math inline">\(\|x\|:=\sqrt{\langle x,x\rangle}\)</span>로 정의한다.</p>
<h4 data-number="20.9.5.3" id="선형연산자와-수반"><span class="header-section-number">20.9.5.3</span> (3) 선형연산자와 수반</h4>
<p>선형연산자 <span class="math inline">\(A:V\to V\)</span>의 수반 <span class="math inline">\(A^\dagger\)</span>는
<span class="math display">\[\langle Ax,y\rangle=\langle x,A^\dagger y\rangle\quad(\forall x,y\in V)\]</span>
를 만족하는 연산자이다. <span class="math inline">\(A=A^\dagger\)</span>이면 <span class="math inline">\(A\)</span>를 (수학적 의미에서) 자기수반이라 한다.</p>
<h4 data-number="20.9.5.4" id="교환자"><span class="header-section-number">20.9.5.4</span> (4) 교환자</h4>
<p>연산자 <span class="math inline">\(A,B\)</span>의 교환자는 <span class="math inline">\([A,B]:=AB-BA\)</span>로 정의한다.</p>
<h2 class="unnumbered" id="a.1-코시슈바르츠-부등식">A.1 코시–슈바르츠 부등식</h2>
<h4 data-number="20.9.5.5" id="정리-a.1코시슈바르츠"><span class="header-section-number">20.9.5.5</span> 정리 A.1(코시–슈바르츠)</h4>
<p>임의의 <span class="math inline">\(x,y\in V\)</span>에 대해
<span class="math display">\[|\langle x,y\rangle|\le \|x\|\,\|y\|
\label{eq:AppA_CS}\]</span>
가 성립한다.</p>
<h4 data-number="20.9.5.6" id="증명-3"><span class="header-section-number">20.9.5.6</span> 증명</h4>
<p><span class="math inline">\(y=0\)</span>이면 좌변은 <span class="math inline">\(0\)</span>이므로 성립한다. 이제 <span class="math inline">\(y\neq 0\)</span>이라 두고,
임의의 <span class="math inline">\(\lambda\in\mathbb{C}\)</span>에 대해
<span class="math display">\[0\le \|x-\lambda y\|^2=\langle x-\lambda y, x-\lambda y\rangle\]</span>
를 전개한다.
<span class="math display">\[\begin{aligned}
\|x-\lambda y\|^2
&amp;=\langle x,x\rangle-\lambda\langle y,x\rangle-\overline{\lambda}\langle x,y\rangle+|\lambda|^2\langle y,y\rangle\\
&amp;=\|x\|^2-\lambda\overline{\langle x,y\rangle}-\overline{\lambda}\langle x,y\rangle+|\lambda|^2\|y\|^2.\end{aligned}\]</span>
<span class="math inline">\(\lambda:=\langle x,y\rangle/\|y\|^2\)</span>로 택하면,
<span class="math display">\[\begin{aligned}
0\le \|x-\lambda y\|^2
&amp;=\|x\|^2-\frac{\langle x,y\rangle\overline{\langle x,y\rangle}}{\|y\|^2}
-\frac{\overline{\langle x,y\rangle}\langle x,y\rangle}{\|y\|^2}
+\frac{|\langle x,y\rangle|^2}{\|y\|^4}\|y\|^2\\
&amp;=\|x\|^2-\frac{|\langle x,y\rangle|^2}{\|y\|^2}.\end{aligned}\]</span>
따라서 <span class="math inline">\(|\langle x,y\rangle|^2\le \|x\|^2\|y\|^2\)</span>이고, 제곱근을 취하면 <a data-reference="eq:AppA_CS" data-reference-type="eqref" href="#eq:AppA_CS">[eq:AppA_CS]</a>가 성립한다. <span class="math inline">\(\square\)</span></p>
<h2 class="unnumbered" id="a.2-삼각부등식">A.2 삼각부등식</h2>
<h4 data-number="20.9.5.7" id="정리-a.2삼각부등식"><span class="header-section-number">20.9.5.7</span> 정리 A.2(삼각부등식)</h4>
<p>임의의 <span class="math inline">\(x,y\in V\)</span>에 대해
<span class="math display">\[\|x+y\|\le \|x\|+\|y\|
\label{eq:AppA_triangle}\]</span>
가 성립한다.</p>
<h4 data-number="20.9.5.8" id="증명-4"><span class="header-section-number">20.9.5.8</span> 증명</h4>
<p><span class="math display">\[\|x+y\|^2=\langle x+y,x+y\rangle=\|x\|^2+\|y\|^2+2\operatorname{Re}\langle x,y\rangle.\]</span>
코시–슈바르츠 <a data-reference="eq:AppA_CS" data-reference-type="eqref" href="#eq:AppA_CS">[eq:AppA_CS]</a>로부터 <span class="math inline">\(|\langle x,y\rangle|\le \|x\|\|y\|\)</span>이고,
<span class="math inline">\(\operatorname{Re}\langle x,y\rangle\le |\langle x,y\rangle|\)</span>이므로
<span class="math display">\[\|x+y\|^2\le \|x\|^2+\|y\|^2+2\|x\|\|y\|=(\|x\|+\|y\|)^2.\]</span>
양변 제곱근으로 <a data-reference="eq:AppA_triangle" data-reference-type="eqref" href="#eq:AppA_triangle">[eq:AppA_triangle]</a>. <span class="math inline">\(\square\)</span></p>
<h2 class="unnumbered" id="a.3-몫공간-차원-정리전역-기준-자유도-제거">A.3 몫공간 차원 정리(전역 기준 자유도 제거)</h2>
<h4 data-number="20.9.5.9" id="정리-a.3몫공간-차원"><span class="header-section-number">20.9.5.9</span> 정리 A.3(몫공간 차원)</h4>
<p><span class="math inline">\(V\)</span>가 유한차원 벡터공간이고 <span class="math inline">\(W\subset V\)</span>가 부분공간이면,
<span class="math display">\[\dim(V/W)=\dim(V)-\dim(W)
\label{eq:AppA_dim_quotient}\]</span>
가 성립한다.</p>
<h4 data-number="20.9.5.10" id="증명-5"><span class="header-section-number">20.9.5.10</span> 증명</h4>
<p><span class="math inline">\(W\)</span>의 기저 <span class="math inline">\(\{w_1,\dots,w_k\}\)</span>를 <span class="math inline">\(V\)</span>의 기저로 확장하여
<span class="math inline">\(\{w_1,\dots,w_k,u_1,\dots,u_{n-k}\}\)</span>가 <span class="math inline">\(V\)</span>의 기저가 되게 한다(<span class="math inline">\(n=\dim(V)\)</span>).
몫사상 <span class="math inline">\(\pi:V\to V/W\)</span>에 대해 <span class="math inline">\(\{\pi(u_1),\dots,\pi(u_{n-k})\}\)</span>가 <span class="math inline">\(V/W\)</span>를 생성함을 보인다.
임의의 <span class="math inline">\(v\in V\)</span>는
<span class="math display">\[v=\sum_{i=1}^k a_i w_i + \sum_{j=1}^{n-k} b_j u_j\]</span>
로 쓰이고, <span class="math inline">\(\pi(w_i)=0\)</span>이므로
<span class="math display">\[\pi(v)=\sum_{j=1}^{n-k} b_j \pi(u_j).\]</span>
따라서 <span class="math inline">\(\{\pi(u_j)\}\)</span>는 생성계이다. 선형독립성은
<span class="math display">\[\sum_{j=1}^{n-k} b_j \pi(u_j)=0 \Rightarrow \pi\Bigl(\sum_{j=1}^{n-k} b_j u_j\Bigr)=0
\Rightarrow \sum_{j=1}^{n-k} b_j u_j \in W.\]</span>
그런데 <span class="math inline">\(\{w_i,u_j\}\)</span>가 기저이므로 <span class="math inline">\(W\)</span>에 속하는 벡터는 <span class="math inline">\(u_j\)</span> 성분이 모두 <span class="math inline">\(0\)</span>이어야 한다.
따라서 <span class="math inline">\(b_j=0\)</span>이고, <span class="math inline">\(\{\pi(u_j)\}\)</span>는 기저이며 <span class="math inline">\(\dim(V/W)=n-k\)</span>이다. <span class="math inline">\(\square\)</span></p>
<h4 data-number="20.9.5.11" id="적용-a.3.16면-채널에서-전역-기준-제거"><span class="header-section-number">20.9.5.11</span> 적용 A.3.1(6면 채널에서 전역 기준 제거)</h4>
<p><span class="math inline">\(V=\mathbb{R}^6\)</span>, <span class="math inline">\(W=\mathrm{span}\{\mathbf{1}_6\}\)</span>, <span class="math inline">\(\mathbf{1}_6=(1,1,1,1,1,1)\)</span>이면
<span class="math inline">\(\dim(W)=1\)</span>, <span class="math inline">\(\dim(V)=6\)</span>이므로 <a data-reference="eq:AppA_dim_quotient" data-reference-type="eqref" href="#eq:AppA_dim_quotient">[eq:AppA_dim_quotient]</a>에 의해 <span class="math inline">\(\dim(V/W)=5\)</span>.</p>
<h2 class="unnumbered" id="a.4-이산-푸리에-변환과-파르세발-정리유한-격자">A.4 이산 푸리에 변환과 파르세발 정리(유한 격자)</h2>
<h4 data-number="20.9.5.12" id="설정"><span class="header-section-number">20.9.5.12</span> 설정</h4>
<p><span class="math inline">\(N\in\mathbb{N}\)</span>에 대해 <span class="math inline">\(\mathbb{Z}_N=\{0,1,\dots,N-1\}\)</span>을 모듈러 <span class="math inline">\(N\)</span>의 순환군으로 둔다.
복소수열 <span class="math inline">\(x:\mathbb{Z}_N\to\mathbb{C}\)</span>의 내적을
<span class="math display">\[\langle x,y\rangle := \sum_{n=0}^{N-1} x_n \overline{y_n}\]</span>
로 둔다.</p>
<h4 data-number="20.9.5.13" id="정의-a.4dft"><span class="header-section-number">20.9.5.13</span> 정의 A.4(DFT)</h4>
<p>이산 푸리에 변환(DFT)을
<span class="math display">\[X_k := \sum_{n=0}^{N-1} x_n\,e^{-2\pi i kn/N}\qquad (k=0,\dots,N-1)
\label{eq:AppA_DFT}\]</span>
로 정의하고, 역변환을
<span class="math display">\[x_n := \frac{1}{N}\sum_{k=0}^{N-1} X_k\,e^{2\pi i kn/N}\qquad (n=0,\dots,N-1)
\label{eq:AppA_IDFT}\]</span>
로 정의한다.</p>
<h4 data-number="20.9.5.14" id="정리-a.4.1직교성"><span class="header-section-number">20.9.5.14</span> 정리 A.4.1(직교성)</h4>
<p><span class="math display">\[\sum_{n=0}^{N-1} e^{2\pi i (k-\ell)n/N}=N\,\delta_{k\ell}.\]</span></p>
<h4 data-number="20.9.5.15" id="증명-6"><span class="header-section-number">20.9.5.15</span> 증명</h4>
<p><span class="math inline">\(k=\ell\)</span>이면 합은 <span class="math inline">\(N\)</span>. <span class="math inline">\(k\neq \ell\)</span>이면 공비 <span class="math inline">\(r=e^{2\pi i (k-\ell)/N}\neq 1\)</span>인 등비급수로
<span class="math display">\[\sum_{n=0}^{N-1} r^n=\frac{1-r^N}{1-r}=\frac{1-1}{1-r}=0.\]</span>
<span class="math inline">\(\square\)</span></p>
<h4 data-number="20.9.5.16" id="정리-a.4.2파르세발"><span class="header-section-number">20.9.5.16</span> 정리 A.4.2(파르세발)</h4>
<p><span class="math display">\[\sum_{n=0}^{N-1}|x_n|^2=\frac{1}{N}\sum_{k=0}^{N-1}|X_k|^2.
\label{eq:AppA_Parseval}\]</span></p>
<h4 data-number="20.9.5.17" id="증명-7"><span class="header-section-number">20.9.5.17</span> 증명</h4>
<p><a data-reference="eq:AppA_IDFT" data-reference-type="eqref" href="#eq:AppA_IDFT">[eq:AppA_IDFT]</a>를 사용하여
<span class="math display">\[x_n=\frac{1}{N}\sum_{k}X_k e^{2\pi i kn/N},\quad \overline{x_n}=\frac{1}{N}\sum_{\ell}\overline{X_\ell} e^{-2\pi i \ell n/N}.\]</span>
따라서
<span class="math display">\[\begin{aligned}
\sum_{n}|x_n|^2
&amp;=\sum_{n}x_n\overline{x_n}
=\sum_n \frac{1}{N^2}\sum_{k,\ell} X_k\overline{X_\ell} e^{2\pi i (k-\ell)n/N}\\
&amp;=\frac{1}{N^2}\sum_{k,\ell}X_k\overline{X_\ell}\sum_n e^{2\pi i (k-\ell)n/N}.\end{aligned}\]</span>
정리 A.4.1로 내부합은 <span class="math inline">\(N\delta_{k\ell}\)</span>이므로
<span class="math display">\[\sum_{n}|x_n|^2=\frac{1}{N^2}\sum_{k,\ell}X_k\overline{X_\ell}\,N\delta_{k\ell}
=\frac{1}{N}\sum_k |X_k|^2.\]</span>
<span class="math inline">\(\square\)</span></p>
<h2 class="unnumbered" id="a.5-교환자-기반-불확정성-부등식순수-대수">A.5 교환자 기반 불확정성 부등식(순수 대수)</h2>
<h4 data-number="20.9.5.18" id="정리-a.5로버트슨-형태"><span class="header-section-number">20.9.5.18</span> 정리 A.5(로버트슨 형태)</h4>
<p>내적공간에서 자기수반 <span class="math inline">\(A,B\)</span>와 정규화된 벡터 <span class="math inline">\(\psi\)</span>(<span class="math inline">\(\|\psi\|=1\)</span>)에 대해
<span class="math display">\[\Delta_\psi A\cdot \Delta_\psi B \ge \frac{1}{2}\left|\left\langle \psi,\;[A,B]\psi\right\rangle\right|
\label{eq:AppA_Robertson}\]</span>
가 성립한다. 여기서
<span class="math display">\[\Delta_\psi A:=\sqrt{\langle (A-\langle A\rangle)\psi,(A-\langle A\rangle)\psi\rangle},
\quad
\langle A\rangle:=\langle \psi,A\psi\rangle\]</span>
로 둔다.</p>
<h4 data-number="20.9.5.19" id="증명-8"><span class="header-section-number">20.9.5.19</span> 증명</h4>
<p><span class="math inline">\(A':=A-\langle A\rangle I\)</span>, <span class="math inline">\(B':=B-\langle B\rangle I\)</span>로 두고
<span class="math inline">\(u:=A'\psi\)</span>, <span class="math inline">\(v:=B'\psi\)</span>라 두면
<span class="math display">\[\|u\|=\Delta_\psi A,\quad \|v\|=\Delta_\psi B.\]</span>
코시–슈바르츠 <a data-reference="eq:AppA_CS" data-reference-type="eqref" href="#eq:AppA_CS">[eq:AppA_CS]</a>로부터
<span class="math display">\[|\langle u,v\rangle|\le \|u\|\,\|v\|=\Delta_\psi A\cdot \Delta_\psi B.\]</span>
한편
<span class="math display">\[\langle u,v\rangle=\langle A'\psi,B'\psi\rangle=\langle \psi,A'B'\psi\rangle.\]</span>
복소수 <span class="math inline">\(z:=\langle \psi,A'B'\psi\rangle\)</span>에 대해 <span class="math inline">\(\operatorname{Im}(z)\le |z|\)</span>이므로
<span class="math display">\[|z|\ge |\operatorname{Im}(z)|.\]</span>
또한
<span class="math display">\[\begin{aligned}
z-\overline{z}
&amp;=\langle \psi,A'B'\psi\rangle-\overline{\langle \psi,A'B'\psi\rangle}
=\langle \psi,A'B'\psi\rangle-\langle \psi,(A'B')^\dagger\psi\rangle\\
&amp;=\langle \psi,A'B'\psi\rangle-\langle \psi,B'A'\psi\rangle
=\langle \psi,[A',B']\psi\rangle.\end{aligned}\]</span>
따라서
<span class="math display">\[2i\,\operatorname{Im}(z)=\langle \psi,[A',B']\psi\rangle.\]</span>
절댓값을 취하면
<span class="math display">\[2|\operatorname{Im}(z)|=\left|\langle \psi,[A',B']\psi\rangle\right|.\]</span>
그런데 상수항은 교환자에서 소거되므로 <span class="math inline">\([A',B']=[A,B]\)</span>이다. 따라서
<span class="math display">\[|z|\ge |\operatorname{Im}(z)|=\frac{1}{2}\left|\langle \psi,[A,B]\psi\rangle\right|.\]</span>
마지막으로 <span class="math inline">\(|z|=|\langle u,v\rangle|\le \Delta_\psi A\Delta_\psi B\)</span>를 결합하면 <a data-reference="eq:AppA_Robertson" data-reference-type="eqref" href="#eq:AppA_Robertson">[eq:AppA_Robertson]</a>. <span class="math inline">\(\square\)</span></p>
<h2 class="unnumbered" id="a.6-민감도오차-전파-상한">A.6 민감도(오차 전파) 상한</h2>
<h4 data-number="20.9.5.20" id="정리-a.61차-민감도-상한"><span class="header-section-number">20.9.5.20</span> 정리 A.6(1차 민감도 상한)</h4>
<p><span class="math inline">\(f:\mathbb{R}^n\to\mathbb{R}\)</span>가 점 <span class="math inline">\(x\)</span>에서 미분가능하고, 입력 오차가 <span class="math inline">\(\delta x\in\mathbb{R}^n\)</span>일 때
<span class="math display">\[|f(x+\delta x)-f(x)| \le \|\nabla f(x)\|_2\,\|\delta x\|_2 + o(\|\delta x\|_2).
\label{eq:AppA_sensitivity}\]</span></p>
<h4 data-number="20.9.5.21" id="증명-9"><span class="header-section-number">20.9.5.21</span> 증명</h4>
<p>미분가능성 정의로
<span class="math display">\[f(x+\delta x)-f(x)=\nabla f(x)\cdot \delta x + r(\delta x),
\quad
\frac{|r(\delta x)|}{\|\delta x\|_2}\to 0\ (\delta x\to 0).\]</span>
코시–슈바르츠로 <span class="math inline">\(|\nabla f(x)\cdot \delta x|\le \|\nabla f(x)\|_2\|\delta x\|_2\)</span>.
따라서 <a data-reference="eq:AppA_sensitivity" data-reference-type="eqref" href="#eq:AppA_sensitivity">[eq:AppA_sensitivity]</a>. <span class="math inline">\(\square\)</span></p>
<h2 class="unnumbered" id="a.7-유효숫자-반올림-연산자보고-규약">A.7 유효숫자 반올림 연산자(보고 규약)</h2>
<h4 data-number="20.9.5.22" id="정의-a.7반올림-연산자"><span class="header-section-number">20.9.5.22</span> 정의 A.7(반올림 연산자)</h4>
<p><span class="math inline">\(k\in\mathbb{Z}\)</span>에 대해 <span class="math inline">\(\mathrm{Round}_k:\mathbb{R}\to\mathbb{R}\)</span>를
<span class="math display">\[\mathrm{Round}_k(x):=10^{-k}\cdot \mathrm{round}(10^k x)\]</span>
로 정의한다. 여기서 <span class="math inline">\(\mathrm{round}\)</span>는 가장 가까운 정수로의 반올림(동점 처리 규칙은 <code>analysis_lock</code>에 잠김)이다.</p>
<h4 data-number="20.9.5.23" id="성질-a.7.1오차-상한"><span class="header-section-number">20.9.5.23</span> 성질 A.7.1(오차 상한)</h4>
<p>동점 처리 규칙이 무엇이든,
<span class="math display">\[|\mathrm{Round}_k(x)-x|\le \frac{1}{2}\cdot 10^{-k}\]</span>
가 성립한다(정수 격자 간격이 <span class="math inline">\(10^{-k}\)</span>이므로 최악의 경우 반 간격).</p>
<h1 class="unnumbered" id="부록-b.-수치-프로토콜-상세게이트-시드-샘플링">부록 B. 수치 프로토콜 상세(게이트, 시드, 샘플링)</h1>
<h2 class="unnumbered" id="b.0-실행-단위와-기록-단위정의">B.0 실행 단위와 기록 단위(정의)</h2>
<h4 data-number="20.9.5.24" id="정의-b.0.1run"><span class="header-section-number">20.9.5.24</span> 정의 B.0.1(Run)</h4>
<p>Run은 다음 튜플로 식별되는 단일 실행 단위이다.
<span class="math display">\[\mathrm{run\_id}
:=
\bigl(\mathrm{code\_version},\mathrm{registry\_snapshot\_id},\mathrm{protocol\_id},\mathrm{seed\_id},\mathrm{dataset\_id}\bigr).
\label{eq:AppB_runid}\]</span>
동일 <span class="math inline">\(\mathrm{run\_id}\)</span>는 동일 산출물을 재생산해야 하며, 이는 Gate(G-REP)의 판정 대상이다.</p>
<h4 data-number="20.9.5.25" id="정의-b.0.2artifact"><span class="header-section-number">20.9.5.25</span> 정의 B.0.2(Artifact)</h4>
<p>Artifact는 Run이 남기는 파일 묶음이다.
<span class="math display">\[\mathrm{artifact} := \{\mathrm{logs},\mathrm{metrics},\mathrm{figures},\mathrm{tables},\mathrm{manifests},\mathrm{checksums}\}.\]</span>
Artifact는 <code>manifest+checksums+registry_snapshot</code>으로 봉인되어야 하며, 봉인 누락은 Gate에서 결론 자격을 박탈한다.</p>
<h4 data-number="20.9.5.26" id="정의-b.0.3ssot"><span class="header-section-number">20.9.5.26</span> 정의 B.0.3(SSOT)</h4>
<p>SSOT(Single Source of Truth)는 동일 의미의 상수/정의/문턱값이 둘 이상 존재하지 않는 상태를 의미한다. SSOT 위반은 (i) 동일 키의 중복 정의, (ii) 서로 다른 파일에서 동일 개념을 다른 값으로 정의, (iii) 로그에만 존재하고 레지스트리에 존재하지 않는 “유령 상수”로 판정한다.</p>
<h2 class="unnumbered" id="b.1-시드-규약결정론">B.1 시드 규약(결정론)</h2>
<h4 data-number="20.9.5.27" id="정의-b.1.1seed_id"><span class="header-section-number">20.9.5.27</span> 정의 B.1.1(seed_id)</h4>
<p><span class="math display">\[\mathrm{seed\_id}:=\mathrm{SHA256}(\mathrm{seed\_namespace}\Vert \mathrm{seed\_payload})
\label{eq:AppB_seedid}\]</span>
여기서 <span class="math inline">\(\Vert\)</span>는 바이트열 연결(concatenation)이다. <code>seed_namespace</code>는 고정 문자열(예: <code>"v4.seed"</code>)이고, <code>seed_payload</code>는 다음을 순서대로 연결한 바이트열이다.
<span class="math display">\[\mathrm{seed\_payload}:=
\mathrm{UTF8}(\mathrm{code\_version})\Vert
\mathrm{UTF8}(\mathrm{registry\_snapshot\_id})\Vert
\mathrm{UTF8}(\mathrm{protocol\_id})\Vert
\mathrm{UTF8}(\mathrm{dataset\_id})\Vert
\mathrm{UTF8}(\mathrm{user\_tag}).\]</span>
<code>user_tag</code>는 실험 라벨이며, 결과를 본 뒤 변경될 수 없고(버전업으로만 변경), 변경 시 새로운 <code>seed_id</code>가 생성된다.</p>
<h4 data-number="20.9.5.28" id="정의-b.1.232비트64비트-시드로의-사상"><span class="header-section-number">20.9.5.28</span> 정의 B.1.2(32비트/64비트 시드로의 사상)</h4>
<p>해시(digest) 32바이트를 상위 8바이트와 하위 8바이트로 분해하여,
<span class="math display">\[s_{64}^{(0)}:=\mathrm{uint64}(\mathrm{digest}[0:8]),\quad
s_{64}^{(1)}:=\mathrm{uint64}(\mathrm{digest}[8:16])\]</span>
로 초기 상태를 정의한다. 이후 난수 생성기는 이 상태만을 입력으로 사용한다.</p>
<h4 data-number="20.9.5.29" id="결정론-rng외부-라이브러리-비의존-규약"><span class="header-section-number">20.9.5.29</span> 결정론 RNG(외부 라이브러리 비의존 규약)</h4>
<p>외부 RNG 구현 차이를 배제하기 위해 다음 xorshift128+를 표준 생성기로 잠근다.
<span class="math display">\[\begin{aligned}
&amp;\texttt{uint64 next():}\\
&amp;s_1\leftarrow s_0,\;\; s_0\leftarrow s_1\\
&amp;s_1 \leftarrow s_1 \oplus (s_1 \ll 23)\\
&amp;s_1 \leftarrow s_1 \oplus (s_1 \gg 17)\\
&amp;s_1 \leftarrow s_1 \oplus s_0\\
&amp;s_1 \leftarrow s_1 \oplus (s_0 \gg 26)\\
&amp;\text{return } (s_1+s_0)\bmod 2^{64}
\end{aligned}
\label{eq:AppB_xorshift}\]</span>
상태 <span class="math inline">\((s_0,s_1)\)</span>는 64비트 정수 두 개로 구성되며, 초기 상태는 <a data-reference="eq:AppB_seedid" data-reference-type="eqref" href="#eq:AppB_seedid">[eq:AppB_seedid]</a>–<a data-reference="eq:AppB_xorshift" data-reference-type="eqref" href="#eq:AppB_xorshift">[eq:AppB_xorshift]</a> 규약으로만 설정한다.</p>
<h2 class="unnumbered" id="b.2-샘플링-규약창시드반복">B.2 샘플링 규약(창/시드/반복)</h2>
<h4 data-number="20.9.5.30" id="정의-b.2.1창-분할"><span class="header-section-number">20.9.5.30</span> 정의 B.2.1(창 분할)</h4>
<p>시간축 또는 이벤트축은 길이 <span class="math inline">\(W\)</span>의 창(window)으로 분할하며, 분할 규칙은
<span class="math display">\[\mathrm{window}(j):=[jW,(j+1)W)\]</span>
로 고정한다. <span class="math inline">\(W\)</span>의 단위(틱/초/사건 수)는 <code>analysis_lock</code>에 잠긴다.</p>
<h4 data-number="20.9.5.31" id="정의-b.2.2반복-인덱스"><span class="header-section-number">20.9.5.31</span> 정의 B.2.2(반복 인덱스)</h4>
<p>반복 횟수 <span class="math inline">\(R\in\mathbb{N}\)</span>을 잠그고, 반복 인덱스 <span class="math inline">\(r\in\{0,\dots,R-1\}\)</span>를 둔다.
각 반복은 동일 <code>run_id</code>를 공유하되, <code>seed_payload</code>에 <code>replica=r</code>를 추가하여 시드를 분기한다.</p>
<h4 data-number="20.9.5.32" id="정의-b.2.3샘플-선택-함수"><span class="header-section-number">20.9.5.32</span> 정의 B.2.3(샘플 선택 함수)</h4>
<p>유한 모집단 <span class="math inline">\(\Omega=\{0,\dots,M-1\}\)</span>에서 크기 <span class="math inline">\(K\)</span>의 샘플을 선택하는 함수 <span class="math inline">\(\mathcal{S}\)</span>를
<span class="math display">\[\mathcal{S}(\Omega,K; s_0,s_1):=\texttt{RNG}\text{로 생성한 순열의 앞 }K\text{개}\]</span>
로 정의한다. 구체적으로,</p>
<ol>
<li><p>xorshift128+로 <span class="math inline">\(M\)</span>개의 64비트 값을 생성한다: <span class="math inline">\(u_0,\dots,u_{M-1}\)</span>.</p></li>
<li><p>키-값 쌍 <span class="math inline">\((u_i,i)\)</span>를 키 기준 오름차순으로 정렬한다.</p></li>
<li><p>정렬된 인덱스열의 앞 <span class="math inline">\(K\)</span>개를 샘플로 채택한다.</p></li>
</ol>
<p>정렬의 안정성(동점 처리)은 <code>analysis_lock</code>에 잠긴 비교 규칙(예: <span class="math inline">\((u_i,i)\)</span>의 사전식)으로 고정한다.</p>
<h2 class="unnumbered" id="b.3-수치-연산-규약오차안정성">B.3 수치 연산 규약(오차/안정성)</h2>
<h4 data-number="20.9.5.33" id="정의-b.3.1상대절대-허용오차"><span class="header-section-number">20.9.5.33</span> 정의 B.3.1(상대/절대 허용오차)</h4>
<p>두 실수 <span class="math inline">\(x,y\)</span>의 근접 판정은 다음 규약으로 고정한다.
<span class="math display">\[\mathrm{close}(x,y;\varepsilon_{\mathrm{abs}},\varepsilon_{\mathrm{rel}})
\;\Longleftrightarrow\;
|x-y|\le \varepsilon_{\mathrm{abs}}+\varepsilon_{\mathrm{rel}}\max\{|x|,|y|\}.
\label{eq:AppB_close}\]</span>
<span class="math inline">\(\varepsilon_{\mathrm{abs}},\varepsilon_{\mathrm{rel}}\)</span>은 <code>gate_lock</code>에 잠긴다.</p>
<h4 data-number="20.9.5.34" id="정의-b.3.2합산-안정화-보정-합"><span class="header-section-number">20.9.5.34</span> 정의 B.3.2(합산 안정화: 보정 합)</h4>
<p>길이가 큰 합 <span class="math inline">\(\sum_i a_i\)</span>에 대해 수치 안정화를 위해 Kahan 보정합을 표준으로 둔다.</p>
<pre><code>sum = 0.0
c = 0.0
for a in a_list:
    y = a - c
    t = sum + y
    c = (t - sum) - y
    sum = t
return sum</code></pre>
<p>이 절차의 적용 대상(예: 사건율 추정, 빈도 누적, 에너지/장력 누적)은 <code>analysis_lock</code>에 잠긴다.</p>
<h2 class="unnumbered" id="b.4-gate-평가-규약순서기록봉인">B.4 Gate 평가 규약(순서/기록/봉인)</h2>
<h4 data-number="20.9.5.35" id="정의-b.4.1gate-dag"><span class="header-section-number">20.9.5.35</span> 정의 B.4.1(Gate DAG)</h4>
<p>Gate는 방향성 비순환 그래프(DAG)로 구성되며, 각 Gate <span class="math inline">\(G_i\)</span>는 입력(artifact, locks, metrics)과 출력 상태를 가진다.
Gate 스택은 위상정렬 순서로만 평가한다.</p>
<h4 data-number="20.9.5.36" id="정의-b.4.2gate-출력"><span class="header-section-number">20.9.5.36</span> 정의 B.4.2(Gate 출력)</h4>
<p>각 Gate의 출력은
<span class="math display">\[\mathrm{status}\in\{\texttt{PASS},\texttt{FAIL},\texttt{INCONCLUSIVE}\}\]</span>
로 제한한다. <code>INCONCLUSIVE</code>는 결론 유예이며, 결론 근거로 사용될 수 없다.</p>
<h4 data-number="20.9.5.37" id="정의-b.4.3gate-로그"><span class="header-section-number">20.9.5.37</span> 정의 B.4.3(Gate 로그)</h4>
<p>각 Gate는 다음 키를 포함하는 로그 객체를 생성한다.
<span class="math display">\[\mathrm{gate\_log}:=\{
\mathrm{gate\_id},\mathrm{inputs},\mathrm{thresholds},\mathrm{metrics},\mathrm{status},\mathrm{timestamp},\mathrm{hashes}
\}.
\label{eq:AppB_gatelog}\]</span>
<code>inputs</code>에는 사용된 lock_id, manifest 해시, 스키마 버전이 포함되어야 한다.</p>
<h2 class="unnumbered" id="b.5-fail-트리거반증-트리거-기록-형식">B.5 FAIL 트리거(반증 트리거 기록 형식)</h2>
<h4 data-number="20.9.5.38" id="정의-b.5.1fail-코드"><span class="header-section-number">20.9.5.38</span> 정의 B.5.1(FAIL 코드)</h4>
<p>FAIL은 단일 문자열 코드로 기록하며, 코드는 <code>gate_lock</code>의 사전 등록 목록에 존재해야 한다.
예시 형태:
<span class="math display">\[\texttt{F-LOCK-MIX},\texttt{F-NOTUNING},\texttt{F-REP-MISSING},\texttt{F-SYM-UNIT}.\]</span>
코드 목록과 의미는 SSOT로 유지되며, 로그에만 존재하는 임시 코드는 금지된다.</p>
<h4 data-number="20.9.5.39" id="정의-b.5.2반증-트리거-객체"><span class="header-section-number">20.9.5.39</span> 정의 B.5.2(반증 트리거 객체)</h4>
<p>FAIL이 발생하면 다음 객체를 남긴다.
<span class="math display">\[\mathrm{falsify\_trigger}:=
\{\mathrm{fail\_code},\mathrm{fail\_evidence},\mathrm{scope},\mathrm{lock\_ids},\mathrm{artifacts}\}.\]</span>
<code>scope</code>는 영향 범위(단일 절/장/전역)를 명시한다.</p>
<h1 class="unnumbered" id="부록-c.-아카이브-스키마-파일-트리">부록 C. 아카이브 스키마 &amp; 파일 트리</h1>
<h2 class="unnumbered" id="c.0-디렉터리-트리불변-규약">C.0 디렉터리 트리(불변 규약)</h2>
<p>다음 트리는 최소 불변 구조로 잠근다.</p>
<pre><code>repo_root/
  registry/
    canon_lock.json
    realization_lock.json
    analysis_lock.json
    gate_lock.json
    protocol_lock.json
    registry_snapshot.json
  protocol/
    protocol.yaml
    pass.rules.yaml
  runs/
    run_&lt;run_id&gt;/
      inputs/
      logs/
      metrics/
      figures/
      tables/
      manifest.json
      checksums.sha256
  releases/
    v4.&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;/
      release_manifest.json
      checksums.sha256
      registry_snapshot.json
      artifacts/</code></pre>
<p><code>registry/</code>는 SSOT이며, <code>runs/</code>는 산출물, <code>releases/</code>는 배포 단위이다.</p>
<h2 class="unnumbered" id="c.1-registry_snapshot-스키마ssot-봉인">C.1 registry_snapshot 스키마(SSOT 봉인)</h2>
<pre><code>{
  "registry_snapshot_id": "sha256:&lt;64hex&gt;",
  "created_utc": "YYYY-MM-DDThh:mm:ssZ",
  "code_version": "git:&lt;commit&gt;",
  "locks": {
    "canon_lock_id": "canon_lock:v4.x.y:sha256:&lt;64hex&gt;",
    "realization_lock_id": "realization_lock:v4.x.y:sha256:&lt;64hex&gt;",
    "analysis_lock_id": "analysis_lock:v4.x.y:sha256:&lt;64hex&gt;",
    "gate_lock_id": "gate_lock:v4.x.y:sha256:&lt;64hex&gt;",
    "protocol_lock_id": "protocol_lock:v4.x.y:sha256:&lt;64hex&gt;"
  },
  "files": [
    {"path": "registry/canon_lock.json", "sha256": "&lt;64hex&gt;"},
    {"path": "registry/realization_lock.json", "sha256": "&lt;64hex&gt;"},
    {"path": "registry/analysis_lock.json", "sha256": "&lt;64hex&gt;"},
    {"path": "registry/gate_lock.json", "sha256": "&lt;64hex&gt;"},
    {"path": "registry/protocol_lock.json", "sha256": "&lt;64hex&gt;"}
  ]
}</code></pre>
<h2 class="unnumbered" id="c.2-canon_lock-스키마정준-입력">C.2 canon_lock 스키마(정준 입력)</h2>
<pre><code>{
  "lock_type": "canon_lock",
  "lock_id": "canon_lock:v4.x.y:sha256:&lt;64hex&gt;",
  "version": "v4.x.y",
  "constants": {
    "pi": 3.141592653589793,
    "alpha_rect": "2/pi",
    "delta_rect": "1/pi^2"
  },
  "inputs": {
    "D_anch_m": "&lt;float&gt;",
    "r_p_m": 0.8412e-15,
    "l_rot_m": "&lt;float|optional&gt;",
    "geometry_meaning": "diameter|radius",
    "cell_geometry": "cube"
  },
  "hash_policy": {
    "float_format": "decimal_string",
    "unit_strings": "SI",
    "ordering": "sorted_keys"
  }
}</code></pre>
<h2 class="unnumbered" id="c.3-realization_lock-스키마단위-실현">C.3 realization_lock 스키마(단위 실현)</h2>
<pre><code>{
  "lock_type": "realization_lock",
  "lock_id": "realization_lock:v4.x.y:sha256:&lt;64hex&gt;",
  "version": "v4.x.y",
  "inputs": {
    "a_m": 6.3299121257859865746e-19,
    "dt_s": 1.86e-21,
    "c_ref_m_s": 299792458
  },
  "anchors": {
    "lambda_ref_nm": [633.0, 532.0],
    "rcross_ref_id": "R-mean|R-633|R-532"
  }
}</code></pre>
<h2 class="unnumbered" id="c.4-analysis_lock-스키마선택레짐정의-고정">C.4 analysis_lock 스키마(선택/레짐/정의 고정)</h2>
<pre><code>{
  "lock_type": "analysis_lock",
  "lock_id": "analysis_lock:v4.x.y:sha256:&lt;64hex&gt;",
  "version": "v4.x.y",
  "definitions": {
    "event_definition_id": "&lt;string&gt;",
    "closure_stack_id": "&lt;string&gt;",
    "regime_map_id": "&lt;string&gt;"
  },
  "choices": {
    "cell_geometry": "cube",
    "geometry_meaning": "diameter",
    "normalization_length_id": "a|Lq|lambda_C",
    "report_unit_energy": "GeV",
    "rounding_rule_id": "&lt;string&gt;"
  },
  "numerics": {
    "kahan_sum": true,
    "window_size": "&lt;int&gt;",
    "replicas": "&lt;int&gt;"
  }
}</code></pre>
<h2 class="unnumbered" id="c.5-gate_lock-스키마문턱판정-규칙">C.5 gate_lock 스키마(문턱/판정 규칙)</h2>
<pre><code>{
  "lock_type": "gate_lock",
  "lock_id": "gate_lock:v4.x.y:sha256:&lt;64hex&gt;",
  "version": "v4.x.y",
  "tolerances": {
    "eps_abs": "&lt;float&gt;",
    "eps_rel": "&lt;float&gt;",
    "dev_tol_max": "&lt;float&gt;"
  },
  "fail_codes": [
    {"code":"F-LOCK-MIX","meaning":"lock_id 혼합"},
    {"code":"F-NOTUNING","meaning":"사후 보정/피팅 탐지"},
    {"code":"F-REP-MISSING","meaning":"봉인/재현 정보 누락"},
    {"code":"F-SYM-UNIT","meaning":"기호/단위/의미 충돌"}
  ]
}</code></pre>
<h2 class="unnumbered" id="c.6-protocol_lock-스키마단위-변환보고-규약">C.6 protocol_lock 스키마(단위 변환/보고 규약)</h2>
<pre><code>{
  "lock_type": "protocol_lock",
  "lock_id": "protocol_lock:v4.x.y:sha256:&lt;64hex&gt;",
  "version": "v4.x.y",
  "unit_conversions": {
    "GeV_to_J": 1.602176634e-10
  },
  "hashes": {
    "sha256_impl": "sha256",
    "encoding": "utf-8"
  }
}</code></pre>
<h2 class="unnumbered" id="c.7-run-manifest-스키마입력산출물-봉인">C.7 run manifest 스키마(입력/산출물 봉인)</h2>
<pre><code>{
  "run_id": "&lt;tuple-string-or-hash&gt;",
  "created_utc": "YYYY-MM-DDThh:mm:ssZ",
  "registry_snapshot_id": "sha256:&lt;64hex&gt;",
  "protocol_id": "&lt;string&gt;",
  "seed_id": "sha256:&lt;64hex&gt;",
  "artifacts": [
    {"path":"logs/run.log","sha256":"&lt;64hex&gt;"},
    {"path":"metrics/metrics.json","sha256":"&lt;64hex&gt;"},
    {"path":"tables/table.csv","sha256":"&lt;64hex&gt;"}
  ]
}</code></pre>
<h1 class="unnumbered" id="부록-d.-용어집색인">부록 D. 용어집/색인</h1>
<h2 class="unnumbered" id="d.0-용어정의-고정">D.0 용어(정의 고정)</h2>
<dl>
<dt>VP(부피입자)</dt>
<dd>
<p>무한강성+충만 공리로 고정되는 공간의 기본 구성 단위.</p>
</dd>
<dt>정준(CANON)</dt>
<dd>
<p>문서 전역 입력으로 잠기는 상수/정의/규약의 층.</p>
</dd>
<dt>실현(REALIZATION)</dt>
<dd>
<p>무차원 구조/시간을 SI 단위로 고정하는 층.</p>
</dd>
<dt>LOCK</dt>
<dd>
<p>사후 변경이 금지되는 입력 묶음(정준/실현/분석).</p>
</dd>
<dt>SSOT</dt>
<dd>
<p>동일 의미 항목의 유일 출처 원칙.</p>
</dd>
<dt>Gate</dt>
<dd>
<p>유도 결과의 자격을 판정하는 PASS/FAIL/INCONCLUSIVE 장치.</p>
</dd>
<dt>PASS.rules</dt>
<dd>
<p><code>PASS</code>가 아닌 결과를 근거로 사용하지 않는 규칙 집합.</p>
</dd>
<dt>정류 상수 <span class="math inline">\(\alpha,\delta\)</span></dt>
<dd>
<p>기하 평균/투영 규약으로부터 잠기는 상수. 보편 레짐에서 <span class="math inline">\(\alpha=2/\pi\)</span>, <span class="math inline">\(\delta=1/\pi^2\)</span>.</p>
</dd>
<dt>앵커 길이 <span class="math inline">\(D_{\mathrm{anch}}\)</span></dt>
<dd>
<p>정준 셀(Anchor Cell)의 길이 스케일 입력.</p>
</dd>
<dt>정준 셀(Anchor Cell)</dt>
<dd>
<p>정준 기하(큐브)로 고정된 셀. 의미 혼동(지름/반지름) 시 버전업 필요.</p>
</dd>
<dt>사건(Event)</dt>
<dd>
<p>로그 가능한 운영 정의를 만족하는 최소 변화/갱신 단위.</p>
</dd>
<dt>정준 사건율 <span class="math inline">\(\nu_{\mathrm{can}}\)</span></dt>
<dd>
<p>LOCK된 규약으로 정의되는 사건율 표준형.</p>
</dd>
<dt>RCROSS</dt>
<dd>
<p>서로 다른 광학 앵커(예: 633/532 nm)에서 실현값의 교차정합 판정.</p>
</dd>
<dt><span class="math inline">\(U_{\mathrm{lat}}\)</span></dt>
<dd>
<p>격자 단위 에너지. 정의 <span class="math inline">\(U_{\mathrm{lat}}:=h\,c_{\mathrm{ref}}/a\)</span>.</p>
</dd>
<dt><span class="math inline">\(F_{\mathrm{lat}}\)</span></dt>
<dd>
<p>격자 단위 장력. 정의 <span class="math inline">\(F_{\mathrm{lat}}:=U_{\mathrm{lat}}/a=h\,c_{\mathrm{ref}}/a^2\)</span>.</p>
</dd>
<dt><span class="math inline">\(\sigma_{\mathrm{eff}}\)</span></dt>
<dd>
<p>무차원 저항(효과 단면 계수). 질량의 분모로 사용.</p>
</dd>
</dl>
<h2 class="unnumbered" id="d.1-기호-색인최소">D.1 기호 색인(최소)</h2>
<dl>
<dt><span class="math inline">\(a\)</span></dt>
<dd>
<p>실현 길이(부피입자 지름).</p>
</dd>
<dt><span class="math inline">\(\Delta t\)</span></dt>
<dd>
<p>실현 시간 틱.</p>
</dd>
<dt><span class="math inline">\(c_{\mathrm{ref}}\)</span></dt>
<dd>
<p>운영 닻 속도 상수.</p>
</dd>
<dt><span class="math inline">\(r_p\)</span></dt>
<dd>
<p>양성자 반경(정준 입력).</p>
</dd>
<dt><span class="math inline">\(D_{\mathrm{anch}}\)</span></dt>
<dd>
<p>앵커 길이(정준 입력).</p>
</dd>
<dt><span class="math inline">\(r_e\)</span></dt>
<dd>
<p>전자 반경(정준 정의).</p>
</dd>
<dt><span class="math inline">\(\lambda_C\)</span></dt>
<dd>
<p>코어 위상 완결 길이(잠김 규약으로 연결).</p>
</dd>
</dl>
<h1 class="unnumbered" id="부록-epmr.-핵심-유도-원문-결정론-검증-스크립트">부록 E/P/M/R. 핵심 유도 원문 + 결정론 검증 스크립트</h1>
<h2 class="unnumbered" id="부록-e.-전자-질량의-기하학적-기원과-직접-측정">부록 E. 전자 질량의 기하학적 기원과 직접 측정</h2>
<h3 class="unnumbered" id="e.0-입력lock과-목표">E.0 입력(LOCK)과 목표</h3>
<p>본 부록은 다음 입력이 잠겨 있다고 둔다.</p>
<ol>
<li><p>작용 단위 상수: <span class="math inline">\(h\)</span>.</p></li>
<li><p>운영 닻 속도 상수: <span class="math inline">\(c_{\mathrm{ref}}\)</span>.</p></li>
<li><p>실현 길이(부피입자 지름): <span class="math inline">\(a\)</span>.</p></li>
<li><p>앵커 길이: <span class="math inline">\(D_{\mathrm{anch}}\)</span>.</p></li>
<li><p>정류 계수: <span class="math inline">\(\delta\)</span> (보편 레짐에서 <span class="math inline">\(\delta=1/\pi^2\)</span>).</p></li>
<li><p>격자 단위 에너지(단일 출처):
<span class="math display">\[U_{\mathrm{lat}}:=\frac{h\,c_{\mathrm{ref}}}{a}.
  \label{eq:AppE_Ulat}\]</span></p></li>
</ol>
<p>목표는 (i) 전자 반경 <span class="math inline">\(r_e\)</span>, (ii) 전자 저항 적분 <span class="math inline">\(S\)</span>, (iii) 전자 질량 <span class="math inline">\(m_e\)</span>를
정의<span class="math inline">\(\rightarrow\)</span>대입<span class="math inline">\(\rightarrow\)</span>소거로 닫힌 형태로 고정하는 것이다.</p>
<h3 class="unnumbered" id="e.1-전자-반경-r_e의-정의정준">E.1 전자 반경 <span class="math inline">\(r_e\)</span>의 정의(정준)</h3>
<p>전자 반경을 다음으로 정의한다.
<span class="math display">\[\boxed{
r_e:=\frac{D_{\mathrm{anch}}}{2}\,\delta
}
\label{eq:AppE_re_def}\]</span>
보편 레짐에서 <span class="math inline">\(\delta=1/\pi^2\)</span>가 적용되는 경우,
<span class="math display">\[\boxed{
r_e=\frac{D_{\mathrm{anch}}}{2\pi^2}
}
\label{eq:AppE_re_univ}\]</span></p>
<h3 class="unnumbered" id="e.2-전자-저항-적분-s의-운영정의층수-적분">E.2 전자 저항 적분 <span class="math inline">\(S\)</span>의 운영정의(층수 적분)</h3>
<p>반경 좌표 <span class="math inline">\(R\)</span>을 <span class="math inline">\(0\le R\le r_e\)</span>에서 정의한다. 한 층의 두께를 VP 지름 <span class="math inline">\(a\)</span>로 고정하면
미소 구간 <span class="math inline">\(dR\)</span>의 층수(무차원)는
<span class="math display">\[dN(R):=\frac{dR}{a}.
\label{eq:AppE_dN}\]</span>
전자 저항 적분 <span class="math inline">\(S\)</span>를 다음 적분으로 정의한다.
<span class="math display">\[\boxed{
S:=\int_{0}^{r_e}\frac{dR}{a}
}
\label{eq:AppE_S_int}\]</span>
<span class="math inline">\(a\)</span>는 상수로 잠겨 있으므로 적분을 전개하면,
<span class="math display">\[\begin{aligned}
S
&amp;=\int_{0}^{r_e}\frac{dR}{a}
=\frac{1}{a}\int_{0}^{r_e} dR
=\frac{1}{a}\Bigl[R\Bigr]_{0}^{r_e}
=\frac{r_e}{a}.
\label{eq:AppE_S_eval}\end{aligned}\]</span>
따라서
<span class="math display">\[\boxed{
S=\frac{r_e}{a}
}
\label{eq:AppE_S_final}\]</span>
<a data-reference="eq:AppE_re_def" data-reference-type="eqref" href="#eq:AppE_re_def">[eq:AppE_re_def]</a>를 대입하면
<span class="math display">\[\boxed{
S=\frac{D_{\mathrm{anch}}}{2a}\,\delta
}
\label{eq:AppE_S_Ddelta}\]</span>
보편 레짐에서는
<span class="math display">\[\boxed{
S=\frac{D_{\mathrm{anch}}}{2a\pi^2}
}
\label{eq:AppE_S_univ}\]</span></p>
<h3 class="unnumbered" id="e.3-전자-질량-m_e의-정의-및-닫힌-형태">E.3 전자 질량 <span class="math inline">\(m_e\)</span>의 정의 및 닫힌 형태</h3>
<p>질량=저항 공리(운영 정의)를 전자에 적용하여
<span class="math display">\[\boxed{
m_e:=\frac{U_{\mathrm{lat}}}{S}
}
\label{eq:AppE_me_def}\]</span>
로 정의한다. <a data-reference="eq:AppE_S_final" data-reference-type="eqref" href="#eq:AppE_S_final">[eq:AppE_S_final]</a>을 대입하면,
<span class="math display">\[\begin{aligned}
m_e
&amp;=\frac{U_{\mathrm{lat}}}{r_e/a}
=U_{\mathrm{lat}}\frac{a}{r_e}.
\label{eq:AppE_me_expand1}\end{aligned}\]</span>
또한 <a data-reference="eq:AppE_Ulat" data-reference-type="eqref" href="#eq:AppE_Ulat">[eq:AppE_Ulat]</a>를 <a data-reference="eq:AppE_me_expand1" data-reference-type="eqref" href="#eq:AppE_me_expand1">[eq:AppE_me_expand1]</a>에 대입하면,
<span class="math display">\[\begin{aligned}
m_e
&amp;=\left(\frac{h\,c_{\mathrm{ref}}}{a}\right)\frac{a}{r_e}
=\frac{h\,c_{\mathrm{ref}}}{r_e}.
\label{eq:AppE_me_closed}\end{aligned}\]</span>
따라서 동일 잠금 버전에서
<span class="math display">\[\boxed{
m_e=\frac{h\,c_{\mathrm{ref}}}{r_e}
}
\label{eq:AppE_me_final}\]</span>
이 닫힌 형태로 고정된다.</p>
<h3 class="unnumbered" id="e.4-민감도잠금값-변화에-대한-의존성">E.4 민감도(잠금값 변화에 대한 의존성)</h3>
<p><a data-reference="eq:AppE_me_final" data-reference-type="eqref" href="#eq:AppE_me_final">[eq:AppE_me_final]</a>에서 <span class="math inline">\(h,c_{\mathrm{ref}}\)</span>가 잠겨 있을 때,
<span class="math display">\[\frac{dm_e}{m_e}=-\frac{dr_e}{r_e}.\]</span>
또한 <a data-reference="eq:AppE_re_def" data-reference-type="eqref" href="#eq:AppE_re_def">[eq:AppE_re_def]</a>로부터
<span class="math display">\[\frac{dr_e}{r_e}=\frac{dD_{\mathrm{anch}}}{D_{\mathrm{anch}}}+\frac{d\delta}{\delta}.\]</span>
보편 레짐에서 <span class="math inline">\(\delta\)</span>가 상수로 잠겨 있으면 <span class="math inline">\(\frac{d\delta}{\delta}=0\)</span>이므로,
<span class="math display">\[\frac{dm_e}{m_e}=-\frac{dD_{\mathrm{anch}}}{D_{\mathrm{anch}}}.\]</span></p>
<h3 class="unnumbered" id="e.5-결정론-검증-스크립트전자-질량-산출">E.5 결정론 검증 스크립트(전자 질량 산출)</h3>
<pre><code># verify_appendix_E.py
# 목적: registry의 LOCK 값만으로 r_e, S, m_e를 산출하고,
#       산출 과정(식별자/해시)을 로그로 남기는 결정론 스크립트.

import json
import hashlib
from math import pi

def sha256_file(path: str) -&gt; str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        while True:
            b = f.read(1024 * 1024)
            if not b:
                break
            h.update(b)
    return h.hexdigest()

def read_json(path: str) -&gt; dict:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def main():
    canon = read_json("registry/canon_lock.json")
    realz = read_json("registry/realization_lock.json")
    prot  = read_json("registry/protocol_lock.json")
    snap  = read_json("registry/registry_snapshot.json")

    # [LOCK] constants
    h_Js = canon["constants"].get("h_Js", 6.62607015e-34)
    c_ref = realz["inputs"]["c_ref_m_s"]
    a_m   = realz["inputs"]["a_m"]
    D_anch = canon["inputs"]["D_anch_m"]

    # delta: either explicit numeric or derived from pi
    delta_item = canon["constants"].get("delta_rect", "1/pi^2")
    if isinstance(delta_item, (int, float)):
        delta = float(delta_item)
    else:
        delta = 1.0 / (pi**2)

    GeV_to_J = prot["unit_conversions"]["GeV_to_J"]

    # [DERIVED] U_lat
    U_lat_J = (h_Js * c_ref) / a_m
    U_lat_GeV = U_lat_J / GeV_to_J

    # [DERIVED] r_e, S, m_e
    r_e = (D_anch / 2.0) * delta
    S = r_e / a_m
    m_e_GeV = U_lat_GeV / S

    out = {
        "registry_snapshot_id": snap["registry_snapshot_id"],
        "locks": snap["locks"],
        "hashes": {
            "canon_lock_sha256": sha256_file("registry/canon_lock.json"),
            "realization_lock_sha256": sha256_file("registry/realization_lock.json"),
            "protocol_lock_sha256": sha256_file("registry/protocol_lock.json"),
            "registry_snapshot_sha256": sha256_file("registry/registry_snapshot.json"),
        },
        "derived": {
            "U_lat_J": U_lat_J,
            "U_lat_GeV": U_lat_GeV,
            "r_e_m": r_e,
            "S_dimless": S,
            "m_e_GeV": m_e_GeV,
        }
    }

    print(json.dumps(out, indent=2, ensure_ascii=False))

if __name__ == "__main__":
    main()</code></pre>
<h2 class="unnumbered" id="부록-p.-양성자-질량의-격자-기원과-적분법">부록 P. 양성자 질량의 격자 기원과 적분법</h2>
<h3 class="unnumbered" id="p.0-입력lock과-목표">P.0 입력(LOCK)과 목표</h3>
<p>본 부록은 다음 입력이 잠겨 있다고 둔다.</p>
<ol>
<li><p>실현 길이: <span class="math inline">\(a\)</span>.</p></li>
<li><p>양성자 반경(정준 입력): <span class="math inline">\(r_p\)</span>.</p></li>
<li><p>원주율: <span class="math inline">\(\pi\)</span>.</p></li>
<li><p>격자 단위 에너지:
<span class="math display">\[U_{\mathrm{lat}}:=\frac{h\,c_{\mathrm{ref}}}{a}.\]</span></p></li>
</ol>
<p>목표는 (i) <span class="math inline">\(\lambda_C\)</span>의 잠긴 연결식, (ii) 저항 적분 <span class="math inline">\(S_p\)</span>, (iii) 양성자 질량 <span class="math inline">\(m_p\)</span>의 닫힌 형태를 고정하는 것이다.</p>
<h3 class="unnumbered" id="p.1-lambda_cpi2r_p의-대수적-귀결잠긴-연결">P.1 <span class="math inline">\(\lambda_C=(\pi/2)r_p\)</span>의 대수적 귀결(잠긴 연결)</h3>
<p>동일 버전에서 다음 두 연결이 잠겨 있다고 둔다.
<span class="math display">\[\frac{r_p}{L_q}=\frac{2}{\pi},
\qquad
L_q=\lambda_C.
\label{eq:AppP_links}\]</span>
<a data-reference="eq:AppP_links" data-reference-type="eqref" href="#eq:AppP_links">[eq:AppP_links]</a>의 좌식을 <span class="math inline">\(\lambda_C\)</span>로 치환하면
<span class="math display">\[\frac{r_p}{\lambda_C}=\frac{2}{\pi}.\]</span>
이를 <span class="math inline">\(\lambda_C\)</span>에 대해 풀어
<span class="math display">\[\boxed{
\lambda_C=\frac{\pi}{2}\,r_p
}
\label{eq:AppP_lC}\]</span></p>
<h3 class="unnumbered" id="p.2-양성자-저항-적분-s_p의-정의-및-전개">P.2 양성자 저항 적분 <span class="math inline">\(S_p\)</span>의 정의 및 전개</h3>
<p>방사형 좌표 <span class="math inline">\(R\)</span>을 <span class="math inline">\(0\le R\le \lambda_C\)</span>에서 정의하고, 층 두께를 <span class="math inline">\(a\)</span>로 고정한다.
<span class="math display">\[dN(R):=\frac{dR}{a}.\]</span>
저항 적분을
<span class="math display">\[\boxed{
S_p:=\int_{0}^{\lambda_C}\frac{dR}{a}
}
\label{eq:AppP_Sp_int}\]</span>
로 정의한다. <span class="math inline">\(a\)</span>는 상수이므로,
<span class="math display">\[\begin{aligned}
S_p
&amp;=\frac{1}{a}\int_0^{\lambda_C} dR
=\frac{1}{a}\Bigl[R\Bigr]_0^{\lambda_C}
=\frac{\lambda_C}{a}.
\label{eq:AppP_Sp_eval}\end{aligned}\]</span>
따라서
<span class="math display">\[\boxed{
S_p=\frac{\lambda_C}{a}
}
\label{eq:AppP_Sp_final}\]</span>
<a data-reference="eq:AppP_lC" data-reference-type="eqref" href="#eq:AppP_lC">[eq:AppP_lC]</a>를 대입하면
<span class="math display">\[\boxed{
S_p=\frac{\pi}{2}\,\frac{r_p}{a}
}
\label{eq:AppP_Sp_rp}\]</span></p>
<h3 class="unnumbered" id="p.3-양성자-질량-m_p의-정의-및-닫힌-형태">P.3 양성자 질량 <span class="math inline">\(m_p\)</span>의 정의 및 닫힌 형태</h3>
<p>질량=저항 공리를 양성자에 적용하여
<span class="math display">\[\boxed{
m_p:=\frac{U_{\mathrm{lat}}}{S_p}
}
\label{eq:AppP_mp_def}\]</span>
로 정의한다. <span class="math inline">\(U_{\mathrm{lat}}=\frac{h\,c_{\mathrm{ref}}}{a}\)</span>, <span class="math inline">\(S_p=\frac{\lambda_C}{a}\)</span>이므로
<span class="math display">\[\begin{aligned}
m_p
&amp;=\frac{(h\,c_{\mathrm{ref}}/a)}{(\lambda_C/a)}
=\frac{h\,c_{\mathrm{ref}}}{\lambda_C}.
\label{eq:AppP_mp_closed_lC}\end{aligned}\]</span>
따라서
<span class="math display">\[\boxed{
m_p=\frac{h\,c_{\mathrm{ref}}}{\lambda_C}
=\frac{2}{\pi}\frac{h\,c_{\mathrm{ref}}}{r_p}
}
\label{eq:AppP_mp_final}\]</span></p>
<h3 class="unnumbered" id="p.4-결정론-검증-스크립트양성자-질량-산출">P.4 결정론 검증 스크립트(양성자 질량 산출)</h3>
<pre><code># verify_appendix_P.py
# 목적: registry의 LOCK 값만으로 lambda_C, S_p, m_p를 산출하는 결정론 스크립트.

import json
import hashlib
from math import pi

def sha256_file(path: str) -&gt; str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        while True:
            b = f.read(1024 * 1024)
            if not b:
                break
            h.update(b)
    return h.hexdigest()

def read_json(path: str) -&gt; dict:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def main():
    canon = read_json("registry/canon_lock.json")
    realz = read_json("registry/realization_lock.json")
    prot  = read_json("registry/protocol_lock.json")
    snap  = read_json("registry/registry_snapshot.json")

    h_Js = canon["constants"].get("h_Js", 6.62607015e-34)
    c_ref = realz["inputs"]["c_ref_m_s"]
    a_m   = realz["inputs"]["a_m"]
    r_p   = canon["inputs"]["r_p_m"]
    GeV_to_J = prot["unit_conversions"]["GeV_to_J"]

    # U_lat
    U_lat_J = (h_Js * c_ref) / a_m
    U_lat_GeV = U_lat_J / GeV_to_J

    # lambda_C, S_p, m_p
    lambda_C = (pi / 2.0) * r_p
    S_p = lambda_C / a_m
    m_p_GeV = U_lat_GeV / S_p

    out = {
        "registry_snapshot_id": snap["registry_snapshot_id"],
        "locks": snap["locks"],
        "hashes": {
            "canon_lock_sha256": sha256_file("registry/canon_lock.json"),
            "realization_lock_sha256": sha256_file("registry/realization_lock.json"),
            "protocol_lock_sha256": sha256_file("registry/protocol_lock.json"),
            "registry_snapshot_sha256": sha256_file("registry/registry_snapshot.json"),
        },
        "derived": {
            "U_lat_GeV": U_lat_GeV,
            "lambda_C_m": lambda_C,
            "S_p_dimless": S_p,
            "m_p_GeV": m_p_GeV
        }
    }

    print(json.dumps(out, indent=2, ensure_ascii=False))

if __name__ == "__main__":
    main()</code></pre>
<h2 class="unnumbered" id="부록-m.-질량-대통일-격자-에너지의-기하학적-분화">부록 M. 질량 대통일: 격자 에너지의 기하학적 분화</h2>
<h3 class="unnumbered" id="m.0-잠긴-정의단일-출처">M.0 잠긴 정의(단일 출처)</h3>
<p><span class="math display">\[U_{\mathrm{lat}}:=\frac{h\,c_{\mathrm{ref}}}{a}.
\label{eq:AppM_Ulat}\]</span>
질량=저항 공리를
<span class="math display">\[\boxed{
m(X):=\frac{U_{\mathrm{lat}}}{\sigma_{\mathrm{eff}}(X)}
}
\label{eq:AppM_mass_axiom}\]</span>
로 고정한다. 여기서 <span class="math inline">\(\sigma_{\mathrm{eff}}(X)\)</span>는 객체 <span class="math inline">\(X\)</span>의 무차원 저항(효과 단면 계수)이다.</p>
<h3 class="unnumbered" id="m.1-세-객체의-저항-계수유일-정의">M.1 세 객체의 저항 계수(유일 정의)</h3>
<h4 data-number="20.9.5.40" id="h-모드"><span class="header-section-number">20.9.5.40</span> (1) <span class="math inline">\(H\)</span>-모드</h4>
<p>정준 셀(큐브) 경계 6면에서 전역 기준 자유도 1개 제거로 독립 채널 수 <span class="math inline">\(\kappa_H=5\)</span>가 잠긴 경우,
각 채널의 정준 단면을 <span class="math inline">\(\pi\)</span>로 고정하면
<span class="math display">\[\boxed{
\sigma_{\mathrm{eff}}(H):=5\pi
}
\label{eq:AppM_sigmaH}\]</span></p>
<h4 data-number="20.9.5.41" id="양성자"><span class="header-section-number">20.9.5.41</span> (2) 양성자</h4>
<p>양성자 저항 적분을
<span class="math display">\[S_p:=\int_0^{\lambda_C}\frac{dR}{a}=\frac{\lambda_C}{a}\]</span>
로 정의하고,
<span class="math display">\[\boxed{
\sigma_{\mathrm{eff}}(p):=S_p
}
\label{eq:AppM_sigmap}\]</span></p>
<h4 data-number="20.9.5.42" id="전자"><span class="header-section-number">20.9.5.42</span> (3) 전자</h4>
<p>전자 저항 적분을
<span class="math display">\[S:=\int_0^{r_e}\frac{dR}{a}=\frac{r_e}{a}\]</span>
로 정의하고,
<span class="math display">\[\boxed{
\sigma_{\mathrm{eff}}(e):=S
}
\label{eq:AppM_sigmae}\]</span></p>
<h3 class="unnumbered" id="m.2-질량-대통일-정리동일-형식">M.2 질량 대통일 정리(동일 형식)</h3>
<h4 data-number="20.9.5.43" id="정리-m.2.1"><span class="header-section-number">20.9.5.43</span> 정리 M.2.1</h4>
<p>동일 잠금 버전에서 <a data-reference="eq:AppM_Ulat" data-reference-type="eqref" href="#eq:AppM_Ulat">[eq:AppM_Ulat]</a>–<a data-reference="eq:AppM_sigmae" data-reference-type="eqref" href="#eq:AppM_sigmae">[eq:AppM_sigmae]</a>가 성립하면
<span class="math display">\[\boxed{
m_H=\frac{U_{\mathrm{lat}}}{5\pi},\quad
m_p=\frac{U_{\mathrm{lat}}}{S_p},\quad
m_e=\frac{U_{\mathrm{lat}}}{S}
}
\label{eq:AppM_masses}\]</span></p>
<h3 class="unnumbered" id="m.3-불변량-집합과-dev-정의교차검증용">M.3 불변량 집합과 dev 정의(교차검증용)</h3>
<p>불변량을 다음으로 정의한다.
<span class="math display">\[\begin{aligned}
I_H &amp;:= \frac{m_H(5\pi)}{U_{\mathrm{lat}}}, \label{eq:AppM_IH}\\
I_p &amp;:= \frac{m_p S_p}{U_{\mathrm{lat}}}, \label{eq:AppM_Ip}\\
I_e &amp;:= \frac{m_e S}{U_{\mathrm{lat}}}. \label{eq:AppM_Ie}\end{aligned}\]</span>
정의상 이상적으로는 <span class="math inline">\(I_H=I_p=I_e=1\)</span>이어야 한다(동일 정의를 수치로 재확인하는 채널).</p>
<p>각 불변량의 편차를
<span class="math display">\[\mathrm{dev}(I):=|I-1|
\label{eq:AppM_dev}\]</span>
로 정의하고, 최대 편차를
<span class="math display">\[\mathrm{dev}_{\max}:=\max\{\mathrm{dev}(I_H),\mathrm{dev}(I_p),\mathrm{dev}(I_e)\}
\label{eq:AppM_devmax}\]</span>
로 정의한다. <span class="math inline">\(\mathrm{dev}_{\max}\)</span>의 허용 문턱 <span class="math inline">\(\mathrm{dev}_{\mathrm{tol}}\)</span>은 <code>gate_lock</code>에 사전 잠금된다.</p>
<h3 class="unnumbered" id="m.4-gate-판정-형식">M.4 Gate 판정 형식</h3>
<p>다음 판정식을 표준형으로 고정한다.
<span class="math display">\[\boxed{
\texttt{PASS} \Longleftrightarrow \mathrm{dev}_{\max}\le \mathrm{dev}_{\mathrm{tol}}
\quad\text{AND}\quad
\text{(봉인/lock\_id/스키마 일치)}
}
\label{eq:AppM_gate}\]</span></p>
<h3 class="unnumbered" id="m.5-결정론-검증-스크립트질량-대통일-불변량">M.5 결정론 검증 스크립트(질량 대통일 불변량)</h3>
<pre><code># verify_appendix_M.py
# 목적: U_lat, m_H, m_p, m_e 및 불변량 I_H,I_p,I_e, dev_max를 산출하고 Gate 입력을 생성.

import json
import hashlib
from math import pi

def sha256_file(path: str) -&gt; str:
    h = hashlib.sha256()
    with open(path, "rb") as f:
        while True:
            b = f.read(1024 * 1024)
            if not b:
                break
            h.update(b)
    return h.hexdigest()

def read_json(path: str) -&gt; dict:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def main():
    canon = read_json("registry/canon_lock.json")
    realz = read_json("registry/realization_lock.json")
    prot  = read_json("registry/protocol_lock.json")
    gate  = read_json("registry/gate_lock.json")
    snap  = read_json("registry/registry_snapshot.json")

    h_Js = canon["constants"].get("h_Js", 6.62607015e-34)
    c_ref = realz["inputs"]["c_ref_m_s"]
    a_m   = realz["inputs"]["a_m"]
    r_p   = canon["inputs"]["r_p_m"]
    D_anch= canon["inputs"]["D_anch_m"]

    delta_item = canon["constants"].get("delta_rect", "1/pi^2")
    delta = float(delta_item) if isinstance(delta_item, (int, float)) else 1.0/(pi**2)

    GeV_to_J = prot["unit_conversions"]["GeV_to_J"]

    # U_lat
    U_lat_J = (h_Js * c_ref) / a_m
    U_lat_GeV = U_lat_J / GeV_to_J

    # m_H
    m_H = U_lat_GeV / (5.0 * pi)

    # proton: lambda_C, S_p, m_p
    lambda_C = (pi/2.0) * r_p
    S_p = lambda_C / a_m
    m_p = U_lat_GeV / S_p

    # electron: r_e, S, m_e
    r_e = (D_anch/2.0) * delta
    S = r_e / a_m
    m_e = U_lat_GeV / S

    # invariants
    I_H = (m_H * (5.0*pi)) / U_lat_GeV
    I_p = (m_p * S_p) / U_lat_GeV
    I_e = (m_e * S) / U_lat_GeV

    dev_H = abs(I_H - 1.0)
    dev_p = abs(I_p - 1.0)
    dev_e = abs(I_e - 1.0)
    dev_max = max(dev_H, dev_p, dev_e)

    dev_tol = gate["tolerances"]["dev_tol_max"]

    status = "PASS" if dev_max &lt;= dev_tol else "FAIL"

    out = {
        "registry_snapshot_id": snap["registry_snapshot_id"],
        "locks": snap["locks"],
        "hashes": {
            "canon_lock_sha256": sha256_file("registry/canon_lock.json"),
            "realization_lock_sha256": sha256_file("registry/realization_lock.json"),
            "protocol_lock_sha256": sha256_file("registry/protocol_lock.json"),
            "gate_lock_sha256": sha256_file("registry/gate_lock.json"),
            "registry_snapshot_sha256": sha256_file("registry/registry_snapshot.json"),
        },
        "derived": {
            "U_lat_GeV": U_lat_GeV,
            "m_H_GeV": m_H,
            "m_p_GeV": m_p,
            "m_e_GeV": m_e,
            "lambda_C_m": lambda_C,
            "S_p_dimless": S_p,
            "r_e_m": r_e,
            "S_dimless": S,
            "I_H": I_H,
            "I_p": I_p,
            "I_e": I_e,
            "dev_max": dev_max,
            "dev_tol_max": dev_tol
        },
        "gate_eval": {
            "gate_id": "G-RATIO-MASS-UNIFICATION",
            "status": status
        }
    }

    print(json.dumps(out, indent=2, ensure_ascii=False))

if __name__ == "__main__":
    main()</code></pre>
<h2 class="unnumbered" id="부록-r.-격자-장력-이론-전자기력의-절대-크기-유도">부록 R. 격자 장력 이론: 전자기력의 절대 크기 유도</h2>
<h3 class="unnumbered" id="r.0-잠긴-입력과-목표">R.0 잠긴 입력과 목표</h3>
<p>본 부록은 다음 입력이 잠겨 있다고 둔다.</p>
<ol>
<li><p><span class="math inline">\(h\)</span>, <span class="math inline">\(c_{\mathrm{ref}}\)</span>, <span class="math inline">\(a\)</span>, <span class="math inline">\(\pi\)</span>.</p></li>
<li><p><span class="math inline">\(U_{\mathrm{lat}}:=h\,c_{\mathrm{ref}}/a\)</span>.</p></li>
<li><p>양성자 반경 <span class="math inline">\(r_p\)</span> 및 <span class="math inline">\(\lambda_C=(\pi/2)r_p\)</span>.</p></li>
<li><p>양성자 저항 적분 <span class="math inline">\(S_p=\lambda_C/a\)</span>.</p></li>
</ol>
<p>목표는 (i) 격자 장력 <span class="math inline">\(F_{\mathrm{lat}}\)</span>, (ii) 기하 희석/결합/누적 계수의 곱으로
참조 거리 <span class="math inline">\(r_p\)</span>에서의 힘 <span class="math inline">\(F_{\mathrm{VP}}(r_p)\)</span>를 산출하는 것이다.
비교(대상 텍스트) 구간에서는 표준 쿨롱 법칙을 검증 지표로만 사용한다.</p>
<h3 class="unnumbered" id="r.1-격자-단위-장력-f_mathrmlat의-정의">R.1 격자 단위 장력 <span class="math inline">\(F_{\mathrm{lat}}\)</span>의 정의</h3>
<p>격자 단위 장력을 다음으로 정의한다.
<span class="math display">\[\boxed{
F_{\mathrm{lat}}:=\frac{U_{\mathrm{lat}}}{a}
=\frac{h\,c_{\mathrm{ref}}}{a^2}
}
\label{eq:AppR_Flat}\]</span></p>
<h3 class="unnumbered" id="r.2-기하-희석결합누적-계수의-정의">R.2 기하 희석/결합/누적 계수의 정의</h3>
<p>세 개의 계수를 다음으로 고정한다.</p>
<h4 data-number="20.9.5.44" id="질량-희석-계수"><span class="header-section-number">20.9.5.44</span> (1) 질량 희석 계수</h4>
<p>양성자 구조로의 1차 희석을
<span class="math display">\[\boxed{
D_{\mathrm{mass}}:=\frac{1}{S_p}
}
\label{eq:AppR_Dmass}\]</span>
로 정의한다.</p>
<h4 data-number="20.9.5.45" id="공간-희석-계수참조-거리-r_p에서"><span class="header-section-number">20.9.5.45</span> (2) 공간 희석 계수(참조 거리 <span class="math inline">\(r_p\)</span>에서)</h4>
<p>격자 길이 <span class="math inline">\(a\)</span>에서 코어 반경 <span class="math inline">\(r_p\)</span>로의 스케일 확장을
<span class="math display">\[\boxed{
D_{\mathrm{space}}:=\frac{a}{r_p}
}
\label{eq:AppR_Dspace}\]</span>
로 정의한다.</p>
<h4 data-number="20.9.5.46" id="기하-결합-계수투영times누적times구면-보정"><span class="header-section-number">20.9.5.46</span> (3) 기하 결합 계수(투영<span class="math inline">\(\times\)</span>누적<span class="math inline">\(\times\)</span>구면 보정)</h4>
<p>정적 투영 결합을 <span class="math inline">\(\eta_{\mathrm{static}}:=\delta^2\)</span>로 두고,
보편 레짐에서 <span class="math inline">\(\delta=1/\pi^2\)</span>이면
<span class="math display">\[\eta_{\mathrm{static}}=\frac{1}{\pi^4}.\]</span>
동적 누적 계수를
<span class="math display">\[\boxed{
\gamma_{\mathrm{acc}}:=\sqrt{2}
}
\label{eq:AppR_gamma}\]</span>
로 정의하고, 실효 결합을
<span class="math display">\[\eta_{\mathrm{eff}}:=\eta_{\mathrm{static}}\gamma_{\mathrm{acc}}
=\frac{\sqrt{2}}{\pi^4}\]</span>
로 정의한다. 추가로 구면 기하 보정 계수 <span class="math inline">\(1/4\)</span>를 결합하여 최종 결합 계수를
<span class="math display">\[\boxed{
D_{\mathrm{cpl}}:=\frac{\eta_{\mathrm{eff}}}{4}
=\frac{\sqrt{2}}{4\pi^4}
}
\label{eq:AppR_Dcpl}\]</span>
로 고정한다.</p>
<h3 class="unnumbered" id="r.3-참조-거리-r_p에서의-절대-힘-유도">R.3 참조 거리 <span class="math inline">\(r_p\)</span>에서의 절대 힘 유도</h3>
<p><a data-reference="eq:AppR_Flat" data-reference-type="eqref" href="#eq:AppR_Flat">[eq:AppR_Flat]</a>–<a data-reference="eq:AppR_Dcpl" data-reference-type="eqref" href="#eq:AppR_Dcpl">[eq:AppR_Dcpl]</a>를 결합하여
<span class="math display">\[\boxed{
F_{\mathrm{VP}}(r_p)
:=
F_{\mathrm{lat}}\cdot D_{\mathrm{mass}}\cdot D_{\mathrm{space}}\cdot D_{\mathrm{cpl}}
}
\label{eq:AppR_Fvp_def}\]</span>
로 정의한다. 전개하면
<span class="math display">\[\begin{aligned}
F_{\mathrm{VP}}(r_p)
&amp;=
\left(\frac{h\,c_{\mathrm{ref}}}{a^2}\right)
\left(\frac{1}{S_p}\right)
\left(\frac{a}{r_p}\right)
\left(\frac{\sqrt{2}}{4\pi^4}\right).
\label{eq:AppR_Fvp_expand}\end{aligned}\]</span>
여기서 <span class="math inline">\(S_p=\lambda_C/a\)</span>이므로 <span class="math inline">\(1/S_p=a/\lambda_C\)</span>이고, 따라서
<span class="math display">\[\begin{aligned}
F_{\mathrm{VP}}(r_p)
&amp;=
\left(\frac{h\,c_{\mathrm{ref}}}{a^2}\right)
\left(\frac{a}{\lambda_C}\right)
\left(\frac{a}{r_p}\right)
\left(\frac{\sqrt{2}}{4\pi^4}\right)
=
\frac{h\,c_{\mathrm{ref}}}{\lambda_C r_p}\cdot \frac{\sqrt{2}}{4\pi^4}.
\label{eq:AppR_Fvp_cancel}\end{aligned}\]</span>
또한 <span class="math inline">\(\lambda_C=(\pi/2)r_p\)</span>를 대입하면
<span class="math display">\[\begin{aligned}
F_{\mathrm{VP}}(r_p)
&amp;=
\frac{h\,c_{\mathrm{ref}}}{(\pi/2)r_p^2}\cdot\frac{\sqrt{2}}{4\pi^4}
=
\frac{h\,c_{\mathrm{ref}}}{r_p^2}\cdot\frac{\sqrt{2}}{2\pi^5}.
\label{eq:AppR_Fvp_final}\end{aligned}\]</span></p>
<h3 class="unnumbered" id="r.4-결정론-검증-스크립트기하-유도-비교-산출">R.4 결정론 검증 스크립트(기하 유도 + 비교 산출)</h3>
<pre><code># verify_appendix_R.py
# 목적:
#  (1) LOCK 값만으로 F_lat, S_p, F_VP(r_p)를 계산
#  (2) 비교 구간에서만 표준 쿨롱 법칙(대상 텍스트)을 사용하여 수치 비교를 출력

import json
from math import pi, sqrt

def read_json(path: str) -&gt; dict:
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def main():
    canon = read_json("registry/canon_lock.json")
    realz = read_json("registry/realization_lock.json")

    # [LOCK] constants
    h_Js = canon["constants"].get("h_Js", 6.62607015e-34)
    c_ref = realz["inputs"]["c_ref_m_s"]
    a_m   = realz["inputs"]["a_m"]
    r_p   = canon["inputs"]["r_p_m"]

    # [DERIVED] lattice tension
    F_lat = (h_Js * c_ref) / (a_m**2)

    # [DERIVED] lambda_C, S_p
    lambda_C = (pi/2.0) * r_p
    S_p = lambda_C / a_m

    # [DERIVED] coupling
    eta_static = 1.0 / (pi**4)      # delta^2 with delta=1/pi^2
    gamma_acc = sqrt(2.0)           # accumulation
    eta_eff = eta_static * gamma_acc
    Dcpl = eta_eff / 4.0            # spherical correction

    # [DERIVED] absolute force at r_p
    F_vp = F_lat * (1.0/S_p) * (a_m/r_p) * Dcpl

    out = {
        "derived": {
            "F_lat_N": F_lat,
            "lambda_C_m": lambda_C,
            "S_p_dimless": S_p,
            "eta_static": eta_static,
            "gamma_acc": gamma_acc,
            "eta_eff": eta_eff,
            "D_cpl": Dcpl,
            "F_VP_rp_N": F_vp
        }
    }

    # [COMPARE] target-text computation (verification only)
    # Standard Coulomb force between ±e at separation r_p:
    # F = (1/(4*pi*epsilon0)) * e^2 / r_p^2
    e_C = 1.602176634e-19
    eps0 = 8.8541878128e-12
    F_std = (1.0/(4.0*pi*eps0)) * (e_C*e_C) / (r_p*r_p)

    out["compare_target_text"] = {
        "F_std_Coulomb_N": F_std,
        "ratio_FVP_over_Fstd": (F_vp / F_std),
        "abs_rel_diff": abs(1.0 - (F_vp / F_std))
    }

    print(json.dumps(out, indent=2, ensure_ascii=False))

if __name__ == "__main__":
    main()</code></pre>
<h1 class="unnumbered" id="부록-f.-사건율의-이산-분해-가설-정수부활성-사이트와-잔차진동">부록 F. 사건율의 이산 분해 가설: 정수부(활성 사이트)와 잔차(진동)</h1>
<h2 class="unnumbered" id="f.0-목적과-범위비-lock">F.0 목적과 범위(비-LOCK)</h2>
<p>9.4는 <span class="math inline">\(\nu_{p,\mathrm{can}}\approx 292.339978\,\mathrm{s^{-1}}\)</span>를
<code>LOCK</code> 입력(<span class="math inline">\(D_{\mathrm{anch}}, r_p, \delta\)</span>)만으로 닫힌식 <a data-reference="eq:S09_04_closed_form" data-reference-type="eqref" href="#eq:S09_04_closed_form">[eq:S09_04_closed_form]</a>에서 유도하였다.
본 부록은 이 값을 <strong>정수부 + 잔차</strong>로 분해하여,
이산 구조(정수 격자/채널) 관점에서 해석하는 <strong>후행 가설</strong>을 기록한다.
따라서 본 부록의 내용은 본문(LOCK/Gate)의 결론을 변경하지 않으며,
현 버전의 Gate PASS/FAIL 판정 집합에는 포함되지 않는다.</p>
<h2 class="unnumbered" id="f.1-정의-정수-활성도와-잔차">F.1 정의: 정수 활성도와 잔차</h2>
<p>다음 분해를 정의한다.
<span class="math display">\[\nu_{p,\mathrm{can}} = N_{\mathrm{act}} + \varepsilon,
\qquad
N_{\mathrm{act}} := \lfloor \nu_{p,\mathrm{can}} \rfloor,
\qquad
\varepsilon := \nu_{p,\mathrm{can}} - N_{\mathrm{act}}.
\label{eq:AppF_integer_decomp}\]</span>
9.4의 LOCK 값( <a data-reference="eq:S09_04_nup_numeric" data-reference-type="eqref" href="#eq:S09_04_nup_numeric">[eq:S09_04_nup_numeric]</a> )을 사용하면
<span class="math display">\[N_{\mathrm{act}} = 292,
\qquad
\varepsilon = 0.3399781225\ldots
\label{eq:AppF_nact_eps_numeric}\]</span>
이다.</p>
<h4 data-number="20.9.5.47" id="해석후행-가설."><span class="header-section-number">20.9.5.47</span> 해석(후행 가설).</h4>
<p><span class="math inline">\(N_{\mathrm{act}}\)</span>는 양성자 내부에서 “구조를 유지하는 유효 사건”의 이산 개수,
즉 <strong>활성 이벤트-사이트(active event sites)</strong>의 수로 해석할 수 있다.
반면 <span class="math inline">\(\varepsilon\)</span>는 정류(<span class="math inline">\(\delta\)</span>) 및 정수 격자 정합의 한계로 인해 남는
<strong>잔차 진동/요동 성분</strong>으로 해석할 수 있다.
이 잔차는 표준 물리학의 특정 용어(예: 지터베벡궁)와 개념적으로 유사할 수 있으나,
본 백서는 현 단계에서 동치성을 주장하지 않는다.</p>
<h2 class="unnumbered" id="f.2-후보-이산-매핑-82times-4---9times-4-292">F.2 후보 이산 매핑: <span class="math inline">\(82\times 4 - 9\times 4 = 292\)</span></h2>
<p>다음은 <span class="math inline">\(N_{\mathrm{act}}=292\)</span>의 정수부가 <strong>간단한 이산 구조 계산</strong>으로 재현될 수 있다는 후보 해석이다.</p>
<ul>
<li><p>코어 이산 수: <span class="math inline">\(N_{\mathrm{core}}:=82\)</span> (7.2의 코어 정의와 일치)</p></li>
<li><p>국소 강성 최소 단위: “4-점 락킹”(정사면체) <span class="math inline">\(\Rightarrow\)</span> 단위당 4개의 포인트</p></li>
<li><p>정적 입력(통로) 단위: <span class="math inline">\(N_{\mathrm{static\_q}}:=9\)</span> (3-섹터 <span class="math inline">\(\times\)</span> 3-플러그의 후보 구조)</p></li>
</ul>
<p>그러면 총 용량 포인트와 정적 포인트를 각각
<span class="math display">\[N_{\mathrm{cap}}:=4N_{\mathrm{core}}=328,
\qquad
N_{\mathrm{static}}:=4N_{\mathrm{static\_q}}=36
\label{eq:AppF_cap_static}\]</span>
로 두었을 때,
<span class="math display">\[N_{\mathrm{cap}}-N_{\mathrm{static}}=292
\label{eq:AppF_328_36_292}\]</span>
가 되어 <a data-reference="eq:AppF_nact_eps_numeric" data-reference-type="eqref" href="#eq:AppF_nact_eps_numeric">[eq:AppF_nact_eps_numeric]</a>의 정수부와 일치한다.</p>
<h4 data-number="20.9.5.48" id="주의정의-잠금-필요."><span class="header-section-number">20.9.5.48</span> 주의(정의 잠금 필요).</h4>
<p><a data-reference="eq:AppF_328_36_292" data-reference-type="eqref" href="#eq:AppF_328_36_292">[eq:AppF_328_36_292]</a>는
“포인트”, “정적 통로”, “4-점 락킹”, “9-입력”의 의미가 <code>LOCK</code>으로 고정되기 전에는
단지 <strong>후행 해석</strong>이다.
현 버전에서 <a data-reference="eq:AppF_328_36_292" data-reference-type="eqref" href="#eq:AppF_328_36_292">[eq:AppF_328_36_292]</a>는 결론(LOCK/Gate)에 편입되지 않으며,
수치 맞추기 자유도로 오해되지 않도록 <code>NON-LOCK</code>으로 분리하여 기록한다.</p>
<h2 class="unnumbered" id="f.3-향후-gate-설계선언">F.3 향후 Gate 설계(선언)</h2>
<p>향후 본 후보 해석을 본문 결론으로 승격하려면 최소한 다음이 필요하다.</p>
<ul>
<li><p>LOCK: “이벤트-사이트”의 정의(포인트/락킹/채널의 의미)와 레짐(3-섹터, 재밍 조건)을 명시적으로 고정.</p></li>
<li><p>Gate: LOCK에서 유도한 <span class="math inline">\(N_{\mathrm{act}}\)</span>가 <span class="math inline">\(\lfloor\nu_{p,\mathrm{can}}\rfloor\)</span>와 일치하는지 판정.</p></li>
<li><p>Evidence: 코어/채널 구조를 재현 가능한 파일(예: core82 스냅샷, throat/jamming 결과물)로 봉인.</p></li>
</ul>
<h2 class="unnumbered" id="f.4-결정론-계산-스니펫검증용">F.4 결정론 계산 스니펫(검증용)</h2>
<p>아래 스니펫은 9.4의 LOCK 값으로 <span class="math inline">\(\nu_{p,\mathrm{can}}\)</span>을 계산하고,
정수부/잔차 및 <a data-reference="eq:AppF_328_36_292" data-reference-type="eqref" href="#eq:AppF_328_36_292">[eq:AppF_328_36_292]</a> 후보 계산을 함께 출력한다.</p>
<pre><code># verify_appendix_F.py (demonstration; NON-LOCK interpretation)
from math import pi

D_anch = 4.854194962126561e-12   # m
r_p    = 0.8412e-15              # m
delta  = 1.0/(pi*pi)

s_p = D_anch/(2.0*r_p)
nu  = s_p*delta

N_act = int(nu)          # floor for positive nu
eps   = nu - N_act

N_core = 82
points_per = 4
N_static_q = 9
N_cap = N_core*points_per
N_static = N_static_q*points_per
N_active_points = N_cap - N_static

print("s_p=", s_p)
print("nu_p_can=", nu)
print("N_act=", N_act)
print("eps=", eps)
print("N_active_points=", N_active_points)</code></pre>
<h1 class="unnumbered" id="부록-g.-중력의-기하학적-유도-격자-강성-한계와-포화-이론">부록 G. 중력의 기하학적 유도: 격자 강성 한계와 포화 이론</h1>
<h2 class="unnumbered" id="g.-1-적용-레짐게이트-강성-레짐에서만의-유도">G.-1 적용 레짐(게이트): 강성 레짐에서만의 유도</h2>
<p>본 부록의 유도는 3.2에서 정의한 <strong>강성 레짐</strong>(<span class="math inline">\(\chi_{\mathrm{ST}}=1\)</span>)을 전제로 한다.
관측 시간창에서 유동성 지수 <span class="math inline">\(\phi(\mathcal{P};W)\)</span>가 유의미하게 크면(즉, 강성 실패가 빈번하면),
“격자 강성 한계”를 일정 상수로 취급하는 단계가 정당화되지 않으므로,
해당 시간창/프로토콜에서의 결론은 <code>INCONCLUSIVE</code>로 취급한다.
따라서 본 부록의 모든 상한/포화 결론은 <strong><span class="math inline">\(\phi\approx 0\)</span>인 레짐</strong>에서만 결론 자격을 가진다.</p>
<h2 class="unnumbered" id="g.0-핵심-명제-9.8은-공간격자의-항복-강도이다">G.0 핵심 명제: 9.8은 ‘공간(격자)의 항복 강도’이다</h2>
<p>본 이론에서 중력은 “질량이 끌어당기는 힘”이 아니라,
<strong>비움(Void)을 메우려는 재밍 격자의 복원 압력(restoring pressure)</strong>으로 재정의된다.</p>
<p>격자는 유한한 물성(강성/전달 한계)을 가지므로,
<strong>격자가 물질에 ‘직접’ 전달할 수 있는 (접촉/정지 조건의) 최대 가속도에는 상한선</strong>이 존재한다.
이를 <span class="math inline">\(\,g_\star\,\)</span> (lattice yield limit)로 둔다.</p>
<p><span class="math display">\[g_\star \;\equiv\; c^2\,\Psi_{\rm yield}
\quad\text{(공간의 항복 강도 / 표면 장력에 해당)}\]</span></p>
<p>지구는 우연히 <span class="math inline">\(\Psi_{\rm geom}\approx\Psi_{\rm yield}\)</span>인 환경을 제공하므로,
지표에서 관측되는 대표값 <span class="math inline">\(g\approx 9.8\,{\rm m/s^2}\)</span>는
<strong>‘질량이 커져서 무한히 커지는 값’이 아니라 ‘격자 항복 한계 근방의 값’</strong>으로 해석된다.</p>
<h2 class="unnumbered" id="g.1-방어-논리-중력은-단일-성분이-아니라-2-채널로-관측된다">G.1 방어 논리: 중력은 단일 성분이 아니라 <span class="math inline">\(\;2\)</span>-채널로 관측된다</h2>
<p>목성/태양 등에서 <span class="math inline">\(g&gt;9.8\)</span>처럼 보이는 값이 보고되는 것(또는 궤도 데이터로 역산되는 것)은
본 이론과 즉시 충돌하지 않는다. 이유는 <strong>관측 프로토콜(상황)</strong>이 다르기 때문이다.</p>
<p>본 부록에서는 중력 가속도를 두 성분(채널)로 분해한다:
<span class="math display">\[g_{\rm (concept)} \;=\; g_{\rm geom} \;+\; g_{\rm restore}.\]</span></p>
<h4 data-number="20.9.5.49" id="주의운영정의-합은-동일-프로토콜에서의-단순-가산을-뜻하지-않는다."><span class="header-section-number">20.9.5.49</span> 주의(운영정의): ‘합’은 동일 프로토콜에서의 단순 가산을 뜻하지 않는다.</h4>
<p>위 분해는 “같은 실험에서 동시에 더해져서 저울값이 된다”는 의미가 아니다.
본 이론에서 관측량은 프로토콜에 의해 분기되며,
실제로 비교 가능한 관측량은 다음과 같이 정의한다:
<span class="math display">\[g_{\rm obs} \;=\;
\begin{cases}
  g_{\rm geom}\ (\approx g_{\rm pot}) &amp; \text{Orbit / Free-fall mode (자유낙하/궤도)}\\
  g_{\rm restore}\ (\le g_\star) &amp; \text{Contact / Surface mode (접촉/정지)}
\end{cases}\]</span>
즉, 궤도 데이터가 읽는 성분과(원거리 운동) 저울/법선력이 읽는 성분(접촉 정지)은
원리적으로 다른 채널이다.</p>
<h4 data-number="20.9.5.50" id="a-g_rm-geom-곡률원거리-장channel-of-curvature"><span class="header-section-number">20.9.5.50</span> (A) <span class="math inline">\(\;g_{\rm geom}\)</span> : 곡률/원거리 장(channel of curvature)</h4>
<p>질량 결손이 만드는 <strong>기하학적 곡률 성분</strong>이다.
궤도(위성/탐사선)·조석·원거리 운동을 지배하며, 질량/반지름에 따라 계속 커질 수 있다.</p>
<h4 data-number="20.9.5.51" id="b-g_rm-restore-격자-복원압channel-of-restoring-pressure"><span class="header-section-number">20.9.5.51</span> (B) <span class="math inline">\(\;g_{\rm restore}\)</span> : 격자 복원압(channel of restoring pressure)</h4>
<p>비움(Void)을 막기 위해 격자가 <strong>직접 밀고 들어오는 “접촉/정지 조건의” 복원 가속도</strong>이다.
이 성분은 격자의 강성(<span class="math inline">\(c^2\)</span>)과 항복 곡률요구량(<span class="math inline">\(\Psi_{\rm yield}\)</span>)에 의해 제한되며,
<strong>바로 이 성분만 포화(saturation)</strong>된다.
<span class="math display">\[0 \le g_{\rm restore} \le g_\star.\]</span></p>
<h2 class="unnumbered" id="g.2-기하학-파트-결손-곡률요구량-잠재가속도의-항등식">G.2 기하학 파트: 결손-곡률요구량-잠재가속도의 항등식</h2>
<h3 class="unnumbered" id="g.2.1-격자-강성">G.2.1 격자 강성</h3>
<p><span class="math display">\[K \equiv c^2 \quad [{\rm m^2/s^2}]\]</span></p>
<h3 class="unnumbered" id="g.2.2-결손-반지름기하학적-등가량">G.2.2 결손 반지름(기하학적 등가량)</h3>
<p>질량 <span class="math inline">\(M\)</span>은 격자에서 “결손(비움)”에 대응하며, 등가 결손 크기를
<span class="math display">\[R_s \equiv \frac{2GM}{c^2}\]</span>
로 둔다(기하학적 길이 스케일).</p>
<h3 class="unnumbered" id="g.2.3-기하학적-곡률요구량단위-m-1">G.2.3 기하학적 곡률요구량(단위 <span class="math inline">\(m^{-1}\)</span>)</h3>
<p>거리 <span class="math inline">\(R\)</span>에서의 곡률요구량을
<span class="math display">\[\Psi_{\rm geom}(R) \;\equiv\; \frac{R_s}{2R^2}
\;=\; \frac{GM}{c^2R^2}
\quad [m^{-1}]\]</span>
로 둔다.
여기서 <span class="math inline">\(\Psi\)</span>는 표준 탄성학의 무차원 strain이 아니라,
<strong>곡률 요구량(단위 <span class="math inline">\(m^{-1}\)</span>)</strong>이다.</p>
<h3 class="unnumbered" id="g.2.4-잠재-곡률가속도뉴턴-등가">G.2.4 잠재 곡률가속도(뉴턴 등가)</h3>
<p>강성 <span class="math inline">\(c^2\)</span>가 곡률요구량을 가속도로 환산하면,
<span class="math display">\[g_{\rm pot}(R)\;\equiv\; c^2\,\Psi_{\rm geom}(R)
\;=\; \frac{GM}{R^2}.\]</span>
즉, <span class="math inline">\(\;g_{\rm pot}\)</span>는 기존의 뉴턴형 곡률가속도와 동일한 형태로 나타난다.</p>
<h2 class="unnumbered" id="g.3-포화항복-파트-격자-복원압의-구성방정식constitutive-law">G.3 포화(항복) 파트: 격자 복원압의 구성방정식(constitutive law)</h2>
<p>핵심은 <span class="math inline">\(\Psi\)</span>가 무한히 커지지 않는다는 <strong>항복 공리</strong>이다.</p>
<h3 class="unnumbered" id="g.3.1-항복-곡률요구량">G.3.1 항복 곡률요구량</h3>
<p><span class="math display">\[\Psi_{\rm eff} \le \Psi_{\rm yield}.\]</span>
따라서 격자가 실제로 ‘수용하는’ 곡률요구량은
<span class="math display">\[\Psi_{\rm eff} \;=\; \Psi_{\rm yield}\,\Phi\!\left(\frac{\Psi_{\rm geom}}{\Psi_{\rm yield}}\right)\]</span>
로 쓸 수 있다. 여기서 <span class="math inline">\(\Phi(x)\)</span>는 포화 함수이며 <span class="math inline">\(0\le\Phi\le 1\)</span>.</p>
<h3 class="unnumbered" id="g.3.2-하드-항복가장-단순한-포화">G.3.2 하드 항복(가장 단순한 포화)</h3>
<p><span class="math display">\[\Phi(x)=\min(x,1)
\quad\Rightarrow\quad
\Psi_{\rm eff}=\min(\Psi_{\rm geom},\Psi_{\rm yield}).\]</span>
그러면 격자 복원 가속도는
<span class="math display">\[g_{\rm restore}
\equiv c^2\Psi_{\rm eff}
= c^2\min(\Psi_{\rm geom},\Psi_{\rm yield})
= \min(g_{\rm pot},g_\star).\]</span></p>
<h3 class="unnumbered" id="g.3.3-hourglassjanssen형-완만-포화연속-전이-모델">G.3.3 Hourglass/Janssen형 ‘완만 포화’(연속 전이 모델)</h3>
<p>재밍/입상체(모래시계/사일로)에서 수직 응력이 깊이에 대해 포화되는
Janssen-type shielding과 유사하게, 다음과 같은 완만한 포화 커브를 허용한다.</p>
<p>정규화 변수:
<span class="math display">\[x \equiv \frac{g_{\rm pot}}{g_\star} = \frac{\Psi_{\rm geom}}{\Psi_{\rm yield}}.\]</span></p>
<p>대표 커널:
<span class="math display">\[\Phi_{\rm J}(x)=1-e^{-x}
\quad\Rightarrow\quad
g_{\rm restore}=g_\star(1-e^{-x}).\]</span></p>
<p>또는(모래시계 배출률의 master-curve 형태를 참고한 “velocity-like” 형태):
<span class="math display">\[\Phi_{\rm H}(x)=\sqrt{1-e^{-x}}.\]</span>
(단, 이 형태는 작은 <span class="math inline">\(x\)</span>에서 선형성(<span class="math inline">\(\Phi\sim x\)</span>)을 깨기 쉬우므로,
가속도에 직접 적용 시에는 보정(예: 선형-근접 정합)이 필요하다.)</p>
<h2 class="unnumbered" id="g.4-반례목성태양중성자별-등-처리">G.4 반례(목성/태양/중성자별 등) 처리</h2>
<p>본 이론에서 <span class="math inline">\(g_\star\)</span>는 “우주 어디서나 중력장이 9.8로 고정된다”가 아니라,
<strong>격자가 물질을 ‘직접’ 받쳐서 정지시키는 접촉/정지 조건의 최대 가속도</strong>이다.</p>
<h4 data-number="20.9.5.52" id="i-달화성지구"><span class="header-section-number">20.9.5.52</span> (i) 달/화성/지구:</h4>
<p>고체 표면(접촉)이 가능하고 <span class="math inline">\(g_{\rm pot}&lt;g_\star\)</span>이면,
<span class="math display">\[g_{\rm restore}=g_{\rm pot},\]</span>
즉 표면 역학은 기존 예측과 동일하게 나타난다.</p>
<h4 data-number="20.9.5.53" id="ii-목성태양"><span class="header-section-number">20.9.5.53</span> (ii) 목성/태양:</h4>
<p>고체 표면이 없고(연속적 유체/플라즈마),
<span class="math inline">\(\,g_{\rm pot}\gg g_\star\)</span>가 가능해도
<span class="math inline">\(\,g_{\rm restore}\le g_\star\)</span>인 “고체 접촉 기반의 정지 지표”가 형성되지 않는다.
따라서 “지표에서 저울로 재는 g” 자체가 정의되기 어렵다.
원거리 운동/궤도는 <span class="math inline">\(g_{\rm geom}\approx g_{\rm pot}\)</span>에 의해 설명된다.</p>
<h4 data-number="20.9.5.54" id="iii-중성자별블랙홀-근방"><span class="header-section-number">20.9.5.54</span> (iii) 중성자별/블랙홀 근방:</h4>
<p><span class="math inline">\(\,g_{\rm pot}\)</span>는 극단적으로 커지지만,
“고체 접촉 기반 정지 조건”은 일반적으로 붕괴/유체화/비선형 상태로 전이하며,
격자 복원압 성분은 <span class="math inline">\(g_\star\)</span>로 포화된다.
초과분은 다른 구속(유체압/전자기/회전/밀집 응력 등)으로 분산된다.</p>
<h2 class="unnumbered" id="g.5-최종-정리요약-방정식">G.5 최종 정리(요약 방정식)</h2>
<p><span class="math display">\[\boxed{
g_{\rm pot}(R)=\frac{GM}{R^2},\quad
x=\frac{g_{\rm pot}}{g_\star},\quad
g_{\rm restore}=g_\star\,\Phi(x),\quad
0\le g_{\rm restore}\le g_\star
}\]</span></p>
<h2 class="unnumbered" id="g.6-결정론-검증-스크립트재현-가능-출력">G.6 결정론 검증 스크립트(재현 가능 출력)</h2>
<p>아래 스크립트는 부록 G의 핵심 항등식과 포화 커널(하드/완만)을 한 번에 출력한다.</p>
<pre><code>import numpy as np

# =============================================================================
# [APPENDIX G] GRAVITY (CONSOLIDATED)
# =============================================================================

def f_hard_clip(x: float) -&gt; float:
    """Hard yield clamp: f(x)=min(x,1)."""
    if x &lt;= 0.0:
        return 0.0
    return x if x &lt; 1.0 else 1.0

def f_soft_clip(x: float, n: float = 64.0) -&gt; float:
    """Smooth approximation of min(x,1): f = x/(1+x^n)^(1/n)."""
    if x &lt;= 0.0:
        return 0.0
    if n &lt;= 0.0:
        raise ValueError("n must be &gt; 0")
    u = -n * np.log(x)
    log_1pexp_u = np.logaddexp(0.0, u)
    log_f = -(1.0 / n) * log_1pexp_u
    return float(np.exp(log_f))

def f_tanh(x: float) -&gt; float:
    """Generic smooth saturation: f=tanh(x)."""
    if x &lt;= 0.0:
        return 0.0
    return float(np.tanh(x))

def f_janssen(x: float) -&gt; float:
    """Janssen-like saturation curve: f=1-exp(-x)."""
    if x &lt;= 0.0:
        return 0.0
    return float(1.0 - np.exp(-x))

def f_sqrt_janssen(x: float) -&gt; float:
    """Unified discharge master-curve shape: f=sqrt(1-exp(-x))."""
    if x &lt;= 0.0:
        return 0.0
    return float(np.sqrt(1.0 - np.exp(-x)))

def classify_regime(x: float) -&gt; str:
    if x &lt; 0.1:
        return "Fluid (linear)"
    if x &lt; 1.0:
        return "Transition (0.1&lt;=x&lt;1)"
    if x &lt; 3.0:
        return "Near-yield (1&lt;=x&lt;3)"
    return "Saturated (x&gt;=3)"

def g_potential_newton(G: float, M: float, R: float) -&gt; float:
    return G * M / (R ** 2)

def schwartz_radius(G: float, M: float, c2: float) -&gt; float:
    return (2.0 * G * M) / c2

def psi_from_rs(Rs: float, R: float) -&gt; float:
    return Rs / (2.0 * (R ** 2))

def fmt_auto(x: float, width: int = 12, prec: int = 6) -&gt; str:
    ax = abs(x)
    if ax == 0.0:
        return f"{0:{width}.{prec}f}"
    if ax &gt;= 1e6 or ax &lt; 1e-3:
        return f"{x:{width}.{prec}e}"
    return f"{x:{width}.{prec}f}"

def print_header(title: str) -&gt; None:
    print("=" * 88)
    print(title)
    print("=" * 88)

def print_section(title: str) -&gt; None:
    print("\n" + "[" + title + "]")

def evaluate_models_for_gpot(g_pot: float, g_limit: float, models: dict[str, callable]) -&gt; dict[str, float]:
    x = g_pot / g_limit if g_limit &gt; 0 else np.inf
    out: dict[str, float] = {}
    for name, f in models.items():
        frac = float(f(x))
        g_restore = g_limit * frac
        if g_restore &gt; g_limit:
            g_restore = g_limit
        out[name] = g_restore
    return out

def main() -&gt; None:
    c = 299_792_458.0
    c2 = c ** 2
    G = 6.67430e-11

    print_header("[APP G] GRAVITY: LATTICE STIFFNESS LIMIT &amp; SATURATION + HOURGLASS(JANSSEN)")

    M_earth = 5.9722e24
    R_earth = 6.3710e6

    g_pot_earth = g_potential_newton(G, M_earth, R_earth)
    Rs_earth = schwartz_radius(G, M_earth, c2)
    psi_earth_from_g = g_pot_earth / c2

    psi_yield_geo = psi_earth_from_g
    g_limit_geo = c2 * psi_yield_geo

    g0_standard = 9.80665
    psi_yield_std = g0_standard / c2

    YIELD_MODE = "earth"
    if YIELD_MODE.lower().startswith("earth"):
        g_limit = g_limit_geo
        psi_yield = psi_yield_geo
    else:
        g_limit = g0_standard
        psi_yield = psi_yield_std

    n_soft = 64.0
    models: dict[str, callable] = {
        "hard": lambda x: f_hard_clip(x),
        f"soft_n{int(n_soft)}": (lambda x, n=n_soft: f_soft_clip(x, n=n)),
        "tanh": lambda x: f_tanh(x),
        "janssen": lambda x: f_janssen(x),
        "sqrt_janssen": lambda x: f_sqrt_janssen(x),
    }
    kernel_names = list(models.keys())

    bodies_geom = {
        "Moon": (7.342e22, 1.7374e6),
        "Mars": (6.4171e23, 3.3895e6),
        "Earth": (M_earth, R_earth),
        "Jupiter": (1.898e27, 7.1492e7),
        "Sun": (1.989e30, 6.963e8),
        "NeutronStar": (1.4 * 1.989e30, 1.0e4),
    }

    print_section("TABLE: (M,R)-&gt;g_pot then g_restore by kernels")
    header = ["OBJECT", "g_pot", "x"] + [f"g_{k}" for k in kernel_names] + ["REGIME"]
    print(" | ".join([f"{h:&lt;12}" for h in header]))
    print("-" * (15 * len(header)))

    for name, (M, R) in bodies_geom.items():
        Rs = schwartz_radius(G, M, c2)
        psi_geom = psi_from_rs(Rs, R)
        g_pot = c2 * psi_geom
        x = g_pot / g_limit
        g_restore = evaluate_models_for_gpot(g_pot, g_limit, models)
        regime = classify_regime(x)

        row = [name, fmt_auto(g_pot), fmt_auto(x)]
        for k in kernel_names:
            row.append(fmt_auto(g_restore[k]))
        row.append(regime)
        print(" | ".join([f"{c:&lt;12}" for c in row]))

    print("\nEND APP G")

if __name__ == "__main__":
    main()</code></pre>
<h1 data-number="21" id="app:geom_rigidity_v2_1"><span class="header-section-number">21</span> Appendix H: Theory of Geometric Rigidity (v2.1)</h1>
<p>This appendix records a compact, self-contained derivation that links an effective coordination number <span class="math inline">\(N\)</span> (jamming state) to a rigidity measure <span class="math inline">\(\Psi\)</span>.
It is intended as an extension note: the algebra is locked and reproduced by a script in the DOI bundle, while the physical interpretation can be debated and improved.</p>
<h2 data-number="21.1" id="h.1-geometric-gap-and-barrier"><span class="header-section-number">21.1</span> H.1 Geometric gap and barrier</h2>
<p>Define the geometric gap
<span class="math display">\[\delta \equiv 4 - N.\]</span>
Assume a minimal inverse-gap barrier for rearrangement:
<span class="math display">\[U_{\mathrm{barrier}} = \frac{C_{\mathrm{geo}}}{4-N}.\]</span></p>
<h2 data-number="21.2" id="h.2-statistical-stability-and-the-rigidity-form"><span class="header-section-number">21.2</span> H.2 Statistical stability and the rigidity form</h2>
<p>With a Boltzmann-type escape probability <span class="math inline">\(P_{\mathrm{escape}} \propto \exp(-U_{\mathrm{barrier}}/E_{\mathrm{th}})\)</span>, define rigidity as inverse failure: <span class="math inline">\(\Psi \propto 1/P_{\mathrm{escape}}\)</span>.
This yields an exponential rigidity law, normalized at <span class="math inline">\(N=3\)</span>:
<span class="math display">\[\Psi(N) = \Psi_{\mathrm{base}} \exp\Big[k \Big(\frac{1}{4-N} - 1\Big)\Big],\]</span>
where <span class="math inline">\(k \equiv C_{\mathrm{geo}}/E_{\mathrm{th}}\)</span> is a dimensionless geometric coupling constant.</p>
<h2 data-number="21.3" id="h.3-diagnostic-inversion-effective-coordination-from-modulus-ratios"><span class="header-section-number">21.3</span> H.3 Diagnostic inversion: effective coordination from modulus ratios</h2>
<p>If a material-specific mapping allows <span class="math inline">\(\Psi\)</span> to be compared via a measurable rigidity proxy (e.g., a bulk-modulus ratio <span class="math inline">\(R \approx K_s/K_l\)</span> across a transition), then the equation inverts to
<span class="math display">\[N_{\mathrm{eff}} = 4 - \frac{1}{1 + (1/k)\ln R}.\]</span></p>
<h2 data-number="21.4" id="h.4-doi-reproducibility-artifacts-lock"><span class="header-section-number">21.4</span> H.4 DOI reproducibility artifacts (LOCK)</h2>
<p>The following files fully reproduce the numerical table used in this appendix:</p>
<ul>
<li><p>LOCK: <code>04_vp_whitepaper/LOCK/rigidity_theory_v2_1_lock.json</code></p></li>
<li><p>Data: <code>04_vp_whitepaper/data/rigidity/rigidity_case_studies_v1.csv</code></p></li>
<li><p>Script: <code>04_vp_whitepaper/scripts/run_rigidity_theory_v2_1.py</code></p></li>
</ul>
<h1 data-number="22" id="app:doi_cite_registry"><span class="header-section-number">22</span> Appendix I: DOI-anchored Citation Registry (No Missing DOI)</h1>
<p>This appendix resolves the internal citation tokens used in the white paper, written in the form <code>[cite: XX]</code>.
Each cite-ID maps to a DOI and a concrete bundle path.</p>
<ul>
<li><p>Zenodo DOI (this bundle): <a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>.</p></li>
<li><p>Source of truth (CSV): <code>04_vp_whitepaper/docs/citations/CITE_REGISTRY.csv</code>.</p></li>
<li><p>Per-ID notes: <code>04_vp_whitepaper/docs/citations/CITE-*.md</code>.</p></li>
</ul>
<table style="width:98%;">
<colgroup>
<col style="width: 8%"/>
<col style="width: 40%"/>
<col style="width: 12%"/>
<col style="width: 38%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>ID</strong></th>
<th style="text-align: left;"><strong>What it anchors</strong></th>
<th style="text-align: left;"><strong>Gate</strong></th>
<th style="text-align: left;"><strong>DOI / bundle pointer</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>ID</strong></td>
<td style="text-align: left;"><strong>What it anchors</strong></td>
<td style="text-align: left;"><strong>Gate</strong></td>
<td style="text-align: left;"><strong>DOI / bundle pointer</strong></td>
</tr>
<tr class="even">
<td style="text-align: left;">20</td>
<td style="text-align: left;">Fe-Mo catalyst: asymmetric compression-field (design note)</td>
<td style="text-align: left;">UNLOGGED</td>
<td style="text-align: left;"><a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>; <code>04_vp_whitepaper/docs/citations/CITE-020.md</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">21</td>
<td style="text-align: left;">N2 bond-break critical amplitude ( <span class="math inline">\(\pm 290\,\mathrm{fm}\)</span> )</td>
<td style="text-align: left;">PASS</td>
<td style="text-align: left;"><a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>; <code>04_vp_whitepaper/docs/citations/CITE-021.md</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">26</td>
<td style="text-align: left;">N2 case internal simulation/report pointer (scalar traceability)</td>
<td style="text-align: left;">PASS</td>
<td style="text-align: left;"><a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>; <code>04_vp_whitepaper/docs/citations/CITE-026.md</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">30</td>
<td style="text-align: left;">Asymmetric strike / alignment-interference protocol (design note)</td>
<td style="text-align: left;">UNLOGGED</td>
<td style="text-align: left;"><a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>; <code>04_vp_whitepaper/docs/citations/CITE-030.md</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">47</td>
<td style="text-align: left;">N2 case secondary note pointer</td>
<td style="text-align: left;">PASS</td>
<td style="text-align: left;"><a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>; <code>04_vp_whitepaper/docs/citations/CITE-047.md</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">61</td>
<td style="text-align: left;">CO2 case: high-temperature decomposition ( <span class="math inline">\(\pm 300\,\mathrm{fm}\)</span> )</td>
<td style="text-align: left;">PASS</td>
<td style="text-align: left;"><a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>; <code>04_vp_whitepaper/docs/citations/CITE-061.md</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">65</td>
<td style="text-align: left;">CO2 case: break threshold + recombination/quenching note</td>
<td style="text-align: left;">PASS*</td>
<td style="text-align: left;"><a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>; <code>04_vp_whitepaper/docs/citations/CITE-065.md</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">68</td>
<td style="text-align: left;">CO2 case: quenching + alignment<span class="math inline">\(&lt;70\%\)</span> recombination suppression</td>
<td style="text-align: left;">UNLOGGED</td>
<td style="text-align: left;"><a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>; <code>04_vp_whitepaper/docs/citations/CITE-068.md</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">77</td>
<td style="text-align: left;">Seawater process: H2O/ion amplitude ranges</td>
<td style="text-align: left;">PASS</td>
<td style="text-align: left;"><a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>; <code>04_vp_whitepaper/docs/citations/CITE-077.md</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">83</td>
<td style="text-align: left;">Seawater process: water operational-range record</td>
<td style="text-align: left;">PASS</td>
<td style="text-align: left;"><a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>; <code>04_vp_whitepaper/docs/citations/CITE-083.md</code></td>
</tr>
<tr class="even">
<td style="text-align: left;">85</td>
<td style="text-align: left;">Ion expulsion efficiency 97.3% (pending)</td>
<td style="text-align: left;">UNLOGGED</td>
<td style="text-align: left;"><a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>; <code>04_vp_whitepaper/docs/citations/CITE-085.md</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;">102</td>
<td style="text-align: left;">Water stiffness cross-check via <span class="math inline">\(P_{\mathrm{idx}}\)</span> table</td>
<td style="text-align: left;">PASS</td>
<td style="text-align: left;"><a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>; <code>04_vp_whitepaper/docs/citations/CITE-102.md</code></td>
</tr>
</tbody>
</table>
<p><strong>Note:</strong> <code>PASS*</code> indicates that the <em>scalar threshold</em> is reproduced in-bundle (PASS), while any additional mechanistic claim attached to the same sentence is treated as pending unless a primary run log is bundled.</p>
<h1 data-number="23" id="app:black_copper_ess"><span class="header-section-number">23</span> Appendix J: 블랙-코팅 구리 ESS — 임피던스 변환 집열, 과립(Granular) 격자 저장, 그리고 Black-Copper 트랜스덕션 (공학 부록; NON-LOCK)</h1>
<h2 data-number="23.1" id="j.0-범위와-상태-non-lock"><span class="header-section-number">23.1</span> J.0 범위와 상태 (NON-LOCK)</h2>
<p>본 부록은 VP 공리(axioms)에서 <em>동기</em>를 얻은 <strong>공학적 청사진(blueprint)</strong>을 기록한다.
그러나 이는 본문 LOCK 사슬의 입력으로 사용되지 않는다.
따라서 본 부록에 등장하는 모든 수치값은, (i) 사전등록된 측정 프로토콜과 (ii) Zenodo 번들(<a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a>)에 봉인된 artifact에 <em>명시적으로</em> 연결되지 않는 한 <code>NON-LOCK</code>로 간주한다.</p>
<h4 data-number="23.1.0.1" id="왜-별도-부록인가"><span class="header-section-number">23.1.0.1</span> 왜 별도 부록인가?</h4>
<p>여기서 제안하는 “Black-Copper ESS”는 다음의 <strong>단일 폐쇄 논리 사슬</strong>로 취급한다:
<strong>집열(collect)</strong>(태양) <span class="math inline">\(\rightarrow\)</span> <strong>주입(inject)</strong>(구리 격자) <span class="math inline">\(\rightarrow\)</span> <strong>저장(store)</strong>(과립 격자 진동/열) <span class="math inline">\(\rightarrow\)</span> <strong>추출(extract)</strong>(전기에너지) <span class="math inline">\(\rightarrow\)</span> 선택적 <strong>피드백(feedback)</strong>(전기 <span class="math inline">\(\rightarrow\)</span> 공동 내부 가열).
이는 <em>응용 공학 레이어</em>이며, 이 부록의 설계가 VP 상수(LOCK)를 역으로 “튜닝”해서는 안 된다.</p>
<h2 data-number="23.2" id="j.1-격자-및-인터페이스의-공학적-정의"><span class="header-section-number">23.2</span> J.1 격자 및 인터페이스의 공학적 정의</h2>
<p>모듈은 네 개의 결합된 부분계로 정의한다.</p>
<h3 data-number="23.2.1" id="j.1.1-구리-격자-lambda_mathrmcu-저임피던스-격자-증폭기"><span class="header-section-number">23.2.1</span> J.1.1 구리 격자 <span class="math inline">\(\Lambda_{\mathrm{Cu}}\)</span> (저임피던스 격자 증폭기)</h3>
<p>VP 해석에서 구리는, 주어진 전력 처리량(power throughput)에서 <em>flow-형</em> 진폭(전류-유사/속도-유사 변수)을 크게 지지하는 <em>저임피던스 격자</em>로 취급된다.
공학 계산에서는 대표적인 물성(여기서는 LOCK 하지 않음)인 질량밀도 <span class="math inline">\(\rho\)</span>, 탄성계수 <span class="math inline">\(\kappa\)</span>, 작은 소산 파라미터 <span class="math inline">\(\gamma\)</span>를 참조할 수 있다.</p>
<h3 data-number="23.2.2" id="j.1.2-블랙-코팅-인터페이스-gamma_mathrmbc-광대역-흡수임피던스-매칭"><span class="header-section-number">23.2.2</span> J.1.2 블랙 코팅 인터페이스 <span class="math inline">\(\Gamma_{\mathrm{BC}}\)</span> (광대역 흡수/임피던스 매칭)</h3>
<p>“Black Copper”는 나노구조(black coating)를 통해 (i) 목표 스펙트럼 대역에서 반사를 억제하고, (ii) 입사 광자 플럭스를 경계 과정으로서 격자 주입(phonon/electron excitation)으로 변환하는 구리를 뜻한다.
실제로는 코팅 성능을 측정된 반사율 스펙트럼 <span class="math inline">\(R(\omega)\)</span> 및 내구성(온도/산화) 엔벨로프와 함께 규정해야 하며, 이는 DOI artifact로 봉인되어야 한다.</p>
<h3 data-number="23.2.3" id="j.1.3-과립-저장-격자-lambda_mathrmsand-비연속-phonon-저장소"><span class="header-section-number">23.2.3</span> J.1.3 과립 저장 격자 <span class="math inline">\(\Lambda_{\mathrm{Sand}}\)</span> (비연속 phonon 저장소)</h3>
<p>저장 매질은 (예: 실리카/알루미나) 무질서 과립 네트워크로 모델링하며, <em>이산 진동자 앙상블</em>로 취급한다.
모듈 수준에서 선도차(leading order)의 저장 용량은 여전히 벌크 열용량 모델로 잘 근사된다.</p>
<h3 data-number="23.2.4" id="j.1.4-유리-공동-경계-gamma_mathrmglass-복사-트랩-단열-인터페이스"><span class="header-section-number">23.2.4</span> J.1.4 유리 공동 경계 <span class="math inline">\(\Gamma_{\mathrm{Glass}}\)</span> (복사 트랩 + 단열 인터페이스)</h3>
<p>공동 경계는 (i) 외부 단열로 전도 손실을 억제하고, (ii) 내부 라이너로 적외선(IR) 교환을 가두어, 아디아바틱 경계 조건에 가까워지도록 설계한다.</p>
<h2 data-number="23.3" id="j.2-임피던스-미스매치와-진폭-변환-에너지-이득-없음"><span class="header-section-number">23.3</span> J.2 임피던스 미스매치와 진폭 변환 (에너지 이득 없음)</h2>
<p>혼동을 피하기 위해, 파동의 표준 <em>effort/flow</em> 표현을 사용한다.
<span class="math inline">\(E\)</span>를 effort-형(전압/힘 계열) 진폭, <span class="math inline">\(J\)</span>를 flow-형(전류/속도 계열) 진폭으로 두고,
유효 임피던스를 다음으로 정의한다:
<span class="math display">\[E = Z\,J,
\qquad
P = \frac{1}{2}\,EJ = \frac{1}{2}ZJ^2 = \frac{1}{2}\frac{E^2}{Z}.
\label{eq:AppJ_power_effort_flow}\]</span></p>
<p>블랙 코팅 인터페이스가 운용 대역에서 반사가 작도록 설계되어, 흡수된 전력이 대략 구리 격자로 전달된다고 가정하면
<span class="math display">\[P_{\mathrm{in}}\;\approx\;P_{\mathrm{Cu}}.
\label{eq:AppJ_power_continuity}\]</span></p>
<p>이때 <strong>flow-형 진폭</strong>은
<span class="math display">\[\boxed{
\frac{J_{\mathrm{Cu}}}{J_{\mathrm{in}}} = \sqrt{\frac{Z_{\mathrm{in}}}{Z_{\mathrm{Cu,eff}}}}
}
\label{eq:AppJ_flow_gain}\]</span>
처럼 스케일링되며, <strong>effort-형 진폭</strong>은 반대로
<span class="math display">\[\boxed{
\frac{E_{\mathrm{Cu}}}{E_{\mathrm{in}}} = \sqrt{\frac{Z_{\mathrm{Cu,eff}}}{Z_{\mathrm{in}}}}
}
\label{eq:AppJ_effort_gain}\]</span>
스케일링된다. 전력은 보존되며(에너지 생성 없음), 변하는 것은 표현(진폭 배분)이다.</p>
<h4 data-number="23.3.0.1" id="수치-예시-보편-주장-아님."><span class="header-section-number">23.3.0.1</span> 수치 예시 (보편 주장 아님).</h4>
<p><span class="math inline">\(Z_{\mathrm{in}}\)</span>을 자유공간 임피던스 <span class="math inline">\(Z_0\approx 376.73\,\Omega\)</span>로 두고, (예시로만) 구리 격자의 유효 임피던스를 <span class="math inline">\(Z_{\mathrm{Cu,eff}}\approx 0.01\,\Omega\)</span>로 두면,
<span class="math display">\[G_J := \frac{J_{\mathrm{Cu}}}{J_{\mathrm{in}}} = \sqrt{\frac{376.73}{0.01}}\approx 194.
\label{eq:AppJ_gain_example}\]</span>
LOCK<span class="math inline">\(\rightarrow\)</span>Gate 프레임에서는 <span class="math inline">\(Z_{\mathrm{Cu,eff}}\)</span>를 <strong>측정-잠금(measured-and-locked)</strong>된 인터페이스 파라미터(프로토콜+불확도)로 취급해야 하며, 그렇지 않으면 위 숫자는 정성적 스케일링 예시에 그친다.</p>
<h3 data-number="23.3.1" id="j.2.1-vp-해석-새-전기-형태를-flow-진폭-변수로-이해"><span class="header-section-number">23.3.1</span> J.2.1 VP 해석: “새 전기 형태”를 flow-진폭 변수로 이해</h3>
<p>통상 회로 언어에서는 전압-유사(effort) 진폭 <span class="math inline">\(E\)</span>가 강조된다.
본 부록에서는 의도적으로 <em>flow-형</em> 진폭 <span class="math inline">\(J\)</span>를 강조한다. 저임피던스 격자는, 동일한 흡수 전력 예산에서 큰 전류/속도 응답(큰 <span class="math inline">\(J\)</span>)을 자연스럽게 지지하기 때문이다.
VP 용어로 이는 “진폭-전류(amplitude-current)” 상태로 묘사될 수 있다: 새로운 에너지 원천이 아니라, 동일한 보존 전력 예산을 (low-<span class="math inline">\(E\)</span>/high-<span class="math inline">\(J\)</span>) 형태로 표현하는 것이다.</p>
<h2 data-number="23.4" id="j.3-기하-모닝글로리morning-glory-트럼펫을-임피던스-변환기로-사용"><span class="header-section-number">23.4</span> J.3 기하: “모닝글로리(morning-glory)” 트럼펫을 임피던스 변환기로 사용</h2>
<p>외부 집열기는 <strong>트럼펫/혼(horn)/모닝글로리</strong> 형상을 갖도록 규정한다.
이는 미적 선택이 아니라, <em>분포형 임피던스 변환(distributed impedance transformation)</em>을 구현하고,
미스매치를 유한 길이에 분산시켜 반사를 억제하기 위한 설계 선택이다.</p>
<h3 data-number="23.4.1" id="j.3.1-기하학적-집중-이득-면적비"><span class="header-section-number">23.4.1</span> J.3.1 기하학적 집중 이득 (면적비)</h3>
<p>입구(마우스) 면적을 <span class="math inline">\(A_{\mathrm{m}}\)</span>, 목(throat) 결합 면적을 <span class="math inline">\(A_{\mathrm{t}}\)</span>라 하자.
입사 강도 <span class="math inline">\(I_{\odot}\)</span> (W/m<span class="math inline">\(^2\)</span>)에 대해 흡수 전력은
<span class="math display">\[P_{\mathrm{in}}\approx \eta_{\mathrm{abs}}\, I_{\odot}\,A_{\mathrm{m}},
\label{eq:AppJ_Pin}\]</span>
로 쓸 수 있다. 여기서 <span class="math inline">\(\eta_{\mathrm{abs}}\in[0,1]\)</span>는 <span class="math inline">\(\Gamma_{\mathrm{BC}}\)</span>의 대역 평균 흡수 효율이며(측정 필요),
결합이 큰 손실 없이 목 면적으로 전력을 전달한다면, 목 근처의 국소 강도 스케일은
<span class="math display">\[I_{\mathrm{t}} \sim \frac{P_{\mathrm{in}}}{A_{\mathrm{t}}}
\approx \eta_{\mathrm{abs}}\,I_{\odot}\,\frac{A_{\mathrm{m}}}{A_{\mathrm{t}}}.
\label{eq:AppJ_Intensity_gain}\]</span>
따라서 에너지 밀도가 (진폭)<span class="math inline">\(^2\)</span>에 비례하는 장-유사(field-like) 진폭은 <strong>기하학적 이득</strong>
<span class="math display">\[\boxed{
G_{\mathrm{geo}} := \sqrt{\frac{A_{\mathrm{m}}}{A_{\mathrm{t}}}}.
}
\label{eq:AppJ_Ggeo}\]</span>
을 갖는다. 이는 순수 기하학(물성 상수 비개입)이다.</p>
<h3 data-number="23.4.2" id="j.3.2-완만-테이퍼-조건-반사-억제"><span class="header-section-number">23.4.2</span> J.3.2 완만 테이퍼 조건 (반사 억제)</h3>
<p>혼 축을 <span class="math inline">\(z\in[0,L]\)</span>, 단면적을 <span class="math inline">\(A(z)\)</span>라 하자.
완만히 변하는(adiabatic) 변환기에서 선도 반사 크기는 유효 임피던스의 기울기에 비례해 스케일링한다.
대표적인 공학적 기준은
<span class="math display">\[\bigl|\partial_z\ln Z_{\mathrm{eff}}(z)\bigr|\ll k
\qquad (k:=2\pi/\lambda),
\label{eq:AppJ_adiabatic}\]</span>
로, 테이퍼를 운용 파장에 비해 충분히 길고 매끄럽게 만들라는 뜻이다.
모닝글로리 플레어는 불연속을 도입하지 않고 이 조건을 기하학적으로 만족시키는 한 방법이다.</p>
<h3 data-number="23.4.3" id="j.3.3-단순-폐곡선-프로파일-지수형-혼"><span class="header-section-number">23.4.3</span> J.3.3 단순 폐곡선 프로파일 (지수형 혼)</h3>
<p>구체적인 청사진으로 지수형 플레어를 사용할 수 있다:
<span class="math display">\[r(z)=r_{\mathrm{t}}\,\exp\!\left(\frac{z}{L}\ln\frac{r_{\mathrm{m}}}{r_{\mathrm{t}}}\right),
\qquad
A(z)=\pi r(z)^2,
\label{eq:AppJ_exponential_horn}\]</span>
여기서 <span class="math inline">\(r_{\mathrm{t}}\)</span>는 목 반지름, <span class="math inline">\(r_{\mathrm{m}}\)</span>은 마우스 반지름이다.
이 프로파일은 상대 팽창률이 일정하며 제작/파라미터화가 단순하다.</p>
<h2 data-number="23.5" id="j.4-과립-격자-저장모래-배터리-용량"><span class="header-section-number">23.5</span> J.4 과립 격자 저장(모래 배터리) 용량</h2>
<p>선도차에서 열 저장 용량은
<span class="math display">\[E_{\mathrm{store}} \approx M\,c_p\,\Delta T.
\label{eq:AppJ_Estore}\]</span>
로 근사된다.
<span class="math inline">\(1\,\mathrm{m}^3\)</span> 포장 모듈, 벌크 밀도 <span class="math inline">\(\rho_{\mathrm{bulk}}\approx 1600\,\mathrm{kg/m^3}\)</span>, 실리카 열용량 <span class="math inline">\(c_p\approx 830\,\mathrm{J/(kg\cdot K)}\)</span>,
운용 온도 스윙 <span class="math inline">\(\Delta T\approx 500\,\mathrm{K}\)</span>를 가정하면
<span class="math display">\[\begin{aligned}
M &amp;\approx 1600\,\mathrm{kg},\\
E_{\mathrm{store}} &amp;\approx 1600\times 830\times 500\,\mathrm{J}\approx 6.64\times 10^{8}\,\mathrm{J}\approx 184\,\mathrm{kWh}.
\label{eq:AppJ_Estore_num}\end{aligned}\]</span>
이로부터 모듈 크기의 올바른 차수(order-of-magnitude)를 얻는다.
손실/보존성(retention)은 실제 경계 설계(단열, 복사 트랩, 누설 경로)로부터 평가되어야 하며,
성능 주장은 Gate로 통제되는 형태로만 제시되어야 한다.</p>
<h2 data-number="23.6" id="j.5-공동-내부의-black-copper-스프링이중-용도-히터-트랜스듀서"><span class="header-section-number">23.6</span> J.5 공동 내부의 Black-Copper 스프링(이중 용도: 히터 + 트랜스듀서)</h2>
<p>공동 내부 구리 소자는 <strong>스프링/헬릭스(helix)</strong> 형상을 갖도록 규정한다.
청사진 수준에서 이 소자는 두 가지 역할을 갖는다.</p>
<h3 data-number="23.6.1" id="j.5.1-충전-모드-전기-rightarrow-열-공동으로의-주입"><span class="header-section-number">23.6.1</span> J.5.1 충전 모드 (전기 <span class="math inline">\(\rightarrow\)</span> 열): 공동으로의 주입</h3>
<p>잉여 전력이 있을 때, 이를 헬릭스에 저항/유도 구동으로 인가할 수 있다.
블랙 코팅은 복사 결합을 증가시켜 전기 에너지가 공동의 열(격자 진동)로 효율적으로 변환되도록 하며,
즉 제어 가능한 “전력<span class="math inline">\(\rightarrow\)</span>열” 경로를 제공한다.</p>
<h3 data-number="23.6.2" id="j.5.2-방전-모드-열-rightarrow-전기-발전-단계로의-결합"><span class="header-section-number">23.6.2</span> J.5.2 방전 모드 (열 <span class="math inline">\(\rightarrow\)</span> 전기): 발전 단계로의 결합</h3>
<p>저장된 열로부터 전기를 추출하려면 <strong>열기관 메커니즘</strong>이 필요하다(온도 차/비평형).
본 청사진에서 블랙-코팅 구리 헬릭스는 발전 단계의 <em>열 인터페이스 + 전기 권선</em>으로 취급된다.
구체적인 변환 방식(열전, 열자기, Stirling/Brayton+발전기, TPV 등)은 별도로 명시·검증되어야 한다.
VP 이론만으로 온도 구배와 닫힌 에너지 예산의 필요성이 사라지는 것은 아니다.</p>
<h3 data-number="23.6.3" id="j.5.3-피드백-루프-허용-해석"><span class="header-section-number">23.6.3</span> J.5.3 피드백 루프 (허용 해석)</h3>
<p>“남는 전기를 ESS로 다시 넣는다”는 문구는 여기서 <strong>양방향 저장 모드</strong>로 해석한다.
즉, 전기를 다시 열로 변환(충전 모드)하여 낭비를 줄이고 목표 공동 상태를 유지하는 제어/저장 기능이다.
이는 에너지 보존을 위반하지 않는다.</p>
<h3 data-number="23.6.4" id="j.5.4-형상-잠금-헬릭스스프링-파라미터화"><span class="header-section-number">23.6.4</span> J.5.4 형상 잠금: 헬릭스(스프링) 파라미터화</h3>
<p>헬릭스 중심선을 반지름 <span class="math inline">\(R\)</span>, 피치 <span class="math inline">\(p\)</span>, 회전수 <span class="math inline">\(N_{\mathrm{turn}}\)</span>로 파라미터화하면
<span class="math display">\[\mathbf{x}(t)=\bigl(R\cos t,\;R\sin t,\; \tfrac{p}{2\pi}\,t\bigr),
\qquad
t\in[0,2\pi N_{\mathrm{turn}}].
\label{eq:AppJ_helix_param}\]</span>
이 형상은 (i) 소수의 기하 자유도 <span class="math inline">\((R,p,N_{\mathrm{turn}})\)</span>로 완전히 결정되고,
(ii) 단위 부피당 큰 코팅 표면적을 제공하며,
(iii) 선재 직경과 재료 상태가 고정되면 표준 전기 파라미터(인덕턴스, 저항)로 깨끗하게 매핑된다는 점에서 유리하다.</p>
<h2 data-number="23.7" id="j.6-본-부록을-위한-lock-rightarrow-gate-체크리스트-권장"><span class="header-section-number">23.7</span> J.6 본 부록을 위한 “LOCK <span class="math inline">\(\rightarrow\)</span> Gate” 체크리스트 (권장)</h2>
<p>본 부록이 본문 스타일과 정합되려면, 성능 주장은 최소한 다음 artifact에 연결되어야 한다.</p>
<ul>
<li><p><strong>LOCK (공학)</strong>: 기하 파라미터 <span class="math inline">\((r_{\mathrm{m}},r_{\mathrm{t}},L)\)</span>, 헬릭스 형상 <span class="math inline">\((N,\,R,\,p)\)</span>, 공동 치수; 모두 버전 관리되는 설계 JSON으로 잠금.</p></li>
<li><p><strong>LOCK (인터페이스)</strong>: 블랙 코팅의 측정 <span class="math inline">\(R(\omega)\)</span> 및 프로토콜로 정의된 유효 <span class="math inline">\(Z_{\mathrm{Cu,eff}}(\omega,T)\)</span> (또는 불확도를 포함한 명시적 모델).</p></li>
<li><p><strong>Gate (에너지 예산)</strong>: <span class="math inline">\(P_{\mathrm{in}}\)</span>, 저장 에너지 <span class="math inline">\(E_{\mathrm{store}}\)</span>, 손실, 추출 전력을 보고하는 닫힌 회계(허용오차 포함).</p></li>
<li><p><strong>DOI 완결성</strong>: CAD, BOM, 테스트 로그, 스크립트, 플롯을 Zenodo 번들에 봉인하여 “DOI missing = 0”을 유지.</p></li>
</ul>
<h1 data-number="24" id="app:acoustic_validation"><span class="header-section-number">24</span> Appendix K: 고전 기체 음향학을 통한 방법론 검증 (평균자유행로 재구성)</h1>
<h2 data-number="24.1" id="k.0-범위와-의도-캘리브레이션-모듈-non-lock"><span class="header-section-number">24.1</span> K.0 범위와 의도 (캘리브레이션 모듈; NON-LOCK)</h2>
<p>본 부록은 VP의 “이산 매질 재구성(discrete-medium reconstruction)” 논리에 대해 <strong>외부 캘리브레이션</strong>을 추가한다.
이는 “공간이 공기와 같다”류의 비유가 아니며, VP의 어떠한 LOCK 상수도 튜닝하지 않는다.
대신, 다음과 같은 <strong>블랙박스 역문제(inversion) 테스트</strong>로 취급한다.</p>
<blockquote>
<p><strong>주어짐:</strong> 알려진 이산 매질의 거시적 파동 데이터와 거시적 수송(transport) 데이터.<br/>
<strong>복원:</strong> 그 매질의 공인된 미시 길이 스케일.<br/>
<strong>해석:</strong> 알려진 미시 스케일을 가진 고전계에서 동일한 역문제 구조가 성공한다면,
VP 격자 문제에 같은 <em>구조(structure)</em>를 적용하는 것이 방법론적으로 덜 임의적임을 보인다.</p>
</blockquote>
<h2 data-number="24.2" id="k.1-공기-음향이-적절한-캘리브레이션-표적인-이유"><span class="header-section-number">24.2</span> K.1 공기 음향이 적절한 캘리브레이션 표적인 이유</h2>
<p>희박 기체에서 <strong>음속</strong> <span class="math inline">\(v_s\)</span>는 평형 열역학(주로 <span class="math inline">\(T\)</span>와 단열지수 <span class="math inline">\(\gamma\)</span>)에 의해 결정되지만,
파동 역학의 <strong>연속체 유효성</strong>과 주파수 의존 감쇠는 충돌 기반의 미시 물리에 의해 지배된다.
이때 지배적 미시 길이는 <strong>평균자유행로</strong> <span class="math inline">\(\lambda_{\mathrm{mfp}}\)</span>이다.</p>
<p>핵심은 <span class="math inline">\(\lambda_{\mathrm{mfp}}\)</span>가 <em><span class="math inline">\(v_s\)</span>만으로는</em> 추정될 수 없다는 점이다.
점성(예: <span class="math inline">\(\eta\)</span>) 같은 수송 계수 또는 감쇠 자료가 최소 하나 더 필요하다.
이는 VP 이론에서 요구하는 구조와 동일하다: <em>파동 속도 + 소산/수송 Gate</em>가 있어야 이산 스케일을 추론할 수 있다.</p>
<h2 data-number="24.3" id="k.2-거시-자료로부터-lambda_mathrmmfp-재구성-예제-1건"><span class="header-section-number">24.3</span> K.2 거시 자료로부터 <span class="math inline">\(\lambda_{\mathrm{mfp}}\)</span> 재구성 (예제 1건)</h2>
<p>상온, <span class="math inline">\(1\,\mathrm{atm}\)</span> 근처의 건조 공기를 캘리브레이션 케이스로 둔다.
대표적인 거시 입력으로
<span class="math display">\[v_s \approx 343\,\mathrm{m/s},\quad
\eta \approx 1.81\times 10^{-5}\,\mathrm{Pa\cdot s},\quad
p \approx 1.01325\times 10^{5}\,\mathrm{Pa},\]</span>
및 <span class="math inline">\(\gamma\approx 1.4\)</span>, 몰질량 <span class="math inline">\(M\approx 28.97\,\mathrm{g/mol}\)</span>을 사용한다.</p>
<h3 data-number="24.3.1" id="k.2.1-1단계-음속으로부터-온도"><span class="header-section-number">24.3.1</span> K.2.1 1단계: 음속으로부터 온도</h3>
<p>이상기체에서
<span class="math display">\[v_s=\sqrt{\gamma \frac{R T}{M}}
\quad\Longrightarrow\quad
T=\frac{v_s^2\,M}{\gamma R}.\]</span>
위 입력을 대입하면 <span class="math inline">\(T\approx 2.93\times 10^2\,\mathrm{K}\)</span>이다.</p>
<h3 data-number="24.3.2" id="k.2.2-2단계-점성으로부터-유효-충돌-직경-하드스피어-스케일링"><span class="header-section-number">24.3.2</span> K.2.2 2단계: 점성으로부터 유효 충돌 직경 (하드스피어 스케일링)</h3>
<p>동점성에 대한 하드스피어 운동론(Chapman–Enskog 형태)의 대표적 스케일링은
<span class="math display">\[\eta \approx \frac{5}{16\,d^2}\sqrt{\frac{m\,k_B\,T}{\pi}},\]</span>
이며, 여기서 <span class="math inline">\(d\)</span>는 유효 충돌 직경, <span class="math inline">\(m=M/N_A\)</span>는 분자 질량이다.
이를 <span class="math inline">\(d\)</span>에 대해 풀면
<span class="math display">\[d \approx \sqrt{\frac{5}{16\,\eta}\sqrt{\frac{m\,k_B\,T}{\pi}}}.\]</span>
수치적으로 <span class="math inline">\(d\approx 3.7\times 10^{-10}\,\mathrm{m}\)</span> (서브 나노미터 스케일)을 얻는다.</p>
<h3 data-number="24.3.3" id="k.2.3-3단계-평균자유행로"><span class="header-section-number">24.3.3</span> K.2.3 3단계: 평균자유행로</h3>
<p>하드스피어 기체에서
<span class="math display">\[\lambda_{\mathrm{mfp}}=\frac{k_B T}{\sqrt{2}\,\pi\,d^2\,p}.\]</span>
복원된 <span class="math inline">\(d\)</span>와 위 입력을 사용하면
<span class="math display">\[\lambda_{\mathrm{mfp}}\approx 6.6\times 10^{-8}\,\mathrm{m}\;\approx\;66\,\mathrm{nm}.\]</span>
이는 상온, <span class="math inline">\(1\,\mathrm{atm}\)</span> 근처 공기의 평균자유행로로 흔히 인용되는 차수(<span class="math inline">\(\sim 10^{2}\,\mathrm{nm}\)</span>)와 일치한다.</p>
<h2 data-number="24.4" id="k.3-레짐-gate-연속체-음향-vs.-이산-충돌-스케일"><span class="header-section-number">24.4</span> K.3 레짐 Gate: 연속체 음향 vs. 이산 충돌 스케일</h2>
<p>간단한 레짐 지표로 파장 기반 Knudsen 수를 정의한다:
<span class="math display">\[\mathrm{Kn}_\lambda := \frac{\lambda_{\mathrm{mfp}}}{\lambda_{\mathrm{wave}}}
=\frac{\lambda_{\mathrm{mfp}}\,\nu}{v_s},\]</span>
여기서 <span class="math inline">\(\lambda_{\mathrm{wave}}=v_s/\nu\)</span>, <span class="math inline">\(\nu\)</span>는 음향 주파수이다.
연속체 음향 모델은 <span class="math inline">\(\mathrm{Kn}_\lambda\ll 1\)</span>에서 신뢰 가능하며,
<span class="math inline">\(\mathrm{Kn}_\lambda\to O(1)\)</span>로 가면 강한 운동론 감쇠/비연속체 거동이 나타난다.
즉, 이 재구성은 숫자 맞추기만이 아니라, 거시 파동 이론이 무너지는 <strong>주파수 Gate</strong>까지 예측한다.</p>
<h2 data-number="24.5" id="k.4-동형isomorphic-비교표-음향-vs.-vp-격자-재구성"><span class="header-section-number">24.5</span> K.4 동형(isomorphic) 비교표 (음향 vs. VP 격자 재구성)</h2>
<table style="width:92%;">
<caption><strong>동형 검증 논리.</strong> 목적은 “공기”와 “공간”을 동일시하는 것이 아니라,
<em>수송/감쇠 Gate를 포함하면 거시 파동 자료로부터 이산 미시 스케일을 추론하는 작업이 잘 정의된다</em>는 점을 고전계 벤치마크로 확인하는 데 있다.</caption>
<colgroup>
<col style="width: 28%"/>
<col style="width: 32%"/>
<col style="width: 32%"/>
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;"><strong>항목</strong></th>
<th style="text-align: left;"><strong>고전 기체 음향(공기)</strong></th>
<th style="text-align: left;"><strong>VP 격자 재구성(공간)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">파동 종류</td>
<td style="text-align: left;">종압(pressure) 파동</td>
<td style="text-align: left;">VP 매질의 EM/격자 파동</td>
</tr>
<tr class="even">
<td style="text-align: left;">거시 속도</td>
<td style="text-align: left;"><span class="math inline">\(v_s\)</span> (측정)</td>
<td style="text-align: left;"><span class="math inline">\(c\)</span> (정의/측정)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">추론할 미시 길이</td>
<td style="text-align: left;"><span class="math inline">\(\lambda_{\mathrm{mfp}}\)</span> (충돌 스케일)</td>
<td style="text-align: left;"><span class="math inline">\(\ell_{\mathrm{VP}}\)</span> (격자 스케일)</td>
</tr>
<tr class="even">
<td style="text-align: left;">보조 거시 입력</td>
<td style="text-align: left;"><span class="math inline">\(\eta\)</span> (수송/감쇠 Gate)</td>
<td style="text-align: left;">VP 수송/감쇠 Gate(프로토콜 정의)</td>
</tr>
<tr class="odd">
<td style="text-align: left;">레짐 Gate</td>
<td style="text-align: left;"><span class="math inline">\(\mathrm{Kn}_\lambda\ll 1\)</span> (연속체 유효)</td>
<td style="text-align: left;">VP Gate 스택(재밍/언재밍, 창 정의)</td>
</tr>
<tr class="even">
<td style="text-align: left;">결과</td>
<td style="text-align: left;"><span class="math inline">\(\lambda_{\mathrm{mfp}}\sim 10^2\,\mathrm{nm}\)</span> (기지)</td>
<td style="text-align: left;"><span class="math inline">\(\ell_{\mathrm{VP}}\)</span> (예측/앵커)</td>
</tr>
</tbody>
</table>
<h2 data-number="24.6" id="k.5-주장-레벨과-한계"><span class="header-section-number">24.6</span> K.5 주장 레벨과 한계</h2>
<p>본 부록이 지지하는 것은 <strong>방법론적 주장</strong>이다:
<em>(파동 속도 + 수송 Gate)<span class="math inline">\(\rightarrow\)</span>(미시 스케일)</em>의 역문제 논리는 VP에만 고유하지 않으며,
고전 벤치마크에서 실제로 성공한다.
이는 특정 VP 격자 값 자체를 증명하지는 않으며, 알려진 계에서의 동형 재구성을 보여 줌으로써 임의성을 줄이는 역할을 한다.</p>
<h1 data-number="25" id="app:state_dictionary_431"><span class="header-section-number">25</span> Appendix L: 재밍 레짐 통합을 위한 4-3-1 상태 사전 (해석 모듈; NON-LOCK)</h1>
<h2 data-number="25.1" id="l.0-범위-이-부록이-하는-것하지-않는-것"><span class="header-section-number">25.1</span> L.0 범위 (이 부록이 하는 것/하지 않는 것)</h2>
<p>본 부록은 익숙한 거시 상(고체-액체-기체) 언어를,
본문에서 이미 정의한 이산 재밍(jamming) 언어(재밍 격자, 실패율 기반 유동성 <span class="math inline">\(\phi\)</span>, 언재밍 사건)와 연결하는 <em>해석 사전(dictionary)</em>을 제공한다.
목적은 <em>개념적 닫힘(conceptual closure)</em>과 독자 내비게이션을 개선하는 것이며,
새 공리를 도입하지 않고, 잠긴 수치 유도(LOCK) 입력으로도 사용되지 않는다.</p>
<h2 data-number="25.2" id="l.1-4-3-1-사전-연결성connectivity을-레짐-라벨로"><span class="header-section-number">25.2</span> L.1 4-3-1 사전 (연결성(connectivity)을 레짐 라벨로)</h2>
<p>Appendix J 등에서 사용된 전기적 임피던스 <span class="math inline">\(Z\)</span>와의 기호 충돌을 피하기 위해,
하중을 지지하는 유효 브리지 수(유효 배위수)를 <span class="math inline">\(N_{\mathrm{bond}}\)</span>로 표기한다.</p>
<div id="tab:AppL_431_dictionary">
<table>
<caption><strong>4-3-1 상태 사전.</strong> 상태 코드는 연결성 레짐을 압축 표기한 라벨이다.
이는 독자용 <em>사전</em>으로, 거시 직관을 이미 정의된 VP 재밍 어휘에 매핑한다.</caption>
<thead>
<tr class="header">
<th style="text-align: center;"><strong>상태 코드</strong></th>
<th style="text-align: center;"><span class="math inline">\(\mathbf{N_{\mathrm{bond}}}\)</span></th>
<th style="text-align: left;"><strong>거시적 비유</strong></th>
<th style="text-align: left;"><strong>VP 레짐 해석(본 백서)</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;"><span class="math inline">\(\gtrsim 4\)</span></td>
<td style="text-align: left;">고체(예: 얼음): 형태 보존, 높은 강성</td>
<td style="text-align: left;"><strong>재밍 격자/공간-유사 레짐.</strong>
<span class="math inline">\(\chi_{\mathrm{ST}}=1\)</span>, <span class="math inline">\(\phi \approx 0\)</span>; 결맞은 파동 전파를 지지(“진공=강성 격자”).</td>
</tr>
<tr class="even">
<td style="text-align: center;">3</td>
<td style="text-align: center;"><span class="math inline">\(\approx 3\)</span></td>
<td style="text-align: left;">액체: 지속적 재배열/흐름</td>
<td style="text-align: left;"><strong>준-재밍/유동 레짐.</strong>
<span class="math inline">\(\chi_{\mathrm{ST}}\)</span>가 간헐적으로 실패하며, 반복적 국소 언재밍으로 <span class="math inline">\(\phi\)</span>가 0이 아님(구조적 실패율).</td>
</tr>
<tr class="odd">
<td style="text-align: center;">1</td>
<td style="text-align: center;"><span class="math inline">\(\lesssim 1\)</span></td>
<td style="text-align: left;">기체/혼돈 분산</td>
<td style="text-align: left;"><strong>언재밍/캐리어 방출 레짐.</strong>
연결성이 하중 지지 폐곡면을 유지하기에 부족하며, 자유 캐리어 또는 고엔트로피 여기로 거동.</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;"><span class="math inline">\(=2\)</span></td>
<td style="text-align: left;">(선형)</td>
<td style="text-align: left;"><strong>3차원 폐곡면에 대해 기하학적으로 불안정.</strong>
두 브리지는 부피를 둘러쌀 수 없어 State 1로 붕괴하거나 State 3/4로 재재밍되는 과도 상태(§L.3).</td>
</tr>
</tbody>
</table>
</div>
<h2 data-number="25.3" id="l.2-에너지를-언재밍-비용으로-보기-최소-계단staircase-모형"><span class="header-section-number">25.3</span> L.2 에너지를 “언재밍 비용”으로 보기 (최소 계단(staircase) 모형)</h2>
<p>하중 지지 브리지 1개당 유효 결합(재밍) 에너지를 <span class="math inline">\(\epsilon_{\mathrm{bond}}&gt;0\)</span>라 두면,
조잡화된 에너지 장부는
<span class="math display">\[E_{\mathrm{tot}} \;\equiv\; E_{\mathrm{kin}} \;-\; N_{\mathrm{bond}}\,\epsilon_{\mathrm{bond}},
\label{eq:AppL_energy_staircase}\]</span>
로 쓸 수 있다(퍼텐셜 우물은 <span class="math inline">\(-N_{\mathrm{bond}}\epsilon_{\mathrm{bond}}\)</span>로 표현).
이 언어에서 “에너지”는 언재밍 비용을 지불하는 <em>키(key)</em>처럼 작동한다:
<span class="math display">\[\Delta E_{4\rightarrow 1}
\;\approx\;
\bigl(N_{\mathrm{bond}}^{(4)} - N_{\mathrm{bond}}^{(1)}\bigr)\epsilon_{\mathrm{bond}}
\;+\; \Delta E_{\mathrm{kin}}.
\label{eq:AppL_unjam_cost}\]</span>
반대로 재재밍(냉각/이완) 시에는, 같은 양의 에너지가 연결성 회복에 대응하는 <em>재재밍 잠열(latent heat)</em>로 방출되어야 한다.</p>
<h2 data-number="25.4" id="l.3-state-2가-금지되는-이유-기하학적-폐곡면-실패"><span class="header-section-number">25.4</span> L.3 “State 2”가 금지되는 이유 (기하학적 폐곡면 실패)</h2>
<p>4-3-1 라벨의 장점은 기하학적 제약을 드러내는 데 있다:
두 브리지 구성은 선형(line-like)이며 3차원에서 닫힌 폐곡면을 제공할 수 없다.
본문에서 사용한 2D 단면 언어로도, 코어 점을 둘러싸려면 최소 세 개의 벡터(최소 3-섹터 닫힘)가 필요하다.
두 벡터는 공선(collinear)으로 남아 영역을 가둘 수 없고, 네 벡터는 중복이다.
따라서 <span class="math inline">\(N_{\mathrm{bond}}=2\)</span>는 안정 레짐이 아니라 과도(transient)로 본다.</p>
<h2 data-number="25.5" id="l.4-유동성-phi와의-관계-실패율-관점"><span class="header-section-number">25.5</span> L.4 유동성 <span class="math inline">\(\phi\)</span>와의 관계 (실패율 관점)</h2>
<p>§3.2.1에서 유동성은 창(window) 내 언재밍 사건의 <em>실패율</em>로 정의되었다.
4-3-1 사전은 연결성과 실패율을 다음과 같이 거칠게 대응시킨다:
<span class="math display">\[\text{State 4: }\phi\!\approx\!0,\quad
\text{State 3: }0\!&lt;\!\phi\!&lt;\!1,\quad
\text{State 1: }\phi\!\rightarrow\!1,\]</span>
단, <span class="math inline">\(\phi\)</span>는 프로토콜/창 의존이며, 항상 <span class="math inline">\(\phi(\mathcal{P};W;\chi_{\mathrm{ST}})\)</span>로 보고되어야 한다(본문 정의 참조).</p>
<h2 data-number="25.6" id="l.5-빛은-기체-유사를-모순-없이-말하기-매질-vs-여기"><span class="header-section-number">25.6</span> L.5 “빛은 기체-유사”를 모순 없이 말하기 (매질 vs 여기)</h2>
<p>“빛은 기체-유사”라는 문구는 <em>배경 레짐</em>과 <em>여기 통계</em>를 구분하면 정합될 수 있다.
VP 언어에서 배경 진공은 State 4(강성 재밍 격자)로서 결맞은 전파를 지지한다.
그 위에 얹힌 복사는 여전히 고엔트로피 여기 앙상블(광자 기체 유사 통계)로 다룰 수 있으며,
이는 강성-껍질 필터링으로부터 도출되는 Planck 형태(흑체 유도)에서 나타나는 바로 그 구조다.</p>
<h2 data-number="25.7" id="l.6-음향-캘리브레이션-모듈과의-연결"><span class="header-section-number">25.7</span> L.6 음향 캘리브레이션 모듈과의 연결</h2>
<p>Appendix K는 고전 캘리브레이션을 제공한다: “연속 파동 <span class="math inline">\(\rightarrow\)</span> 이산 스케일” 역문제 논리를 공기 음향에 적용하면 현실적인 평균자유행로 스케일이 복원된다.
목적은 방법론적이며, 진공 격자 스케일로의 적용 전에 이 파이프라인이 VP 고유가 아님을 보이는 데 있다.</p>
<h2 data-number="25.8" id="l.7-에너지-부피-교환-우주-대사를-gate-정의-가설로"><span class="header-section-number">25.8</span> L.7 에너지-부피 교환 (우주 “대사”를 Gate 정의 가설로)</h2>
<p>이산 부피 양자 <span class="math inline">\(V_{\mathrm{VP}}\)</span>의 방출을 언재밍 작업 비용으로 모델링하면,
차원적으로 일관된 형태는 유효 압력(에너지 밀도) 스케일이다:
<span class="math display">\[E_{\mathrm{unjam}} \;\equiv\; P_{\mathrm{jam}}\,V_{\mathrm{VP}},
\label{eq:AppL_energy_volume_pressure}\]</span>
여기서 <span class="math inline">\(P_{\mathrm{jam}}\)</span>은 재밍 압력 스케일이다.
이에 따라 <em>Gate로 정의되는</em> 가설을 표현할 수 있다:
선언된 프로토콜에서 입력 에너지 묶음이 문턱값(<span class="math inline">\(P_{\mathrm{jam}}V_{\mathrm{VP}}\)</span>)을 초과하면,
국소 언재밍이 발생하고 언재밍된 VP 양자가 방출된다는 것이다.
이 문장은 의도적으로 NON-LOCK 부록에 두며,
명시적 측정 또는 시뮬레이션 Gate가 만족되기 전까지는 해석적 진술로 취급한다.</p>
<section class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr/>
<ol>
<li id="fn1" role="doc-endnote"><p>S. K. Lamoreaux, “Demonstration of the Casimir Force in the 0.6 to 6 <span class="math inline">\(\mu\)</span>m Range,” <em>Phys. Rev. Lett.</em> 78, 5–8 (1997). DOI: <a href="https://doi.org/10.1103/PhysRevLett.78.5">10.1103/PhysRevLett.78.5</a>.<a class="footnote-back" href="#fnref1" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>U. Mohideen and A. Roy, “Precision Measurement of the Casimir Force from 0.1 to 0.9 <span class="math inline">\(\mu\)</span>m,” <em>Phys. Rev. Lett.</em> 81, 4549–4552 (1998). DOI: <a href="https://doi.org/10.1103/PhysRevLett.81.4549">10.1103/PhysRevLett.81.4549</a>.<a class="footnote-back" href="#fnref2" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>참조값(예: NIST/CODATA 2022): inverse fine-structure constant <span class="math inline">\(\alpha_{em}^{-1}=137.035\,999\,177(21)\)</span>.NIST 데이터베이스: <a href="https://physics.nist.gov/cgi-bin/cuu/Value?alphinv=">physics.nist.gov</a> (accessed 2025).CODATA 2022 종합 리뷰는 <em>Rev. Mod. Phys.</em> 97, 025002 (2025)로 출판되었으며 DOI: <a href="https://doi.org/10.1103/RevModPhys.97.025002">10.1103/RevModPhys.97.025002</a>.<a class="footnote-back" href="#fnref3" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>플랑크의 원 논문: M. Planck, “Ueber das Gesetz der Energieverteilung im Normalspectrum,” <em>Annalen der Physik</em> <strong>309</strong>(3), 553–563 (1901). DOI: <a href="https://doi.org/10.1002/andp.19013090310">10.1002/andp.19013090310</a>.<a class="footnote-back" href="#fnref4" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>예: Tolman 표면밝기 테스트 및 tired-light 제한 논의는 L. M. Lubin &amp; A. Sandage (2001), <em>AJ</em> 122, 1084–1103, DOI: <a href="https://doi.org/10.1086/322134">10.1086/322134</a>; arXiv: <a href="https://arxiv.org/abs/astro-ph/0106566">astro-ph/0106566</a>. 시간 신장(Time dilation) 논의는 G. Goldhaber et al. (2001), <em>ApJ</em> 558, 359–368, DOI: <a href="https://doi.org/10.1086/322460">10.1086/322460</a>; arXiv: <a href="https://arxiv.org/abs/astro-ph/0104382">astro-ph/0104382</a>.<a class="footnote-back" href="#fnref5" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>본 DOI 번들은 <code>data/chem/traceability_spec_v3.txt</code>에 <span class="math inline">\(\beta_{vac}=1.088\)</span>, <span class="math inline">\(\beta_{bond}=1.000\)</span>을 명시한다.<a class="footnote-back" href="#fnref6" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p><span class="math inline">\(P_{avg}\)</span>를 포함한 완전형(<span class="math inline">\(P_{idx}=P_{avg}\Phi_{geo}(1-\Delta_{ov})\)</span>)은 동일 DOI 내 부록 노트(<code>docs/chem/DEFINITIVE_V3_CONSISTENCY.md</code>)에 정리되어 있다.<a class="footnote-back" href="#fnref7" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
  </main>
</div>
<footer>
  <div>DOI: <a href="https://doi.org/10.5281/zenodo.17932567">10.5281/zenodo.17932567</a> · ORCID: <a href="https://orcid.org/0009-0002-7535-8245">0009-0002-7535-8245</a></div>
  <div>Last updated: 2025-12-15 · HTML build: 2025-12-23</div>
</footer>
<script src="/assets/site.js"></script>
</body>
</html>