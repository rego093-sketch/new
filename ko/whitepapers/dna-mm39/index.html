<!DOCTYPE html>
<html lang="ko">
<head> <meta charset="utf-8"/> <meta name="viewport" content="width=device-width, initial-scale=1"/> <title>결정론적 DNA 해석 백서 (Mouse/mm39)<br />
재현 가능한 LOCK<span
class="math inline">\(\rightarrow\)</span>Derive<span
class="math inline">\(\rightarrow\)</span>Gate 계약, KEY<span
class="math inline">\(\rightarrow\)</span>A4, PCTS<span
class="math inline">\(\rightarrow\)</span>J_LEDGER | Jamming Physics</title> <meta name="description" content="결정론적 DNA 해석 파이프라인
(Mouse/mm39) — LOCK–Derive–Gate 계약."/> <link rel="canonical" href="https://jamming-physics.org/ko/whitepapers/dna-mm39/"/> <link rel="alternate" hreflang="en" href="https://jamming-physics.org/en/whitepapers/dna-mm39/"/><link rel="alternate" hreflang="ko" href="https://jamming-physics.org/ko/whitepapers/dna-mm39/"/> <meta property="og:type" content="article"/> <meta property="og:title" content="결정론적 DNA 해석 백서
(Mouse/mm39)<br />
재현 가능한 LOCK<span
class="math inline">\(\rightarrow\)</span>Derive<span
class="math inline">\(\rightarrow\)</span>Gate 계약, KEY<span
class="math inline">\(\rightarrow\)</span>A4, PCTS<span
class="math inline">\(\rightarrow\)</span>J_LEDGER"/> <meta property="og:description" content="결정론적 DNA 해석 파이프라인
(Mouse/mm39) — LOCK–Derive–Gate 계약."/> <meta property="og:url" content="https://jamming-physics.org/ko/whitepapers/dna-mm39/"/> <meta property="og:image" content="/assets/og.png"/> <meta name="twitter:card" content="summary_large_image"/> <link rel="stylesheet" href="/assets/style.css"/> <link rel="stylesheet" href="/assets/whitepapers.css"/> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script> </head>
<body>
<a class="skip-link" href="#main">Skip to content</a> <nav class="navbar"> <a href="/" class="nav-logo">JAMMING PHYSICS</a> <div class="nav-links"> <a href="/ko/whitepapers/">Whitepapers</a> <label class="paper-select-label" for="paperSelect">Select</label> <select id="paperSelect" class="paper-select" aria-label="Select whitepaper"></select> </div> <div class="nav-right"> <div class="lang-switch"><a href="/ko/whitepapers/dna-mm39/">한국어</a></div> <div class="lang-switch"><a href="/en/whitepapers/dna-mm39/">English</a></div> </div>
</nav> <main id="main" class="wp-main"> <header class="wp-hero"> <div class="wp-breadcrumb"> <a href="/ko/">Home</a> <span>›</span> <a href="/ko/whitepapers/">Whitepapers</a> <span>›</span> <span>결정론적 DNA 해석 백서 (Mouse/mm39)<br />
재현 가능한 LOCK<span
class="math inline">\(\rightarrow\)</span>Derive<span
class="math inline">\(\rightarrow\)</span>Gate 계약, KEY<span
class="math inline">\(\rightarrow\)</span>A4, PCTS<span
class="math inline">\(\rightarrow\)</span>J_LEDGER</span> </div> <div class="wp-meta"> <span class="badge">DOI: <a href="https://doi.org/10.5281/zenodo.17963127">10.5281/zenodo.17963127</a></span> <span class="badge">Version: v1.2-KO (v1.6)</span> <span class="badge">Published: 2025-12-17</span> </div> </header> <div class="wp-grid"> <aside class="wp-toc" aria-label="Table of contents"> <div class="wp-toc-head"> <div>Contents</div> <button class="wp-toc-toggle" type="button" onclick="document.body.classList.toggle('toc-open')">TOC</button> </div> <ul> <li><a href="#서문front-matter">서문(Front matter)</a> <ul> <li><a href="#목적과-주장-경계">목적과 주장 경계</a></li> <li><a href="#범위-포함되는-것과-포함되지-않는-것">범위: 포함되는 것과 포함되지 않는 것</a></li> <li><a href="#문서-규약과-용어">문서 규약과 용어</a></li> <li><a href="#재현성-계약lockderivegate">재현성 계약(LOCK–Derive–Gate)</a></li> <li><a href="#인용-방법">인용 방법</a></li> <li><a href="#evidence-lock-본-백서를-위한-고정-증거">Evidence lock (본 백서를 위한 고정 증거)</a></li> </ul></li> <li><a href="#요약executive-summary">요약(Executive summary)</a> <ul> <li><a href="#한-페이지-파이프라인-개요">한 페이지 파이프라인 개요</a></li> <li><a href="#핵심-주장-공학적-계약으로-재진술">핵심 주장: 공학적 계약으로 재진술</a></li> <li><a href="#핵심-설계-결정">핵심 설계 결정</a></li> <li><a href="#스케일-증거-mm39-autoscan과-대표-패널">스케일 증거: mm39 autoscan과 대표 패널</a></li> <li><a href="#재현성-진술최소">재현성 진술(최소)</a></li> <li><a href="#읽기-가이드">읽기 가이드</a></li> </ul></li> <li><a href="#핵심-정의core-definitions">핵심 정의(Core definitions)</a> <ul> <li><a href="#입력-구간input-region">입력 구간(Input region)</a></li> <li><a href="#a4-배치a4-arrangement">A4 배치(A4 arrangement)</a></li> <li><a href="#고정-활동-문법4개-연산">고정 활동 문법(4개 연산)</a></li> <li><a href="#j_ledger-및-게이트"><strong>J_LEDGER</strong> 및 게이트</a></li> <li><a href="#해석-가능의-운영적-의미">“100% 해석 가능”의 운영적 의미</a></li> <li><a href="#왜-archetype-패널이-중요한가">왜 archetype 패널이 중요한가</a></li> </ul></li> <li><a href="#데이터-계약data-contract-lockderivegate-패키징">데이터 계약(Data contract: LOCK–Derive–Gate 패키징)</a> <ul> <li><a href="#철학과-의도된-사용">철학과 의도된 사용</a></li> <li><a href="#run_id-안정적-식별자"><code>run_id</code>: 안정적 식별자</a></li> <li><a href="#data_lock-무엇이-잠기는가"><code>DATA_LOCK</code>: 무엇이 잠기는가</a></li> <li><a href="#manifest-무엇이-잠기는가"><code>MANIFEST</code>: 무엇이 잠기는가</a></li> <li><a href="#index-무엇이-색인되는가"><code>INDEX</code>: 무엇이 색인되는가</a></li> <li><a href="#게이트-판정과-검증-로직">게이트 판정과 검증 로직</a></li> <li><a href="#계약이-함의하는-불변량invariants-implied-by-the-contract">계약이 함의하는 불변량(Invariants implied by the contract)</a></li> <li><a href="#실패-모드failure-modes-and-rejection-criteria">실패 모드(Failure modes and rejection criteria)</a></li> </ul></li> <li><a href="#key-서열주석에서-a4-배치로">KEY: 서열(+주석)에서 A4 배치로</a> <ul> <li><a href="#창window-관측량과-강성stiffness-프록시">창(window) 관측량과 강성(stiffness) 프록시</a></li> <li><a href="#강건-정규화robust-z-score와-평활화">강건 정규화(robust z-score)와 평활화</a></li> <li><a href="#삼분위-라벨terciles과-shell-분할">삼분위 라벨(terciles)과 shell 분할</a></li> <li><a href="#앵커anchors">앵커(anchors)</a></li> <li><a href="#주석으로부터-모터motor-추출">주석으로부터 모터(motor) 추출</a></li> <li><a href="#루프loops-생성">루프(loops) 생성</a></li> <li><a href="#key-버전">KEY 버전</a> <ul> <li><a href="#key_v0_3_1-단일-스케일">KEY_v0_3_1 (단일 스케일)</a></li> <li><a href="#key_v0_4-멀티스케일">KEY_v0_4 (멀티스케일)</a></li> </ul></li> <li><a href="#산출물outputs">산출물(Outputs)</a></li> <li><a href="#실패-모드-및-진단-신호">실패 모드 및 진단 신호</a></li> </ul></li> <li><a href="#sec:pcts">PCTS: 최소 원장 생성기(PCTS_v0_2)</a> <ul> <li><a href="#상태-변수와-산출물outputs">상태 변수와 산출물(Outputs)</a></li> <li><a href="#잔류-응력-프록시residual-stress와-역할">잔류 응력 프록시(residual stress)와 역할</a></li> <li><a href="#고정-4-활동-진행-규칙fixed-4-activity-progression">고정 4-활동 진행 규칙(Fixed 4-activity progression)</a></li> <li><a href="#사건-규칙-루프-안정화loop-stabilization">사건 규칙: 루프 안정화(loop stabilization)</a></li> <li><a href="#적격성-게이트admissibility-gates">적격성 게이트(Admissibility gates)</a></li> <li><a href="#재현성-요구사항reproducibility-requirements">재현성 요구사항(Reproducibility requirements)</a></li> <li><a href="#pi_t-프록시와-활동-카운트의-해석"><span class="math inline">\(\Pi_T\)</span> 프록시와 활동 카운트의 해석</a></li> <li><a href="#실패-모드-pcts-layer">실패 모드( PCTS layer )</a></li> <li><a href="#요약">요약</a></li> </ul></li> <li><a href="#sec:mm39_prov">마우스/mm39 참조 데이터 출처(Provenance)</a> <ul> <li><a href="#어셈블리-정체성과-좌표계">어셈블리 정체성과 좌표계</a></li> <li><a href="#게놈-서열과-주석의-1차-출처">게놈 서열과 주석의 1차 출처</a></li> <li><a href="#provenance-검증-무엇을-해시하고-왜-하는가">Provenance 검증: 무엇을 해시하고 왜 하는가</a></li> <li><a href="#본-백서에서-사용하는-실무-규약">본 백서에서 사용하는 실무 규약</a></li> <li><a href="#실패-모드및-탐지-방법">실패 모드(및 탐지 방법)</a></li> </ul></li> <li><a href="#sec:autoscan_panel">mm39 autoscan에서 대표 구간 패널로</a> <ul> <li><a href="#윈도잉-스킴과-후보-집합">윈도잉 스킴과 후보 집합</a></li> <li><a href="#autoscan-관측량4개-구조-축">Autoscan 관측량(4개 구조 축)</a></li> <li><a href="#binning-축별-삼분위lmh">Binning: 축별 삼분위(L/M/H)</a></li> <li><a href="#archetype-정의4축-bin">Archetype 정의(4축 bin)</a></li> <li><a href="#선택-알고리즘coverage-우선-균일성-보조">선택 알고리즘(coverage 우선, 균일성 보조)</a></li> <li><a href="#구간-추출-및-step18-job-구성">구간 추출 및 STEP18 job 구성</a></li> <li><a href="#실패-모드autoscan선택추출">실패 모드(autoscan/선택/추출)</a></li> </ul></li> <li><a href="#sec:results_archetype">결과: archetype 커버리지(표 1; 그림 1)</a> <ul> <li><a href="#bin-컷오프와-주변-균형표-1">Bin 컷오프와 주변 균형(표 1)</a></li> <li><a href="#archetype-커버리지coverage-계산">Archetype 커버리지(coverage) 계산</a></li> <li><a href="#균일성-지표와-해석상의-주의">균일성 지표와 해석상의 주의</a></li> <li><a href="#archetype-점유도-격자그림-1">Archetype 점유도 격자(그림 1)</a></li> <li><a href="#evidence-lock-관점에서의-검증-포인트">Evidence lock 관점에서의 검증 포인트</a></li> <li><a href="#실패-모드커버리지-증거">실패 모드(커버리지 증거)</a></li> </ul></li> <li><a href="#sec:interpretation">해석: 강성-껍질(stiffness-shell) 구조의 창발</a> <ul> <li><a href="#서열-통계에서-shellanchor로-결정론적-coarse-graining">서열 통계에서 shell/anchor로: 결정론적 coarse-graining</a></li> <li><a href="#모터와-루프-제약된-결합constrained-couplings">모터와 루프: 제약된 결합(constrained couplings)</a></li> <li><a href="#jevent-비가역-안정화ledger-semantics">JEVENT: 비가역 안정화(ledger semantics)</a></li> <li><a href="#여기서-창발이-의미하는-것">여기서 “창발”이 의미하는 것</a></li> <li><a href="#스케일-거동과-멀티스케일-key">스케일 거동과 멀티스케일 KEY</a></li> <li><a href="#대표-패널이-일반화에-도움이-되는-이유">대표 패널이 일반화에 도움이 되는 이유</a></li> <li><a href="#해석의-한계진실성-제약">해석의 한계(진실성 제약)</a></li> </ul></li> <li><a href="#sec:validation">검증(Validation)과 실패 모드</a> <ul> <li><a href="#검증-레벨validation-levels">검증 레벨(Validation levels)</a></li> <li><a href="#번들-레벨-검증bundle-level-validation">번들 레벨 검증(Bundle-level validation)</a></li> <li><a href="#게이트-분류권장-최소-세트">게이트 분류(권장 최소 세트)</a></li> <li><a href="#fail과-inconclusive의-해석">FAIL과 INCONCLUSIVE의 해석</a></li> <li><a href="#레이어별-실패-모드">레이어별 실패 모드</a></li> <li><a href="#파라미터-민감도와-허용되는-행위">파라미터 민감도와 “허용되는” 행위</a></li> <li><a href="#한계와-비목표진실성-제약">한계와 비목표(진실성 제약)</a></li> </ul></li> <li><a href="#sec:roadmap">로드맵(Roadmap)</a> <ul> <li><a href="#즉시-과제-원고증거-완결">즉시 과제: 원고/증거 완결</a></li> <li><a href="#증거-확장마우스-mm39-내부">증거 확장(마우스 mm39 내부)</a></li> <li><a href="#타-종organism-확장">타 종(organism) 확장</a></li> <li><a href="#조직맥락-패널활동-문법-유지">조직/맥락 패널(활동 문법 유지)</a></li> <li><a href="#버저닝-전략">버저닝 전략</a></li> <li><a href="#장기-연구-방향비구속-non-binding">장기 연구 방향(비구속, non-binding)</a></li> <li><a href="#릴리스-플랜">릴리스 플랜</a></li> </ul></li> <li><a href="#sec:formats">파일 포맷과 스키마(File formats and schemas)</a> <ul> <li><a href="#a5-priors-yaml-a5_priors_dna_v0_1.yaml">A5 priors YAML (<code>A5_priors_dna_v0_1.yaml</code>)</a></li> <li><a href="#a4-레이아웃-yaml-a4_layout_dna_v0_1.yaml">A4 레이아웃 YAML (<code>A4_layout_dna_v0_1.yaml</code>)</a></li> <li><a href="#tsv-산출물key-단계">TSV 산출물(KEY 단계)</a></li> <li><a href="#pcts-산출물j_ledger-및-gate-table">PCTS 산출물(<strong>J_LEDGER</strong> 및 gate table)</a></li> </ul></li> <li><a href="#sec:cookbook">재현성 cookbook(정확한 명령)</a> <ul> <li><a href="#b.0-최종적으로-얻어야-하는-것">B.0 최종적으로 얻어야 하는 것</a></li> <li><a href="#b.1-환경-설정environment-setup">B.1 환경 설정(Environment setup)</a></li> <li><a href="#b.2-mm39-입력-다운로드서열-주석">B.2 mm39 입력 다운로드(서열 + 주석)</a></li> <li><a href="#b.2.1-원커맨드-end-to-end-실행권장">B.2.1 원커맨드 end-to-end 실행(권장)</a></li> <li><a href="#b.2.2-end-to-end-스크립트가-만드는-표준-work_dir-트리">B.2.2 end-to-end 스크립트가 만드는 표준 WORK_DIR 트리</a></li> <li><a href="#b.3-autoscan-후보-창-메트릭-계산">B.3 Autoscan: 후보 창 메트릭 계산</a></li> <li><a href="#b.4-삼분위-컷오프-계산-및-4축-archetype-할당">B.4 삼분위 컷오프 계산 및 4축 archetype 할당</a></li> <li><a href="#b.5-대표-패널-선택n30100">B.5 대표 패널 선택(N=30–100)</a></li> <li><a href="#b.6-원시-구간raw-regions-추출region.fa-region.gtf-및-raw.zip-패킹">B.6 원시 구간(raw regions) 추출(region.fa + region.gtf) 및 raw.zip 패킹</a></li> <li><a href="#b.7-패널에-대해-step18-실행key-pcts">B.7 패널에 대해 STEP18 실행(KEY + PCTS)</a></li> <li><a href="#b.8-run-검증-및-validated-bundle-패킹">B.8 run 검증 및 validated bundle 패킹</a></li> <li><a href="#b.9-표-1-재생성csv-및-latex">B.9 표 1 재생성(CSV 및 LaTeX)</a></li> <li><a href="#b.10-그림-관리-정책이-tex-프로젝트는-이미지를-포함하지-않음">B.10 그림 관리 정책(이 TeX 프로젝트는 이미지를 포함하지 않음)</a></li> <li><a href="#b.11-doi-감사doi-audit">B.11 DOI 감사(DOI audit)</a></li> <li><a href="#b.12-최소-수용-체크리스트minimal-acceptance-checklist">B.12 최소 수용 체크리스트(Minimal acceptance checklist)</a></li> </ul></li> </ul> </aside> <article class="wp-article"> <div class="filecontents*"> <p><span>references.bib</span> @misc<span>zenodo17932567, author = <span>rego093</span>, title = <span>Volume Particle Theory (VP) Whitepaper v2.0: A LOCK→Derive→Gate Framework</span>, year = <span>2025</span>, doi = <span>10.5281/zenodo.17932567</span>, publisher = <span>Zenodo</span>, </span></p> <p>@article<span>ucsc2025, author = <span>Lee, C. M. and others</span>, title = <span>The <span>UCSC</span> Genome Browser database: 2025 update</span>, journal = <span>Nucleic Acids Research</span>, year = <span>2025</span>, doi = <span>10.1093/nar/gkae974</span>, </span></p> <p>@article<span>ucsc2003, author = <span>Kent, W. J. and others</span>, title = <span>The <span>UCSC</span> Genome Browser Database</span>, journal = <span>Nucleic Acids Research</span>, year = <span>2003</span>, doi = <span>10.1093/nar/gkg129</span>, </span></p> <p>@article<span>refseq2016, author = <span>O’Leary, N. A. and others</span>, title = <span>Reference sequence (<span>RefSeq</span>) database at <span>NCBI</span>: current status, taxonomic expansion, and functional annotation</span>, journal = <span>Nucleic Acids Research</span>, year = <span>2016</span>, doi = <span>10.1093/nar/gkv1189</span>, </span></p> <p>@article<span>assembly2016, author = <span>Kitts, P. A. and others</span>, title = <span>Assembly: a resource for assembled genomes at <span>NCBI</span></span>, journal = <span>Nucleic Acids Research</span>, year = <span>2016</span>, doi = <span>10.1093/nar/gkv1226</span>, </span></p> <p>@article<span>genbank2016, author = <span>Benson, D. A. and others</span>, title = <span>GenBank</span>, journal = <span>Nucleic Acids Research</span>, year = <span>2016</span>, doi = <span>10.1093/nar/gkv1276</span>, </span></p> <p>@article<span>cpg1987, author = <span>Gardiner-Garden, M. and Frommer, M.</span>, title = <span><span>CpG</span> islands in vertebrate genomes</span>, journal = <span>Journal of Molecular Biology</span>, year = <span>1987</span>, doi = <span>10.1016/0022-2836(87)90689-9</span>, </span></p> <p>@incollection<span>repeatmasker2009, author = <span>Smit, A. F. A. and Hubley, R. and Green, P.</span>, title = <span>Using <span>RepeatMasker</span> to identify repetitive elements in genomic sequences</span>, booktitle = <span>Current Protocols in Bioinformatics</span>, year = <span>2009</span>, doi = <span>10.1002/0471250953.bi0410s25</span>, </span></p> <p>@article<span>gencode2023, author = <span>Frankish, A. and others</span>, title = <span><span>GENCODE</span>: reference annotation for the human and mouse genomes in 2023</span>, journal = <span>Nucleic Acids Research</span>, year = <span>2023</span>, doi = <span>10.1093/nar/gkac1071</span>, </span></p> </div> <p><strong>키워드:</strong> DNA 해석, 재현성(reproducibility), 감사 추적(audit trail), mouse mm39, GRCm39, GC fraction, CpG density, repeat proxy, A4 arrangement, <strong>J_LEDGER</strong>, <code>DATA_LOCK</code>, <code>MANIFEST</code>, Zenodo DOI.</p> <h1 id="서문front-matter">서문(Front matter)</h1> <h2 id="목적과-주장-경계">목적과 주장 경계</h2> <p>본 백서는 다음과 같은 <strong>정확하고, 테스트 가능하며, 재현 가능한 주장</strong>을 지원하기 위해 작성되었다.</p> <div class="claim"> <p><strong>주장 1</strong> (운영적 “DNA 100% 해석” 주장). <em>LOCK–Derive–Gate DNA Interpreter 계약(LOCK<span class="math inline">\(\rightarrow\)</span>Derive<span class="math inline">\(\rightarrow\)</span>Gate) 하에서, DNA는 다음의 운영적 의미에서 100% 해석 가능하다: 임의의 관심 유전체 구간(서열 + 최소 주석)에 대해 파이프라인은 결정론적으로 (i) A4 배치(강성 껍질, 앵커, 모터, 루프)와 (ii) 고정된 4-활동 문법 (INIT / SCONSERV / SDISSIP / JEVENT)으로 생성되고 게이트로 검증된 비가역 사건 원장(<strong>J_LEDGER</strong>)을 산출한다.</em></p> </div> <p>이 주장은 의도적으로 <strong>생물학적 기능을 완전히 푸는 주장</strong>이 아니다. 여기서의 “해석”은 입력으로부터 A4 및 <em>산출 객체(output objects)</em>를 버전 고정된 규칙으로 생성하는 것을 의미한다. 어떤 입력이든 (a) 산출 객체가 생성되거나, 또는 (b) 실패가 <strong>명시적으로 라벨링되고(FAIL/INCONCLUSIVE)</strong> 그 사유가 감사 가능한 형태로 기록되어야 한다.</p> <h2 id="범위-포함되는-것과-포함되지-않는-것">범위: 포함되는 것과 포함되지 않는 것</h2> <h4 id="포함됨.">포함됨.</h4> <ul> <li><p><em>1D 서열(+주석)</em> <span class="math inline">\(\rightarrow\)</span> A4 프리미티브로의 결정론적 매핑(KEY).</p></li> <li><p>A4<span class="math inline">\(\rightarrow\)</span> 비가역 결정론적(시드 제어) 매핑(PCTS) 및 적격성 게이트.</p></li> <li><p>마우스 mm39 전장(whole-genome) autoscan과 대표 구간 패널(<span class="math inline">\(N\approx 30\)</span>–100) 선택: 네 구조 축(유전자 밀도, 반복서열 proxy, GC 비율, CpG 밀도)을 균형화하고, 그 커버리지를 표 <a href="#tab:archetype_bins" data-reference-type="ref" data-reference="tab:archetype_bins">3</a>, 그림 <a href="#fig:archetype_grid" data-reference-type="ref" data-reference="fig:archetype_grid">[fig:archetype_grid]</a>로 요약.</p></li> <li><p>재현성 산출물: <code>DATA_LOCK</code>, <code>MANIFEST</code> (sha256), <code>INDEX</code>, 검증/DOI 감사 스크립트.</p></li> </ul> <h4 id="포함되지-않음.">포함되지 않음.</h4> <ul> <li><p>본 모델이 생물학적 표현형 또는 모든 조절 메커니즘을 예측한다는 주장.</p></li> <li><p>사용된 강성(stiffness) 프록시가 생체(in vivo)에서의 DNA 물리량을 “보편적으로” 정확히 대변한다는 주장.</p></li> <li><p>고해상 3D 접힘(folding) 시뮬레이션 또는 원자/염기 수준의 완전 물리 모델.</p></li> <li><p>실험적 기능 검증 없이 “이 구간의 의미가 무엇이다”와 같은 절대적 의미 해석.</p></li> </ul> <h2 id="문서-규약과-용어">문서 규약과 용어</h2> <h4 id="interpretation-vs.-meaning.">Interpretation vs. meaning.</h4> <p>본 문서에서 “interpretation(해석)”은 입력으로부터 A4 및 <strong>J_LEDGER</strong> 객체를 버전 고정된 규칙으로 생성하는 것을 뜻한다. 이는 DNA의 “진정한 의미”를 절대적 생물학적 관점에서 복원한다는 뜻이 아니다.</p> <h4 id="lock-vs.-state.">LOCK vs. STATE.</h4> <p>우리는 <strong>LOCK</strong>(고정 가정/규칙)과 <strong>STATE</strong>(런타임에서 변할 수 있는 값)를 분리한다. LOCK의 변경은 새로운 버전으로 취급되며, 검증된(run validated) 실행에서 LOCK에 대한 사후 튜닝(post-hoc tuning)은 금지된다 <span class="citation" data-cites="zenodo17932567"></span>.</p> <h4 id="결정론determinism.">결정론(Determinism).</h4> <p>특별히 언급되지 않는 한, 절차는 다음의 함수로 결정된다.</p> <ol> <li><p>입력 구간 서열(FASTA),</p></li> <li><p>MOTOR 추출에 사용되는 주석 부분집합(GTF),</p></li> <li><p>파라미터 딕셔너리(KEY/PCTS 버전 포함),</p></li> <li><p>랜덤 시드(오직 명시적으로 사용하는 경우에만).</p></li> </ol> <h4 id="검증-상태validated.">검증 상태(Validated).</h4> <p>본 문서에서 한 실행(run)이 <em>validated</em>로 간주되려면:</p> <ol> <li><p>입력이 sha256 해시로 기록되어야 하며(<code>DATA_LOCK</code>),</p></li> <li><p>산출물이 sha256 해시로 기록되어야 하고(<code>MANIFEST</code>),</p></li> <li><p>게이트가 PASS를 반환하거나, FAIL/INCONCLUSIVE인 경우 명시적 이유가 제공되어야 하며,</p></li> <li><p>DOI 레지스트리에 누락된 DOI 엔트리가 없어야 한다(DOI audit PASS).</p></li> </ol> <h2 id="재현성-계약lockderivegate">재현성 계약(LOCK–Derive–Gate)</h2> <p>우리는 세 층으로 구성된 엄격한 재현성 계약을 채택한다 <span class="citation" data-cites="zenodo17932567"></span>:</p> <dl> <dt>LOCK</dt> <dd> <p>버전 고정된 priors, 스키마, 알고리즘(예: 4-활동 문법; A5 priors; KEY와 PCTS 버전).</p> </dd> <dt>Derive</dt> <dd> <p>모든 산출 파일은 LOCK + 입력으로부터 <strong>숨은 수작업 단계 없이</strong> 도출된다.</p> </dd> <dt>Gate</dt> <dd> <p>모든 실행은 적격성(admissibility)과 감사 완전성을 검사하는 fail-fast 게이트를 산출한다 (예: JEVENT의 <span class="math inline">\(\Delta E&lt;0\)</span>).</p> </dd> </dl> <h2 id="인용-방법">인용 방법</h2> <p><strong>Zenodo DOI (본 백서 + 재현성 번들):</strong></p> <p>외부 리소스는 DOI가 포함된 참고문헌으로 인용한다. 내부 산출물(derived artifacts)은 <code>run_id</code> 및 <code>DATA_LOCK</code>/<code>MANIFEST</code>에 기록된 sha256 해시로 인용한다. 결과를 배포할 때에는, 제3자가 검증할 수 있도록 validated bundle과 스크립트를 함께 제공해야 한다 <span class="citation" data-cites="zenodo17932567"></span>.</p> <h2 id="evidence-lock-본-백서를-위한-고정-증거">Evidence lock (본 백서를 위한 고정 증거)</h2> <p><strong>Zenodo 업로드(권장):</strong> 본 백서 PDF와 함께, 본문에서 고정된 증거 번들을 포함하는 래퍼(zip) 번들을 함께 업로드한다. 본 문서에서 사용하는 증거 번들/키 파일의 sha256 해시는 <strong>LOCK</strong>이며, 해시가 바뀌는 어떤 변경(입력, 선택, 생성 요약)은 <strong>새 evidence 버전과 새 백서 리비전</strong>을 요구한다.</p> <p>표 <a href="#tab:archetype_bins" data-reference-type="ref" data-reference="tab:archetype_bins">3</a> 및 그림 <a href="#fig:archetype_grid" data-reference-type="ref" data-reference="fig:archetype_grid">[fig:archetype_grid]</a>를 뒷받침하는 증거를 불변(immutable)·감사 가능하게 만들기 위해, 우리는 정확한 evidence bundle과 내부 key file의 sha256을 아래와 같이 고정한다.</p> <pre><code>EVIDENCE_LOCK_v0_1 (1) mm39 archetype coverage bundle (Table 1 + Fig 1 sources) mm39_archetype_coverage_TABLE1_FIG1_bundle_v0_1.zip sha256: d9adeb446efe6ae2e1e21ef0202ea0ed92d042f5bcaaae573f67a879f15270a8 key files inside the bundle: TABLE1_mm39_archetype_coverage_v0_1.csv sha256: c61ec72d129a899f9787e5cead3047e54004d223c3ae9bd02186c5ecc4239d77 mm39_selected_regions_archetypeN80_v0_1.csv sha256: 9519b2a13164194b50043135ce021d7054c93b90c249caa7462b2ecca2c021a3 mm39_archetype_coverage_matrix9x9_v0_1.csv sha256: 4881c61704f018d866e786036c383c708d20c224fd8b2a185d7c1540ff202abf RUN_METADATA_mm39_archetype_coverage_v0_1.json sha256: 309c920feb61c277ee62e67c47ec0744328a873a950f30b5950754f14ead01f7 MANIFEST_mm39_archetype_coverage_v0_1.json sha256: fe7adc4fb201d31cb243c6f1e765c2248d230e59eaf1989a66be2a7475cf7f99 mm39_inputs_sha256_v0_1.txt sha256: f8ea0caa5a009da6df7b3a77585f528999f56efedced5be6b48835db5b42dce5 (2) End-to-end autoscan+STEP18 bundlekit (scripts and LOCK files) mouse_mm39_autoscan_END2END_bundlekit_v1_0.zip sha256: e2e2803daa972e276b9710db39f450055ad9fdfd44e0cfab974c3a592b826ac2 key files inside the bundlekit: MANIFEST.json sha256: 024bf5ed17fb984fa17ca9bef586c0b72883488352ba3d142422457126604e50 CITATION_REGISTRY.yaml sha256: 69ca4f35e13be7c7a24bdf04d7244d1798d38ac35835a2d5d399b17a8abf8db7 STANDARD/A5_priors_dna_v0_1.yaml sha256: 0fc1b857956b2aa5c277fb919ac56c935fc524707853e83210ab2637477f8f8d STANDARD/J_LEDGER_schema_dna_v0_1.yaml sha256: 1cc118ce979eecdb7b24bd93efbf2efc572941ab1057e6ae0f77f5a9f4a4b769</code></pre> <div id="tab:evidence_lock_bundles"> <table style="width:93%;"> <caption>Evidence lock summary (primary bundles).</caption> <colgroup> <col style="width: 55%" /> <col style="width: 38%" /> </colgroup> <thead> <tr class="header"> <th style="text-align: left;">Artifact (file)</th> <th style="text-align: left;">sha256 (grouped)</th> </tr> </thead> <tbody> <tr class="odd"> <td style="text-align: left;"></td> <td style="text-align: left;"><code>d9adeb44 6efe6ae2 e1e21ef0 202ea0ed 92d042f5 bcaaae57 3f67a879 f15270a8</code></td> </tr> <tr class="even"> <td style="text-align: left;"></td> <td style="text-align: left;"><code>e2e2803d aa972e27 6b9710db 39f45005 5ad9fdfd 44e0cfab 974c3a59 2b826ac2</code></td> </tr> </tbody> </table> </div> <div id="tab:evidence_lock_keyfiles"> <table style="width:94%;"> <caption>Evidence lock: key files (sha256).</caption> <colgroup> <col style="width: 62%" /> <col style="width: 32%" /> </colgroup> <thead> <tr class="header"> <th style="text-align: left;">Path (inside bundle)</th> <th style="text-align: left;">sha256 (grouped)</th> </tr> </thead> <tbody> <tr class="odd"> <td style="text-align: left;">Path (inside bundle)</td> <td style="text-align: left;">sha256 (grouped)</td> </tr> <tr class="even"> <td colspan="2" style="text-align: right;">(continued)</td> </tr> <tr class="odd"> <td style="text-align: left;"></td> <td style="text-align: left;"><code>c61ec72d 129a899f 9787e5ce ad3047e5 4004d223 c3ae9bd0 2186c5ec c4239d77</code></td> </tr> <tr class="even"> <td style="text-align: left;"></td> <td style="text-align: left;"><code>9519b2a1 3164194b 50043135 ce021d70 54c93b90 c249caa7 462b2ecc a2c021a3</code></td> </tr> <tr class="odd"> <td style="text-align: left;"></td> <td style="text-align: left;"><code>4881c617 04f018d8 66e78603 6c383c70 8d20c224 fd8b2a18 5d7c1540 ff202abf</code></td> </tr> <tr class="even"> <td style="text-align: left;"></td> <td style="text-align: left;"><code>309c920f eb61c277 ee62e67c 47ec0744 328a873a 950f30b5 950754f1 4ead01f7</code></td> </tr> <tr class="odd"> <td style="text-align: left;"></td> <td style="text-align: left;"><code>fe7adc4f b201d31c b243c6f1 e765c224 8d230e59 eaf1989a 66be2a74 75cf7f99</code></td> </tr> <tr class="even"> <td style="text-align: left;"></td> <td style="text-align: left;"><code>f8ea0caa 5a009da6 df7b3a77 585f5289 99f56efe dced5be6 b48835db 5b42dce5</code></td> </tr> <tr class="odd"> <td style="text-align: left;"><code>MANIFEST.json (bundlekit)</code></td> <td style="text-align: left;"><code>024bf5ed 17fb984f a17ca9be f586c0b7 28834883 52ba3d14 24224571 26604e50</code></td> </tr> <tr class="even"> <td style="text-align: left;"><code>CITATION_REGISTRY.yaml (bundlekit)</code></td> <td style="text-align: left;"><code>69ca4f35 e13be7c7 a24bdf04 d7244d17 98d38ac3 5835a2d5 d399b17a 8abf8db7</code></td> </tr> <tr class="odd"> <td style="text-align: left;"></td> <td style="text-align: left;"><code>0fc1b857 956b2aa5 c277fb91 9ac56c93 5fc52470 7853e832 10ab2637 477f8f8d</code></td> </tr> <tr class="even"> <td style="text-align: left;"></td> <td style="text-align: left;"><code>1cc118ce 979eecdb 7b24bd93 efbf2efc 572941ab 1057e6ae 0f77f5a9 f4a4b769</code></td> </tr> <tr class="odd"> <td style="text-align: left;"></td> <td style="text-align: left;"></td> </tr> </tbody> </table> </div> <h1 id="요약executive-summary">요약(Executive summary)</h1> <h2 id="한-페이지-파이프라인-개요">한 페이지 파이프라인 개요</h2> <p>LOCK–Derive–Gate DNA Interpreter 파이프라인의 목표는 “해석(interpretation)”을 <strong>재현 가능하고 감사 가능하게</strong> 만드는 것이다.</p> <ol> <li><p><strong>입력(Input)</strong>: 관심 유전체 구간 서열(FASTA)과, 필요 시 해당 구간에 제한된 전사체 주석(GTF).</p></li> <li><p><strong>KEY 단계 (서열 <span class="math inline">\(\rightarrow\)</span> 구조)</strong>: 서열을 창(window) 단위로 요약해 강성(stiffness) 프록시를 구성하고, 이를 기반으로 강성 껍질(shell) 분할과 앵커(anchor) 강도(strength)를 만든다. 주석이 제공되면 TSS로부터 모터(motor)를 추출하고 근접 앵커와 연결하여 루프(loop) 후보를 만든다. 결과는 최소 A4 배치이다.</p></li> <li><p><strong>PCTS 단계 (구조 <span class="math inline">\(\rightarrow\)</span> 원장)</strong>: 입력으로 받아 고정된 4-활동 문법 하에서 비가역 사건열(<strong>J_LEDGER</strong>)을 생성한다.</p></li> <li><p><strong>감사/검증(Audit/validation)</strong>: <code>DATA_LOCK</code>, <code>MANIFEST</code>, <code>INDEX</code>, gate table을 산출하여 런이 적격(admissible)이며 동일 입력/파라미터/시드에서 재현됨을 확인한다.</p></li> </ol> <h2 id="핵심-주장-공학적-계약으로-재진술">핵심 주장: 공학적 계약으로 재진술</h2> <div class="claim"> <p><strong>주장 2</strong> (해석 계약(Interpretation contract)). <em>임의의 입력 구간에 대해 파이프라인은 (a) 유효한 A4 배치와 (b) 게이트로 검증된 산출한다. 만약 산출이 불가능하면, 그 사유는 해시로 추적 가능한 FAIL/INCONCLUSIVE로 명시된다. validated run에서는 사후 LOCK 튜닝(post-hoc tuning)은 허용되지 않는다.</em></p> </div> <p>본 백서에서 “DNA는 100% 해석 가능하다”는 표현은 바로 위의 공학적 계약을 의미한다 <span class="citation" data-cites="zenodo17932567"></span>.</p> <h2 id="핵심-설계-결정">핵심 설계 결정</h2> <h4 id="활동-문법은-고정.">활동 문법은 고정.</h4> <p>INIT / SCONSERV / SDISSIP / JEVENT 외의 새로운 활동 범주는 도입하지 않는다. 다양성(diversity)은 A4 배치 구조에서만 나온다.</p> <h4 id="구조-다양성은-shellanchor에서.">구조 다양성은 shell/anchor에서.</h4> <p>KEY 단계가 강성 껍질 분할과 앵커 강도 등 구조적 다양성을 생성하는 유일한 장소다.</p> <h4 id="비가역성은-가정이-아니라-로그로-강제.">비가역성은 “가정”이 아니라 로그로 강제.</h4> <p>JEVENT는 소산 제약을 만족해야 한다(<span class="math inline">\(\Delta E&lt;0\)</span>). 또한 사건 전후의 잔류 응력(residual stress) 프록시는 증가하면 안 된다.</p> <h2 id="스케일-증거-mm39-autoscan과-대표-패널">스케일 증거: mm39 autoscan과 대표 패널</h2> <p>특정 구간을 임의로 선정하는 문제를 피하기 위해, 우리는 마우스 mm39 전체 게놈을 대상으로 autoscan을 수행한다. 각 창(window)은 다음 4개의 구조 관측량으로 요약된다:</p> <ul> <li><p>유전자 밀도(gene density; Mb당 TSS 수),</p></li> <li><p>반복서열 proxy(repeat proxy; softmask 비율),</p></li> <li><p>GC 비율(GC fraction),</p></li> <li><p>CpG 밀도(CpG density).</p></li> </ul> <p>각 축은 L/M/H(삼분위, terciles)로 이산화되어 <span class="math inline">\(3^4=81\)</span> archetype 격자를 이룬다. 그 다음, <span class="math inline">\(N\approx 30\)</span>–100의 예산 안에서 가능한 한 많은 archetype을 커버하면서 주변(marginal) 균형을 유지하도록 대표 패널을 결정론적으로 선택한다.</p> <h4 id="표-1과-그림-1의-의미.">표 1과 그림 1의 의미.</h4> <ul> <li><p>표 <a href="#tab:archetype_bins" data-reference-type="ref" data-reference="tab:archetype_bins">3</a>는 축별 컷오프 <span class="math inline">\((q_1,q_2)\)</span>와 선택된 구간들의 L/M/H 분포(주변 균형)를 기록한다.</p></li> <li><p>그림 <a href="#fig:archetype_grid" data-reference-type="ref" data-reference="fig:archetype_grid">[fig:archetype_grid]</a>는 선택된 패널의 archetype 점유도(occupancy)를 기록하여, <span class="math inline">\(N\)</span> 예산이 관측된 archetype 공간을 얼마나 균일하게 채우는지 보여준다.</p></li> </ul> <h2 id="재현성-진술최소">재현성 진술(최소)</h2> <p>증거는 validated bundle로 패키징된다:</p> <ul> <li><p>각 run은 입력 해시와 파라미터를 기록한 <code>DATA_LOCK</code>을 가진다.</p></li> <li><p>각 bundle은 산출물 sha256을 기록한 <code>MANIFEST</code>를 가진다.</p></li> <li><p>gate table과 verdict가 포함된다.</p></li> <li><p>참고문헌/DOI에 대한 감사(DOI audit)가 포함된다.</p></li> </ul> <p>제3자는 동일 입력과 동일 파라미터로 파이프라인을 재실행함으로써 동일 <code>run_id</code> 산출물을 재현할 수 있다 <span class="citation" data-cites="zenodo17932567"></span>.</p> <h2 id="읽기-가이드">읽기 가이드</h2> <p>2–3장은 형식적 객체와 재현성 계약을 정의한다. 4–5장은 결정론적 변환(KEY와 PCTS)을 정의한다. 6–8장은 마우스 mm39 데이터 출처와 autoscan 패널 결과(표 <a href="#tab:archetype_bins" data-reference-type="ref" data-reference="tab:archetype_bins">3</a>, 그림 <a href="#fig:archetype_grid" data-reference-type="ref" data-reference="fig:archetype_grid">[fig:archetype_grid]</a>)를 제공한다. 9–10장은 강성-껍질 구조의 창발을 해석하고 실패 모드를 문서화한다.</p> <h1 id="핵심-정의core-definitions">핵심 정의(Core definitions)</h1> <p>본 절은 본문 전반에서 사용하는 객체와 용어를 고정한다.</p> <h2 id="입력-구간input-region">입력 구간(Input region)</h2> <div class="definition"> <p><strong>정의 1</strong> (구간 객체(Region object)). <em>하나의 <em>구간(region)</em>은 다음의 튜플로 정의한다: <span class="math display">\[\mathcal{R} := (S, \mathcal{A}, \theta),\]</span> 여기서 <span class="math inline">\(S\)</span>는 길이 <span class="math inline">\(L\)</span>의 DNA 서열 문자열(<span class="math inline">\(\{A,C,G,T,N\}\)</span>), <span class="math inline">\(\mathcal{A}\)</span>는 선택적 주석(예: 구간에 제한된 GTF), <span class="math inline">\(\theta\)</span>는 파라미터 딕셔너리(창 크기, 스텝, 알고리즘 버전, 시드 등)이다.</em></p> </div> <div class="remark"> <p><strong>비고 1</strong> (최소 주석(minimal annotation)). <em><span class="math inline">\(\mathcal{A}\)</span>는 선택 사항이다. <span class="math inline">\(\mathcal{A}\)</span>가 없는 경우에도 파이프라인은 shell/anchor를 산출한다. 단, motor/loop는 비어 있을 수 있다(예: GTF가 없거나, 구간 내 transcript가 없는 경우).</em></p> </div> <h2 id="a4-배치a4-arrangement">A4 배치(A4 arrangement)</h2> <div class="definition"> <p><strong>정의 2</strong> (A4 배치(Arrangement)). <em>A4 배치는 다음 필드를 포함하는 레코드로 정의한다:</em></p> <ul> <li><p><em><strong>shells</strong>: 서열을 따라 분할된 강성 껍질 구간(시작/끝/라벨/강성 요약치),</em></p></li> <li><p><em><strong>boundaries</strong>: 껍질 경계(위치, 경계 강도),</em></p></li> <li><p><em><strong>anchors</strong>: 경계와 특정 기준점에서 유도된 앵커(위치, 종류(kind), 강도),</em></p></li> <li><p><em><strong>motors</strong>: 주석으로부터 유도되는 모터(예: transcript TSS),</em></p></li> <li><p><em><strong>loops</strong>: motor와 anchor의 연결 후보(거리, 참조 ID),</em></p></li> <li><p><em><strong>meta</strong>: KEY 버전, 생성 UTC, FASTA 헤더 등.</em></p></li> </ul> </div> <div class="remark"> <p><strong>비고 2</strong> (최소성(minimality)). <em>“생물학을 더 많이 설명하기 위해” 임의의 객체를 추가하지 않는다. 필요한 구조 다양성은 shell/anchor/motor/loop라는 제한된 프리미티브에서만 나온다.</em></p> </div> <h2 id="고정-활동-문법4개-연산">고정 활동 문법(4개 연산)</h2> <div class="definition"> <p><strong>정의 3</strong> (활동 문법(Activity grammar)). <em>활동 문법은 허용되는 활동 범주의 순서 있는 집합이다: <span class="math display">\[\{\mathrm{INIT}, \mathrm{SCONSERV}, \mathrm{SDISSIP}, \mathrm{JEVENT}\}.\]</span> 추가적인 활동 범주는 도입하지 않는다. 다양성은 새로운 활동 타입의 추가가 아니라 A4 구조와 사건 로그에서 나온다.</em></p> </div> <h4 id="해석interpretation.">해석(Interpretation).</h4> <p>INIT는 런 상태를 초기화한다. SCONSERV는 보존적 제약 투영(예: 불변량 유지)을 의미한다. SDISSIP는 소산적(relaxational) 변화(예: 잔류 응력 감소)를 의미한다. JEVENT는 비가역(discrete, irreversible) 업데이트로서 시간 단계를 진전시키고 원장에 기록한다.</p> <h2 id="j_ledger-및-게이트"><strong>J_LEDGER</strong> 및 게이트</h2> <div class="definition"> <p><strong>정의 4</strong> (<strong>J_LEDGER</strong> 엔트리). <em><strong>J_LEDGER</strong> 엔트리는 다음 필드를 포함하는 행(row)이다: <code>run_id</code>, <code>created_utc</code>, <code>event_id</code>, <code>event_type</code>, <code>t_step</code>, <code>anchor_ids</code>, <code>motor_ids</code>, <code>loop_ids</code>, <code>trigger_summary</code>, <code>deltaE_diss</code>, <code>pres_pre</code>, <code>pres_post</code>, <code>lock_state_pre</code>, <code>lock_state_post</code>, <code>notes</code>. (스키마는 evidence bundle 내 <code>J_LEDGER_schema_dna_v0_1.yaml</code>에 고정된다.)</em></p> </div> <div class="remark"> <p><strong>비고 3</strong> (적격성(admissibility) 제약). <em>JEVENT는 비가역성을 위해 <span class="math inline">\(\Delta E_{\mathrm{diss}}&lt;0\)</span>를 만족해야 한다. 또한 사건 후 잔류 응력은 증가하면 안 된다(<span class="math inline">\(\mathrm{pres}_{post}\le \mathrm{pres}_{pre}\)</span>). 이러한 제약은 게이트 테이블에서 PASS/FAIL로 검증된다.</em></p> </div> <h2 id="해석-가능의-운영적-의미">“100% 해석 가능”의 운영적 의미</h2> <div class="definition"> <p><strong>정의 5</strong> (운영적 100% 해석 가능(Operational 100% interpretability)). <em>주어진 입력 구간 <span class="math inline">\(\mathcal{R}\)</span>에 대해, 파이프라인이 다음 중 하나를 산출하면 “해석 가능”으로 간주한다:</em></p> <ol> <li><p><em><strong>성공(SUCCESS)</strong>: 생성하고, 모든 필수 게이트를 PASS한다.</em></p></li> <li><p><em><strong>명시적 실패(FAIL)</strong>: A4 또는 <strong>J_LEDGER</strong> 생성에 실패했음을 FAIL 라벨로 기록하고, 입력/파라미터/부분 산출물의 해시를 남긴다(<code>DATA_LOCK</code> 및 <code>MANIFEST</code>).</em></p></li> <li><p><em><strong>불확정(INCONCLUSIVE)</strong>: 하드웨어/환경적 이유로 재현성 게이트를 판정할 수 없음을 라벨링하고, 재시도 조건을 명시한다.</em></p></li> </ol> </div> <p>이 정의는 “기능적 의미”를 푼다는 의미가 아니라, <strong>모든 입력에 대해 산출물 또는 실패 라벨을 감사 가능하게 반환한다</strong>는 의미이다.</p> <h2 id="왜-archetype-패널이-중요한가">왜 archetype 패널이 중요한가</h2> <p>전체 게놈에서 임의의 일부 구간만을 “예시”로 택하면 편향이 생긴다. archetype 패널은 다음을 동시에 달성하기 위한 장치다:</p> <ul> <li><p>다양한 구조적 맥락(GC/CpG/repeat/gene density)을 포괄한다.</p></li> <li><p>제한된 예산(<span class="math inline">\(N\approx 30\)</span>–100)으로도 커버리지를 요약할 수 있다.</p></li> <li><p>표/그림으로 커버리지의 균일성(또는 편향)을 명시한다.</p></li> </ul> <h1 id="데이터-계약data-contract-lockderivegate-패키징">데이터 계약(Data contract: LOCK–Derive–Gate 패키징)</h1> <p>본 절은 “재현성”을 기술적 계약으로 고정한다. 핵심은 <strong>무엇을 잠그고(LOCK), 무엇을 도출하며(Derive), 무엇을 검사하는가(Gate)</strong>를 한 번의 실행(run)에서 <em>기계적으로</em> 확인할 수 있게 만드는 것이다 <span class="citation" data-cites="zenodo17932567"></span>.</p> <h2 id="철학과-의도된-사용">철학과 의도된 사용</h2> <h4 id="왜-계약이-필요한가.">왜 계약이 필요한가.</h4> <p>DNA 해석을 주장할 때 가장 큰 위험은 “사후 조정”(post-hoc tuning)이다. 즉, 결과에 맞추어 파라미터를 조정하거나, 일부 입력만 선택적으로 보고하거나, 내부 상태를 수동으로 고치는 행위다. 본 문서의 계약은 이러한 행위를 <strong>원천적으로 차단</strong>한다.</p> <h4 id="계약의-원칙.">계약의 원칙.</h4> <ol> <li><p><strong>입력은 잠긴다:</strong> 입력은 sha256으로 기록되어야 하며(<code>DATA_LOCK</code>), 런의 고유 식별자(<code>run_id</code>)를 결정한다.</p></li> <li><p><strong>산출물은 잠긴다:</strong> 모든 산출 파일은 sha256으로 잠긴다(<code>MANIFEST</code>).</p></li> <li><p><strong>검증은 자동이다:</strong> gate table은 PASS/FAIL/INCONCLUSIVE를 산출하며, 사유가 함께 기록된다.</p></li> </ol> <h2 id="run_id-안정적-식별자"><code>run_id</code>: 안정적 식별자</h2> <div class="definition"> <p><strong>정의 6</strong> (<code>run_id</code>). <em><code>run_id</code>는 한 실행(run)을 식별하는 짧은 ID이다. 정의는 다음과 같다: <span class="math display">\[\texttt{run\_id} := \mathrm{sha256}(\mathrm{canonical\_json}(\texttt{DATA\_LOCK}))[:16],\]</span> 즉, <code>DATA_LOCK</code>의 canonical JSON 표현을 sha256으로 해시한 뒤 첫 16개의 hex를 사용한다. 전체 sha256(64 hex)은 <code>DATA_LOCK</code> 및 개별 파일 sha256로 인해 별도로 증거에 남는다.</em></p> </div> <div class="remark"> <p><strong>비고 4</strong> (안정성). <em>canonical JSON 규칙(키 정렬, 공백 규칙 등)은 LOCK의 일부다. 다른 정렬/표현을 사용하면 <code>run_id</code>가 달라지므로, 동일 run으로 취급되지 않는다.</em></p> </div> <h2 id="data_lock-무엇이-잠기는가"><code>DATA_LOCK</code>: 무엇이 잠기는가</h2> <div class="definition"> <p><strong>정의 7</strong> (<code>DATA_LOCK</code>). <em><code>DATA_LOCK</code>은 입력과 필수 파라미터를 잠그는 JSON 문서다. 반드시 다음을 포함해야 한다:</em></p> <ul> <li><p><em>입력 구간 정보: <code>chrom,start,end,assembly</code></em></p></li> <li><p><em>FASTA sha256(또는 구간 서열 sha256), 주석(GTF) sha256(있다면)</em></p></li> <li><p><em>사용한 KEY/PCTS 버전과 파라미터, 시드(seed)</em></p></li> <li><p><em>실행 환경에 대한 최소 정보(도구 버전, OS 등) — 단, 이는 <em>LOCK</em>이 아니라 <em>audit trace</em>다</em></p></li> </ul> </div> <div class="proposition"> <p><strong>명제 1</strong> (<code>DATA_LOCK</code> 불변성). <em>validated run에서는 <code>DATA_LOCK</code>이 변경되면 안 된다. <code>DATA_LOCK</code>이 바뀌면 <code>run_id</code>도 바뀌며, 다른 run으로 취급된다.</em></p> </div> <h2 id="manifest-무엇이-잠기는가"><code>MANIFEST</code>: 무엇이 잠기는가</h2> <div class="definition"> <p><strong>정의 8</strong> (<code>MANIFEST</code>). <em><code>MANIFEST.json</code>는 모든 산출 파일의 sha256을 나열한 매니페스트다. 각 항목은 (상대 경로, sha256, 파일 크기, 생성 시간) 등을 포함한다.</em></p> </div> <div class="proposition"> <p><strong>명제 2</strong> (<code>MANIFEST</code> 완전성). <em>validated bundle에서는 모든 핵심 산출물(A4 JSON, <strong>J_LEDGER</strong> TSV/CSV, gate table, 표/그림 소스 등)이 <code>MANIFEST</code>에 존재해야 한다. 누락된 파일이 있으면 해당 run은 FAIL 또는 INCONCLUSIVE이다.</em></p> </div> <h2 id="index-무엇이-색인되는가"><code>INDEX</code>: 무엇이 색인되는가</h2> <div class="definition"> <p><strong>정의 9</strong> (<code>INDEX</code>). <em><code>INDEX.csv</code>는 bundle의 “목차”다. 각 run에 대해 다음 정보를 요약한다: <code>run_id</code>, 입력 구간, 주요 산출물 경로, 게이트 판정, 관련 DOI/증거 번들 ID.</em></p> </div> <h2 id="게이트-판정과-검증-로직">게이트 판정과 검증 로직</h2> <p>게이트는 크게 두 종류다:</p> <ul> <li><p><strong>감사/완전성 게이트:</strong> <code>DATA_LOCK</code> 존재 여부(<code>G_LOCK_PRESENT</code>), <code>MANIFEST</code> 존재(<code>G_MANIFEST_PRESENT</code>), <code>MANIFEST</code> 일치(<code>G_MANIFEST_MATCH</code>), 스키마 완전성(<code>G_SCHEMA_COMPLETE</code>).</p></li> <li><p><strong>물리/논리 적격성 게이트:</strong> 소산 제약(<code>G_\Delta E</code>: 모든 JEVENT에서 <span class="math inline">\(\Delta E_{\mathrm{diss}}&lt;0\)</span>), 잔류 응력 비증가(<code>G_PRES</code>: <span class="math inline">\(\mathrm{pres}_{post}\le \mathrm{pres}_{pre}\)</span>).</p></li> </ul> <p>각 게이트 검사는 PASS/FAIL/INCONCLUSIVE의 판정과 짧은 이유 문자열을 반환한다. 결정론적 동작에서의 일탈(예: 비결정적 정렬, OS 의존적 소팅)은 <strong>재현 가능해야 하며</strong>, 그렇지 못하면 진단과 함께 INCONCLUSIVE로 명시되어야 한다 <span class="citation" data-cites="zenodo17932567"></span>.</p> <h2 id="계약이-함의하는-불변량invariants-implied-by-the-contract">계약이 함의하는 불변량(Invariants implied by the contract)</h2> <p>계약은 다음 불변량을 강제한다(원문 v1.2의 체크리스트를 그대로 따른다):</p> <ol> <li><p><strong>결정론적 도출(deterministic derivation):</strong> 산출물은 잠긴 입력과 잠긴 파라미터/시드의 함수이며, 숨은 수작업 단계가 없다.</p></li> <li><p><strong>완전한 provenance(complete provenance):</strong> 모든 run에는 <code>DATA_LOCK</code>이 존재하고, 모든 bundle에는 <code>MANIFEST</code>가 존재해야 한다.</p></li> <li><p><strong>명시적 버저닝(explicit versioning):</strong> KEY와 PCTS 버전은 항상 기록되어야 하며, 사후에 “추정”할 수 있다고 간주하지 않는다.</p></li> <li><p><strong>폐쇄 세계 인용(closed-world citations):</strong> DOI 레지스트리에는 누락된 DOI 엔트리가 없어야 하며(DOI audit PASS), 인용은 감사 가능해야 한다.</p></li> </ol> <div class="remark"> <p><strong>비고 5</strong> (동치성 관점의 요약). <em>동일한 <code>DATA_LOCK</code>는 동일한 <code>run_id</code>를, 동일한 <code>run_id</code>는 동일한 <code>MANIFEST</code>를 요구한다. 표/그림 값의 “부분 수정”은 허용되지 않으며, 값이 바뀌면 새로운 evidence 버전이다.</em></p> </div> <h2 id="실패-모드failure-modes-and-rejection-criteria">실패 모드(Failure modes and rejection criteria)</h2> <h4 id="좌표-불일치시프트-오류.">좌표 불일치/시프트 오류.</h4> <p>구간 FASTA는 로컬 좌표(0–<span class="math inline">\(L\)</span>)로 해석되는데, 주석(GTF)이 절대 좌표에서 로컬 좌표로 올바르게 시프트되지 않으면 MOTOR가 비정상적으로 0이 되거나 경계 밖으로 나간다. 이 경우 run은 provenance 실패로 FAIL 또는 INCONCLUSIVE이며, MOTOR 카운트가 진단 신호가 된다.</p> <h4 id="부분-실행partial-runs.">부분 실행(partial runs).</h4> <p>run 디렉토리는 존재하지만 <code>MANIFEST</code>가 없거나 핵심 산출물이 누락된 경우, 그 run은 “완료된 증거”로 취급할 수 없다. 재실행하거나, 실패 라벨을 남겨야 한다.</p> <h4 id="비결정성.">비결정성.</h4> <p>어떤 구성요소가 기록되지 않은 상태(예: OS 의존 소팅, 비고정 난수)에 의존하면 동일 입력에서도 다른 산출물이 나올 수 있다. 이 경우 원인을 제공하지 못하면 INCONCLUSIVE이며, 제공되면 재현 조건 하에서 검증해야 한다.</p> <h4 id="사후-lock-튜닝post-hoc-lock-tuning.">사후 LOCK 튜닝(post-hoc LOCK tuning).</h4> <p>validated run 이후 LOCK(예: priors, 스키마, 알고리즘 버전)을 변경하고 기존 evidence를 덮어쓰는 행위는 금지된다. 이 경우 기존 evidence는 거부(reject)되며, 새로운 버전으로 다시 실행해야 한다.</p> <h1 id="key-서열주석에서-a4-배치로">KEY: 서열(+주석)에서 A4 배치로</h1> <p>KEY는 1D DNA 서열(그리고 선택적으로 최소 전사체 주석)을 입력으로 받아, 구조 프리미티브(강성 껍질, 앵커, 모터, 루프)로 구성된 A4 배치를 생성하는 결정론적 변환이다. KEY는 “기능 예측기”가 아니라, <em>구조적 분해(structural decomposition)</em>의 규칙을 제공한다.</p> <h2 id="창window-관측량과-강성stiffness-프록시">창(window) 관측량과 강성(stiffness) 프록시</h2> <p>KEY는 창 길이 <span class="math inline">\(W\)</span>와 스텝 <span class="math inline">\(\Delta\)</span>를 사용하여 구간을 슬라이딩하면서 요약 관측량을 계산한다.</p> <div class="definition"> <p><strong>정의 10</strong> (창 관측량). <em>길이 <span class="math inline">\(W\)</span>의 한 창에서 다음을 계산한다: <span class="math display">\[\mathrm{gc} := \frac{\#G+\#C}{W&#39;},\quad \mathrm{cpg} := \frac{\#(CG)}{W&#39;-1},\quad \mathrm{at6} := \frac{\#(AAAAAA)+\#(TTTTTT)}{W&#39;-5},\]</span> 여기서 <span class="math inline">\(W&#39;\)</span>는 유효 염기 수(예: <span class="math inline">\(N\)</span> 제외)이며, 분모가 0 이하인 경우 해당 창은 결측으로 처리한다.</em></p> </div> <div class="definition"> <p><strong>정의 11</strong> (강성 프록시(원시 값)). <em>각 창에서 강성 프록시의 원시 값을 다음과 같이 정의한다: <span class="math display">\[\mathrm{stiff}_{\mathrm{raw}} := w_{\mathrm{gc}}\cdot \mathrm{gc} + w_{\mathrm{cpg}}\cdot \mathrm{cpg} + w_{\mathrm{at6}}\cdot \mathrm{at6}.\]</span> 가중치 <span class="math inline">\(w_{\mathrm{gc}},w_{\mathrm{cpg}},w_{\mathrm{at6}}\)</span>는 LOCK 파라미터이며 evidence bundle의 priors로 고정된다.</em></p> </div> <h2 id="강건-정규화robust-z-score와-평활화">강건 정규화(robust z-score)와 평활화</h2> <div class="definition"> <p><strong>정의 12</strong> (강건 z-score). <em>창별 원시 값 <span class="math inline">\(\mathrm{stiff}_{\mathrm{raw}}(i)\)</span>에 대해, 중앙값과 MAD를 사용한 강건 z-score를 정의한다: <span class="math display">\[z(i) := \frac{\mathrm{stiff}_{\mathrm{raw}}(i)-\mathrm{median}(\mathrm{stiff}_{\mathrm{raw}})} {1.4826\cdot \mathrm{MAD}(\mathrm{stiff}_{\mathrm{raw}}) + \epsilon}.\]</span> 여기서 <span class="math inline">\(1.4826\)</span>은 MAD를 정규분포 표준편차로 보정하기 위한 상수이며, <span class="math inline">\(\epsilon\)</span>은 0으로 나누는 것을 방지하는 작은 상수다.</em></p> </div> <div class="definition"> <p><strong>정의 13</strong> (평활화). <em>경계의 안정성을 위해, <span class="math inline">\(z(i)\)</span>에 대한 짧은 이동 평균을 취한다: <span class="math display">\[\tilde z(i) := \frac{1}{2k+1}\sum_{j=-k}^{k} z(i+j).\]</span> <span class="math inline">\(k\)</span>는 LOCK 파라미터다.</em></p> </div> <h2 id="삼분위-라벨terciles과-shell-분할">삼분위 라벨(terciles)과 shell 분할</h2> <div class="definition"> <p><strong>정의 14</strong> (삼분위 컷오프). <em><span class="math inline">\(\tilde z(i)\)</span>의 분포에서 1/3 및 2/3 분위수 <span class="math inline">\((q_1,q_2)\)</span>를 계산한다. 각 창은 다음과 같이 라벨링한다: <span class="math display">\[\ell(i) := \begin{cases} \mathrm{L} &amp; \tilde z(i) &lt; q_1\\ \mathrm{M} &amp; q_1 \le \tilde z(i) &lt; q_2\\ \mathrm{H} &amp; q_2 \le \tilde z(i). \end{cases}\]</span></em></p> </div> <div class="definition"> <p><strong>정의 15</strong> (shell). <em>서로 연속된 동일 라벨의 창 구간을 병합하여 shell을 만든다. 짧은 shell(길이 <span class="math inline">\(&lt;\tau\)</span> bp)은 이웃 shell로 병합할 수 있으며, 병합 규칙은 결정론적이어야 한다.</em></p> </div> <div class="proposition"> <p><strong>명제 3</strong> (Shell 불변량). <em>모든 shell은 서로 겹치지 않으며, 구간 <span class="math inline">\([0,L]\)</span>을 순서대로 덮는다(허용되는 결측 구간이 없다면).</em></p> </div> <h2 id="앵커anchors">앵커(anchors)</h2> <div class="definition"> <p><strong>정의 16</strong> (앵커 후보). <em>shell 경계와 강성 프록시의 국소 극값(local extrema)을 이용하여 앵커 후보를 정의한다. 각 후보는 위치 <span class="math inline">\(p\)</span>와 강도 <span class="math inline">\(s\ge 0\)</span>를 가진다.</em></p> </div> <div class="definition"> <p><strong>정의 17</strong> (앵커 선택). <em>앵커 후보 집합에서 다음 규칙으로 최종 앵커를 선택한다:</em></p> <ol> <li><p><em>경계 기반 앵커: 모든 shell 경계는 최소 앵커 후보를 제공한다.</em></p></li> <li><p><em>극값 기반 앵커: <span class="math inline">\(\tilde z\)</span>의 국소 극값 중 강도가 임계값 이상인 것만 채택한다.</em></p></li> <li><p><em>근접 중복 제거: <span class="math inline">\(\tau\)</span> bp 이내의 앵커는 하나로 병합하며 더 강한 앵커를 보존한다.</em></p></li> </ol> </div> <div class="proposition"> <p><strong>명제 4</strong> (앵커 불변량). <em>모든 앵커는 다음을 만족한다:</em></p> <ul> <li><p><em>위치는 <span class="math inline">\([0,L]\)</span>에 속한다,</em></p></li> <li><p><em>강도는 음이 아니다,</em></p></li> <li><p><em>앵커 ID는 run 내에서 유일하다.</em></p></li> </ul> </div> <h2 id="주석으로부터-모터motor-추출">주석으로부터 모터(motor) 추출</h2> <p>주석이 제공되면, 모터를 전사체 시작점(TSS)으로 추출한다.</p> <div class="definition"> <p><strong>정의 18</strong> (TSS 추출 규칙). <em>전사체의 절대 좌표가 <span class="math inline">\((\mathrm{start},\mathrm{end})\)</span>이고 strand <span class="math inline">\(\in\{+,-\}\)</span>일 때: <span class="math display">\[\mathrm{TSS}_{\mathrm{abs}} := \begin{cases} \mathrm{start} &amp; \text{strand }=+\\ \mathrm{end} &amp; \text{strand }=-. \end{cases}\]</span> 로컬 좌표는 구간 시작 오프셋을 빼서 얻는다: <span class="math inline">\(\mathrm{TSS}_{\mathrm{local}}=\mathrm{TSS}_{\mathrm{abs}}-\mathrm{region\_start\_abs}\)</span>.</em></p> </div> <p>오직 <span class="math inline">\(0\le \mathrm{TSS}_{\mathrm{local}}\le L\)</span>인 모터만 유지한다.</p> <div class="remark"> <p><strong>비고 6</strong> (주석 출처). <em>본 백서에서 마우스 mm39 전사체 주석은 UCSC의 RefSeq/refGene를 사용하며, 어셈블리 출처는 별도로 문서화한다 <span class="citation" data-cites="ucsc2025 refseq2016 assembly2016"></span>.</em></p> </div> <h2 id="루프loops-생성">루프(loops) 생성</h2> <div class="definition"> <p><strong>정의 19</strong> (<span class="math inline">\(k\)</span>-최근접 앵커 규칙). <em>각 모터 위치 <span class="math inline">\(p\)</span>에 대해, <span class="math inline">\(|p-a|\)</span>를 최소화하는 앵커 <span class="math inline">\(k\)</span>개를 선택한다. 선택된 각 쌍은 거리 <span class="math inline">\(d=|p-a|\)</span>를 갖는 루프를 정의한다.</em></p> </div> <div class="proposition"> <p><strong>명제 5</strong> (루프 불변량). <em>모든 루프는 다음을 만족한다:</em></p> <ul> <li><p><em><code>motor_id</code>와 <code>anchor_id</code>는 해당 테이블에 존재한다,</em></p></li> <li><p><em>거리 <span class="math inline">\(d\)</span>는 음이 아니며 저장된 위치와 일치한다,</em></p></li> <li><p><em>루프 ID는 유일하다.</em></p></li> </ul> </div> <h2 id="key-버전">KEY 버전</h2> <h3 class="unnumbered" id="key_v0_3_1-단일-스케일">KEY_v0_3_1 (단일 스케일)</h3> <p>KEY_v0_3_1은 단일 창 스케일 <span class="math inline">\((W,\Delta)\)</span>로 하나의 shell 계층을 만든다.</p> <h3 class="unnumbered" id="key_v0_4-멀티스케일">KEY_v0_4 (멀티스케일)</h3> <p>KEY_v0_4는 두 스케일을 사용한다:</p> <ul> <li><p><strong>fine tier</strong>: <span class="math inline">\((W_f,\Delta_f)\)</span>,</p></li> <li><p><strong>coarse tier</strong>: <span class="math inline">\((W_c,\Delta_c)\)</span>.</p></li> </ul> <p>두 tier에서 도출된 앵커는 위치 근접성(허용 오차 <span class="math inline">\(\tau\)</span> bp)에 따라 병합되며, 중복이 발생하면 더 강한 앵커를 유지한다.</p> <div class="proposition"> <p><strong>명제 6</strong> (멀티스케일 앵커 병합의 결정론성). <em>fine/coarse 산출물이 고정되고 병합 허용 오차 <span class="math inline">\(\tau\)</span>가 고정되면, 병합된 앵커 목록은 결정론적이다.</em></p> </div> <h2 id="산출물outputs">산출물(Outputs)</h2> <p>KEY는 다음을 산출한다:</p> <ul> <li><p>창 관측량(feature) TSV,</p></li> <li><p>shell 및 경계(boundary) TSV,</p></li> <li><p>앵커/모터/루프 TSV,</p></li> <li><p>A4 배치를 요약한 최소 YAML.</p></li> </ul> <h2 id="실패-모드-및-진단-신호">실패 모드 및 진단 신호</h2> <h4 id="fasta-다중-서열.">FASTA 다중 서열.</h4> <p>입력 FASTA에 여러 서열이 있으면 엄격한 리더가 추가 헤더를 무시할 수 있다. validated bundle에서는 단일-서열 구간 FASTA를 요구한다.</p> <h4 id="과도한-모호-염기n.">과도한 모호 염기(N).</h4> <p><span class="math inline">\(N\)</span> 비율이 높으면 서열 통계의 신뢰도가 떨어진다. autoscan은 보통 유효 염기 비율이 낮은 창을 필터링하며, 이러한 필터는 파라미터로 기록되어야 한다.</p> <h4 id="gtf-누락-또는-불일치.">GTF 누락 또는 불일치.</h4> <p>GTF가 없으면 모터/루프는 비어 있다. GTF 좌표가 구간과 정렬되지 않으면 모터가 모두 구간 밖으로 나갈 수 있다. 두 경우 모두 모터/루프 카운트와 gate/INDEX에 의해 명시되어야 한다.</p> <h4 id="파라미터-극단.">파라미터 극단.</h4> <p>너무 작은 <span class="math inline">\(W\)</span>는 잡음을 과적합할 수 있고, 너무 큰 <span class="math inline">\(W\)</span>는 경계를 희석할 수 있다. 이는 “오류”라기보다 선택된 scale의 효과이며, 오직 STATE 파라미터 스윕으로 탐색되어야 하고, 사후 LOCK 변경으로 조정되어서는 안 된다.</p> <h1 id="sec:pcts">PCTS: 최소 원장 생성기(PCTS_v0_2)</h1> <p>PCTS 단계는 KEY가 산출한 A4 배치(레이아웃 YAML)를 입력으로 받아, 고정된 4-활동 문법 하에서 시간 인덱스 사건 원장(<strong>J_LEDGER</strong>)을 생성한다. PCTS_v0_2는 “완전한 생물학적 동역학”이 아니라, <strong>검증 가능한(게이트로 판정 가능한) 최소 원장 생성 규칙</strong>을 제공하는 것이 목적이다.</p> <h2 id="상태-변수와-산출물outputs">상태 변수와 산출물(Outputs)</h2> <div class="definition"> <p><strong>정의 20</strong> (Run state). <em>런타임 상태는 다음 최소 성분을 가진다:</em></p> <ul> <li><p><em>현재 시간 단계 <span class="math inline">\(t\in\{0,1,\dots\}\)</span>,</em></p></li> <li><p><em>활성 루프 집합 <span class="math inline">\(\mathcal{L}(t)\)</span>,</em></p></li> <li><p><em>잠긴(locked) 루프 집합 <span class="math inline">\(\mathcal{L}_{\mathrm{locked}}(t)\)</span>,</em></p></li> <li><p><em>잔류 응력 프록시 <span class="math inline">\(\mathrm{pres}(t)\)</span>,</em></p></li> <li><p><em>누적 소산 에너지 <span class="math inline">\(E_{\mathrm{diss}}(t)\)</span>,</em></p></li> <li><p><em>(선택적으로) tie-break를 위한 고정 난수 상태(seed).</em></p></li> </ul> </div> <div class="definition"> <p><strong>정의 21</strong> (Outputs). <em>PCTS_v0_2는 최소 다음 파일을 산출한다:</em></p> <ul> <li><p><em><code>snapshots.csv</code>: (선택) 시간별 상태 스냅샷,</em></p></li> <li><p><em><code>J_LEDGER.csv</code>: 사건 원장(각 행이 JEVENT),</em></p></li> <li><p><em><code>gate_table.csv</code>: 게이트 판정(PASS/FAIL/INCONCLUSIVE),</em></p></li> <li><p><em><code>verdict.json</code>: run 요약 판정(게이트 요약 포함).</em></p></li> </ul> </div> <h2 id="잔류-응력-프록시residual-stress와-역할">잔류 응력 프록시(residual stress)와 역할</h2> <p>PCTS_v0_2는 잔류 응력을 직접 물리량으로 주장하지 않고, <strong>비가역 사건 진행 동안 감소해야 하는 단조 프록시</strong>로 사용한다.</p> <div class="definition"> <p><strong>정의 22</strong> (Unlocked loops). <em>활성 루프 중 아직 잠기지 않은 루프의 집합을 <span class="math display">\[\mathcal{L}_{\mathrm{unlocked}}(t) := \mathcal{L}(t)\setminus \mathcal{L}_{\mathrm{locked}}(t)\]</span> 로 정의한다.</em></p> </div> <div class="definition"> <p><strong>정의 23</strong> (Residual stress proxy). <em><span class="math display">\[\mathrm{pres}(t) := \mathrm{mean}\{d(\ell):\ell\in \mathcal{L}_{\mathrm{unlocked}}(t)\},\]</span> 여기서 <span class="math inline">\(d(\ell)\)</span>는 루프 길이(거리)이다. <span class="math inline">\(\mathcal{L}_{\mathrm{unlocked}}(t)=\emptyset\)</span>이면 <span class="math inline">\(\mathrm{pres}(t):=0\)</span>으로 정의한다.</em></p> </div> <h2 id="고정-4-활동-진행-규칙fixed-4-activity-progression">고정 4-활동 진행 규칙(Fixed 4-activity progression)</h2> <p>각 시간 단계는 다음과 같은 순서로 진행된다:</p> <ol> <li><p><strong>INIT</strong>: 상태 초기화, 초기 <span class="math inline">\(\mathcal{L}(0)\)</span> 구성, <span class="math inline">\(\mathrm{pres}(0)\)</span> 계산.</p></li> <li><p><strong>SCONSERV</strong>: 보존적 제약 적용(유효하지 않은 루프 제거 등).</p></li> <li><p><strong>SDISSIP</strong>: 잔류 응력 프록시를 감소시키는 완화(relaxation).</p></li> <li><p><strong>JEVENT</strong>: 비가역 사건을 기록하고(원장 행 추가), 시간 <span class="math inline">\(t\mapsto t+1\)</span>로 전진.</p></li> </ol> <p>INIT/SCONSERV/SDISSIP는 상태를 준비하는 연산이며, JEVENT만이 원장(<strong>J_LEDGER</strong>)에 “사건”으로 기록된다.</p> <h2 id="사건-규칙-루프-안정화loop-stabilization">사건 규칙: 루프 안정화(loop stabilization)</h2> <p>PCTS_v0_2에서 JEVENT의 대표적 사건 규칙은 “루프 잠금(loop locking)”이다.</p> <div class="definition"> <p><strong>정의 24</strong> (Lock threshold). <em>각 루프 <span class="math inline">\(\ell\)</span>에 대해 잠금 임계값을 <span class="math display">\[d_{\mathrm{lock}}(\ell) := d_0\cdot (1 + c \cdot \min(2,\alpha(\ell))),\]</span> 로 정의한다. 여기서 <span class="math inline">\(d_0,c\)</span>는 LOCK 파라미터이고, <span class="math inline">\(\alpha(\ell)\)</span>는 루프의 강도/가중치 프록시다.</em></p> </div> <div class="definition"> <p><strong>정의 25</strong> (Locking event). <em>시간 <span class="math inline">\(t\)</span>에서 잠금 이벤트는 다음을 만족하는 <span class="math inline">\(\ell\in\mathcal{L}_{\mathrm{unlocked}}(t)\)</span>를 선택하여 <span class="math inline">\(\mathcal{L}_{\mathrm{locked}}(t^+) := \mathcal{L}_{\mathrm{locked}}(t^-)\cup\{\ell\}\)</span> 로 업데이트하는 것이다. 선택 규칙은 결정론적이어야 하며(tie-break는 고정 시드로).</em></p> </div> <div class="remark"> <p><strong>비고 7</strong> (해석). <em><span class="math inline">\(\alpha(\ell)\)</span>가 클수록 잠금 임계값이 커져(더 “쉽게” 잠김), 강한 루프가 먼저 안정화되는 편향을 제공한다. 이는 물리적 사실의 주장이라기보다, <strong>검증 가능한 최소 동역학</strong>을 위한 설계다.</em></p> </div> <h2 id="적격성-게이트admissibility-gates">적격성 게이트(Admissibility gates)</h2> <p>PCTS_v0_2는 다음 게이트를 통해 비가역성/적격성을 강제한다.</p> <div class="proposition"> <p><strong>명제 7</strong> (<span class="math inline">\(\Delta E&lt;0\)</span> (dissipation)). <em>모든 JEVENT에서 소산 에너지 변화는 음이어야 한다: <span class="math display">\[\Delta E_{\mathrm{diss}}(t) &lt; 0.\]</span></em></p> </div> <div class="proposition"> <p><strong>명제 8</strong> (Non-increasing residual stress). <em>모든 JEVENT에서 잔류 응력 프록시는 증가하면 안 된다: <span class="math display">\[\mathrm{pres}(t+1) \le \mathrm{pres}(t).\]</span></em></p> </div> <div class="proposition"> <p><strong>명제 9</strong> (Monotone locking). <em>잠긴 루프 집합은 단조 증가한다: <span class="math display">\[\mathcal{L}_{\mathrm{locked}}(t)\subseteq \mathcal{L}_{\mathrm{locked}}(t+1).\]</span></em></p> </div> <p>이 게이트들은 <code>gate_table.csv</code>에 PASS/FAIL/INCONCLUSIVE로 기록된다.</p> <h2 id="재현성-요구사항reproducibility-requirements">재현성 요구사항(Reproducibility requirements)</h2> <p>PCTS_v0_2는 “의미론적(semantic) 재현성”을 요구한다. 즉, 동일한 A4 입력과 동일한 LOCK/시드 하에서, 사건 스켈레톤이 동일해야 한다.</p> <div class="definition"> <p><strong>정의 26</strong> (Event skeleton). <em>각 JEVENT에서 다음 필드의 튜플을 사건 스켈레톤로 정의한다: <span class="math display">\[\mathrm{skel} := (\texttt{event\_type},\texttt{anchor\_ids},\texttt{motor\_ids},\texttt{loop\_ids}).\]</span> (정확한 필드 집합은 스키마로 고정된다.)</em></p> </div> <div class="proposition"> <p><strong>명제 10</strong> (Deterministic skeleton). <em>입력 A4, LOCK 파라미터, 시드가 고정되면, PCTS_v0_2가 산출하는 사건 스켈레톤 시퀀스는 결정론적이다.</em></p> </div> <div class="remark"> <p><strong>비고 8</strong> (확장성). <em>향후 확률적 요소를 더 포함하더라도, 본 백서 계약은 “스켈레톤 재현성”을 최소 요구로 유지할 수 있다.</em></p> </div> <h2 id="pi_t-프록시와-활동-카운트의-해석"><span class="math inline">\(\Pi_T\)</span> 프록시와 활동 카운트의 해석</h2> <p>PCTS_v0_2는 런 요약으로 활동 카운트와 간단한 프록시를 제공할 수 있다. 예: 시간 <span class="math inline">\(T\)</span>까지의 JEVENT 수, 잠긴 루프 수, <span class="math inline">\(\mathrm{pres}(t)\)</span>의 감소 곡선 등.</p> <div class="remark"> <p><strong>비고 9</strong> (이 절의 위치). <em>이러한 요약은 “의미 해석”이라기보다, <strong>run 진단과 비교 가능성</strong>을 위한 통계다.</em></p> </div> <h2 id="실패-모드-pcts-layer">실패 모드( PCTS layer )</h2> <h4 id="루프-부재.">루프 부재.</h4> <p><span class="math inline">\(\mathcal{L}(0)=\emptyset\)</span>이면 잠금 이벤트가 발생하지 않으며, 비어 있거나 최소 엔트리만 포함할 수 있다. 이는 오류가 아니라 입력/주석 구조의 결과이며, <code>verdict.json</code>에 명시되어야 한다.</p> <h4 id="최대-스텝-제한max-step-truncation.">최대 스텝 제한(max-step truncation).</h4> <p><span class="math inline">\(\texttt{max\_steps}\)</span>에 도달하여 중단된 경우, 이는 FAIL이 아니라 “계산 예산에 의한 종료”일 수 있다. 단, 종료 상태와 이유는 반드시 기록되어야 한다.</p> <h4 id="스키마-드리프트.">스키마 드리프트.</h4> <p><strong>J_LEDGER</strong> 스키마가 버전 불일치로 달라지면 <code>G_SCHEMA_COMPLETE</code>에서 FAIL해야 한다.</p> <h4 id="잔류-응력-비증가-위반.">잔류 응력 비증가 위반.</h4> <p><span class="math inline">\(\mathrm{pres}(t+1)&gt;\mathrm{pres}(t)\)</span>가 관측되면 gate 위반으로 FAIL이다. 이는 구현 버그 또는 프록시 정의의 부적절함을 의미한다.</p> <h2 id="요약">요약</h2> <p>PCTS_v0_2는 다음을 고정한다:</p> <ul> <li><p>고정된 4-활동 문법,</p></li> <li><p>결정론적 사건 생성,</p></li> <li><p>적격성 게이트(<span class="math inline">\(\Delta E&lt;0\)</span>, 잔류 응력 비증가, monotone locking),</p></li> <li><p>사건 스켈레톤 기반의 의미론적 재현성 요구.</p></li> </ul> <p>따라서 PCTS_v0_2는 본 백서의 LOCK<span class="math inline">\(\rightarrow\)</span>Derive<span class="math inline">\(\rightarrow\)</span>Gate 계약에서 “원장 생성기”의 최소 역할을 수행한다 <span class="citation" data-cites="zenodo17932567"></span>.</p> <h1 id="sec:mm39_prov">마우스/mm39 참조 데이터 출처(Provenance)</h1> <p>본 절은 본 백서에서 말하는 “마우스 mm39 데이터”가 <em>정확히 무엇인지</em>, 어디에서 왔는지, 그리고 provenance(출처/계보)를 어떻게 검증하는지를 명세한다. 전장 게놈 분석에서 가장 흔한 실패 모드는 <strong>조용한(침묵) 어셈블리/주석 드리프트</strong>이므로, 이를 원천 차단하는 것이 목적이다.</p> <h2 id="어셈블리-정체성과-좌표계">어셈블리 정체성과 좌표계</h2> <div class="definition"> <p><strong>정의 27</strong> (어셈블리 정체성). <em>본 문서에서 mm39 은 마우스 참조 어셈블리 <em>GRCm39</em>를 의미한다. 모든 유전체 좌표는 해당 어셈블리의 좌표계로 해석한다.</em></p> </div> <div class="proposition"> <p><strong>명제 11</strong> (좌표 일관성 요구). <em>서열과 주석을 결합하는 모든 단계(특히 MOTOR 추출)는 다음을 요구한다:</em></p> <ol> <li><p><em>염색체 명명 규칙이 일치해야 한다(예: <code>chr1</code> vs <code>1</code>),</em></p></li> <li><p><em>주석 좌표는 FASTA와 동일 어셈블리에서 정의되어야 한다,</em></p></li> <li><p><em>창 수준 좌표 이동()은 기록되고 일관되게 적용되어야 한다.</em></p></li> </ol> <p><em>조건이 실패하면 MOTOR의 개수/위치가 해당 구간에서 무효가 되며, claim 범위에 따라 FAIL 또는 INCONCLUSIVE이다.</em></p> </div> <h2 id="게놈-서열과-주석의-1차-출처">게놈 서열과 주석의 1차 출처</h2> <h4 id="게놈-서열fasta.">게놈 서열(FASTA).</h4> <p>마우스 mm39 서열은 UCSC Genome Browser 다운로드 인프라를 통해 획득한다 <span class="citation" data-cites="ucsc2025 ucsc2003"></span>. autoscan과 repeat proxy 구성에는 반복이 소문자로 표시되는 <em>soft-masked</em> 염색체 FASTA를 사용한다.</p> <h4 id="유전자전사체-주석refgenerefseq.">유전자/전사체 주석(refGene/RefSeq).</h4> <p>전사체 모델은 UCSC가 제공하는 RefSeq 유래 소스(예: <code>refGene</code>/RefSeq 트랙)로부터 얻는다 <span class="citation" data-cites="refseq2016 ucsc2025"></span>. 이는 TSS를 MOTOR 위치로 추출하기에 충분한 최소 주석을 제공한다.</p> <h4 id="어셈블리-provenance.">어셈블리 provenance.</h4> <p>어셈블리 정체성과 provenance는 NCBI Assembly를 인용하고, 조립 게놈 배포의 1차 아카이브로서 GenBank를 인용한다 <span class="citation" data-cites="assembly2016 genbank2016"></span>.</p> <h4 id="반복-마스킹-provenance.">반복 마스킹 provenance.</h4> <p>soft masking과 repeat 중심 처리의 개념은 표준 RepeatMasker 파이프라인과 일치한다 <span class="citation" data-cites="repeatmasker2009"></span>.</p> <h2 id="provenance-검증-무엇을-해시하고-왜-하는가">Provenance 검증: 무엇을 해시하고 왜 하는가</h2> <div class="definition"> <p><strong>정의 28</strong> (해시에 의한 입력 검증). <em>각 run에 대해, 입력 파일은 <code>DATA_LOCK</code>에 기록된 sha256로 검증된다:</em></p> <ul> <li><p><em>: 구간 아카이브(zip)의 sha256,</em></p></li> <li><p><em>: 추출된 구간 FASTA의 sha256,</em></p></li> <li><p><em>: 추출된 구간 GTF의 sha256(없으면 empty).</em></p></li> </ul> </div> <div class="proposition"> <p><strong>명제 12</strong> (재현 가능한 provenance). <em>두 사용자가 동일한 UCSC/NCBI 상위 소스를 내려받고 동일 autoscan/추출 스크립트를 실행하면, 동일한 구간 FASTA/GTF를 생성하고, 따라서 동일한 해시와 <code>run_id</code>(동일 선택 파라미터/시드 하)를 얻는다.</em></p> </div> <div class="remark"> <p><strong>비고 10</strong> (왜 “추출된 구간 파일”을 해시하는가). <em>상위의 수 GB 게놈 아카이브 해시만으로는 충분하지 않다. 추출 파이프라인이 달라질 수 있기 때문이다. 우리는 KEY와 실제로 보는 <em>derived region FASTA/GTF</em>를 해시하여 입력을 동결한다.</em></p> </div> <h2 id="본-백서에서-사용하는-실무-규약">본 백서에서 사용하는 실무 규약</h2> <h4 id="염색체-집합.">염색체 집합.</h4> <p>autoscan은 보통 canonical 염색체(chr1–chr19, chrX, chrY)를 대상으로 하며, 특별한 목적이 없으면 unlocalized contig를 제외할 수 있다.</p> <h4 id="softmask-fraction-repeat-proxy.">softmask fraction = repeat proxy.</h4> <p>repeat proxy 축은 soft-masked FASTA 창에서 소문자 A/C/G/T의 비율로 정의한다. 이는 repeat family 분해가 아니라, archetype 균형화에 충분한 단일 스칼라다.</p> <h4 id="tss-중복-제거.">TSS 중복 제거.</h4> <p>여러 전사체 엔트리가 동일한 TSS를 공유하면 MOTOR를 중복 제거하거나 유지할 수 있다. 정책은 LOCK 또는 STATE로 기록되어야 하며 카운트에 반영되어야 한다.</p> <h2 id="실패-모드및-탐지-방법">실패 모드(및 탐지 방법)</h2> <h4 id="잘못된-어셈블리mm10-vs-mm39.">잘못된 어셈블리(mm10 vs mm39).</h4> <p>증상: 많은 transcript가 추출 구간 밖으로 떨어짐; gene-dense 영역에서 MOTOR가 거의 0; 염색체 길이 불일치. 대응: 어셈블리 메타데이터를 강제하고, 정확한 입력을 해시로 잠근다.</p> <h4 id="염색체-이름-불일치.">염색체 이름 불일치.</h4> <p>증상: annotation 파서가 염색체 ID 불일치로 모터를 0개 생성. 대응: 다운로드/추출 단계에서 이름을 정규화하고, 정규화 규칙을 파라미터로 기록.</p> <h4 id="softmask-부재-또는-불일치.">softmask 부재 또는 불일치.</h4> <p>증상: repeat proxy 축이 붕괴(대부분 창에서 softmask fraction <span class="math inline">\(\approx 0\)</span>). 대응: soft-masked FASTA 사용 여부를 확인하고, 마스킹 존재 여부를 기록.</p> <h4 id="주석-버전-드리프트.">주석 버전 드리프트.</h4> <p>증상: gene density 분포 이동, 삼분위 컷오프 변화. 대응: 주석 릴리스를 LOCK의 일부로 취급하고 해시를 기록; 입력이 바뀌면 표 <a href="#tab:archetype_bins" data-reference-type="ref" data-reference="tab:archetype_bins">3</a>를 재생성.</p> <h4 id="어셈블리-갭고-n-창.">어셈블리 갭/고-N 창.</h4> <p>증상: 모호 염기가 많아 GC/CpG 추정이 불안정. 대응: 유효 염기 비율 필터를 적용(파라미터에 기록)하고 제외된 창을 라벨링.</p> <h1 id="sec:autoscan_panel">mm39 autoscan에서 대표 구간 패널로</h1> <p>본 절은 전체 mm39 게놈을 자동으로 스캔하여 대표 구간 패널(<span class="math inline">\(N\approx 30\)</span>–100)를 <strong>결정론적으로</strong> 선택하는 절차를 문서화한다. 핵심은, 대표 구간이 특정 연구자의 직관에 의해 선택되지 않고, <strong>4축 archetype 공간을 균일하게 커버하도록</strong> 선택된다는 점이다.</p> <h2 id="윈도잉-스킴과-후보-집합">윈도잉 스킴과 후보 집합</h2> <p>우리는 고정된 창 길이 <span class="math inline">\(W_0\)</span>와 스텝 <span class="math inline">\(S_0\)</span>로 게놈을 슬라이딩하며 후보 창을 만든다. 후보 창은 다음 필터를 통과해야 한다:</p> <ul> <li><p>canonical 염색체 집합(기본: chr1–chr19, chrX, chrY),</p></li> <li><p>유효 염기 비율(예: <span class="math inline">\(N\)</span> 제외)이 임계값 이상,</p></li> <li><p>창이 어셈블리 경계/갭에서 심각하게 손상되지 않을 것.</p></li> </ul> <p>필터 파라미터는 autoscan LOCK/STATE로 기록되어야 하며, 동일 파라미터에서만 재현 비교가 가능하다.</p> <h2 id="autoscan-관측량4개-구조-축">Autoscan 관측량(4개 구조 축)</h2> <p>각 후보 창에서 다음 관측량을 계산한다(정의는 <a href="#sec:mm39_prov" data-reference-type="ref" data-reference="sec:mm39_prov">7</a>의 provenance 규약을 따른다).</p> <div class="definition"> <p><strong>정의 29</strong> (유전자 밀도(gene density)). <em>해당 창에 속하는 TSS의 개수를 센 뒤 Mb당 개수로 정규화한다.</em></p> </div> <div class="definition"> <p><strong>정의 30</strong> (반복서열 proxy(repeat proxy)). <em>soft-masked FASTA에서 소문자 염기의 비율을 계산한다. (Repeat family 분해가 아니라, 단일 스칼라 proxy로 사용한다.)</em></p> </div> <div class="definition"> <p><strong>정의 31</strong> (GC 비율). <em>유효 염기 중 G/C의 비율.</em></p> </div> <div class="definition"> <p><strong>정의 32</strong> (CpG 밀도). <em>유효 염기에서 “CG” 다이뉴클레오타이드의 밀도.</em></p> </div> <h2 id="binning-축별-삼분위lmh">Binning: 축별 삼분위(L/M/H)</h2> <p>각 축에 대해 후보 창 분포에서 삼분위 컷오프 <span class="math inline">\((q_1,q_2)\)</span>를 계산하고, 각 창을 L/M/H로 라벨링한다. 컷오프는 evidence로 고정되며(표 <a href="#tab:archetype_bins" data-reference-type="ref" data-reference="tab:archetype_bins">3</a>), 축 정의/필터가 바뀌면 컷오프와 분포가 바뀌므로 새로운 evidence가 된다.</p> <h2 id="archetype-정의4축-bin">Archetype 정의(4축 bin)</h2> <p>네 축 라벨의 데카르트 곱은 <span class="math inline">\(3^4=81\)</span>개의 archetype을 만든다. 각 창은 다음과 같은 archetype ID로 표현할 수 있다: <span class="math display">\[\mathrm{archetype}(w) := (\ell_G,\ell_R,\ell_{GC},\ell_{CpG}) \in \{L,M,H\}^4,\]</span> 여기서 <span class="math inline">\(G\)</span>는 gene density, <span class="math inline">\(R\)</span>은 repeat proxy를 의미한다. 이 표현은 표 <a href="#tab:archetype_bins" data-reference-type="ref" data-reference="tab:archetype_bins">3</a>와 그림 <a href="#fig:archetype_grid" data-reference-type="ref" data-reference="fig:archetype_grid">[fig:archetype_grid]</a>에서 사용한다.</p> <h2 id="선택-알고리즘coverage-우선-균일성-보조">선택 알고리즘(coverage 우선, 균일성 보조)</h2> <p>대표 패널은 다음 원칙으로 선택한다:</p> <ol> <li><p><strong>coverage-first:</strong> 가능한 한 많은 archetype을 커버한다.</p></li> <li><p><strong>uniformity-second:</strong> 같은 예산 <span class="math inline">\(N\)</span>에서 주변(marginal) 분포가 심하게 치우치지 않도록 한다.</p></li> <li><p><strong>deterministic:</strong> 동률(tie) 상황에서의 선택은 완전히 결정론적이어야 한다.</p></li> </ol> <p>구현은 greedy 방식으로 가능하며, 각 단계에서 “새로운 archetype 커버”를 최대화하고, 동시에 축별 주변 분포가 목표(가능한 균등)에 가까워지도록 score를 구성한다. 동률은 창의 좌표 사전순 정렬(또는 해시 기반 key)로 깨며, 이 규칙은 LOCK의 일부다.</p> <h2 id="구간-추출-및-step18-job-구성">구간 추출 및 STEP18 job 구성</h2> <p>선택된 창 집합이 정해지면, 각 창에 대해 다음 derived inputs를 생성한다:</p> <ul> <li><p>구간 FASTA (해당 창 서열만 포함),</p></li> <li><p>구간 GTF (해당 창과 교차하는 transcript 엔트리만 포함),</p></li> <li><p><code>DATA_LOCK</code> 및 <code>run_id</code>.</p></li> </ul> <p>그 다음, end-to-end 스크립트는 각 구간을 KEY<span class="math inline">\(\rightarrow\)</span>A4 및 PCTS<span class="math inline">\(\rightarrow\)</span>처리하는 job 목록을 생성한다. 본 백서의 재현성 번들에서는 가 이 과정을 자동으로 수행한다 <span class="citation" data-cites="zenodo17932567"></span>.</p> <h2 id="실패-모드autoscan선택추출">실패 모드(autoscan/선택/추출)</h2> <h4 id="후보-창-필터-편향.">후보 창 필터 편향.</h4> <p>너무 강한 필터는 archetype 공간 자체를 축소한다. 필터는 파라미터로 명시하고, 후보 수/필터 후 분포를 기록해야 한다.</p> <h4 id="주석-불일치로-인한-gene-density-붕괴.">주석 불일치로 인한 gene density 붕괴.</h4> <p>어셈블리/주석 불일치가 있으면 gene density 축이 잘못된다. 이는 provenance 게이트로 탐지해야 한다(<a href="#sec:mm39_prov" data-reference-type="ref" data-reference="sec:mm39_prov">7</a>).</p> <h4 id="repeat-proxy의-비정상-분포.">repeat proxy의 비정상 분포.</h4> <p>softmask가 없으면 repeat 축이 거의 0으로 붕괴한다. softmask 사용 여부는 입력 provenance의 일부다.</p> <h4 id="동률-결정-규칙-미고정.">동률 결정 규칙 미고정.</h4> <p>동률 깨기 규칙이 OS/파이썬 버전에 따라 달라지면 패널이 달라진다. 따라서 tie-break는 완전히 결정론적이어야 하며, 정렬 규칙을 LOCK으로 고정해야 한다.</p> <h1 id="sec:results_archetype">결과: archetype 커버리지(표 1; 그림 1)</h1> <p>본 절은 autoscan binning 및 대표 패널 선택 결과를 <strong>고정 증거</strong>로 기록한다. 관리(TeX 단일화) 관점에서 외부 이미지 파일을 본 프로젝트에 포함하지 않는다. 대신, 그림 <a href="#fig:archetype_grid" data-reference-type="ref" data-reference="fig:archetype_grid">[fig:archetype_grid]</a>는 TeX 내부에서 직접 렌더링되는 9<span class="math inline">\(\times\)</span>9 점유도 테이블로 제공한다 (선택 패널이 4축 archetype 공간에서 어떻게 분포하는지에 대한 최소 통계적 뷰).</p> <h2 id="bin-컷오프와-주변-균형표-1">Bin 컷오프와 주변 균형(표 1)</h2> <p>표 <a href="#tab:archetype_bins" data-reference-type="ref" data-reference="tab:archetype_bins">3</a>는 각 축에 대한 삼분위 컷오프 <span class="math inline">\((q_1,q_2)\)</span>와, 선택된 패널이 L/M/H에 걸쳐 얼마나 균형 잡혀 있는지(주변 분포)를 기록한다. 이는 대표 선택이 특정 축에 과도하게 편향되지 않았음을 간단히 검증하는 장치다.</p> <div id="tab:archetype_bins"> <table> <caption>mm39 autoscan archetype bins and selection balance (Table 1).</caption> <thead> <tr class="header"> <th style="text-align: left;">Axis</th> <th style="text-align: left;">Observable</th> <th style="text-align: right;"><span class="math inline">\(q_{1}\)</span></th> <th style="text-align: right;"><span class="math inline">\(q_{2}\)</span></th> <th style="text-align: right;">Sel(L)</th> <th style="text-align: right;">Sel(M)</th> <th style="text-align: right;">Sel(H)</th> <th style="text-align: left;">Notes</th> </tr> </thead> <tbody> <tr class="odd"> <td style="text-align: left;">G</td> <td style="text-align: left;">TSS per Mb (refGene transcripts)</td> <td style="text-align: right;">10</td> <td style="text-align: right;">18.8</td> <td style="text-align: right;">25</td> <td style="text-align: right;">29</td> <td style="text-align: right;">26</td> <td style="text-align: left;"></td> </tr> <tr class="even"> <td style="text-align: left;">R</td> <td style="text-align: left;">softmask fraction (repeat proxy; lowercase A/C/G/T)</td> <td style="text-align: right;">0.40285</td> <td style="text-align: right;">0.473893</td> <td style="text-align: right;">26</td> <td style="text-align: right;">30</td> <td style="text-align: right;">24</td> <td style="text-align: left;"></td> </tr> <tr class="odd"> <td style="text-align: left;">GC</td> <td style="text-align: left;">GC fraction (A/C/G/T only; N excluded)</td> <td style="text-align: right;">0.400741</td> <td style="text-align: right;">0.427662</td> <td style="text-align: right;">23</td> <td style="text-align: right;">33</td> <td style="text-align: right;">24</td> <td style="text-align: left;"></td> </tr> <tr class="even"> <td style="text-align: left;">CPG</td> <td style="text-align: left;">CpG per kb (count(<code>CG</code>)/kb; N excluded)</td> <td style="text-align: right;">6.908133</td> <td style="text-align: right;">9.018333</td> <td style="text-align: right;">24</td> <td style="text-align: right;">35</td> <td style="text-align: right;">21</td> <td style="text-align: left;"></td> </tr> <tr class="odd"> <td style="text-align: left;">Archetype (4-axis)</td> <td style="text-align: left;">Archetype = (G_bin, R_bin, GC_bin, CPG_bin), each in (L,M,H)</td> <td style="text-align: right;"></td> <td style="text-align: right;"></td> <td style="text-align: right;"></td> <td style="text-align: right;"></td> <td style="text-align: right;"></td> <td style="text-align: left;">N_selected=80; candidate_windows=522; archetypes_present=49; archetypes_covered=49/81 (60.5%)</td> </tr> <tr class="even"> <td style="text-align: left;">Uniformity</td> <td style="text-align: left;">Counts over covered archetypes (nonzero 9x9 cells)</td> <td style="text-align: right;"></td> <td style="text-align: right;"></td> <td style="text-align: right;"></td> <td style="text-align: right;"></td> <td style="text-align: right;"></td> <td style="text-align: left;">min/median/max=1/2.0/2; entropy_ratio=0.988; gini=0.142; CV=0.295</td> </tr> <tr class="odd"> <td style="text-align: left;">Parameters</td> <td style="text-align: left;">Scan and selection settings</td> <td style="text-align: right;"></td> <td style="text-align: right;"></td> <td style="text-align: right;"></td> <td style="text-align: right;"></td> <td style="text-align: right;"></td> <td style="text-align: left;">assembly=mm39(UCSC); chroms=chr1–19,X,Y; win=5,000,000; step=5,000,000; valid_frac<span class="math inline">\(\ge\)</span>0.8; bins=terciles; target_N=80; selection=coverage-first; dup(max2)</td> </tr> </tbody> </table> </div> <h2 id="archetype-커버리지coverage-계산">Archetype 커버리지(coverage) 계산</h2> <p>네 축의 삼분위 라벨 조합은 총 <span class="math inline">\(81\)</span>개의 archetype을 만든다. 예산 <span class="math inline">\(N=80\)</span>에서는 이론적으로 모든 archetype을 1개씩 완전히 채우는 것은 불가능할 수 있으며, 실제 선택은 <em>coverage-first</em> 원칙과 주변 균형 제약의 타협 결과다.</p> <p>다음 값을 사용해 커버리지를 요약한다:</p> <ul> <li><p><strong>occupied archetypes</strong>: 선택된 패널에서 점유도가 1 이상인 archetype의 수,</p></li> <li><p><strong>coverage fraction</strong>: 점유 archetype 수를 <span class="math inline">\(81\)</span>로 나눈 값,</p></li> <li><p><strong>marginal balance</strong>: 각 축에서 L/M/H 빈도의 편향 정도(표 <a href="#tab:archetype_bins" data-reference-type="ref" data-reference="tab:archetype_bins">3</a>).</p></li> </ul> <h2 id="균일성-지표와-해석상의-주의">균일성 지표와 해석상의 주의</h2> <p>균일성(uniformity)은 “좋다/나쁘다”의 문제가 아니라 선택 목적의 문제다. 대표 패널은 <strong>극단값만</strong> 모으는 것이 아니라, 구조적 맥락을 다양하게 포함하도록 설계되었다. 따라서 어떤 archetype은 예산 제약상 중복 선택되거나 누락될 수 있다. 중요한 것은 이러한 편향이 <em>표와 그림으로 명시되어 있다는 점</em>이다.</p> <h2 id="archetype-점유도-격자그림-1">Archetype 점유도 격자(그림 1)</h2> <p>그림 <a href="#fig:archetype_grid" data-reference-type="ref" data-reference="fig:archetype_grid">[fig:archetype_grid]</a>는 선택된 패널의 archetype 점유도를 9<span class="math inline">\(\times\)</span>9 격자로 표현한다. 열(column)은 <span class="math inline">\((G,R)\)</span> 조합(유전자 밀도, 반복 proxy)의 3<span class="math inline">\(\times\)</span>3=9 조합을, 행(row)은 <span class="math inline">\((GC,CpG)\)</span> 조합의 3<span class="math inline">\(\times\)</span>3=9 조합을 나타낸다. 각 셀 값은 해당 archetype으로 분류된 선택 구간의 개수다.</p> <h2 id="evidence-lock-관점에서의-검증-포인트">Evidence lock 관점에서의 검증 포인트</h2> <p>본 절의 표/그림은 단순한 시각화가 아니라, <strong>증거 잠금(evidence lock)</strong>의 일부다. 따라서 다음이 성립해야 한다:</p> <ol> <li><p>표 <a href="#tab:archetype_bins" data-reference-type="ref" data-reference="tab:archetype_bins">3</a>의 수치(컷오프와 빈도)는 원본 테이블 CSV와 일치해야 한다.</p></li> <li><p>그림 <a href="#fig:archetype_grid" data-reference-type="ref" data-reference="fig:archetype_grid">[fig:archetype_grid]</a>의 9<span class="math inline">\(\times\)</span>9 격자 값은 원본 occupancy CSV와 일치해야 한다.</p></li> <li><p>두 원본 파일은 evidence bundle 내 <code>MANIFEST</code>의 sha256과 일치해야 한다.</p></li> </ol> <p>어느 하나라도 바뀌면, 이는 “사소한 편집”이 아니라 <strong>새로운 evidence 버전</strong>이며, DOI 및 백서 리비전 업데이트가 필요하다.</p> <h2 id="실패-모드커버리지-증거">실패 모드(커버리지 증거)</h2> <h4 id="컷오프가-달라짐.">컷오프가 달라짐.</h4> <p>후보 필터 또는 주석/어셈블리 버전이 바뀌면 컷오프와 분포가 달라진다. 이 경우 기존 표/그림은 더 이상 유효한 증거가 아니다.</p> <h4 id="선택-알고리즘의-비결정성.">선택 알고리즘의 비결정성.</h4> <p>tie-break가 비결정적이면 패널이 달라진다. 이 경우 동일 파라미터에서도 표/그림이 재현되지 않으며 INCONCLUSIVE 또는 FAIL이 된다.</p> <h4 id="원본-csv와-tex-표그림-불일치.">원본 CSV와 TeX 표/그림 불일치.</h4> <p>TeX 내 표/그림 값이 원본 CSV와 다르면, 이는 증거 잠금 위반이다. TeX는 반드시 원본 CSV에서 생성되거나, 값이 일치함이 검증되어야 한다.</p> <h1 id="sec:interpretation">해석: 강성-껍질(stiffness-shell) 구조의 창발</h1> <p>본 절은 KEY와 만들어내는 구조가 왜 “임의의 장식”이 아니라 입력 서열 통계와 계약(gates)에서 <em>필연적으로</em> 유도되는지, 그 논리적 연결고리를 설명한다. 여기서 “창발(emergence)”은 새로운 물리 실체의 발견이 아니라, <strong>규칙을 고정했을 때 구조가 결정론적으로 나타나는 현상</strong>을 의미한다.</p> <h2 id="서열-통계에서-shellanchor로-결정론적-coarse-graining">서열 통계에서 shell/anchor로: 결정론적 coarse-graining</h2> <p>KEY는 서열을 창 단위로 요약하고, 강성 프록시 <span class="math inline">\(\mathrm{stiff}\)</span>를 만든다. 이 프록시는 (GC, CpG, AT6) 같은 로컬 서열 통계의 선형 결합이며, 강건 정규화와 평활화를 거쳐 <span class="math inline">\(\tilde z(i)\)</span>로 표현된다.</p> <p>이때 shell은 <span class="math inline">\(\tilde z(i)\)</span>의 삼분위 라벨(L/M/H)의 연속 구간을 병합한 것이다. 따라서 shell은 “해석자의 주관”이 아니라, <strong>고정된 통계 규칙의 출력</strong>이다. 앵커는 shell 경계와 국소 극값으로부터 유도되므로, anchor 구조 역시 동일한 의미에서 결정론적 coarse-graining의 산물이다.</p> <h2 id="모터와-루프-제약된-결합constrained-couplings">모터와 루프: 제약된 결합(constrained couplings)</h2> <p>주석이 제공되면, 모터는 TSS로부터 추출된다. 이는 기능적 의미를 예측하려는 것이 아니라, <strong>서열 기반 shell/anchor 구조 위에</strong> 주석 기반 “구동점”을 배치하는 최소 규칙이다.</p> <p>루프는 모터와 앵커를 제한된 규칙(예: <span class="math inline">\(k\)</span>-최근접)으로 결합한 것이다. 따라서 루프 구조는 (a) 서열 통계에 의해 유도된 앵커, (b) 주석에 의해 주어진 모터, (c) 결합 규칙 의 세 요소가 잠겨 있을 때 결정된다.</p> <h2 id="jevent-비가역-안정화ledger-semantics">JEVENT: 비가역 안정화(ledger semantics)</h2> <p>JEVENT는 비가역 업데이트이며, 원장에 기록된다. JEVENT의 핵심 의미론은 다음이다:</p> <ul> <li><p><strong>비가역성</strong>: 사건 전/후 상태가 원장에 기록되므로, 사건은 “되돌릴 수 없는 역사”가 된다.</p></li> <li><p><strong>적격성</strong>: <span class="math inline">\(\Delta E_{\mathrm{diss}}&lt;0\)</span> 및 잔류 응력 비증가라는 게이트를 통과해야 한다.</p></li> </ul> <p>즉, JEVENT는 단순한 로그가 아니라, <strong>게이트가 강제하는 안정화(stabilization)</strong>의 기록이다.</p> <h2 id="여기서-창발이-의미하는-것">여기서 “창발”이 의미하는 것</h2> <p>본 백서에서 창발이란 다음과 같다:</p> <ul> <li><p>활동 문법을 고정하고,</p></li> <li><p>입력을 해시로 잠그고,</p></li> <li><p>산출물 및 게이트를 모두 잠그면,</p></li> </ul> <p>shell/anchor/motor/loop 및 JEVENT 패턴이 <strong>임의의 해석자 선택 없이</strong> 산출된다는 의미다.</p> <p>이는 생물학적 의미의 창발(예: phenotype)의 주장과는 다르며, <strong>재현 가능한 구조 생성 규칙</strong>에 대한 주장이다.</p> <h2 id="스케일-거동과-멀티스케일-key">스케일 거동과 멀티스케일 KEY</h2> <p>단일 스케일 KEY는 특정 창 크기에서의 경계를 강조한다. 멀티스케일 KEY는 서로 다른 스케일에서의 경계 후보를 합성하여, “해석”의 스케일 민감도를 낮추려는 선택이다.</p> <p>중요한 점은: 멀티스케일이 “더 진실”을 의미하지는 않는다. 다만, LOCK된 규칙 하에서 더 많은 구조 후보를 일관되게 제공하여 후속 분석(예: PCTS 사건열)이 보다 안정적으로 구성되도록 돕는다.</p> <h2 id="대표-패널이-일반화에-도움이-되는-이유">대표 패널이 일반화에 도움이 되는 이유</h2> <p>대표 패널은 특정 구간만을 예시로 보이는 편향을 줄인다. 4축 archetype 공간을 커버하는 패널에서 얻는 관찰은 다음을 가능케 한다:</p> <ul> <li><p>다양한 서열 통계 맥락에서 shell/anchor의 분포를 비교,</p></li> <li><p>주석 밀도가 다른 영역에서 motor/loop의 안정성 비교,</p></li> <li><p>게이트 위반이 발생하는 “경계 사례”의 유형화.</p></li> </ul> <h2 id="해석의-한계진실성-제약">해석의 한계(진실성 제약)</h2> <p>본 문서는 다음을 명시한다:</p> <ul> <li><p>기능을 예측하지 않으며, 실험적 의미를 “정답”으로 제공하지 않는다.</p></li> <li><p>강성 프록시는 구조 다양성을 생성하는 도구이며, 물리량의 보편적 추정기라고 주장하지 않는다.</p></li> <li><p>결과는 LOCK/계약 하에서 재현 가능하다는 의미이며, 생물학적 참(truth)을 완전히 대체한다는 의미가 아니다.</p></li> </ul> <h1 id="sec:validation">검증(Validation)과 실패 모드</h1> <p>본 절은 “validated”의 의미를 계층(layer)별로 정의하고, 실패(FAIL)와 불확정(INCONCLUSIVE)을 어떻게 해석해야 하는지, 그리고 가장 흔한 실패 모드를 어디에서 탐지하는지 문서화한다.</p> <h2 id="검증-레벨validation-levels">검증 레벨(Validation levels)</h2> <p>실행(run)의 검증은 다음 레벨로 생각할 수 있다:</p> <ol> <li><p><strong>L0 (형식/파일 존재)</strong>: 산출 파일이 생성되었는가?</p></li> <li><p><strong>L1 (해시 잠금)</strong>: <code>DATA_LOCK</code>과 <code>MANIFEST</code>가 존재하고 해시가 일치하는가?</p></li> <li><p><strong>L2 (스키마 완전성)</strong>: A4/고정 스키마를 만족하는가?</p></li> <li><p><strong>L3 (적격성 게이트)</strong>: <span class="math inline">\(\Delta E_{\mathrm{diss}}&lt;0\)</span>, 잔류 응력 비증가 등 핵심 게이트가 PASS인가?</p></li> <li><p><strong>L4 (재현성)</strong>: 동일 LOCK/seed에서 동일 <code>run_id</code>와 동일 <code>MANIFEST</code>를 재현하는가?</p></li> </ol> <p>본 백서에서 “validated bundle”은 최소 L1–L3을 만족해야 하며, L4는 동일 환경/동일 스크립트에서 재현 가능함을 의미한다 <span class="citation" data-cites="zenodo17932567"></span>.</p> <h2 id="번들-레벨-검증bundle-level-validation">번들 레벨 검증(Bundle-level validation)</h2> <p>번들 레벨에서의 최소 검증 체크리스트:</p> <ul> <li><p><code>DATA_LOCK</code> 존재 + canonical JSON + <code>run_id</code> 일치,</p></li> <li><p><code>MANIFEST</code> 존재 + 모든 listed file sha256이 실제 파일과 일치,</p></li> <li><p><code>INDEX</code> 존재 + 필수 열 존재 + <code>run_id</code> 연결 가능,</p></li> <li><p>표/그림 원본 CSV 및 TeX 내 값이 일치(증거 잠금),</p></li> <li><p>DOI 감사 스크립트 PASS.</p></li> </ul> <h2 id="게이트-분류권장-최소-세트">게이트 분류(권장 최소 세트)</h2> <p>최소 권장 게이트는 두 묶음이다:</p> <h4 id="a-감사완전성-게이트">(A) 감사/완전성 게이트</h4> <ul> <li><p><code>G_LOCK_PRESENT</code></p></li> <li><p><code>G_MANIFEST_PRESENT</code></p></li> <li><p><code>G_MANIFEST_MATCH</code></p></li> <li><p><code>G_SCHEMA_COMPLETE</code></p></li> </ul> <h4 id="b-적격성물리논리-게이트">(B) 적격성(물리/논리) 게이트</h4> <ul> <li><p><code>G_\Delta E</code>: 모든 JEVENT에서 <span class="math inline">\(\Delta E_{\mathrm{diss}}&lt;0\)</span></p></li> <li><p><code>G_PRES</code>: <span class="math inline">\(\mathrm{pres}_{post}\le \mathrm{pres}_{pre}\)</span></p></li> </ul> <p>이 외의 게이트는 확장 가능하지만, “핵심”과 “부가”를 명확히 구분해야 한다.</p> <h2 id="fail과-inconclusive의-해석">FAIL과 INCONCLUSIVE의 해석</h2> <h4 id="fail.">FAIL.</h4> <p>FAIL은 모델/구현이 계약을 위반했음을 의미한다. 이때 FAIL은 <em>나쁜 결과를 숨기는 것</em>이 아니라, <strong>경계 사례를 증거로 남기는 것</strong>이다.</p> <h4 id="inconclusive.">INCONCLUSIVE.</h4> <p>INCONCLUSIVE는 계약의 진위를 판정할 수 없는 상태다. 예: 파일 시스템 오류, 하드웨어 문제, OS 의존적 정렬 차이 등으로 인해 재현성 비교가 신뢰할 수 없는 경우. 이때는 진단 정보를 제공하고, 재시도 조건을 명시해야 한다.</p> <h2 id="레이어별-실패-모드">레이어별 실패 모드</h2> <h4 id="입력provenance-레이어.">입력/Provenance 레이어.</h4> <p>어셈블리/주석 불일치, chr 이름 불일치, softmask 부재.</p> <h4 id="key-레이어.">KEY 레이어.</h4> <p>고-N 구간으로 인한 통계 붕괴, 파라미터 극단으로 인한 과/저분할, GTF 결여로 인한 motor/loop 비어 있음.</p> <h4 id="pcts-레이어.">PCTS 레이어.</h4> <p><span class="math inline">\(\Delta E\)</span> 게이트 위반, 잔류 응력 비증가 위반, 난수 시드 미고정으로 인한 사건열 비재현.</p> <h4 id="bundle-레이어.">Bundle 레이어.</h4> <p>MANIFEST 누락/불일치, 표/그림 원본과 TeX 불일치, DOI 레지스트리 누락.</p> <h2 id="파라미터-민감도와-허용되는-행위">파라미터 민감도와 “허용되는” 행위</h2> <p>허용되는 행위:</p> <ul> <li><p>명시적 STATE 스윕(예: 창 크기, 임계값 등)을 통해 민감도를 탐색하고, 각 스윕 결과를 별도 run으로 기록(각각 <code>DATA_LOCK</code>/<code>MANIFEST</code> 포함).</p></li> </ul> <p>허용되지 않는 행위:</p> <ul> <li><p>특정 결과에 맞추어 LOCK를 사후 변경하고 기존 evidence를 덮어쓰는 것.</p></li> <li><p>표/그림 수치를 “보기 좋게” 임의 수정하는 것.</p></li> </ul> <h2 id="한계와-비목표진실성-제약">한계와 비목표(진실성 제약)</h2> <p>본 백서는 다음을 주장하지 않는다:</p> <ul> <li><p>생물학적 기능의 완전한 해석,</p></li> <li><p>강성 프록시의 보편적 물리량 정확도,</p></li> <li><p>모든 종/어셈블리에 대한 즉시 일반화(단, 계약은 일반화 가능하도록 설계됨).</p></li> </ul> <p>우리가 주장하는 것은 <strong>감사 가능하고 재현 가능한 구조-원장 생성</strong>이다.</p> <h1 id="sec:roadmap">로드맵(Roadmap)</h1> <p>본 절은 본 백서(v1.2)가 고정하는 것과, 향후 확장 가능한 연구/엔지니어링 방향을 구분하여 제시한다. 핵심 원칙은 <strong>활동 문법을 늘리지 않고</strong>, evidence와 진단/게이트를 확장하는 것이다.</p> <h2 id="즉시-과제-원고증거-완결">즉시 과제: 원고/증거 완결</h2> <ul> <li><p>TeX 단일 소스에서 표/그림 및 본문이 완전 재현 컴파일되도록 유지.</p></li> <li><p>evidence bundle의 DOI 감사 및 MANIFEST 검증 자동화 강화.</p></li> <li><p>대표 패널 선택의 tie-break 규칙을 명확히 문서화.</p></li> </ul> <h2 id="증거-확장마우스-mm39-내부">증거 확장(마우스 mm39 내부)</h2> <ul> <li><p><span class="math inline">\(N\)</span>을 늘리거나, 특정 축(예: repeat proxy)의 극단을 더 촘촘히 샘플링하는 패널 추가.</p></li> <li><p>실패 사례(게이트 위반)를 의도적으로 포함하는 “edge-case” 패널.</p></li> <li><p>특정 염색체/구간 클래스(예: subtelomeric, pericentromeric) 중심 패널.</p></li> </ul> <h2 id="타-종organism-확장">타 종(organism) 확장</h2> <p>계약 구조 자체는 종-불변이다. 종 확장은 다음 요소의 교체로 정의된다:</p> <ul> <li><p>어셈블리/주석 provenance,</p></li> <li><p>autoscan 파라미터(창 길이, 필터),</p></li> <li><p>축 분포(컷오프).</p></li> </ul> <p>이 때도 LOCK/Derive/Gate는 동일하게 유지된다.</p> <h2 id="조직맥락-패널활동-문법-유지">조직/맥락 패널(활동 문법 유지)</h2> <p>활동 문법을 바꾸지 않고도, “어떤 맥락을 대표한다”는 증거를 강화할 수 있다. 예: 특정 조직에서 발현되는 유전자에 대한 주석 필터를 STATE로 적용하여, motor 분포가 다른 패널을 구축한다.</p> <h2 id="버저닝-전략">버저닝 전략</h2> <ul> <li><p>KEY/PCTS 버전은 LOCK의 일부이며, 버전 변경은 새로운 evidence 버전을 요구한다.</p></li> <li><p>문서 버전(v1.2 등)과 evidence DOI는 1:1로 연결하는 것을 권장한다.</p></li> <li><p>작은 문구 수정이라도 표/그림 수치 또는 해시가 바뀌면 “패치”가 아니라 새 버전이다.</p></li> </ul> <h2 id="장기-연구-방향비구속-non-binding">장기 연구 방향(비구속, non-binding)</h2> <ul> <li><p>더 정교한 강성 프록시(예: k-mer 기반) 탐색(단, 이는 새로운 LOCK/버전).</p></li> <li><p>루프 생성 규칙의 대안 비교(그러나 규칙은 반드시 결정론적).</p></li> <li><p>JEVENT 타입 사전의 확장 여부 검토(활동 문법은 유지).</p></li> </ul> <h2 id="릴리스-플랜">릴리스 플랜</h2> <ul> <li><p>각 릴리스는 (PDF, TeX, scripts, schemas, manifests, table/figure sources)를 포함하는 validated bundle로 Zenodo에 업로드.</p></li> <li><p>DOI audit 및 MANIFEST audit 결과를 릴리스 노트에 포함.</p></li> <li><p>재현성 cookbook(부록 B)을 업데이트하여 “한 줄 실행”을 유지.</p></li> </ul> <h1 id="sec:formats">파일 포맷과 스키마(File formats and schemas)</h1> <p>본 절은 evidence bundle에 포함되는 주요 산출 파일의 포맷을 요약한다. <strong>정확한 필드 정의는 (i) evidence bundle에 포함된 스키마 YAML 또는 (ii) 버전 고정된 표준 파일/스크립트가 원본(source of truth)</strong>이며, 런타임 산출물은 해당 정의를 만족해야 한다.</p> <h2 id="a5-priors-yaml-a5_priors_dna_v0_1.yaml">A5 priors YAML (<code>A5_priors_dna_v0_1.yaml</code>)</h2> <p>A5 priors YAML은 LOCK(사전 가정/파라미터)을 담는다. 주요 항목 예시는 다음과 같다:</p> <ul> <li><p><code>version</code>: priors 파일 버전</p></li> <li><p><code>axis_bins</code>:</p> <ul> <li><p><code>gene_density</code>: <span class="math inline">\((q_1,q_2)\)</span></p></li> <li><p><code>repeat_proxy</code>: <span class="math inline">\((q_1,q_2)\)</span></p></li> <li><p><code>GC_fraction</code>: <span class="math inline">\((q_1,q_2)\)</span></p></li> <li><p><code>CpG_density</code>: <span class="math inline">\((q_1,q_2)\)</span></p></li> </ul></li> <li><p><code>KEY_weights</code>: <code>w_gc</code>, <code>w_cpg</code>, <code>w_at6</code></p></li> <li><p><code>KEY_params</code>: 창 크기, 스텝, 필터, 병합 임계값 등</p></li> <li><p><code>PCTS_params</code>: <code>max_steps</code>, <code>seed_policy</code>, <code>alpha_loop</code>, ...</p></li> </ul> <p>본 릴리스의 evidence-locked 번들에는 별도의 <code>A5_priors_schema_dna_v0_1.yaml</code> 파일을 포함하지 않는다. A5 priors의 구조(필드/의미)는 (버전 고정)과 이를 해석하는 kit 스크립트에 의해 고정된다.</p> <h2 id="a4-레이아웃-yaml-a4_layout_dna_v0_1.yaml">A4 레이아웃 YAML (<code>A4_layout_dna_v0_1.yaml</code>)</h2> <p>A4 레이아웃 YAML은 KEY의 구조 산출물을 최소 형태로 직렬화(serialization)한 것이다. 예시 필드:</p> <ul> <li><p><code>run_id</code>, <code>created_utc</code></p></li> <li><p><code>region</code>: <code>chrom,start,end,assembly</code></p></li> <li><p><code>KEY_version</code> 및 주요 파라미터</p></li> <li><p><code>shells</code>: shell 구간 목록(시작/끝/라벨/요약치)</p></li> <li><p><code>anchors</code>: 앵커 목록(위치/강도/종류)</p></li> <li><p><code>motors</code>: 모터 목록(TSS 등)</p></li> <li><p><code>loops</code>: 루프 목록(motor-anchor 연결)</p></li> </ul> <p>본 릴리스에서는 A4 레이아웃의 최소 직렬화가 run 디렉토리의 <code>A4_layout_min.yaml</code>로 산출되며, 필드 집합은 본 절의 목록과 KEY 출력 규칙(버전 고정)에 의해 고정된다. 별도의 <code>A4_layout_schema_dna_v0_1.yaml</code> 파일은 evidence bundle에 포함하지 않는다.</p> <h2 id="tsv-산출물key-단계">TSV 산출물(KEY 단계)</h2> <p>KEY 단계는 다음 TSV들을 산출한다(번들 내 경로는 <code>INDEX</code>와 <code>MANIFEST</code>에 기록됨):</p> <ul> <li><p><code>window_features.tsv</code>: 창별 (gc,cpg,at6,stiff_raw,z,z̃,tercile 라벨,...)</p></li> <li><p><code>shells.tsv</code>: shell 구간 요약</p></li> <li><p><code>anchors.tsv</code>: 앵커 목록</p></li> <li><p><code>motors.tsv</code>: 모터 목록(주석이 없으면 비어 있을 수 있음)</p></li> <li><p><code>loops.tsv</code>: 루프 목록(모터/앵커 기반)</p></li> <li><p><code>key_summary.yaml</code>: KEY 산출물 요약(카운트/파라미터/버전)</p></li> </ul> <p>TSV 열 정의는 스키마 YAML 또는 스크립트 내 상수로 고정된다.</p> <h2 id="pcts-산출물j_ledger-및-gate-table">PCTS 산출물(<strong>J_LEDGER</strong> 및 gate table)</h2> <p>PCTS 단계는 다음을 산출한다:</p> <ul> <li><p><code>J_LEDGER.tsv</code>: 비가역 사건 원장(각 행이 JEVENT)</p></li> <li><p><code>gate_table.tsv</code>: 게이트별 PASS/FAIL/INCONCLUSIVE와 이유</p></li> </ul> <p>최소 <code>run_id, event_id, event_type, t_step, deltaE_diss, pres_pre, pres_post, ...</code>를 포함해야 한다. gate table은 최소 <code>gate_id, verdict, reason, ...</code>를 포함해야 한다.</p> <p>전체 스키마는 evidence bundle 내 <code>J_LEDGER_schema_dna_v0_1.yaml</code> 및 관련 schema 파일이 정의한다.</p> <h1 id="sec:cookbook">재현성 cookbook(정확한 명령)</h1> <p>본 부록은 본 백서의 <strong>재현 가능한 증거 번들</strong>을 직접 생성/검증하기 위한 <strong>정확한 명령 목록</strong>을 제공한다. 가능한 한 “한 번의 실행”으로 끝나도록 설계된 end-to-end 스크립트를 우선 제공하며, 필요한 경우 단계별로 분해된 명령을 함께 제시한다.</p> <h2 id="b.0-최종적으로-얻어야-하는-것">B.0 최종적으로 얻어야 하는 것</h2> <p>전체 절차를 완료하면 다음을 얻어야 한다:</p> <ul> <li><p>autoscan 산출물(후보 창 메트릭, 컷오프, archetype 라벨, 선택 패널),</p></li> <li><p>선택된 패널의 각 구간에 대한 run 디렉토리(<code>DATA_LOCK</code>, <code>MANIFEST</code>, A4, <strong>J_LEDGER</strong>, gate table 포함),</p></li> <li><p>validated bundle ZIP(해시 검증/DOI 감사 가능),</p></li> <li><p>동일 입력/파라미터/시드에서 재실행 시 동일한 <code>run_id</code>와 동일한 산출물 해시를 재현할 수 있는 능력.</p></li> </ul> <h2 id="b.1-환경-설정environment-setup">B.1 환경 설정(Environment setup)</h2> <p>이 cookbook은 Linux/macOS의 표준 bash 환경을 가정한다. 필수 도구(최소):</p> <ul> <li><p><code>bash</code>, <code>coreutils</code>(<code>sha256sum</code>, <code>sort</code>, <code>awk</code> 등),</p></li> <li><p><code>python3</code> (가상환경 사용 권장),</p></li> <li><p><code>wget</code> 또는 <code>curl</code>,</p></li> <li><p><code>unzip</code>.</p></li> </ul> <p>아래는 kit(zip)를 풀어 둔 디렉토리를 가리키도록 <code>KIT_DIR</code>을 설정하는 예시다. (본 백서의 Zenodo 업로드 번들 내에 포함됨.)</p> <pre><code>export KIT_DIR=$PWD/mouse_mm39_autoscan_END2END_bundlekit_v1_0
cd &quot;$KIT_DIR&quot;</code></pre> <pre><code>python3 -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt</code></pre> <pre><code>export WORK_DIR=$PWD/WORK_MM39_AUTOSCAN
mkdir -p &quot;$WORK_DIR&quot;</code></pre> <h2 id="b.2-mm39-입력-다운로드서열-주석">B.2 mm39 입력 다운로드(서열 + 주석)</h2> <p>이 단계는 mm39 어셈블리(soft-masked FASTA)와 주석(refGene)을 작업 디렉토리로 내려받아 end-to-end 실행에 사용할 준비를 한다.</p> <p>주의:</p> <ul> <li><p>다운로드 URL은 시간이 지나며 변경될 수 있다.</p></li> <li><p>그러나 최종적으로는 <code>DATA_LOCK</code>에 sha256이 기록되므로, 동일 입력을 재현하려면 동일 sha256을 얻어야 한다.</p></li> </ul> <pre><code>export DATA_DIR=$PWD/DATA_SOURCES
mkdir -p &quot;$DATA_DIR/mm39&quot;</code></pre> <pre><code>cd &quot;$DATA_DIR/mm39&quot;
# Recommended: use the provided download helper (UCSC)
./scripts/download_ucsc_mm39.sh # If you downloaded a tar.gz manually, extract with:
tar -xzf mm39.chromFa.tar.gz
# expected output: a directory like chromFa/ containing chr*.fa files</code></pre> <pre><code>cd &quot;$DATA_DIR/mm39&quot;
# curl -L -o refGene.gtf.gz &lt;UCSC_URL&gt;/mm39/...
gzip -d refGene.gtf.gz</code></pre> <pre><code>cd &quot;$DATA_DIR/mm39&quot;
sha256sum mm39.chromFa.tar.gz &gt; SHA256SUMS.txt
sha256sum refGene.gtf &gt;&gt; SHA256SUMS.txt</code></pre> <h2 id="b.2.1-원커맨드-end-to-end-실행권장">B.2.1 원커맨드 end-to-end 실행(권장)</h2> <p>가장 간단한 재현 경로는 다음 스크립트를 한 번 실행하는 것이다. 이 스크립트는 autoscan부터 선택, 구간 추출, STEP18 실행, 검증/패킹까지를 순차적으로 수행한다.</p> <pre><code>cd &quot;$KIT_DIR&quot;
./scripts/RUN_MM39_AUTOSCAN_END2END_v1_0.sh</code></pre> <h2 id="b.2.2-end-to-end-스크립트가-만드는-표준-work_dir-트리">B.2.2 end-to-end 스크립트가 만드는 표준 WORK_DIR 트리</h2> <p>end-to-end 실행이 완료되면 WORK_DIR 아래에 다음과 같은 표준 디렉토리 트리가 생성된다. (경로/파일명은 LOCK의 일부이며, <code>MANIFEST</code>로 고정된다.)</p> <pre><code>./scripts/RUN_MM39_AUTOSCAN_END2END_v1_0.sh</code></pre> <pre><code>WORK_DIR/ AUTOSCAN/ mm39_windows_metrics.csv mm39_windows_archetyped.csv archetype_bins.yaml selected_regions.csv coverage_report.json EVIDENCE/ TABLE1_mm39_archetype_coverage_v0_1.csv mm39_selected_regions_archetypeN80_v0_1.csv mm39_archetype_coverage_matrix9x9_v0_1.csv RUN_METADATA_mm39_archetype_coverage_v0_1.json MANIFEST_mm39_archetype_coverage_v0_1.json mm39_inputs_sha256_v0_1.txt mm39_archetype_coverage_TABLE1_FIG1_bundle_v0_1.zip RAW_REGIONS/ regions/ &lt;region_id_0001&gt;.zip &lt;region_id_0002&gt;.zip ... raw_regions_index.csv JOBS/ jobs_mm39_panel.jsonl progress.csv checkpoint.pkl runs/ &lt;run_id_1&gt;/ DATA_LOCK/ data_lock.json DERIVED/ KEY_v0_4/ A4_layout_min.yaml anchors.tsv motors.tsv loops.tsv shells_fine.tsv shells_coarse.tsv boundaries_fine.tsv boundaries_coarse.tsv KEY_RUN.json OUTPUT/ PCTS_v0_2/ snapshots.csv J_LEDGER.csv gate_table.csv verdict.json MANIFEST.json &lt;run_id_2&gt;/ ... INDEX.csv mouse_dna_mm39_autoscan_VALIDATED_bundle.zip (optional)</code></pre> <h2 id="b.3-autoscan-후보-창-메트릭-계산">B.3 Autoscan: 후보 창 메트릭 계산</h2> <p>autoscan은 전체 게놈에서 후보 창을 생성하고, 각 창에 대해 4축 메트릭(gene density, repeat proxy, GC fraction, CpG density)을 계산한다. 산출물은 이후의 컷오프 계산 및 archetype 라벨링, 패널 선택의 입력이 된다.</p> <pre><code>python scripts/scan_mm39_windows.py \ --chrom_fa_dir &quot;$DATA_DIR/mm39/chromFa&quot; \ --gtf &quot;$DATA_DIR/mm39/refGene.gtf&quot; \ --win_bp 5000000 \ --step_bp 5000000 \ --valid_frac_min 0.80 \ --out_csv &quot;$WORK_DIR/AUTOSCAN/mm39_windows_metrics.csv&quot;</code></pre> <pre><code>chrom, start, end, valid_frac,
gc_frac, cpg_per_kb,
softmask_frac,
tss_count, gene_density_per_mb</code></pre> <h2 id="b.4-삼분위-컷오프-계산-및-4축-archetype-할당">B.4 삼분위 컷오프 계산 및 4축 archetype 할당</h2> <p>B.3에서 계산된 후보 창 메트릭에 대해, 축별 삼분위 컷오프 <span class="math inline">\((q_1,q_2)\)</span>를 계산하고 L/M/H 라벨을 부여한다. 그 결과 각 창은 4축 archetype ID를 갖는다.</p> <pre><code># (implemented inside the kit&#39;s autoscan pipeline; see RUN_MM39_AUTOSCAN_END2END_v1_0.sh) \ --metrics_csv &quot;$WORK_DIR/AUTOSCAN/mm39_windows_metrics.csv&quot; \ --out_yaml &quot;$WORK_DIR/AUTOSCAN/archetype_bins.yaml&quot;</code></pre> <pre><code># (implemented inside the kit&#39;s autoscan pipeline; see RUN_MM39_AUTOSCAN_END2END_v1_0.sh) \ --metrics_csv &quot;$WORK_DIR/AUTOSCAN/mm39_windows_metrics.csv&quot; \ --bins_yaml &quot;$WORK_DIR/AUTOSCAN/archetype_bins.yaml&quot; \ --out_csv &quot;$WORK_DIR/AUTOSCAN/mm39_windows_archetyped.csv&quot;</code></pre> <h2 id="b.5-대표-패널-선택n30100">B.5 대표 패널 선택(N=30–100)</h2> <p>B.4의 archetype 라벨링 결과를 사용해, 지정한 예산 <span class="math inline">\(N\)</span>에서 archetype 커버리지를 최대화하면서 주변 균형을 유지하도록 패널을 선택한다. 결과는 선택된 구간 목록 CSV로 저장된다.</p> <pre><code>python scripts/select_representative_windows.py \ --archetyped_csv &quot;$WORK_DIR/AUTOSCAN/mm39_windows_archetyped.csv&quot; \ --target_n 80 \ --min_sep_bp 5000000 \ --seed 0 \ --out_csv &quot;$WORK_DIR/AUTOSCAN/selected_regions.csv&quot;</code></pre> <pre><code># (implemented inside the kit&#39;s autoscan pipeline; see RUN_MM39_AUTOSCAN_END2END_v1_0.sh) \ --archetyped_csv &quot;$WORK_DIR/AUTOSCAN/mm39_windows_archetyped.csv&quot; \ --selected_csv &quot;$WORK_DIR/AUTOSCAN/selected_regions.csv&quot; \ --out_json &quot;$WORK_DIR/AUTOSCAN/coverage_report.json&quot;</code></pre> <h2 id="b.6-원시-구간raw-regions-추출region.fa-region.gtf-및-raw.zip-패킹">B.6 원시 구간(raw regions) 추출(region.fa + region.gtf) 및 raw.zip 패킹</h2> <p>선택된 패널의 각 구간에 대해, (1) 해당 구간 FASTA와 (2) 해당 구간과 교차하는 transcript만 포함한 GTF를 추출한다. 이 두 파일을 raw.zip로 패킹하고 sha256을 기록하여 입력 provenance를 고정한다.</p> <pre><code>python scripts/extract_regions.py \ --selected_csv &quot;$WORK_DIR/AUTOSCAN/selected_regions.csv&quot; \ --chrom_fa_dir &quot;$DATA_DIR/mm39/chromFa&quot; \ --gtf &quot;$DATA_DIR/mm39/refGene.gtf&quot; \ --out_dir &quot;$WORK_DIR/RAW_REGIONS&quot;</code></pre> <h2 id="b.7-패널에-대해-step18-실행key-pcts">B.7 패널에 대해 STEP18 실행(KEY + PCTS)</h2> <p>STEP18은 각 구간에 대해 KEY(A4 생성)와 PCTS(<strong>J_LEDGER</strong> 생성)를 실행한다. 이 단계는 run 디렉토리를 생성하고 <code>DATA_LOCK</code>, <code>MANIFEST</code>, gate table을 산출한다.</p> <pre><code>python scripts/build_jobs_jsonl.py \ --raw_regions_dir &quot;$WORK_DIR/RAW_REGIONS&quot; \ --species_id mouse_mm39 \ --key_version KEY_v0_4 \ --seed 0 \ --work_dir &quot;$WORK_DIR&quot; \ --out_jsonl &quot;$WORK_DIR/JOBS/jobs_mm39_panel.jsonl&quot;</code></pre> <pre><code>python batch_run.py \ --jobs_jsonl &quot;$WORK_DIR/JOBS/jobs_mm39_panel.jsonl&quot; \ --checkpoint &quot;$WORK_DIR/JOBS/checkpoint.pkl&quot; \ --progress_csv &quot;$WORK_DIR/JOBS/progress.csv&quot; \ --save_every 1</code></pre> <h2 id="b.8-run-검증-및-validated-bundle-패킹">B.8 run 검증 및 validated bundle 패킹</h2> <p>모든 run 디렉토리에 대해:</p> <ul> <li><p><code>DATA_LOCK</code>과 <code>run_id</code> 일치,</p></li> <li><p><code>MANIFEST</code>와 실제 파일 sha256 일치,</p></li> <li><p>gate table PASS/FAIL/INCONCLUSIVE 기록,</p></li> </ul> <p>을 검사한다. 그 다음 validated bundle ZIP을 만들고 최상위 sha256을 기록한다.</p> <pre><code>python validate_bundle.py --work_root &quot;$WORK_DIR&quot; --strict</code></pre> <pre><code>python pack_runs.py \ --work_dir &quot;$WORK_DIR&quot; \ --out_zip &quot;$WORK_DIR/mouse_dna_mm39_autoscan_VALIDATED_bundle.zip&quot;</code></pre> <h2 id="b.9-표-1-재생성csv-및-latex">B.9 표 1 재생성(CSV 및 LaTeX)</h2> <p>autoscan 및 패널 선택 결과로부터 표 <a href="#tab:archetype_bins" data-reference-type="ref" data-reference="tab:archetype_bins">3</a>에 해당하는 CSV 및 LaTeX를 재생성할 수 있다. 중요: 표의 수치는 evidence lock의 일부이므로, 재생성 결과가 기존 표와 다르면 입력/파라미터가 바뀌었거나 구현이 달라졌음을 의미한다.</p> <pre><code>python make_table1_archetype_bins.py \ --bins_yaml &quot;$WORK_DIR/AUTOSCAN/archetype_bins.yaml&quot; \ --selected_csv &quot;$WORK_DIR/AUTOSCAN/selected_regions.csv&quot; \ --out_csv &quot;tables/TABLE1_mm39_archetype_coverage.csv&quot;</code></pre> <h2 id="b.10-그림-관리-정책이-tex-프로젝트는-이미지를-포함하지-않음">B.10 그림 관리 정책(이 TeX 프로젝트는 이미지를 포함하지 않음)</h2> <p>본 TeX 프로젝트는 외부 이미지 파일(<code>.png</code>, <code>.pdf</code> figure 등)을 포함하지 않는다. 그 대신 그림 <a href="#fig:archetype_grid" data-reference-type="ref" data-reference="fig:archetype_grid">[fig:archetype_grid]</a>는 TeX 내부에서 직접 렌더링되는 9<span class="math inline">\(\times\)</span>9 점유도 테이블이다. 이 정책은 “단일 소스(TeX)로 완전 재현 컴파일”을 우선하기 위한 것이다.</p> <h2 id="b.11-doi-감사doi-audit">B.11 DOI 감사(DOI audit)</h2> <p>참고문헌에 포함된 DOI가 모두 레지스트리에 존재하는지 자동으로 검사한다. DOI 감사는 bundle 검증의 일부로 포함된다.</p> <pre><code>python doi_audit.py --registry CITATION_REGISTRY.yaml</code></pre> <h2 id="b.12-최소-수용-체크리스트minimal-acceptance-checklist">B.12 최소 수용 체크리스트(Minimal acceptance checklist)</h2> <p>다음 체크리스트를 모두 만족하면, 본 백서의 핵심 재현성 요구를 충족한 것으로 간주한다:</p> <ul> <li><p><strong>입력 잠금</strong>: 모든 run에 <code>DATA_LOCK</code>이 존재하고 sha256이 일치한다.</p></li> <li><p><strong>산출물 잠금</strong>: 모든 run/bundle에 <code>MANIFEST</code>가 존재하고 실제 파일 sha256과 일치한다.</p></li> <li><p><strong>스키마 완전성</strong>: A4/고정 스키마를 만족한다.</p></li> <li><p><strong>게이트 기록</strong>: gate table에 PASS/FAIL/INCONCLUSIVE와 이유가 기록된다.</p></li> <li><p><strong>표/그림 일치</strong>: 표 <a href="#tab:archetype_bins" data-reference-type="ref" data-reference="tab:archetype_bins">3</a> 및 그림 <a href="#fig:archetype_grid" data-reference-type="ref" data-reference="fig:archetype_grid">[fig:archetype_grid]</a> 값이 원본 CSV와 일치한다.</p></li> <li><p><strong>DOI 감사</strong>: DOI audit가 PASS한다.</p></li> </ul> </article> </div>
</main> <footer class="wp-footer"> <div>© 2025 Young Jae Lee · CC BY 4.0 (unless noted)</div>
</footer> <script src="/assets/papers.js"></script>
<script src="/assets/whitepapers.js"></script>
</body>
</html>
